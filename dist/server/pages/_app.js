/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/_app";
exports.ids = ["pages/_app"];
exports.modules = {

/***/ "./src/components/common/App/App.module.scss":
/*!***************************************************!*\
  !*** ./src/components/common/App/App.module.scss ***!
  \***************************************************/
/***/ ((module) => {

eval("// Exports\nmodule.exports = {\n\t\"contentWrapper\": \"App_contentWrapper__b8AQw\",\n\t\"contentBelowHeader\": \"App_contentBelowHeader__bNeeh\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwL0FwcC5tb2R1bGUuc2NzcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9BcHAvQXBwLm1vZHVsZS5zY3NzPzQwZDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiY29udGVudFdyYXBwZXJcIjogXCJBcHBfY29udGVudFdyYXBwZXJfX2I4QVF3XCIsXG5cdFwiY29udGVudEJlbG93SGVhZGVyXCI6IFwiQXBwX2NvbnRlbnRCZWxvd0hlYWRlcl9fYk5lZWhcIlxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/common/App/App.module.scss\n");

/***/ }),

/***/ "./src/components/common/ErrorBoundary/ErrorBoundary.module.scss":
/*!***********************************************************************!*\
  !*** ./src/components/common/ErrorBoundary/ErrorBoundary.module.scss ***!
  \***********************************************************************/
/***/ ((module) => {

eval("// Exports\nmodule.exports = {\n\t\"errorPage\": \"ErrorBoundary_errorPage__4qVOc\",\n\t\"errorPageContents\": \"ErrorBoundary_errorPageContents__yquq3\",\n\t\"errorText\": \"ErrorBoundary_errorText__G_buj\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vRXJyb3JCb3VuZGFyeS9FcnJvckJvdW5kYXJ5Lm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BmeC9hcHAtZnJvbnQtZW5kLXdlYnNpdGUvLi9zcmMvY29tcG9uZW50cy9jb21tb24vRXJyb3JCb3VuZGFyeS9FcnJvckJvdW5kYXJ5Lm1vZHVsZS5zY3NzPzgzMTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiZXJyb3JQYWdlXCI6IFwiRXJyb3JCb3VuZGFyeV9lcnJvclBhZ2VfXzRxVk9jXCIsXG5cdFwiZXJyb3JQYWdlQ29udGVudHNcIjogXCJFcnJvckJvdW5kYXJ5X2Vycm9yUGFnZUNvbnRlbnRzX195cXVxM1wiLFxuXHRcImVycm9yVGV4dFwiOiBcIkVycm9yQm91bmRhcnlfZXJyb3JUZXh0X19HX2J1alwiXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/common/ErrorBoundary/ErrorBoundary.module.scss\n");

/***/ }),

/***/ "./src/components/common/Page/PageError/PageError.module.scss":
/*!********************************************************************!*\
  !*** ./src/components/common/Page/PageError/PageError.module.scss ***!
  \********************************************************************/
/***/ ((module) => {

eval("// Exports\nmodule.exports = {\n\t\"errorWrapper\": \"PageError_errorWrapper__438Th\",\n\t\"description\": \"PageError_description__30xfI\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vUGFnZS9QYWdlRXJyb3IvUGFnZUVycm9yLm1vZHVsZS5zY3NzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL1BhZ2UvUGFnZUVycm9yL1BhZ2VFcnJvci5tb2R1bGUuc2Nzcz80ZmU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0ge1xuXHRcImVycm9yV3JhcHBlclwiOiBcIlBhZ2VFcnJvcl9lcnJvcldyYXBwZXJfXzQzOFRoXCIsXG5cdFwiZGVzY3JpcHRpb25cIjogXCJQYWdlRXJyb3JfZGVzY3JpcHRpb25fXzMweGZJXCJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/common/Page/PageError/PageError.module.scss\n");

/***/ }),

/***/ "../app-front-end-components/lib/index.esm.js":
/*!****************************************************!*\
  !*** ../app-front-end-components/lib/index.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    TooltipFloatingDelayGroup: function() {\n        return _react1.FloatingDelayGroup;\n    },\n    Anchor: function() {\n        return Anchor;\n    },\n    Button: function() {\n        return Button;\n    },\n    Card: function() {\n        return Card;\n    },\n    Checkbox: function() {\n        return Checkbox;\n    },\n    DropDownWrapper: function() {\n        return DropDownWrapper;\n    },\n    Flex: function() {\n        return Flex;\n    },\n    HeaderBar: function() {\n        return HeaderBar;\n    },\n    HeaderBarItem: function() {\n        return HeaderBarItem;\n    },\n    KnobRotary: function() {\n        return KnobRotary;\n    },\n    KnobRotaryWithTicks: function() {\n        return KnobRotaryWithTicks;\n    },\n    Line: function() {\n        return Line;\n    },\n    LoadingSpinner: function() {\n        return LoadingSpinner;\n    },\n    MODAL_DEFAULT_Z_INDEX: function() {\n        return MODAL_DEFAULT_Z_INDEX;\n    },\n    Modal: function() {\n        return Modal;\n    },\n    ModalProvider: function() {\n        return ModalProvider;\n    },\n    PagePaddingX: function() {\n        return PagePaddingX;\n    },\n    PagePaddingY: function() {\n        return PagePaddingY;\n    },\n    Pill: function() {\n        return Pill;\n    },\n    Select: function() {\n        return Select;\n    },\n    Slider: function() {\n        return Slider;\n    },\n    SliderMechanism: function() {\n        return SliderMechanism;\n    },\n    Spacer: function() {\n        return Spacer;\n    },\n    Text: function() {\n        return Text;\n    },\n    TextArea: function() {\n        return TextArea;\n    },\n    TextInput: function() {\n        return TextInput;\n    },\n    Title: function() {\n        return Title;\n    },\n    Tooltip: function() {\n        return Tooltip;\n    },\n    TooltipContent: function() {\n        return TooltipContent;\n    },\n    TooltipSimple: function() {\n        return TooltipSimple;\n    },\n    TooltipTrigger: function() {\n        return TooltipTrigger;\n    },\n    defaultShouldBlurFunction: function() {\n        return defaultShouldBlurFunction;\n    },\n    extractStaticImage: function() {\n        return extractStaticImage;\n    },\n    generateColorProps: function() {\n        return generateColorProps;\n    },\n    generateFontSizeClassName: function() {\n        return generateFontSizeClassName;\n    },\n    generateSvgProps: function() {\n        return generateSvgProps;\n    },\n    getThemeVariable: function() {\n        return getThemeVariable;\n    },\n    handleBlur: function() {\n        return handleBlur;\n    },\n    useClientMountedState: function() {\n        return useClientMountedState;\n    },\n    useMediaQuery: function() {\n        return useMediaQuery;\n    },\n    useOnBlur: function() {\n        return useOnBlur;\n    },\n    useScroll: function() {\n        return useScroll;\n    },\n    useSliderMechanismState: function() {\n        return useSliderMechanismState;\n    },\n    useStateWithRef: function() {\n        return useStateWithRef;\n    },\n    useThemeScreenSize: function() {\n        return useThemeScreenSize;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"../../node_modules/@swc/helpers/cjs/_interop_require_default.cjs\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"../../node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"react\"));\nconst _classnames = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! classnames */ \"classnames\"));\nconst _libutilities = __webpack_require__(/*! @fx/lib-utilities */ \"../lib-utilities/lib/index.esm.js\");\nconst _react1 = __webpack_require__(/*! @floating-ui/react */ \"@floating-ui/react\");\nconst _reacticons = __webpack_require__(/*! @radix-ui/react-icons */ \"@radix-ui/react-icons\");\nconst _reactcheckbox = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! @radix-ui/react-checkbox */ \"@radix-ui/react-checkbox\"));\nconst _usedebounce = __webpack_require__(/*! use-debounce */ \"../app-front-end-components/node_modules/use-debounce/dist/index.module.js\");\nconst _reactwindow = __webpack_require__(/*! react-window */ \"react-window\");\nconst _reactslider = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-slider */ \"react-slider\"));\nconst _reactresizedetector = __webpack_require__(/*! react-resize-detector */ \"react-resize-detector\");\nconst _reactdom = __webpack_require__(/*! react-dom */ \"react-dom\");\nconst _reactselect = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react-select */ \"react-select\"));\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar link$1 = {\n    exports: {}\n};\nvar _interop_require_default$1 = {};\n_interop_require_default$1._ = _interop_require_default$1._interop_require_default = _interop_require_default1;\nfunction _interop_require_default1(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar resolveHref = {\n    exports: {}\n};\nvar querystring = {};\nvar hasRequiredQuerystring;\nfunction requireQuerystring() {\n    if (hasRequiredQuerystring) return querystring;\n    hasRequiredQuerystring = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        function _export(target, all) {\n            for(var name in all)Object.defineProperty(target, name, {\n                enumerable: true,\n                get: all[name]\n            });\n        }\n        _export(exports1, {\n            searchParamsToUrlQuery: function() {\n                return searchParamsToUrlQuery;\n            },\n            urlQueryToSearchParams: function() {\n                return urlQueryToSearchParams;\n            },\n            assign: function() {\n                return assign;\n            }\n        });\n        function searchParamsToUrlQuery(searchParams) {\n            const query = {};\n            searchParams.forEach((value, key)=>{\n                if (typeof query[key] === \"undefined\") {\n                    query[key] = value;\n                } else if (Array.isArray(query[key])) {\n                    query[key].push(value);\n                } else {\n                    query[key] = [\n                        query[key],\n                        value\n                    ];\n                }\n            });\n            return query;\n        }\n        function stringifyUrlQueryParam(param) {\n            if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n                return String(param);\n            } else {\n                return \"\";\n            }\n        }\n        function urlQueryToSearchParams(urlQuery) {\n            const result = new URLSearchParams();\n            Object.entries(urlQuery).forEach((param)=>{\n                let [key, value] = param;\n                if (Array.isArray(value)) {\n                    value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n                } else {\n                    result.set(key, stringifyUrlQueryParam(value));\n                }\n            });\n            return result;\n        }\n        function assign(target) {\n            for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                searchParamsList[_key - 1] = arguments[_key];\n            }\n            searchParamsList.forEach((searchParams)=>{\n                Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n                searchParams.forEach((value, key)=>target.append(key, value));\n            });\n            return target;\n        }\n    })(querystring);\n    return querystring;\n}\nvar formatUrl = {};\nvar _interop_require_wildcard1 = {};\nvar hasRequired_interop_require_wildcard;\nfunction require_interop_require_wildcard() {\n    if (hasRequired_interop_require_wildcard) return _interop_require_wildcard1;\n    hasRequired_interop_require_wildcard = 1;\n    function _getRequireWildcardCache(nodeInterop) {\n        if (typeof WeakMap !== \"function\") return null;\n        var cacheBabelInterop = new WeakMap();\n        var cacheNodeInterop = new WeakMap();\n        return (_getRequireWildcardCache = function(nodeInterop) {\n            return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n        })(nodeInterop);\n    }\n    _interop_require_wildcard1._ = _interop_require_wildcard1._interop_require_wildcard = _interop_require_wildcard$1;\n    function _interop_require_wildcard$1(obj, nodeInterop) {\n        if (!nodeInterop && obj && obj.__esModule) return obj;\n        if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") return {\n            default: obj\n        };\n        var cache = _getRequireWildcardCache(nodeInterop);\n        if (cache && cache.has(obj)) return cache.get(obj);\n        var newObj = {};\n        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for(var key in obj){\n            if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n                if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);\n                else newObj[key] = obj[key];\n            }\n        }\n        newObj.default = obj;\n        if (cache) cache.set(obj, newObj);\n        return newObj;\n    }\n    return _interop_require_wildcard1;\n}\nvar hasRequiredFormatUrl;\nfunction requireFormatUrl() {\n    if (hasRequiredFormatUrl) return formatUrl;\n    hasRequiredFormatUrl = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        function _export(target, all) {\n            for(var name in all)Object.defineProperty(target, name, {\n                enumerable: true,\n                get: all[name]\n            });\n        }\n        _export(exports1, {\n            formatUrl: function() {\n                return formatUrl;\n            },\n            urlObjectKeys: function() {\n                return urlObjectKeys;\n            },\n            formatWithValidation: function() {\n                return formatWithValidation;\n            }\n        });\n        const _interop_require_wildcard = require_interop_require_wildcard();\n        const _querystring = /*#__PURE__*/ _interop_require_wildcard._(requireQuerystring());\n        const slashedProtocols = /https?|ftp|gopher|file/;\n        function formatUrl(urlObj) {\n            let { auth, hostname } = urlObj;\n            let protocol = urlObj.protocol || \"\";\n            let pathname = urlObj.pathname || \"\";\n            let hash = urlObj.hash || \"\";\n            let query = urlObj.query || \"\";\n            let host = false;\n            auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n            if (urlObj.host) {\n                host = auth + urlObj.host;\n            } else if (hostname) {\n                host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n                if (urlObj.port) {\n                    host += \":\" + urlObj.port;\n                }\n            }\n            if (query && typeof query === \"object\") {\n                query = String(_querystring.urlQueryToSearchParams(query));\n            }\n            let search = urlObj.search || query && \"?\" + query || \"\";\n            if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n            if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n                host = \"//\" + (host || \"\");\n                if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n            } else if (!host) {\n                host = \"\";\n            }\n            if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n            if (search && search[0] !== \"?\") search = \"?\" + search;\n            pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n            search = search.replace(\"#\", \"%23\");\n            return \"\" + protocol + host + pathname + search + hash;\n        }\n        const urlObjectKeys = [\n            \"auth\",\n            \"hash\",\n            \"host\",\n            \"hostname\",\n            \"href\",\n            \"path\",\n            \"pathname\",\n            \"port\",\n            \"protocol\",\n            \"query\",\n            \"search\",\n            \"slashes\"\n        ];\n        function formatWithValidation(url) {\n            if (true) {\n                if (url !== null && typeof url === \"object\") {\n                    Object.keys(url).forEach((key)=>{\n                        if (!urlObjectKeys.includes(key)) {\n                            console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                        }\n                    });\n                }\n            }\n            return formatUrl(url);\n        }\n    })(formatUrl);\n    return formatUrl;\n}\nvar omit$2 = {};\nvar hasRequiredOmit;\nfunction requireOmit() {\n    if (hasRequiredOmit) return omit$2;\n    hasRequiredOmit = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"omit\", {\n            enumerable: true,\n            get: function() {\n                return omit;\n            }\n        });\n        function omit(object, keys) {\n            const omitted = {};\n            Object.keys(object).forEach((key)=>{\n                if (!keys.includes(key)) {\n                    omitted[key] = object[key];\n                }\n            });\n            return omitted;\n        }\n    })(omit$2);\n    return omit$2;\n}\nvar utils$1 = {};\nvar hasRequiredUtils$1;\nfunction requireUtils$1() {\n    if (hasRequiredUtils$1) return utils$1;\n    hasRequiredUtils$1 = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        function _export(target, all) {\n            for(var name in all)Object.defineProperty(target, name, {\n                enumerable: true,\n                get: all[name]\n            });\n        }\n        _export(exports1, {\n            WEB_VITALS: function() {\n                return WEB_VITALS;\n            },\n            execOnce: function() {\n                return execOnce;\n            },\n            isAbsoluteUrl: function() {\n                return isAbsoluteUrl;\n            },\n            getLocationOrigin: function() {\n                return getLocationOrigin;\n            },\n            getURL: function() {\n                return getURL;\n            },\n            getDisplayName: function() {\n                return getDisplayName;\n            },\n            isResSent: function() {\n                return isResSent;\n            },\n            normalizeRepeatedSlashes: function() {\n                return normalizeRepeatedSlashes;\n            },\n            loadGetInitialProps: function() {\n                return loadGetInitialProps;\n            },\n            SP: function() {\n                return SP;\n            },\n            ST: function() {\n                return ST;\n            },\n            DecodeError: function() {\n                return DecodeError;\n            },\n            NormalizeError: function() {\n                return NormalizeError;\n            },\n            PageNotFoundError: function() {\n                return PageNotFoundError;\n            },\n            MissingStaticPage: function() {\n                return MissingStaticPage;\n            },\n            MiddlewareNotFoundError: function() {\n                return MiddlewareNotFoundError;\n            },\n            stringifyError: function() {\n                return stringifyError;\n            }\n        });\n        const WEB_VITALS = [\n            \"CLS\",\n            \"FCP\",\n            \"FID\",\n            \"INP\",\n            \"LCP\",\n            \"TTFB\"\n        ];\n        function execOnce(fn) {\n            let used = false;\n            let result;\n            return function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (!used) {\n                    used = true;\n                    result = fn(...args);\n                }\n                return result;\n            };\n        }\n        // Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n        // Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n        const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\n        const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\n        function getLocationOrigin() {\n            const { protocol, hostname, port } = window.location;\n            return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n        }\n        function getURL() {\n            const { href } = window.location;\n            const origin = getLocationOrigin();\n            return href.substring(origin.length);\n        }\n        function getDisplayName(Component) {\n            return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n        }\n        function isResSent(res) {\n            return res.finished || res.headersSent;\n        }\n        function normalizeRepeatedSlashes(url) {\n            const urlParts = url.split(\"?\");\n            const urlNoQuery = urlParts[0];\n            return urlNoQuery // first we replace any non-encoded backslashes with forward\n            // then normalize repeated forward slashes\n            .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n        }\n        async function loadGetInitialProps(App, ctx) {\n            if (true) {\n                var _App_prototype;\n                if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n                    const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n                    throw new Error(message);\n                }\n            }\n            // when called from _app `ctx` is nested in `ctx`\n            const res = ctx.res || ctx.ctx && ctx.ctx.res;\n            if (!App.getInitialProps) {\n                if (ctx.ctx && ctx.Component) {\n                    // @ts-ignore pageProps default\n                    return {\n                        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n                    };\n                }\n                return {};\n            }\n            const props = await App.getInitialProps(ctx);\n            if (res && isResSent(res)) {\n                return props;\n            }\n            if (!props) {\n                const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n                throw new Error(message);\n            }\n            if (true) {\n                if (Object.keys(props).length === 0 && !ctx.ctx) {\n                    console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n                }\n            }\n            return props;\n        }\n        const SP = typeof performance !== \"undefined\";\n        const ST = SP && [\n            \"mark\",\n            \"measure\",\n            \"getEntriesByName\"\n        ].every((method)=>typeof performance[method] === \"function\");\n        class DecodeError extends Error {\n        }\n        class NormalizeError extends Error {\n        }\n        class PageNotFoundError extends Error {\n            constructor(page){\n                super();\n                this.code = \"ENOENT\";\n                this.name = \"PageNotFoundError\";\n                this.message = \"Cannot find module for page: \" + page;\n            }\n        }\n        class MissingStaticPage extends Error {\n            constructor(page, message){\n                super();\n                this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n            }\n        }\n        class MiddlewareNotFoundError extends Error {\n            constructor(){\n                super();\n                this.code = \"ENOENT\";\n                this.message = \"Cannot find the middleware module\";\n            }\n        }\n        function stringifyError(error) {\n            return JSON.stringify({\n                message: error.message,\n                stack: error.stack\n            });\n        }\n    })(utils$1);\n    return utils$1;\n}\nvar normalizeTrailingSlash = {\n    exports: {}\n};\nvar removeTrailingSlash = {};\n/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */ var hasRequiredRemoveTrailingSlash;\nfunction requireRemoveTrailingSlash() {\n    if (hasRequiredRemoveTrailingSlash) return removeTrailingSlash;\n    hasRequiredRemoveTrailingSlash = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"removeTrailingSlash\", {\n            enumerable: true,\n            get: function() {\n                return removeTrailingSlash;\n            }\n        });\n        function removeTrailingSlash(route) {\n            return route.replace(/\\/$/, \"\") || \"/\";\n        }\n    })(removeTrailingSlash);\n    return removeTrailingSlash;\n}\nvar parsePath = {};\n/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */ var hasRequiredParsePath;\nfunction requireParsePath() {\n    if (hasRequiredParsePath) return parsePath;\n    hasRequiredParsePath = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"parsePath\", {\n            enumerable: true,\n            get: function() {\n                return parsePath;\n            }\n        });\n        function parsePath(path) {\n            const hashIndex = path.indexOf(\"#\");\n            const queryIndex = path.indexOf(\"?\");\n            const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\n            if (hasQuery || hashIndex > -1) {\n                return {\n                    pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n                    query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : \"\",\n                    hash: hashIndex > -1 ? path.slice(hashIndex) : \"\"\n                };\n            }\n            return {\n                pathname: path,\n                query: \"\",\n                hash: \"\"\n            };\n        }\n    })(parsePath);\n    return parsePath;\n}\nvar hasRequiredNormalizeTrailingSlash;\nfunction requireNormalizeTrailingSlash() {\n    if (hasRequiredNormalizeTrailingSlash) return normalizeTrailingSlash.exports;\n    hasRequiredNormalizeTrailingSlash = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"normalizePathTrailingSlash\", {\n            enumerable: true,\n            get: function() {\n                return normalizePathTrailingSlash;\n            }\n        });\n        const _removetrailingslash = requireRemoveTrailingSlash();\n        const _parsepath = requireParsePath();\n        const normalizePathTrailingSlash = (path)=>{\n            if (!path.startsWith(\"/\") || undefined) {\n                return path;\n            }\n            const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n            if (true) {\n                if (/\\.[^/]+\\/?$/.test(pathname)) {\n                    return \"\" + (0, _removetrailingslash.removeTrailingSlash)(pathname) + query + hash;\n                } else if (pathname.endsWith(\"/\")) {\n                    return \"\" + pathname + query + hash;\n                } else {\n                    return pathname + \"/\" + query + hash;\n                }\n            }\n            return \"\" + (0, _removetrailingslash.removeTrailingSlash)(pathname) + query + hash;\n        };\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(normalizeTrailingSlash, normalizeTrailingSlash.exports);\n    return normalizeTrailingSlash.exports;\n}\nvar isLocalUrl = {};\nvar hasBasePath = {\n    exports: {}\n};\nvar pathHasPrefix = {};\nvar hasRequiredPathHasPrefix;\nfunction requirePathHasPrefix() {\n    if (hasRequiredPathHasPrefix) return pathHasPrefix;\n    hasRequiredPathHasPrefix = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"pathHasPrefix\", {\n            enumerable: true,\n            get: function() {\n                return pathHasPrefix;\n            }\n        });\n        const _parsepath = requireParsePath();\n        function pathHasPrefix(path, prefix) {\n            if (typeof path !== \"string\") {\n                return false;\n            }\n            const { pathname } = (0, _parsepath.parsePath)(path);\n            return pathname === prefix || pathname.startsWith(prefix + \"/\");\n        }\n    })(pathHasPrefix);\n    return pathHasPrefix;\n}\nvar hasRequiredHasBasePath;\nfunction requireHasBasePath() {\n    if (hasRequiredHasBasePath) return hasBasePath.exports;\n    hasRequiredHasBasePath = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"hasBasePath\", {\n            enumerable: true,\n            get: function() {\n                return hasBasePath;\n            }\n        });\n        const _pathhasprefix = requirePathHasPrefix();\n        const basePath =  false || \"\";\n        function hasBasePath(path) {\n            return (0, _pathhasprefix.pathHasPrefix)(path, basePath);\n        }\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(hasBasePath, hasBasePath.exports);\n    return hasBasePath.exports;\n}\nvar hasRequiredIsLocalUrl;\nfunction requireIsLocalUrl() {\n    if (hasRequiredIsLocalUrl) return isLocalUrl;\n    hasRequiredIsLocalUrl = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"isLocalURL\", {\n            enumerable: true,\n            get: function() {\n                return isLocalURL;\n            }\n        });\n        const _utils = requireUtils$1();\n        const _hasbasepath = requireHasBasePath();\n        function isLocalURL(url) {\n            // prevent a hydration mismatch on href for url with anchor refs\n            if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n            try {\n                // absolute urls can be local if they are on the same origin\n                const locationOrigin = (0, _utils.getLocationOrigin)();\n                const resolved = new URL(url, locationOrigin);\n                return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n            } catch (_) {\n                return false;\n            }\n        }\n    })(isLocalUrl);\n    return isLocalUrl;\n}\nvar utils = {};\nvar sortedRoutes = {};\nvar hasRequiredSortedRoutes;\nfunction requireSortedRoutes() {\n    if (hasRequiredSortedRoutes) return sortedRoutes;\n    hasRequiredSortedRoutes = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"getSortedRoutes\", {\n            enumerable: true,\n            get: function() {\n                return getSortedRoutes;\n            }\n        });\n        class UrlNode {\n            insert(urlPath) {\n                this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n            }\n            smoosh() {\n                return this._smoosh();\n            }\n            _smoosh(prefix) {\n                if (prefix === void 0) prefix = \"/\";\n                const childrenPaths = [\n                    ...this.children.keys()\n                ].sort();\n                if (this.slugName !== null) {\n                    childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n                }\n                if (this.restSlugName !== null) {\n                    childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n                }\n                if (this.optionalRestSlugName !== null) {\n                    childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n                }\n                const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                        ...prev,\n                        ...curr\n                    ], []);\n                if (this.slugName !== null) {\n                    routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n                }\n                if (!this.placeholder) {\n                    const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n                    }\n                    routes.unshift(r);\n                }\n                if (this.restSlugName !== null) {\n                    routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n                }\n                if (this.optionalRestSlugName !== null) {\n                    routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n                }\n                return routes;\n            }\n            _insert(urlPaths, slugNames, isCatchAll) {\n                if (urlPaths.length === 0) {\n                    this.placeholder = false;\n                    return;\n                }\n                if (isCatchAll) {\n                    throw new Error(\"Catch-all must be the last part of the URL.\");\n                }\n                // The next segment in the urlPaths list\n                let nextSegment = urlPaths[0];\n                // Check if the segment matches `[something]`\n                if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n                    // Strip `[` and `]`, leaving only `something`\n                    let segmentName = nextSegment.slice(1, -1);\n                    let isOptional = false;\n                    if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                        // Strip optional `[` and `]`, leaving only `something`\n                        segmentName = segmentName.slice(1, -1);\n                        isOptional = true;\n                    }\n                    if (segmentName.startsWith(\"...\")) {\n                        // Strip `...`, leaving only `something`\n                        segmentName = segmentName.substring(3);\n                        isCatchAll = true;\n                    }\n                    if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                        throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n                    }\n                    if (segmentName.startsWith(\".\")) {\n                        throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n                    }\n                    function handleSlug(previousSlug, nextSlug) {\n                        if (previousSlug !== null) {\n                            // If the specific segment already has a slug but the slug is not `something`\n                            // This prevents collisions like:\n                            // pages/[post]/index.js\n                            // pages/[id]/index.js\n                            // Because currently multiple dynamic params on the same segment level are not supported\n                            if (previousSlug !== nextSlug) {\n                                // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                                throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                            }\n                        }\n                        slugNames.forEach((slug)=>{\n                            if (slug === nextSlug) {\n                                throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                            }\n                            if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                                throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                            }\n                        });\n                        slugNames.push(nextSlug);\n                    }\n                    if (isCatchAll) {\n                        if (isOptional) {\n                            if (this.restSlugName != null) {\n                                throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                            }\n                            handleSlug(this.optionalRestSlugName, segmentName);\n                            // slugName is kept as it can only be one particular slugName\n                            this.optionalRestSlugName = segmentName;\n                            // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                            nextSegment = \"[[...]]\";\n                        } else {\n                            if (this.optionalRestSlugName != null) {\n                                throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                            }\n                            handleSlug(this.restSlugName, segmentName);\n                            // slugName is kept as it can only be one particular slugName\n                            this.restSlugName = segmentName;\n                            // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                            nextSegment = \"[...]\";\n                        }\n                    } else {\n                        if (isOptional) {\n                            throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                        }\n                        handleSlug(this.slugName, segmentName);\n                        // slugName is kept as it can only be one particular slugName\n                        this.slugName = segmentName;\n                        // nextSegment is overwritten to [] so that it can later be sorted specifically\n                        nextSegment = \"[]\";\n                    }\n                }\n                // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n                if (!this.children.has(nextSegment)) {\n                    this.children.set(nextSegment, new UrlNode());\n                }\n                this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n            }\n            constructor(){\n                this.placeholder = true;\n                this.children = new Map();\n                this.slugName = null;\n                this.restSlugName = null;\n                this.optionalRestSlugName = null;\n            }\n        }\n        function getSortedRoutes(normalizedPages) {\n            // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n            // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n            // Only 1 dynamic segment per nesting level\n            // So in the case that is test/integration/dynamic-routing it'll be this:\n            // pages/[post]/comments.js\n            // pages/blog/[post]/comment/[id].js\n            // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n            // So in this case `UrlNode` created here has `this.slugName === 'post'`\n            // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n            // Instead what has to be passed through is the upwards path's dynamic names\n            const root = new UrlNode();\n            // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n            normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n            // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n            return root.smoosh();\n        }\n    })(sortedRoutes);\n    return sortedRoutes;\n}\nvar isDynamic = {};\nvar hasRequiredIsDynamic;\nfunction requireIsDynamic() {\n    if (hasRequiredIsDynamic) return isDynamic;\n    hasRequiredIsDynamic = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"isDynamicRoute\", {\n            enumerable: true,\n            get: function() {\n                return isDynamicRoute;\n            }\n        });\n        const TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\n        function isDynamicRoute(route) {\n            return TEST_ROUTE.test(route);\n        }\n    })(isDynamic);\n    return isDynamic;\n}\nvar hasRequiredUtils;\nfunction requireUtils() {\n    if (hasRequiredUtils) return utils;\n    hasRequiredUtils = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        function _export(target, all) {\n            for(var name in all)Object.defineProperty(target, name, {\n                enumerable: true,\n                get: all[name]\n            });\n        }\n        _export(exports1, {\n            getSortedRoutes: function() {\n                return _sortedroutes.getSortedRoutes;\n            },\n            isDynamicRoute: function() {\n                return _isdynamic.isDynamicRoute;\n            }\n        });\n        const _sortedroutes = requireSortedRoutes();\n        const _isdynamic = requireIsDynamic();\n    })(utils);\n    return utils;\n}\nvar interpolateAs = {};\nvar routeMatcher = {};\nvar hasRequiredRouteMatcher;\nfunction requireRouteMatcher() {\n    if (hasRequiredRouteMatcher) return routeMatcher;\n    hasRequiredRouteMatcher = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"getRouteMatcher\", {\n            enumerable: true,\n            get: function() {\n                return getRouteMatcher;\n            }\n        });\n        const _utils = requireUtils$1();\n        function getRouteMatcher(param) {\n            let { re, groups } = param;\n            return (pathname)=>{\n                const routeMatch = re.exec(pathname);\n                if (!routeMatch) {\n                    return false;\n                }\n                const decode = (param)=>{\n                    try {\n                        return decodeURIComponent(param);\n                    } catch (_) {\n                        throw new _utils.DecodeError(\"failed to decode param\");\n                    }\n                };\n                const params = {};\n                Object.keys(groups).forEach((slugName)=>{\n                    const g = groups[slugName];\n                    const m = routeMatch[g.pos];\n                    if (m !== undefined) {\n                        params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                            decode(m)\n                        ] : decode(m);\n                    }\n                });\n                return params;\n            };\n        }\n    })(routeMatcher);\n    return routeMatcher;\n}\nvar routeRegex = {};\nvar interceptionRoutes = {};\nvar appPaths = {};\nvar ensureLeadingSlash = {};\n/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */ var hasRequiredEnsureLeadingSlash;\nfunction requireEnsureLeadingSlash() {\n    if (hasRequiredEnsureLeadingSlash) return ensureLeadingSlash;\n    hasRequiredEnsureLeadingSlash = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"ensureLeadingSlash\", {\n            enumerable: true,\n            get: function() {\n                return ensureLeadingSlash;\n            }\n        });\n        function ensureLeadingSlash(path) {\n            return path.startsWith(\"/\") ? path : \"/\" + path;\n        }\n    })(ensureLeadingSlash);\n    return ensureLeadingSlash;\n}\nvar segment = {};\nvar hasRequiredSegment;\nfunction requireSegment() {\n    if (hasRequiredSegment) return segment;\n    hasRequiredSegment = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"isGroupSegment\", {\n            enumerable: true,\n            get: function() {\n                return isGroupSegment;\n            }\n        });\n        function isGroupSegment(segment) {\n            // Use array[0] for performant purpose\n            return segment[0] === \"(\" && segment.endsWith(\")\");\n        }\n    })(segment);\n    return segment;\n}\nvar hasRequiredAppPaths;\nfunction requireAppPaths() {\n    if (hasRequiredAppPaths) return appPaths;\n    hasRequiredAppPaths = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        function _export(target, all) {\n            for(var name in all)Object.defineProperty(target, name, {\n                enumerable: true,\n                get: all[name]\n            });\n        }\n        _export(exports1, {\n            normalizeAppPath: function() {\n                return normalizeAppPath;\n            },\n            normalizeRscPath: function() {\n                return normalizeRscPath;\n            }\n        });\n        const _ensureleadingslash = requireEnsureLeadingSlash();\n        const _segment = requireSegment();\n        function normalizeAppPath(route) {\n            return (0, _ensureleadingslash.ensureLeadingSlash)(route.split(\"/\").reduce((pathname, segment, index, segments)=>{\n                // Empty segments are ignored.\n                if (!segment) {\n                    return pathname;\n                }\n                // Groups are ignored.\n                if ((0, _segment.isGroupSegment)(segment)) {\n                    return pathname;\n                }\n                // Parallel segments are ignored.\n                if (segment[0] === \"@\") {\n                    return pathname;\n                }\n                // The last segment (if it's a leaf) should be ignored.\n                if ((segment === \"page\" || segment === \"route\") && index === segments.length - 1) {\n                    return pathname;\n                }\n                return pathname + \"/\" + segment;\n            }, \"\"));\n        }\n        function normalizeRscPath(pathname, enabled) {\n            return enabled ? pathname.replace(/\\.rsc($|\\?)/, \"$1\") : pathname;\n        }\n    })(appPaths);\n    return appPaths;\n}\nvar hasRequiredInterceptionRoutes;\nfunction requireInterceptionRoutes() {\n    if (hasRequiredInterceptionRoutes) return interceptionRoutes;\n    hasRequiredInterceptionRoutes = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        function _export(target, all) {\n            for(var name in all)Object.defineProperty(target, name, {\n                enumerable: true,\n                get: all[name]\n            });\n        }\n        _export(exports1, {\n            INTERCEPTION_ROUTE_MARKERS: function() {\n                return INTERCEPTION_ROUTE_MARKERS;\n            },\n            isInterceptionRouteAppPath: function() {\n                return isInterceptionRouteAppPath;\n            },\n            extractInterceptionRouteInformation: function() {\n                return extractInterceptionRouteInformation;\n            }\n        });\n        const _apppaths = requireAppPaths();\n        const INTERCEPTION_ROUTE_MARKERS = [\n            \"(..)(..)\",\n            \"(.)\",\n            \"(..)\",\n            \"(...)\"\n        ];\n        function isInterceptionRouteAppPath(path) {\n            // TODO-APP: add more serious validation\n            return path.split(\"/\").find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;\n        }\n        function extractInterceptionRouteInformation(path) {\n            let interceptingRoute, marker, interceptedRoute;\n            for (const segment of path.split(\"/\")){\n                marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n                if (marker) {\n                    [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n                    break;\n                }\n            }\n            if (!interceptingRoute || !marker || !interceptedRoute) {\n                throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);\n            }\n            interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n            ;\n            switch(marker){\n                case \"(.)\":\n                    // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n                    if (interceptingRoute === \"/\") {\n                        interceptedRoute = `/${interceptedRoute}`;\n                    } else {\n                        interceptedRoute = interceptingRoute + \"/\" + interceptedRoute;\n                    }\n                    break;\n                case \"(..)\":\n                    // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n                    if (interceptingRoute === \"/\") {\n                        throw new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`);\n                    }\n                    interceptedRoute = interceptingRoute.split(\"/\").slice(0, -1).concat(interceptedRoute).join(\"/\");\n                    break;\n                case \"(...)\":\n                    // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n                    interceptedRoute = \"/\" + interceptedRoute;\n                    break;\n                case \"(..)(..)\":\n                    // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n                    const splitInterceptingRoute = interceptingRoute.split(\"/\");\n                    if (splitInterceptingRoute.length <= 2) {\n                        throw new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`);\n                    }\n                    interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join(\"/\");\n                    break;\n                default:\n                    throw new Error(\"Invariant: unexpected marker\");\n            }\n            return {\n                interceptingRoute,\n                interceptedRoute\n            };\n        }\n    })(interceptionRoutes);\n    return interceptionRoutes;\n}\nvar escapeRegexp = {};\nvar hasRequiredEscapeRegexp;\nfunction requireEscapeRegexp() {\n    if (hasRequiredEscapeRegexp) return escapeRegexp;\n    hasRequiredEscapeRegexp = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"escapeStringRegexp\", {\n            enumerable: true,\n            get: function() {\n                return escapeStringRegexp;\n            }\n        });\n        const reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\n        const reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\n        function escapeStringRegexp(str) {\n            // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n            if (reHasRegExp.test(str)) {\n                return str.replace(reReplaceRegExp, \"\\\\$&\");\n            }\n            return str;\n        }\n    })(escapeRegexp);\n    return escapeRegexp;\n}\nvar hasRequiredRouteRegex;\nfunction requireRouteRegex() {\n    if (hasRequiredRouteRegex) return routeRegex;\n    hasRequiredRouteRegex = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        function _export(target, all) {\n            for(var name in all)Object.defineProperty(target, name, {\n                enumerable: true,\n                get: all[name]\n            });\n        }\n        _export(exports1, {\n            getRouteRegex: function() {\n                return getRouteRegex;\n            },\n            getNamedRouteRegex: function() {\n                return getNamedRouteRegex;\n            },\n            getNamedMiddlewareRegex: function() {\n                return getNamedMiddlewareRegex;\n            }\n        });\n        const _interceptionroutes = requireInterceptionRoutes();\n        const _escaperegexp = requireEscapeRegexp();\n        const _removetrailingslash = requireRemoveTrailingSlash();\n        const NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\n        const NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n        /**\n\t\t * Parses a given parameter from a route to a data structure that can be used\n\t\t * to generate the parametrized route. Examples:\n\t\t *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n\t\t *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n\t\t *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n\t\t *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n\t\t */ function parseParameter(param) {\n            const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n            if (optional) {\n                param = param.slice(1, -1);\n            }\n            const repeat = param.startsWith(\"...\");\n            if (repeat) {\n                param = param.slice(3);\n            }\n            return {\n                key: param,\n                repeat,\n                optional\n            };\n        }\n        function getParametrizedRoute(route) {\n            const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n            const groups = {};\n            let groupIndex = 1;\n            return {\n                parameterizedRoute: segments.map((segment)=>{\n                    const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n                    const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n                    ;\n                    if (markerMatch && paramMatches) {\n                        const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                        groups[key] = {\n                            pos: groupIndex++,\n                            repeat,\n                            optional\n                        };\n                        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n                    } else if (paramMatches) {\n                        const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                        groups[key] = {\n                            pos: groupIndex++,\n                            repeat,\n                            optional\n                        };\n                        return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n                    } else {\n                        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n                    }\n                }).join(\"\"),\n                groups\n            };\n        }\n        function getRouteRegex(normalizedRoute) {\n            const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n            return {\n                re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n                groups: groups\n            };\n        }\n        /**\n\t\t * Builds a function to generate a minimal routeKey using only a-z and minimal\n\t\t * number of characters.\n\t\t */ function buildGetSafeRouteKey() {\n            let i = 0;\n            return ()=>{\n                let routeKey = \"\";\n                let j = ++i;\n                while(j > 0){\n                    routeKey += String.fromCharCode(97 + (j - 1) % 26);\n                    j = Math.floor((j - 1) / 26);\n                }\n                return routeKey;\n            };\n        }\n        function getSafeKeyFromSegment(param) {\n            let { getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n            const { key, optional, repeat } = parseParameter(segment);\n            // replace any non-word characters since they can break\n            // the named regex\n            let cleanedKey = key.replace(/\\W/g, \"\");\n            if (keyPrefix) {\n                cleanedKey = \"\" + keyPrefix + cleanedKey;\n            }\n            let invalidKey = false;\n            // check if the key is still invalid and fallback to using a known\n            // safe key\n            if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n                invalidKey = true;\n            }\n            if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n                invalidKey = true;\n            }\n            if (invalidKey) {\n                cleanedKey = getSafeRouteKey();\n            }\n            if (keyPrefix) {\n                routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n            } else {\n                routeKeys[cleanedKey] = \"\" + key;\n            }\n            return repeat ? optional ? \"(?:/(?<\" + cleanedKey + \">.+?))?\" : \"/(?<\" + cleanedKey + \">.+?)\" : \"/(?<\" + cleanedKey + \">[^/]+?)\";\n        }\n        function getNamedParametrizedRoute(route, prefixRouteKeys) {\n            const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n            const getSafeRouteKey = buildGetSafeRouteKey();\n            const routeKeys = {};\n            return {\n                namedParameterizedRoute: segments.map((segment)=>{\n                    const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n                    const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n                    ;\n                    if (hasInterceptionMarker && paramMatches) {\n                        return getSafeKeyFromSegment({\n                            getSafeRouteKey,\n                            segment: paramMatches[1],\n                            routeKeys,\n                            keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                        });\n                    } else if (paramMatches) {\n                        return getSafeKeyFromSegment({\n                            getSafeRouteKey,\n                            segment: paramMatches[1],\n                            routeKeys,\n                            keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                        });\n                    } else {\n                        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n                    }\n                }).join(\"\"),\n                routeKeys\n            };\n        }\n        function getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n            const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n            return {\n                ...getRouteRegex(normalizedRoute),\n                namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n                routeKeys: result.routeKeys\n            };\n        }\n        function getNamedMiddlewareRegex(normalizedRoute, options) {\n            const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n            const { catchAll = true } = options;\n            if (parameterizedRoute === \"/\") {\n                let catchAllRegex = catchAll ? \".*\" : \"\";\n                return {\n                    namedRegex: \"^/\" + catchAllRegex + \"$\"\n                };\n            }\n            const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n            let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n            return {\n                namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n            };\n        }\n    })(routeRegex);\n    return routeRegex;\n}\nvar hasRequiredInterpolateAs;\nfunction requireInterpolateAs() {\n    if (hasRequiredInterpolateAs) return interpolateAs;\n    hasRequiredInterpolateAs = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"interpolateAs\", {\n            enumerable: true,\n            get: function() {\n                return interpolateAs;\n            }\n        });\n        const _routematcher = requireRouteMatcher();\n        const _routeregex = requireRouteRegex();\n        function interpolateAs(route, asPathname, query) {\n            let interpolatedRoute = \"\";\n            const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n            const dynamicGroups = dynamicRegex.groups;\n            const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n            // TODO: should this take priority; also need to change in the router.\n            query;\n            interpolatedRoute = route;\n            const params = Object.keys(dynamicGroups);\n            if (!params.every((param)=>{\n                let value = dynamicMatches[param] || \"\";\n                const { repeat, optional } = dynamicGroups[param];\n                // support single-level catch-all\n                // TODO: more robust handling for user-error (passing `/`)\n                let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n                if (optional) {\n                    replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n                }\n                if (repeat && !Array.isArray(value)) value = [\n                    value\n                ];\n                return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n                (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n                // into the URL and we expect URL encoded segments\n                // when parsing dynamic route params\n                (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n            })) {\n                interpolatedRoute = \"\" // did not satisfy all requirements\n                ;\n            // n.b. We ignore this error because we handle warning for this case in\n            // development in the `<Link>` component directly.\n            }\n            return {\n                params,\n                result: interpolatedRoute\n            };\n        }\n    })(interpolateAs);\n    return interpolateAs;\n}\nvar hasRequiredResolveHref;\nfunction requireResolveHref() {\n    if (hasRequiredResolveHref) return resolveHref.exports;\n    hasRequiredResolveHref = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"resolveHref\", {\n            enumerable: true,\n            get: function() {\n                return resolveHref;\n            }\n        });\n        const _querystring = requireQuerystring();\n        const _formaturl = requireFormatUrl();\n        const _omit = requireOmit();\n        const _utils = requireUtils$1();\n        const _normalizetrailingslash = requireNormalizeTrailingSlash();\n        const _islocalurl = requireIsLocalUrl();\n        const _utils1 = requireUtils();\n        const _interpolateas = requireInterpolateAs();\n        function resolveHref(router, href, resolveAs) {\n            // we use a dummy base url for relative urls\n            let base;\n            let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n            // repeated slashes and backslashes in the URL are considered\n            // invalid and will never match a Next.js page/file\n            const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n            const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n            const urlParts = urlAsStringNoProto.split(\"?\");\n            if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n                console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n                const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n                urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n            }\n            // Return because it cannot be routed by the Next.js router\n            if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n                return resolveAs ? [\n                    urlAsString\n                ] : urlAsString;\n            }\n            try {\n                base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n            } catch (_) {\n                // fallback to / for invalid asPath values e.g. //\n                base = new URL(\"/\", \"http://n\");\n            }\n            try {\n                const finalUrl = new URL(urlAsString, base);\n                finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n                let interpolatedAs = \"\";\n                if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n                    const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n                    const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n                    if (result) {\n                        interpolatedAs = (0, _formaturl.formatWithValidation)({\n                            pathname: result,\n                            hash: finalUrl.hash,\n                            query: (0, _omit.omit)(query, params)\n                        });\n                    }\n                }\n                // if the origin didn't change, it means we received a relative href\n                const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n                return resolveAs ? [\n                    resolvedHref,\n                    interpolatedAs || resolvedHref\n                ] : resolvedHref;\n            } catch (_) {\n                return resolveAs ? [\n                    urlAsString\n                ] : urlAsString;\n            }\n        }\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(resolveHref, resolveHref.exports);\n    return resolveHref.exports;\n}\nvar addLocale$1 = {\n    exports: {}\n};\nvar addLocale = {};\nvar addPathPrefix = {};\nvar hasRequiredAddPathPrefix;\nfunction requireAddPathPrefix() {\n    if (hasRequiredAddPathPrefix) return addPathPrefix;\n    hasRequiredAddPathPrefix = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"addPathPrefix\", {\n            enumerable: true,\n            get: function() {\n                return addPathPrefix;\n            }\n        });\n        const _parsepath = requireParsePath();\n        function addPathPrefix(path, prefix) {\n            if (!path.startsWith(\"/\") || !prefix) {\n                return path;\n            }\n            const { pathname, query, hash } = (0, _parsepath.parsePath)(path);\n            return \"\" + prefix + pathname + query + hash;\n        }\n    })(addPathPrefix);\n    return addPathPrefix;\n}\nvar hasRequiredAddLocale$1;\nfunction requireAddLocale$1() {\n    if (hasRequiredAddLocale$1) return addLocale;\n    hasRequiredAddLocale$1 = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"addLocale\", {\n            enumerable: true,\n            get: function() {\n                return addLocale;\n            }\n        });\n        const _addpathprefix = requireAddPathPrefix();\n        const _pathhasprefix = requirePathHasPrefix();\n        function addLocale(path, locale, defaultLocale, ignorePrefix) {\n            // If no locale was given or the locale is the default locale, we don't need\n            // to prefix the path.\n            if (!locale || locale === defaultLocale) return path;\n            const lower = path.toLowerCase();\n            // If the path is an API path or the path already has the locale prefix, we\n            // don't need to prefix the path.\n            if (!ignorePrefix) {\n                if ((0, _pathhasprefix.pathHasPrefix)(lower, \"/api\")) return path;\n                if ((0, _pathhasprefix.pathHasPrefix)(lower, \"/\" + locale.toLowerCase())) return path;\n            }\n            // Add the locale prefix to the path.\n            return (0, _addpathprefix.addPathPrefix)(path, \"/\" + locale);\n        }\n    })(addLocale);\n    return addLocale;\n}\nvar hasRequiredAddLocale;\nfunction requireAddLocale() {\n    if (hasRequiredAddLocale) return addLocale$1.exports;\n    hasRequiredAddLocale = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"addLocale\", {\n            enumerable: true,\n            get: function() {\n                return addLocale;\n            }\n        });\n        const _normalizetrailingslash = requireNormalizeTrailingSlash();\n        const addLocale = function(path) {\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                args[_key - 1] = arguments[_key];\n            }\n            if (false) {}\n            return path;\n        };\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(addLocale$1, addLocale$1.exports);\n    return addLocale$1.exports;\n}\nvar routerContext_sharedRuntime = {};\nvar hasRequiredRouterContext_sharedRuntime;\nfunction requireRouterContext_sharedRuntime() {\n    if (hasRequiredRouterContext_sharedRuntime) return routerContext_sharedRuntime;\n    hasRequiredRouterContext_sharedRuntime = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"RouterContext\", {\n            enumerable: true,\n            get: function() {\n                return RouterContext;\n            }\n        });\n        const _interop_require_default = _interop_require_default$1;\n        const _react1 = /*#__PURE__*/ _interop_require_default._(_react.default);\n        const RouterContext = _react1.default.createContext(null);\n        if (true) {\n            RouterContext.displayName = \"RouterContext\";\n        }\n    })(routerContext_sharedRuntime);\n    return routerContext_sharedRuntime;\n}\nvar appRouterContext_sharedRuntime = {};\nvar hasRequiredAppRouterContext_sharedRuntime;\nfunction requireAppRouterContext_sharedRuntime() {\n    if (hasRequiredAppRouterContext_sharedRuntime) return appRouterContext_sharedRuntime;\n    hasRequiredAppRouterContext_sharedRuntime = 1;\n    (function(exports1) {\n        \"use client\";\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        function _export(target, all) {\n            for(var name in all)Object.defineProperty(target, name, {\n                enumerable: true,\n                get: all[name]\n            });\n        }\n        _export(exports1, {\n            CacheStates: function() {\n                return CacheStates;\n            },\n            AppRouterContext: function() {\n                return AppRouterContext;\n            },\n            LayoutRouterContext: function() {\n                return LayoutRouterContext;\n            },\n            GlobalLayoutRouterContext: function() {\n                return GlobalLayoutRouterContext;\n            },\n            TemplateContext: function() {\n                return TemplateContext;\n            }\n        });\n        const _interop_require_default = _interop_require_default$1;\n        const _react1 = /*#__PURE__*/ _interop_require_default._(_react.default);\n        var CacheStates;\n        (function(CacheStates) {\n            CacheStates[\"LAZY_INITIALIZED\"] = \"LAZYINITIALIZED\";\n            CacheStates[\"DATA_FETCH\"] = \"DATAFETCH\";\n            CacheStates[\"READY\"] = \"READY\";\n        })(CacheStates || (CacheStates = {}));\n        const AppRouterContext = _react1.default.createContext(null);\n        const LayoutRouterContext = _react1.default.createContext(null);\n        const GlobalLayoutRouterContext = _react1.default.createContext(null);\n        const TemplateContext = _react1.default.createContext(null);\n        if (true) {\n            AppRouterContext.displayName = \"AppRouterContext\";\n            LayoutRouterContext.displayName = \"LayoutRouterContext\";\n            GlobalLayoutRouterContext.displayName = \"GlobalLayoutRouterContext\";\n            TemplateContext.displayName = \"TemplateContext\";\n        }\n    })(appRouterContext_sharedRuntime);\n    return appRouterContext_sharedRuntime;\n}\nvar useIntersection = {\n    exports: {}\n};\nvar requestIdleCallback = {\n    exports: {}\n};\nvar hasRequiredRequestIdleCallback;\nfunction requireRequestIdleCallback() {\n    if (hasRequiredRequestIdleCallback) return requestIdleCallback.exports;\n    hasRequiredRequestIdleCallback = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        function _export(target, all) {\n            for(var name in all)Object.defineProperty(target, name, {\n                enumerable: true,\n                get: all[name]\n            });\n        }\n        _export(exports1, {\n            requestIdleCallback: function() {\n                return requestIdleCallback;\n            },\n            cancelIdleCallback: function() {\n                return cancelIdleCallback;\n            }\n        });\n        const requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n            let start = Date.now();\n            return self.setTimeout(function() {\n                cb({\n                    didTimeout: false,\n                    timeRemaining: function() {\n                        return Math.max(0, 50 - (Date.now() - start));\n                    }\n                });\n            }, 1);\n        };\n        const cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n            return clearTimeout(id);\n        };\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(requestIdleCallback, requestIdleCallback.exports);\n    return requestIdleCallback.exports;\n}\nvar hasRequiredUseIntersection;\nfunction requireUseIntersection() {\n    if (hasRequiredUseIntersection) return useIntersection.exports;\n    hasRequiredUseIntersection = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"useIntersection\", {\n            enumerable: true,\n            get: function() {\n                return useIntersection;\n            }\n        });\n        const _react1 = _react.default;\n        const _requestidlecallback = requireRequestIdleCallback();\n        const hasIntersectionObserver = typeof IntersectionObserver === \"function\";\n        const observers = new Map();\n        const idList = [];\n        function createObserver(options) {\n            const id = {\n                root: options.root || null,\n                margin: options.rootMargin || \"\"\n            };\n            const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n            let instance;\n            if (existing) {\n                instance = observers.get(existing);\n                if (instance) {\n                    return instance;\n                }\n            }\n            const elements = new Map();\n            const observer = new IntersectionObserver((entries)=>{\n                entries.forEach((entry)=>{\n                    const callback = elements.get(entry.target);\n                    const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n                    if (callback && isVisible) {\n                        callback(isVisible);\n                    }\n                });\n            }, options);\n            instance = {\n                id,\n                observer,\n                elements\n            };\n            idList.push(id);\n            observers.set(id, instance);\n            return instance;\n        }\n        function observe(element, callback, options) {\n            const { id, observer, elements } = createObserver(options);\n            elements.set(element, callback);\n            observer.observe(element);\n            return function unobserve() {\n                elements.delete(element);\n                observer.unobserve(element);\n                // Destroy observer when there's nothing left to watch:\n                if (elements.size === 0) {\n                    observer.disconnect();\n                    observers.delete(id);\n                    const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n                    if (index > -1) {\n                        idList.splice(index, 1);\n                    }\n                }\n            };\n        }\n        function useIntersection(param) {\n            let { rootRef, rootMargin, disabled } = param;\n            const isDisabled = disabled || !hasIntersectionObserver;\n            const [visible, setVisible] = (0, _react1.useState)(false);\n            const elementRef = (0, _react1.useRef)(null);\n            const setElement = (0, _react1.useCallback)((element)=>{\n                elementRef.current = element;\n            }, []);\n            (0, _react1.useEffect)(()=>{\n                if (hasIntersectionObserver) {\n                    if (isDisabled || visible) return;\n                    const element = elementRef.current;\n                    if (element && element.tagName) {\n                        const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                            root: rootRef == null ? void 0 : rootRef.current,\n                            rootMargin\n                        });\n                        return unobserve;\n                    }\n                } else {\n                    if (!visible) {\n                        const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                        return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n                    }\n                }\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            }, [\n                isDisabled,\n                rootMargin,\n                rootRef,\n                visible,\n                elementRef.current\n            ]);\n            const resetVisible = (0, _react1.useCallback)(()=>{\n                setVisible(false);\n            }, []);\n            return [\n                setElement,\n                visible,\n                resetVisible\n            ];\n        }\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(useIntersection, useIntersection.exports);\n    return useIntersection.exports;\n}\nvar getDomainLocale = {\n    exports: {}\n};\nvar normalizeLocalePath$1 = {\n    exports: {}\n};\nvar normalizeLocalePath = {};\nvar hasRequiredNormalizeLocalePath$1;\nfunction requireNormalizeLocalePath$1() {\n    if (hasRequiredNormalizeLocalePath$1) return normalizeLocalePath;\n    hasRequiredNormalizeLocalePath$1 = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"normalizeLocalePath\", {\n            enumerable: true,\n            get: function() {\n                return normalizeLocalePath;\n            }\n        });\n        function normalizeLocalePath(pathname, locales) {\n            let detectedLocale;\n            // first item will be empty string from splitting at first char\n            const pathnameParts = pathname.split(\"/\");\n            (locales || []).some((locale)=>{\n                if (pathnameParts[1] && pathnameParts[1].toLowerCase() === locale.toLowerCase()) {\n                    detectedLocale = locale;\n                    pathnameParts.splice(1, 1);\n                    pathname = pathnameParts.join(\"/\") || \"/\";\n                    return true;\n                }\n                return false;\n            });\n            return {\n                pathname,\n                detectedLocale\n            };\n        }\n    })(normalizeLocalePath);\n    return normalizeLocalePath;\n}\nvar hasRequiredNormalizeLocalePath;\nfunction requireNormalizeLocalePath() {\n    if (hasRequiredNormalizeLocalePath) return normalizeLocalePath$1.exports;\n    hasRequiredNormalizeLocalePath = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"normalizeLocalePath\", {\n            enumerable: true,\n            get: function() {\n                return normalizeLocalePath;\n            }\n        });\n        const normalizeLocalePath = (pathname, locales)=>{\n            if (false) {}\n            return {\n                pathname,\n                detectedLocale: undefined\n            };\n        };\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(normalizeLocalePath$1, normalizeLocalePath$1.exports);\n    return normalizeLocalePath$1.exports;\n}\nvar detectDomainLocale$1 = {\n    exports: {}\n};\nvar detectDomainLocale = {};\nvar hasRequiredDetectDomainLocale$1;\nfunction requireDetectDomainLocale$1() {\n    if (hasRequiredDetectDomainLocale$1) return detectDomainLocale;\n    hasRequiredDetectDomainLocale$1 = 1;\n    (function(exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"detectDomainLocale\", {\n            enumerable: true,\n            get: function() {\n                return detectDomainLocale;\n            }\n        });\n        function detectDomainLocale(domainItems, hostname, detectedLocale) {\n            if (!domainItems) return;\n            if (detectedLocale) {\n                detectedLocale = detectedLocale.toLowerCase();\n            }\n            for (const item of domainItems){\n                var _item_domain, _item_locales;\n                // remove port if present\n                const domainHostname = (_item_domain = item.domain) == null ? void 0 : _item_domain.split(\":\")[0].toLowerCase();\n                if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((_item_locales = item.locales) == null ? void 0 : _item_locales.some((locale)=>locale.toLowerCase() === detectedLocale))) {\n                    return item;\n                }\n            }\n        }\n    })(detectDomainLocale);\n    return detectDomainLocale;\n}\nvar hasRequiredDetectDomainLocale;\nfunction requireDetectDomainLocale() {\n    if (hasRequiredDetectDomainLocale) return detectDomainLocale$1.exports;\n    hasRequiredDetectDomainLocale = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"detectDomainLocale\", {\n            enumerable: true,\n            get: function() {\n                return detectDomainLocale;\n            }\n        });\n        const detectDomainLocale = function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            if (false) {}\n        };\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(detectDomainLocale$1, detectDomainLocale$1.exports);\n    return detectDomainLocale$1.exports;\n}\nvar hasRequiredGetDomainLocale;\nfunction requireGetDomainLocale() {\n    if (hasRequiredGetDomainLocale) return getDomainLocale.exports;\n    hasRequiredGetDomainLocale = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"getDomainLocale\", {\n            enumerable: true,\n            get: function() {\n                return getDomainLocale;\n            }\n        });\n        const _normalizetrailingslash = requireNormalizeTrailingSlash();\n        const basePath =  false || \"\";\n        function getDomainLocale(path, locale, locales, domainLocales) {\n            if (false) {} else {\n                return false;\n            }\n        }\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(getDomainLocale, getDomainLocale.exports);\n    return getDomainLocale.exports;\n}\nvar addBasePath = {\n    exports: {}\n};\nvar hasRequiredAddBasePath;\nfunction requireAddBasePath() {\n    if (hasRequiredAddBasePath) return addBasePath.exports;\n    hasRequiredAddBasePath = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports1, \"addBasePath\", {\n            enumerable: true,\n            get: function() {\n                return addBasePath;\n            }\n        });\n        const _addpathprefix = requireAddPathPrefix();\n        const _normalizetrailingslash = requireNormalizeTrailingSlash();\n        const basePath =  false || \"\";\n        function addBasePath(path, required) {\n            return (0, _normalizetrailingslash.normalizePathTrailingSlash)( false ? 0 : (0, _addpathprefix.addPathPrefix)(path, basePath));\n        }\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(addBasePath, addBasePath.exports);\n    return addBasePath.exports;\n}\nvar routerReducerTypes = {\n    exports: {}\n};\nvar hasRequiredRouterReducerTypes;\nfunction requireRouterReducerTypes() {\n    if (hasRequiredRouterReducerTypes) return routerReducerTypes.exports;\n    hasRequiredRouterReducerTypes = 1;\n    (function(module, exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n        function _export(target, all) {\n            for(var name in all)Object.defineProperty(target, name, {\n                enumerable: true,\n                get: all[name]\n            });\n        }\n        _export(exports1, {\n            PrefetchKind: function() {\n                return PrefetchKind;\n            },\n            ACTION_REFRESH: function() {\n                return ACTION_REFRESH;\n            },\n            ACTION_NAVIGATE: function() {\n                return ACTION_NAVIGATE;\n            },\n            ACTION_RESTORE: function() {\n                return ACTION_RESTORE;\n            },\n            ACTION_SERVER_PATCH: function() {\n                return ACTION_SERVER_PATCH;\n            },\n            ACTION_PREFETCH: function() {\n                return ACTION_PREFETCH;\n            },\n            ACTION_FAST_REFRESH: function() {\n                return ACTION_FAST_REFRESH;\n            },\n            ACTION_SERVER_ACTION: function() {\n                return ACTION_SERVER_ACTION;\n            }\n        });\n        const ACTION_REFRESH = \"refresh\";\n        const ACTION_NAVIGATE = \"navigate\";\n        const ACTION_RESTORE = \"restore\";\n        const ACTION_SERVER_PATCH = \"server-patch\";\n        const ACTION_PREFETCH = \"prefetch\";\n        const ACTION_FAST_REFRESH = \"fast-refresh\";\n        const ACTION_SERVER_ACTION = \"server-action\";\n        var PrefetchKind;\n        (function(PrefetchKind) {\n            PrefetchKind[\"AUTO\"] = \"auto\";\n            PrefetchKind[\"FULL\"] = \"full\";\n            PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n        })(PrefetchKind || (PrefetchKind = {}));\n        if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n            Object.defineProperty(exports1.default, \"__esModule\", {\n                value: true\n            });\n            Object.assign(exports1.default, exports1);\n            module.exports = exports1.default;\n        }\n    })(routerReducerTypes, routerReducerTypes.exports);\n    return routerReducerTypes.exports;\n}\n(function(module, exports1) {\n    \"use client\";\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    Object.defineProperty(exports1, \"default\", {\n        enumerable: true,\n        get: function() {\n            return _default;\n        }\n    });\n    const _interop_require_default = _interop_require_default$1;\n    const _react1 = /*#__PURE__*/ _interop_require_default._(_react.default);\n    const _resolvehref = requireResolveHref();\n    const _islocalurl = requireIsLocalUrl();\n    const _formaturl = requireFormatUrl();\n    const _utils = requireUtils$1();\n    const _addlocale = requireAddLocale();\n    const _routercontextsharedruntime = requireRouterContext_sharedRuntime();\n    const _approutercontextsharedruntime = requireAppRouterContext_sharedRuntime();\n    const _useintersection = requireUseIntersection();\n    const _getdomainlocale = requireGetDomainLocale();\n    const _addbasepath = requireAddBasePath();\n    const _routerreducertypes = requireRouterReducerTypes();\n    const prefetched = new Set();\n    function prefetch(router, href, as, options, appOptions, isAppRouter) {\n        if (true) {\n            return;\n        }\n        // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n        if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n            return;\n        }\n        // We should only dedupe requests when experimental.optimisticClientCache is\n        // disabled.\n        if (!options.bypassPrefetchedCheck) {\n            const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n            const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n            // If we've already fetched the key, then don't prefetch it again!\n            if (prefetched.has(prefetchedKey)) {\n                return;\n            }\n            // Mark this URL as prefetched.\n            prefetched.add(prefetchedKey);\n        }\n        const prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n        // Prefetch the JSON page if asked (only in the client)\n        // We need to handle a prefetch error here since we may be\n        // loading with priority which can reject but we don't\n        // want to force navigation since this is only a prefetch\n        Promise.resolve(prefetchPromise).catch((err)=>{\n            if (true) {\n                // rethrow to show invalid URL errors\n                throw err;\n            }\n        });\n    }\n    function isModifiedEvent(event) {\n        const eventTarget = event.currentTarget;\n        const target = eventTarget.getAttribute(\"target\");\n        return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n        event.nativeEvent && event.nativeEvent.which === 2;\n    }\n    function linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n        const { nodeName } = e.currentTarget;\n        // anchors inside an svg have a lowercase nodeName\n        const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n        if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n        !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n            // ignore click for browser’s default behavior\n            return;\n        }\n        e.preventDefault();\n        const navigate = ()=>{\n            // If the router is an NextRouter instance it will have `beforePopState`\n            const routerScroll = scroll != null ? scroll : true;\n            if (\"beforePopState\" in router) {\n                router[replace ? \"replace\" : \"push\"](href, as, {\n                    shallow,\n                    locale,\n                    scroll: routerScroll\n                });\n            } else {\n                router[replace ? \"replace\" : \"push\"](as || href, {\n                    forceOptimisticNavigation: !prefetchEnabled,\n                    scroll: routerScroll\n                });\n            }\n        };\n        if (isAppRouter) {\n            _react1.default.startTransition(navigate);\n        } else {\n            navigate();\n        }\n    }\n    function formatStringOrUrl(urlObjOrString) {\n        if (typeof urlObjOrString === \"string\") {\n            return urlObjOrString;\n        }\n        return (0, _formaturl.formatUrl)(urlObjOrString);\n    }\n    /**\n\t * React Component that enables client-side transitions between routes.\n\t */ const Link = /*#__PURE__*/ _react1.default.forwardRef(function LinkComponent(props, forwardedRef) {\n        let children;\n        const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n        children = childrenProp;\n        if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n            children = /*#__PURE__*/ _react1.default.createElement(\"a\", null, children);\n        }\n        const pagesRouter = _react1.default.useContext(_routercontextsharedruntime.RouterContext);\n        const appRouter = _react1.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n        const router = pagesRouter != null ? pagesRouter : appRouter;\n        // We're in the app directory if there is no pages router.\n        const isAppRouter = !pagesRouter;\n        const prefetchEnabled = prefetchProp !== false;\n        /**\n\t     * The possible states for prefetch are:\n\t     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n\t     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n\t     * - false: we will not prefetch if in the viewport at all\n\t     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n        if (true) {\n            function createPropError(args) {\n                return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( false ? 0 : \"\"));\n            }\n            // TypeScript trick for type-guarding:\n            const requiredPropsGuard = {\n                href: true\n            };\n            const requiredProps = Object.keys(requiredPropsGuard);\n            requiredProps.forEach((key)=>{\n                if (key === \"href\") {\n                    if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                        throw createPropError({\n                            key,\n                            expected: \"`string` or `object`\",\n                            actual: props[key] === null ? \"null\" : typeof props[key]\n                        });\n                    }\n                }\n            });\n            // TypeScript trick for type-guarding:\n            const optionalPropsGuard = {\n                as: true,\n                replace: true,\n                scroll: true,\n                shallow: true,\n                passHref: true,\n                prefetch: true,\n                locale: true,\n                onClick: true,\n                onMouseEnter: true,\n                onTouchStart: true,\n                legacyBehavior: true\n            };\n            const optionalProps = Object.keys(optionalPropsGuard);\n            optionalProps.forEach((key)=>{\n                const valType = typeof props[key];\n                if (key === \"as\") {\n                    if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                        throw createPropError({\n                            key,\n                            expected: \"`string` or `object`\",\n                            actual: valType\n                        });\n                    }\n                } else if (key === \"locale\") {\n                    if (props[key] && valType !== \"string\") {\n                        throw createPropError({\n                            key,\n                            expected: \"`string`\",\n                            actual: valType\n                        });\n                    }\n                } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                    if (props[key] && valType !== \"function\") {\n                        throw createPropError({\n                            key,\n                            expected: \"`function`\",\n                            actual: valType\n                        });\n                    }\n                } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                    if (props[key] != null && valType !== \"boolean\") {\n                        throw createPropError({\n                            key,\n                            expected: \"`boolean`\",\n                            actual: valType\n                        });\n                    }\n                } else ;\n            });\n            // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n            // eslint-disable-next-line react-hooks/rules-of-hooks\n            const hasWarned = _react1.default.useRef(false);\n            if (props.prefetch && !hasWarned.current && !isAppRouter) {\n                hasWarned.current = true;\n                console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n            }\n        }\n        if (true) {\n            if (isAppRouter && !asProp) {\n                let href;\n                if (typeof hrefProp === \"string\") {\n                    href = hrefProp;\n                } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                    href = hrefProp.pathname;\n                }\n                if (href) {\n                    const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                    if (hasDynamicSegment) {\n                        throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                    }\n                }\n            }\n        }\n        const { href, as } = _react1.default.useMemo(()=>{\n            if (!pagesRouter) {\n                const resolvedHref = formatStringOrUrl(hrefProp);\n                return {\n                    href: resolvedHref,\n                    as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n                };\n            }\n            const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n            return {\n                href: resolvedHref,\n                as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n            };\n        }, [\n            pagesRouter,\n            hrefProp,\n            asProp\n        ]);\n        const previousHref = _react1.default.useRef(href);\n        const previousAs = _react1.default.useRef(as);\n        // This will return the first child, if multiple are provided it will throw an error\n        let child;\n        if (legacyBehavior) {\n            if (true) {\n                if (onClick) {\n                    console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n                }\n                if (onMouseEnterProp) {\n                    console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n                }\n                try {\n                    child = _react1.default.Children.only(children);\n                } catch (err) {\n                    if (!children) {\n                        throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                    }\n                    throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( false ? 0 : \"\"));\n                }\n            } else {}\n        } else {\n            if (true) {\n                if ((children == null ? void 0 : children.type) === \"a\") {\n                    throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n                }\n            }\n        }\n        const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n        const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n            rootMargin: \"200px\"\n        });\n        const setRef = _react1.default.useCallback((el)=>{\n            // Before the link getting observed, check if visible state need to be reset\n            if (previousAs.current !== as || previousHref.current !== href) {\n                resetVisible();\n                previousAs.current = as;\n                previousHref.current = href;\n            }\n            setIntersectionRef(el);\n            if (childRef) {\n                if (typeof childRef === \"function\") childRef(el);\n                else if (typeof childRef === \"object\") {\n                    childRef.current = el;\n                }\n            }\n        }, [\n            as,\n            childRef,\n            href,\n            resetVisible,\n            setIntersectionRef\n        ]);\n        // Prefetch the URL if we haven't already and it's visible.\n        _react1.default.useEffect(()=>{\n            // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n            if (true) {\n                return;\n            }\n            if (!router) {\n                return;\n            }\n            // If we don't need to prefetch the URL, don't do prefetch.\n            if (!isVisible || !prefetchEnabled) {\n                return;\n            }\n            // Prefetch the URL.\n            prefetch(router, href, as, {\n                locale\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }, [\n            as,\n            href,\n            isVisible,\n            locale,\n            prefetchEnabled,\n            pagesRouter == null ? void 0 : pagesRouter.locale,\n            router,\n            isAppRouter,\n            appPrefetchKind\n        ]);\n        const childProps = {\n            ref: setRef,\n            onClick (e) {\n                if (true) {\n                    if (!e) {\n                        throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                    }\n                }\n                if (!legacyBehavior && typeof onClick === \"function\") {\n                    onClick(e);\n                }\n                if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                    child.props.onClick(e);\n                }\n                if (!router) {\n                    return;\n                }\n                if (e.defaultPrevented) {\n                    return;\n                }\n                linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);\n            },\n            onMouseEnter (e) {\n                if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                    onMouseEnterProp(e);\n                }\n                if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                    child.props.onMouseEnter(e);\n                }\n                if (!router) {\n                    return;\n                }\n                if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                    return;\n                }\n                prefetch(router, href, as, {\n                    locale,\n                    priority: true,\n                    // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                    bypassPrefetchedCheck: true\n                }, {\n                    kind: appPrefetchKind\n                }, isAppRouter);\n            },\n            onTouchStart (e) {\n                if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                    onTouchStartProp(e);\n                }\n                if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                    child.props.onTouchStart(e);\n                }\n                if (!router) {\n                    return;\n                }\n                if (!prefetchEnabled && isAppRouter) {\n                    return;\n                }\n                prefetch(router, href, as, {\n                    locale,\n                    priority: true,\n                    // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                    bypassPrefetchedCheck: true\n                }, {\n                    kind: appPrefetchKind\n                }, isAppRouter);\n            }\n        };\n        // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n        // defined, we specify the current 'href', so that repetition is not needed by the user.\n        // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n        if ((0, _utils.isAbsoluteUrl)(as)) {\n            childProps.href = as;\n        } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n            const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n            // we only render domain locales if we are currently on a domain locale\n            // so that locale links are still visitable in development/preview envs\n            const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n            childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n        }\n        return legacyBehavior ? /*#__PURE__*/ _react1.default.cloneElement(child, childProps) : /*#__PURE__*/ _react1.default.createElement(\"a\", {\n            ...restProps,\n            ...childProps\n        }, children);\n    });\n    const _default = Link;\n    if ((typeof exports1.default === \"function\" || typeof exports1.default === \"object\" && exports1.default !== null) && typeof exports1.default.__esModule === \"undefined\") {\n        Object.defineProperty(exports1.default, \"__esModule\", {\n            value: true\n        });\n        Object.assign(exports1.default, exports1);\n        module.exports = exports1.default;\n    }\n})(link$1, link$1.exports);\nvar linkExports = link$1.exports;\nvar link = linkExports;\nvar Link = /*@__PURE__*/ getDefaultExportFromCjs(link);\nvar styles$p = {\n    \"anchor\": \"Anchor-module_anchor__hzmne\",\n    \"isSpan\": \"Anchor-module_isSpan__JAO3f\"\n};\nconst A = ({ children, ...props })=>/*#__PURE__*/ _react.default.createElement(\"a\", {\n        ...props\n    }, children);\nconst Anchor = ({ id, href, opensInNewTab = false, className, classNameAnchor, children, useNextJSLink = true, as, disable = false, onClick, useSpanInline = false, ...props })=>{\n    const useNextJS = useNextJSLink && !opensInNewTab;\n    const LinkComponent = useNextJS ? Link : A;\n    const handleClick = (0, _react.useCallback)((e)=>{\n        if (disable) {\n            e.preventDefault();\n        }\n        onClick?.(e);\n    }, [\n        onClick,\n        disable\n    ]);\n    const child = (0, _react.useMemo)(()=>/*#__PURE__*/ _react.default.createElement(LinkComponent, {\n            ...props,\n            as: as,\n            className: (0, _classnames.default)(classNameAnchor, styles$p.anchor, {\n                [styles$p.isSpan]: useSpanInline\n            }),\n            href: href,\n            onClick: handleClick,\n            rel: \"noreferrer\",\n            target: opensInNewTab ? \"_blank\" : \"\"\n        }, children), [\n        LinkComponent,\n        as,\n        children,\n        classNameAnchor,\n        handleClick,\n        href,\n        opensInNewTab,\n        props,\n        useSpanInline\n    ]);\n    return useSpanInline ? /*#__PURE__*/ _react.default.createElement(\"span\", {\n        className: (0, _classnames.default)(className, styles$p.anchorWrapper),\n        id: id\n    }, child) : /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(className, styles$p.anchorWrapper),\n        id: id\n    }, child);\n};\nconst extractStaticImage = (imageImport)=>{\n    if (process.env.STORYBOOK && typeof imageImport === \"object\") {\n        return imageImport?.src;\n    }\n    if (typeof imageImport === \"string\") {\n        return imageImport;\n    }\n    return \"\";\n};\nconst HEADER_SIZES = [\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\"\n];\nconst generateFontSizeClassName = ({ fontSize, bold, italic = false, bold500 = false, bold600 = false, underline = false, inherit = true, notBold = bold === false, headerVariant, useHeaderFont = false })=>(0, _classnames.default)(\"font\", `font-size-${fontSize}`, {\n        header: useHeaderFont || HEADER_SIZES.includes(headerVariant || \"\"),\n        bold,\n        bold500,\n        bold600,\n        notBold,\n        italic,\n        underline,\n        inherit\n    });\nconst POSSIBLE_COLORS = [\n    \"white\",\n    \"black\",\n    \"dark\",\n    \"gray\",\n    \"red\",\n    \"pink\",\n    \"grape\",\n    \"violet\",\n    \"indigo\",\n    \"blue\",\n    \"cyan\",\n    \"teal\",\n    \"green\",\n    \"lime\",\n    \"yellow\",\n    \"orange\"\n];\nconst POSSIBLE_SHADES = [\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9\n];\nconst getCssVariableForColor = (color, shade)=>{\n    if (color === \"white\") {\n        return \"--theme-color-white\";\n    }\n    if (color === \"black\") {\n        return \"--theme-color-black\";\n    }\n    return `--theme-color-${color}-${shade}`;\n};\nconst getThemeVariable = (paramsObj)=>{\n    let cssVariableKey;\n    switch(paramsObj.type){\n        case \"color\":\n            {\n                const { color, shade, excludeColors, excludeShades } = paramsObj;\n                if (color === \"random\") {\n                    const randomColor = (0, _libutilities.getNRandomElementsFromArray)(POSSIBLE_COLORS.filter((col)=>!(excludeColors || []).some((c)=>c.toString() === col.toString())), 1)[0];\n                    cssVariableKey = getCssVariableForColor(randomColor, shade === \"random\" ? (0, _libutilities.getNRandomElementsFromArray)(POSSIBLE_SHADES.filter((col)=>!(excludeShades || []).some((c)=>c.toString() === col.toString())), 1)[0] : shade);\n                } else {\n                    cssVariableKey = getCssVariableForColor(color, shade);\n                }\n                break;\n            }\n        case \"font-size\":\n            {\n                const { size } = paramsObj;\n                cssVariableKey = `--theme-${size}-font-size`;\n                break;\n            }\n        case \"line-height\":\n            {\n                const { size } = paramsObj;\n                if ([\n                    \"xs\",\n                    \"sm\",\n                    \"md\",\n                    \"lg\",\n                    \"xl\"\n                ].includes(size)) {\n                    cssVariableKey = `--theme-line-height`;\n                } else {\n                    cssVariableKey = `--theme-${size}-line-height`;\n                }\n                break;\n            }\n        case \"shadow\":\n            {\n                const { size } = paramsObj;\n                cssVariableKey = `--theme-shadow-base-${size}`;\n                break;\n            }\n        case \"radius\":\n            {\n                const { size } = paramsObj;\n                cssVariableKey = `--theme-radius-${size}`;\n                break;\n            }\n    }\n    return (0, _libutilities.isBrowser)() && cssVariableKey ? window.getComputedStyle(document.body).getPropertyValue(cssVariableKey) : undefined;\n};\n/**\n * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n * without support for iteratee shorthands, which iterates over `collection`\n * using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the found element or its key, else `undefined`.\n */ function baseFindKey$1(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n        if (predicate(value, key, collection)) {\n            result = key;\n            return false;\n        }\n    });\n    return result;\n}\nvar _baseFindKey = baseFindKey$1;\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */ function createBaseFor$1(fromRight) {\n    return function(object, iteratee, keysFunc) {\n        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;\n        while(length--){\n            var key = props[fromRight ? length : ++index];\n            if (iteratee(iterable[key], key, iterable) === false) {\n                break;\n            }\n        }\n        return object;\n    };\n}\nvar _createBaseFor = createBaseFor$1;\nvar createBaseFor = _createBaseFor;\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */ var baseFor$1 = createBaseFor();\nvar _baseFor = baseFor$1;\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */ function baseTimes$1(n, iteratee) {\n    var index = -1, result = Array(n);\n    while(++index < n){\n        result[index] = iteratee(index);\n    }\n    return result;\n}\nvar _baseTimes = baseTimes$1;\n/** Detect free variable `global` from Node.js. */ var freeGlobal$1 = typeof commonjsGlobal == \"object\" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\nvar _freeGlobal = freeGlobal$1;\nvar freeGlobal = _freeGlobal;\n/** Detect free variable `self`. */ var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n/** Used as a reference to the global object. */ var root$8 = freeGlobal || freeSelf || Function(\"return this\")();\nvar _root = root$8;\nvar root$7 = _root;\n/** Built-in value references. */ var Symbol$6 = root$7.Symbol;\nvar _Symbol = Symbol$6;\nvar Symbol$5 = _Symbol;\n/** Used for built-in method references. */ var objectProto$f = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$c = objectProto$f.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var nativeObjectToString$1 = objectProto$f.toString;\n/** Built-in value references. */ var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : undefined;\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */ function getRawTag$1(value) {\n    var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];\n    try {\n        value[symToStringTag$1] = undefined;\n        var unmasked = true;\n    } catch (e) {}\n    var result = nativeObjectToString$1.call(value);\n    if (unmasked) {\n        if (isOwn) {\n            value[symToStringTag$1] = tag;\n        } else {\n            delete value[symToStringTag$1];\n        }\n    }\n    return result;\n}\nvar _getRawTag = getRawTag$1;\n/** Used for built-in method references. */ var objectProto$e = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var nativeObjectToString = objectProto$e.toString;\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */ function objectToString$1(value) {\n    return nativeObjectToString.call(value);\n}\nvar _objectToString = objectToString$1;\nvar Symbol$4 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;\n/** `Object#toString` result references. */ var nullTag = \"[object Null]\", undefinedTag = \"[object Undefined]\";\n/** Built-in value references. */ var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : undefined;\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */ function baseGetTag$7(value) {\n    if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n    }\n    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\nvar _baseGetTag = baseGetTag$7;\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ function isObjectLike$9(value) {\n    return value != null && typeof value == \"object\";\n}\nvar isObjectLike_1 = isObjectLike$9;\nvar baseGetTag$6 = _baseGetTag, isObjectLike$8 = isObjectLike_1;\n/** `Object#toString` result references. */ var argsTag$3 = \"[object Arguments]\";\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */ function baseIsArguments$1(value) {\n    return isObjectLike$8(value) && baseGetTag$6(value) == argsTag$3;\n}\nvar _baseIsArguments = baseIsArguments$1;\nvar baseIsArguments = _baseIsArguments, isObjectLike$7 = isObjectLike_1;\n/** Used for built-in method references. */ var objectProto$d = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$b = objectProto$d.hasOwnProperty;\n/** Built-in value references. */ var propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable;\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */ var isArguments$3 = baseIsArguments(function() {\n    return arguments;\n}()) ? baseIsArguments : function(value) {\n    return isObjectLike$7(value) && hasOwnProperty$b.call(value, \"callee\") && !propertyIsEnumerable$1.call(value, \"callee\");\n};\nvar isArguments_1 = isArguments$3;\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */ var isArray$c = Array.isArray;\nvar isArray_1 = isArray$c;\nvar isArray$d = /*@__PURE__*/ getDefaultExportFromCjs(isArray_1);\nvar isBuffer$3 = {\n    exports: {}\n};\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */ function stubFalse() {\n    return false;\n}\nvar stubFalse_1 = stubFalse;\nisBuffer$3.exports;\n(function(module, exports1) {\n    var root = _root, stubFalse = stubFalse_1;\n    /** Detect free variable `exports`. */ var freeExports = exports1 && !exports1.nodeType && exports1;\n    /** Detect free variable `module`. */ var freeModule = freeExports && \"object\" == \"object\" && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined;\n    /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n    /**\n\t * Checks if `value` is a buffer.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.3.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n\t * @example\n\t *\n\t * _.isBuffer(new Buffer(2));\n\t * // => true\n\t *\n\t * _.isBuffer(new Uint8Array(2));\n\t * // => false\n\t */ var isBuffer = nativeIsBuffer || stubFalse;\n    module.exports = isBuffer;\n})(isBuffer$3, isBuffer$3.exports);\nvar isBufferExports = isBuffer$3.exports;\n/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER$1 = 9007199254740991;\n/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\\d*)$/;\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */ function isIndex$3(value, length) {\n    var type = typeof value;\n    length = length == null ? MAX_SAFE_INTEGER$1 : length;\n    return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n}\nvar _isIndex = isIndex$3;\n/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */ function isLength$3(value) {\n    return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\nvar isLength_1 = isLength$3;\nvar baseGetTag$5 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$6 = isObjectLike_1;\n/** `Object#toString` result references. */ var argsTag$2 = \"[object Arguments]\", arrayTag$2 = \"[object Array]\", boolTag$3 = \"[object Boolean]\", dateTag$3 = \"[object Date]\", errorTag$2 = \"[object Error]\", funcTag$2 = \"[object Function]\", mapTag$6 = \"[object Map]\", numberTag$3 = \"[object Number]\", objectTag$4 = \"[object Object]\", regexpTag$3 = \"[object RegExp]\", setTag$6 = \"[object Set]\", stringTag$4 = \"[object String]\", weakMapTag$2 = \"[object WeakMap]\";\nvar arrayBufferTag$3 = \"[object ArrayBuffer]\", dataViewTag$4 = \"[object DataView]\", float32Tag$2 = \"[object Float32Array]\", float64Tag$2 = \"[object Float64Array]\", int8Tag$2 = \"[object Int8Array]\", int16Tag$2 = \"[object Int16Array]\", int32Tag$2 = \"[object Int32Array]\", uint8Tag$2 = \"[object Uint8Array]\", uint8ClampedTag$2 = \"[object Uint8ClampedArray]\", uint16Tag$2 = \"[object Uint16Array]\", uint32Tag$2 = \"[object Uint32Array]\";\n/** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {};\ntypedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;\ntypedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */ function baseIsTypedArray$1(value) {\n    return isObjectLike$6(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$5(value)];\n}\nvar _baseIsTypedArray = baseIsTypedArray$1;\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */ function baseUnary$4(func) {\n    return function(value) {\n        return func(value);\n    };\n}\nvar _baseUnary = baseUnary$4;\nvar _nodeUtil = {\n    exports: {}\n};\n_nodeUtil.exports;\n(function(module, exports1) {\n    var freeGlobal = _freeGlobal;\n    /** Detect free variable `exports`. */ var freeExports = exports1 && !exports1.nodeType && exports1;\n    /** Detect free variable `module`. */ var freeModule = freeExports && \"object\" == \"object\" && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;\n    /** Used to access faster Node.js helpers. */ var nodeUtil = function() {\n        try {\n            // Use `util.types` for Node.js 10+.\n            var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n            if (types) {\n                return types;\n            }\n            // Legacy `process.binding('util')` for Node.js < 10.\n            return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n        } catch (e) {}\n    }();\n    module.exports = nodeUtil;\n})(_nodeUtil, _nodeUtil.exports);\nvar _nodeUtilExports = _nodeUtil.exports;\nvar baseIsTypedArray = _baseIsTypedArray, baseUnary$3 = _baseUnary, nodeUtil$2 = _nodeUtilExports;\n/* Node.js helper references. */ var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */ var isTypedArray$2 = nodeIsTypedArray ? baseUnary$3(nodeIsTypedArray) : baseIsTypedArray;\nvar isTypedArray_1 = isTypedArray$2;\nvar baseTimes = _baseTimes, isArguments$2 = isArguments_1, isArray$b = isArray_1, isBuffer$2 = isBufferExports, isIndex$2 = _isIndex, isTypedArray$1 = isTypedArray_1;\n/** Used for built-in method references. */ var objectProto$c = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$a = objectProto$c.hasOwnProperty;\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */ function arrayLikeKeys$2(value, inherited) {\n    var isArr = isArray$b(value), isArg = !isArr && isArguments$2(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;\n    for(var key in value){\n        if ((inherited || hasOwnProperty$a.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n        (key == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n        isBuff && (key == \"offset\" || key == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n        isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n        isIndex$2(key, length)))) {\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _arrayLikeKeys = arrayLikeKeys$2;\n/** Used for built-in method references. */ var objectProto$b = Object.prototype;\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */ function isPrototype$3(value) {\n    var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$b;\n    return value === proto;\n}\nvar _isPrototype = isPrototype$3;\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */ function overArg$2(func, transform) {\n    return function(arg) {\n        return func(transform(arg));\n    };\n}\nvar _overArg = overArg$2;\nvar overArg$1 = _overArg;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeKeys$1 = overArg$1(Object.keys, Object);\nvar _nativeKeys = nativeKeys$1;\nvar isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;\n/** Used for built-in method references. */ var objectProto$a = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$9 = objectProto$a.hasOwnProperty;\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function baseKeys$2(object) {\n    if (!isPrototype$2(object)) {\n        return nativeKeys(object);\n    }\n    var result = [];\n    for(var key in Object(object)){\n        if (hasOwnProperty$9.call(object, key) && key != \"constructor\") {\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _baseKeys = baseKeys$2;\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ function isObject$7(value) {\n    var type = typeof value;\n    return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_1 = isObject$7;\nvar baseGetTag$4 = _baseGetTag, isObject$6 = isObject_1;\n/** `Object#toString` result references. */ var asyncTag = \"[object AsyncFunction]\", funcTag$1 = \"[object Function]\", genTag$1 = \"[object GeneratorFunction]\", proxyTag = \"[object Proxy]\";\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */ function isFunction$2(value) {\n    if (!isObject$6(value)) {\n        return false;\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = baseGetTag$4(value);\n    return tag == funcTag$1 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;\n}\nvar isFunction_1 = isFunction$2;\nvar isFunction$1 = isFunction_1, isLength$1 = isLength_1;\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */ function isArrayLike$6(value) {\n    return value != null && isLength$1(value.length) && !isFunction$1(value);\n}\nvar isArrayLike_1 = isArrayLike$6;\nvar arrayLikeKeys$1 = _arrayLikeKeys, baseKeys$1 = _baseKeys, isArrayLike$5 = isArrayLike_1;\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */ function keys$5(object) {\n    return isArrayLike$5(object) ? arrayLikeKeys$1(object) : baseKeys$1(object);\n}\nvar keys_1 = keys$5;\nvar baseFor = _baseFor, keys$4 = keys_1;\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */ function baseForOwn$3(object, iteratee) {\n    return object && baseFor(object, iteratee, keys$4);\n}\nvar _baseForOwn = baseForOwn$3;\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */ function listCacheClear$1() {\n    this.__data__ = [];\n    this.size = 0;\n}\nvar _listCacheClear = listCacheClear$1;\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */ function eq$4(value, other) {\n    return value === other || value !== value && other !== other;\n}\nvar eq_1 = eq$4;\nvar eq$3 = eq_1;\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */ function assocIndexOf$4(array, key) {\n    var length = array.length;\n    while(length--){\n        if (eq$3(array[length][0], key)) {\n            return length;\n        }\n    }\n    return -1;\n}\nvar _assocIndexOf = assocIndexOf$4;\nvar assocIndexOf$3 = _assocIndexOf;\n/** Used for built-in method references. */ var arrayProto = Array.prototype;\n/** Built-in value references. */ var splice = arrayProto.splice;\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function listCacheDelete$1(key) {\n    var data = this.__data__, index = assocIndexOf$3(data, key);\n    if (index < 0) {\n        return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n        data.pop();\n    } else {\n        splice.call(data, index, 1);\n    }\n    --this.size;\n    return true;\n}\nvar _listCacheDelete = listCacheDelete$1;\nvar assocIndexOf$2 = _assocIndexOf;\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function listCacheGet$1(key) {\n    var data = this.__data__, index = assocIndexOf$2(data, key);\n    return index < 0 ? undefined : data[index][1];\n}\nvar _listCacheGet = listCacheGet$1;\nvar assocIndexOf$1 = _assocIndexOf;\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function listCacheHas$1(key) {\n    return assocIndexOf$1(this.__data__, key) > -1;\n}\nvar _listCacheHas = listCacheHas$1;\nvar assocIndexOf = _assocIndexOf;\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */ function listCacheSet$1(key, value) {\n    var data = this.__data__, index = assocIndexOf(data, key);\n    if (index < 0) {\n        ++this.size;\n        data.push([\n            key,\n            value\n        ]);\n    } else {\n        data[index][1] = value;\n    }\n    return this;\n}\nvar _listCacheSet = listCacheSet$1;\nvar listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function ListCache$4(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while(++index < length){\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `ListCache`.\nListCache$4.prototype.clear = listCacheClear;\nListCache$4.prototype[\"delete\"] = listCacheDelete;\nListCache$4.prototype.get = listCacheGet;\nListCache$4.prototype.has = listCacheHas;\nListCache$4.prototype.set = listCacheSet;\nvar _ListCache = ListCache$4;\nvar ListCache$3 = _ListCache;\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */ function stackClear$1() {\n    this.__data__ = new ListCache$3;\n    this.size = 0;\n}\nvar _stackClear = stackClear$1;\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function stackDelete$1(key) {\n    var data = this.__data__, result = data[\"delete\"](key);\n    this.size = data.size;\n    return result;\n}\nvar _stackDelete = stackDelete$1;\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function stackGet$1(key) {\n    return this.__data__.get(key);\n}\nvar _stackGet = stackGet$1;\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function stackHas$1(key) {\n    return this.__data__.has(key);\n}\nvar _stackHas = stackHas$1;\nvar root$6 = _root;\n/** Used to detect overreaching core-js shims. */ var coreJsData$1 = root$6[\"__core-js_shared__\"];\nvar _coreJsData = coreJsData$1;\nvar coreJsData = _coreJsData;\n/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n    return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */ function isMasked$1(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n}\nvar _isMasked = isMasked$1;\n/** Used for built-in method references. */ var funcProto$2 = Function.prototype;\n/** Used to resolve the decompiled source of functions. */ var funcToString$2 = funcProto$2.toString;\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */ function toSource$2(func) {\n    if (func != null) {\n        try {\n            return funcToString$2.call(func);\n        } catch (e) {}\n        try {\n            return func + \"\";\n        } catch (e) {}\n    }\n    return \"\";\n}\nvar _toSource = toSource$2;\nvar isFunction = isFunction_1, isMasked = _isMasked, isObject$5 = isObject_1, toSource$1 = _toSource;\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */ var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n/** Used for built-in method references. */ var funcProto$1 = Function.prototype, objectProto$9 = Object.prototype;\n/** Used to resolve the decompiled source of functions. */ var funcToString$1 = funcProto$1.toString;\n/** Used to check objects for own properties. */ var hasOwnProperty$8 = objectProto$9.hasOwnProperty;\n/** Used to detect if a method is native. */ var reIsNative = RegExp(\"^\" + funcToString$1.call(hasOwnProperty$8).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */ function baseIsNative$1(value) {\n    if (!isObject$5(value) || isMasked(value)) {\n        return false;\n    }\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource$1(value));\n}\nvar _baseIsNative = baseIsNative$1;\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */ function getValue$1(object, key) {\n    return object == null ? undefined : object[key];\n}\nvar _getValue = getValue$1;\nvar baseIsNative = _baseIsNative, getValue = _getValue;\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */ function getNative$7(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n}\nvar _getNative = getNative$7;\nvar getNative$6 = _getNative, root$5 = _root;\n/* Built-in method references that are verified to be native. */ var Map$4 = getNative$6(root$5, \"Map\");\nvar _Map = Map$4;\nvar getNative$5 = _getNative;\n/* Built-in method references that are verified to be native. */ var nativeCreate$4 = getNative$5(Object, \"create\");\nvar _nativeCreate = nativeCreate$4;\nvar nativeCreate$3 = _nativeCreate;\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */ function hashClear$1() {\n    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};\n    this.size = 0;\n}\nvar _hashClear = hashClear$1;\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function hashDelete$1(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n}\nvar _hashDelete = hashDelete$1;\nvar nativeCreate$2 = _nativeCreate;\n/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED$2 = \"__lodash_hash_undefined__\";\n/** Used for built-in method references. */ var objectProto$8 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$7 = objectProto$8.hasOwnProperty;\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function hashGet$1(key) {\n    var data = this.__data__;\n    if (nativeCreate$2) {\n        var result = data[key];\n        return result === HASH_UNDEFINED$2 ? undefined : result;\n    }\n    return hasOwnProperty$7.call(data, key) ? data[key] : undefined;\n}\nvar _hashGet = hashGet$1;\nvar nativeCreate$1 = _nativeCreate;\n/** Used for built-in method references. */ var objectProto$7 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$6 = objectProto$7.hasOwnProperty;\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function hashHas$1(key) {\n    var data = this.__data__;\n    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$6.call(data, key);\n}\nvar _hashHas = hashHas$1;\nvar nativeCreate = _nativeCreate;\n/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */ function hashSet$1(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;\n    return this;\n}\nvar _hashSet = hashSet$1;\nvar hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function Hash$1(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while(++index < length){\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `Hash`.\nHash$1.prototype.clear = hashClear;\nHash$1.prototype[\"delete\"] = hashDelete;\nHash$1.prototype.get = hashGet;\nHash$1.prototype.has = hashHas;\nHash$1.prototype.set = hashSet;\nvar _Hash = Hash$1;\nvar Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */ function mapCacheClear$1() {\n    this.size = 0;\n    this.__data__ = {\n        \"hash\": new Hash,\n        \"map\": new (Map$3 || ListCache$2),\n        \"string\": new Hash\n    };\n}\nvar _mapCacheClear = mapCacheClear$1;\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */ function isKeyable$1(value) {\n    var type = typeof value;\n    return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar _isKeyable = isKeyable$1;\nvar isKeyable = _isKeyable;\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */ function getMapData$4(map, key) {\n    var data = map.__data__;\n    return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar _getMapData = getMapData$4;\nvar getMapData$3 = _getMapData;\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function mapCacheDelete$1(key) {\n    var result = getMapData$3(this, key)[\"delete\"](key);\n    this.size -= result ? 1 : 0;\n    return result;\n}\nvar _mapCacheDelete = mapCacheDelete$1;\nvar getMapData$2 = _getMapData;\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function mapCacheGet$1(key) {\n    return getMapData$2(this, key).get(key);\n}\nvar _mapCacheGet = mapCacheGet$1;\nvar getMapData$1 = _getMapData;\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function mapCacheHas$1(key) {\n    return getMapData$1(this, key).has(key);\n}\nvar _mapCacheHas = mapCacheHas$1;\nvar getMapData = _getMapData;\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */ function mapCacheSet$1(key, value) {\n    var data = getMapData(this, key), size = data.size;\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n}\nvar _mapCacheSet = mapCacheSet$1;\nvar mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function MapCache$3(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while(++index < length){\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `MapCache`.\nMapCache$3.prototype.clear = mapCacheClear;\nMapCache$3.prototype[\"delete\"] = mapCacheDelete;\nMapCache$3.prototype.get = mapCacheGet;\nMapCache$3.prototype.has = mapCacheHas;\nMapCache$3.prototype.set = mapCacheSet;\nvar _MapCache = MapCache$3;\nvar ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;\n/** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE$1 = 200;\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */ function stackSet$1(key, value) {\n    var data = this.__data__;\n    if (data instanceof ListCache$1) {\n        var pairs = data.__data__;\n        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {\n            pairs.push([\n                key,\n                value\n            ]);\n            this.size = ++data.size;\n            return this;\n        }\n        data = this.__data__ = new MapCache$2(pairs);\n    }\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n}\nvar _stackSet = stackSet$1;\nvar ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function Stack$3(entries) {\n    var data = this.__data__ = new ListCache(entries);\n    this.size = data.size;\n}\n// Add methods to `Stack`.\nStack$3.prototype.clear = stackClear;\nStack$3.prototype[\"delete\"] = stackDelete;\nStack$3.prototype.get = stackGet;\nStack$3.prototype.has = stackHas;\nStack$3.prototype.set = stackSet;\nvar _Stack = Stack$3;\n/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */ function setCacheAdd$1(value) {\n    this.__data__.set(value, HASH_UNDEFINED);\n    return this;\n}\nvar _setCacheAdd = setCacheAdd$1;\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */ function setCacheHas$1(value) {\n    return this.__data__.has(value);\n}\nvar _setCacheHas = setCacheHas$1;\nvar MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */ function SetCache$2(values) {\n    var index = -1, length = values == null ? 0 : values.length;\n    this.__data__ = new MapCache$1;\n    while(++index < length){\n        this.add(values[index]);\n    }\n}\n// Add methods to `SetCache`.\nSetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;\nSetCache$2.prototype.has = setCacheHas;\nvar _SetCache = SetCache$2;\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */ function arraySome$1(array, predicate) {\n    var index = -1, length = array == null ? 0 : array.length;\n    while(++index < length){\n        if (predicate(array[index], index, array)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar _arraySome = arraySome$1;\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function cacheHas$2(cache, key) {\n    return cache.has(key);\n}\nvar _cacheHas = cacheHas$2;\nvar SetCache$1 = _SetCache, arraySome = _arraySome, cacheHas$1 = _cacheHas;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */ function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n    }\n    // Check that cyclic values are equal.\n    var arrStacked = stack.get(array);\n    var othStacked = stack.get(other);\n    if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n    }\n    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$1 : undefined;\n    stack.set(array, other);\n    stack.set(other, array);\n    // Ignore non-index properties.\n    while(++index < arrLength){\n        var arrValue = array[index], othValue = other[index];\n        if (customizer) {\n            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n            if (compared) {\n                continue;\n            }\n            result = false;\n            break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n            if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas$1(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                    return seen.push(othIndex);\n                }\n            })) {\n                result = false;\n                break;\n            }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n            result = false;\n            break;\n        }\n    }\n    stack[\"delete\"](array);\n    stack[\"delete\"](other);\n    return result;\n}\nvar _equalArrays = equalArrays$2;\nvar root$4 = _root;\n/** Built-in value references. */ var Uint8Array$2 = root$4.Uint8Array;\nvar _Uint8Array = Uint8Array$2;\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */ function mapToArray$1(map) {\n    var index = -1, result = Array(map.size);\n    map.forEach(function(value, key) {\n        result[++index] = [\n            key,\n            value\n        ];\n    });\n    return result;\n}\nvar _mapToArray = mapToArray$1;\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */ function setToArray$3(set) {\n    var index = -1, result = Array(set.size);\n    set.forEach(function(value) {\n        result[++index] = value;\n    });\n    return result;\n}\nvar _setToArray = setToArray$3;\nvar Symbol$3 = _Symbol, Uint8Array$1 = _Uint8Array, eq$2 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;\n/** `Object#toString` result references. */ var boolTag$2 = \"[object Boolean]\", dateTag$2 = \"[object Date]\", errorTag$1 = \"[object Error]\", mapTag$5 = \"[object Map]\", numberTag$2 = \"[object Number]\", regexpTag$2 = \"[object RegExp]\", setTag$5 = \"[object Set]\", stringTag$3 = \"[object String]\", symbolTag$3 = \"[object Symbol]\";\nvar arrayBufferTag$2 = \"[object ArrayBuffer]\", dataViewTag$3 = \"[object DataView]\";\n/** Used to convert symbols to primitives and strings. */ var symbolProto$2 = Symbol$3 ? Symbol$3.prototype : undefined, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */ function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch(tag){\n        case dataViewTag$3:\n            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n                return false;\n            }\n            object = object.buffer;\n            other = other.buffer;\n        case arrayBufferTag$2:\n            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {\n                return false;\n            }\n            return true;\n        case boolTag$2:\n        case dateTag$2:\n        case numberTag$2:\n            // Coerce booleans to `1` or `0` and dates to milliseconds.\n            // Invalid dates are coerced to `NaN`.\n            return eq$2(+object, +other);\n        case errorTag$1:\n            return object.name == other.name && object.message == other.message;\n        case regexpTag$2:\n        case stringTag$3:\n            // Coerce regexes to strings and treat strings, primitives and objects,\n            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n            // for more details.\n            return object == other + \"\";\n        case mapTag$5:\n            var convert = mapToArray;\n        case setTag$5:\n            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;\n            convert || (convert = setToArray$2);\n            if (object.size != other.size && !isPartial) {\n                return false;\n            }\n            // Assume cyclic values are equal.\n            var stacked = stack.get(object);\n            if (stacked) {\n                return stacked == other;\n            }\n            bitmask |= COMPARE_UNORDERED_FLAG$2;\n            // Recursively compare objects (susceptible to call stack limits).\n            stack.set(object, other);\n            var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n            stack[\"delete\"](object);\n            return result;\n        case symbolTag$3:\n            if (symbolValueOf$1) {\n                return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);\n            }\n    }\n    return false;\n}\nvar _equalByTag = equalByTag$1;\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */ function arrayPush$3(array, values) {\n    var index = -1, length = values.length, offset = array.length;\n    while(++index < length){\n        array[offset + index] = values[index];\n    }\n    return array;\n}\nvar _arrayPush = arrayPush$3;\nvar arrayPush$2 = _arrayPush, isArray$a = isArray_1;\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */ function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray$a(object) ? result : arrayPush$2(result, symbolsFunc(object));\n}\nvar _baseGetAllKeys = baseGetAllKeys$2;\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */ function arrayFilter$1(array, predicate) {\n    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n    while(++index < length){\n        var value = array[index];\n        if (predicate(value, index, array)) {\n            result[resIndex++] = value;\n        }\n    }\n    return result;\n}\nvar _arrayFilter = arrayFilter$1;\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */ function stubArray$2() {\n    return [];\n}\nvar stubArray_1 = stubArray$2;\nvar arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;\n/** Used for built-in method references. */ var objectProto$6 = Object.prototype;\n/** Built-in value references. */ var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols$1 = Object.getOwnPropertySymbols;\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */ var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {\n    if (object == null) {\n        return [];\n    }\n    object = Object(object);\n    return arrayFilter(nativeGetSymbols$1(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n    });\n};\nvar _getSymbols = getSymbols$3;\nvar baseGetAllKeys$1 = _baseGetAllKeys, getSymbols$2 = _getSymbols, keys$3 = keys_1;\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */ function getAllKeys$2(object) {\n    return baseGetAllKeys$1(object, keys$3, getSymbols$2);\n}\nvar _getAllKeys = getAllKeys$2;\nvar getAllKeys$1 = _getAllKeys;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$3 = 1;\n/** Used for built-in method references. */ var objectProto$5 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$5 = objectProto$5.hasOwnProperty;\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */ function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys$1(object), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;\n    if (objLength != othLength && !isPartial) {\n        return false;\n    }\n    var index = objLength;\n    while(index--){\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {\n            return false;\n        }\n    }\n    // Check that cyclic values are equal.\n    var objStacked = stack.get(object);\n    var othStacked = stack.get(other);\n    if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n    }\n    var result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n    var skipCtor = isPartial;\n    while(++index < objLength){\n        key = objProps[index];\n        var objValue = object[key], othValue = other[key];\n        if (customizer) {\n            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n            result = false;\n            break;\n        }\n        skipCtor || (skipCtor = key == \"constructor\");\n    }\n    if (result && !skipCtor) {\n        var objCtor = object.constructor, othCtor = other.constructor;\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n            result = false;\n        }\n    }\n    stack[\"delete\"](object);\n    stack[\"delete\"](other);\n    return result;\n}\nvar _equalObjects = equalObjects$1;\nvar getNative$4 = _getNative, root$3 = _root;\n/* Built-in method references that are verified to be native. */ var DataView$1 = getNative$4(root$3, \"DataView\");\nvar _DataView = DataView$1;\nvar getNative$3 = _getNative, root$2 = _root;\n/* Built-in method references that are verified to be native. */ var Promise$2 = getNative$3(root$2, \"Promise\");\nvar _Promise = Promise$2;\nvar getNative$2 = _getNative, root$1 = _root;\n/* Built-in method references that are verified to be native. */ var Set$3 = getNative$2(root$1, \"Set\");\nvar _Set = Set$3;\nvar getNative$1 = _getNative, root = _root;\n/* Built-in method references that are verified to be native. */ var WeakMap$2 = getNative$1(root, \"WeakMap\");\nvar _WeakMap = WeakMap$2;\nvar DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$2 = _Set, WeakMap$1 = _WeakMap, baseGetTag$3 = _baseGetTag, toSource = _toSource;\n/** `Object#toString` result references. */ var mapTag$4 = \"[object Map]\", objectTag$3 = \"[object Object]\", promiseTag = \"[object Promise]\", setTag$4 = \"[object Set]\", weakMapTag$1 = \"[object WeakMap]\";\nvar dataViewTag$2 = \"[object DataView]\";\n/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */ var getTag$5 = baseGetTag$3;\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif (DataView && getTag$5(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$5(new Map$1) != mapTag$4 || Promise$1 && getTag$5(Promise$1.resolve()) != promiseTag || Set$2 && getTag$5(new Set$2) != setTag$4 || WeakMap$1 && getTag$5(new WeakMap$1) != weakMapTag$1) {\n    getTag$5 = function(value) {\n        var result = baseGetTag$3(value), Ctor = result == objectTag$3 ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : \"\";\n        if (ctorString) {\n            switch(ctorString){\n                case dataViewCtorString:\n                    return dataViewTag$2;\n                case mapCtorString:\n                    return mapTag$4;\n                case promiseCtorString:\n                    return promiseTag;\n                case setCtorString:\n                    return setTag$4;\n                case weakMapCtorString:\n                    return weakMapTag$1;\n            }\n        }\n        return result;\n    };\n}\nvar _getTag = getTag$5;\nvar Stack$2 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$4 = _getTag, isArray$9 = isArray_1, isBuffer$1 = isBufferExports, isTypedArray = isTypedArray_1;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$2 = 1;\n/** `Object#toString` result references. */ var argsTag$1 = \"[object Arguments]\", arrayTag$1 = \"[object Array]\", objectTag$2 = \"[object Object]\";\n/** Used for built-in method references. */ var objectProto$4 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$4 = objectProto$4.hasOwnProperty;\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */ function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray$9(object), othIsArr = isArray$9(other), objTag = objIsArr ? arrayTag$1 : getTag$4(object), othTag = othIsArr ? arrayTag$1 : getTag$4(other);\n    objTag = objTag == argsTag$1 ? objectTag$2 : objTag;\n    othTag = othTag == argsTag$1 ? objectTag$2 : othTag;\n    var objIsObj = objTag == objectTag$2, othIsObj = othTag == objectTag$2, isSameTag = objTag == othTag;\n    if (isSameTag && isBuffer$1(object)) {\n        if (!isBuffer$1(other)) {\n            return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n    }\n    if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack$2);\n        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n    }\n    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n        var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty$4.call(other, \"__wrapped__\");\n        if (objIsWrapped || othIsWrapped) {\n            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n            stack || (stack = new Stack$2);\n            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n    }\n    if (!isSameTag) {\n        return false;\n    }\n    stack || (stack = new Stack$2);\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\nvar _baseIsEqualDeep = baseIsEqualDeep$1;\nvar baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$5 = isObjectLike_1;\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */ function baseIsEqual$2(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n        return true;\n    }\n    if (value == null || other == null || !isObjectLike$5(value) && !isObjectLike$5(other)) {\n        return value !== value && other !== other;\n    }\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);\n}\nvar _baseIsEqual = baseIsEqual$2;\nvar Stack$1 = _Stack, baseIsEqual$1 = _baseIsEqual;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */ function baseIsMatch$1(object, source, matchData, customizer) {\n    var index = matchData.length, length = index, noCustomizer = !customizer;\n    if (object == null) {\n        return !length;\n    }\n    object = Object(object);\n    while(index--){\n        var data = matchData[index];\n        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n            return false;\n        }\n    }\n    while(++index < length){\n        data = matchData[index];\n        var key = data[0], objValue = object[key], srcValue = data[1];\n        if (noCustomizer && data[2]) {\n            if (objValue === undefined && !(key in object)) {\n                return false;\n            }\n        } else {\n            var stack = new Stack$1;\n            if (customizer) {\n                var result = customizer(objValue, srcValue, key, object, source, stack);\n            }\n            if (!(result === undefined ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nvar _baseIsMatch = baseIsMatch$1;\nvar isObject$4 = isObject_1;\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */ function isStrictComparable$2(value) {\n    return value === value && !isObject$4(value);\n}\nvar _isStrictComparable = isStrictComparable$2;\nvar isStrictComparable$1 = _isStrictComparable, keys$2 = keys_1;\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */ function getMatchData$1(object) {\n    var result = keys$2(object), length = result.length;\n    while(length--){\n        var key = result[length], value = object[key];\n        result[length] = [\n            key,\n            value,\n            isStrictComparable$1(value)\n        ];\n    }\n    return result;\n}\nvar _getMatchData = getMatchData$1;\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */ function matchesStrictComparable$2(key, srcValue) {\n    return function(object) {\n        if (object == null) {\n            return false;\n        }\n        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n    };\n}\nvar _matchesStrictComparable = matchesStrictComparable$2;\nvar baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */ function baseMatches$1(source) {\n    var matchData = getMatchData(source);\n    if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);\n    }\n    return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n    };\n}\nvar _baseMatches = baseMatches$1;\nvar baseGetTag$2 = _baseGetTag, isObjectLike$4 = isObjectLike_1;\n/** `Object#toString` result references. */ var symbolTag$2 = \"[object Symbol]\";\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */ function isSymbol$4(value) {\n    return typeof value == \"symbol\" || isObjectLike$4(value) && baseGetTag$2(value) == symbolTag$2;\n}\nvar isSymbol_1 = isSymbol$4;\nvar isArray$8 = isArray_1, isSymbol$3 = isSymbol_1;\n/** Used to match property names within property paths. */ var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/;\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */ function isKey$3(value, object) {\n    if (isArray$8(value)) {\n        return false;\n    }\n    var type = typeof value;\n    if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol$3(value)) {\n        return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n}\nvar _isKey = isKey$3;\nvar MapCache = _MapCache;\n/** Error message constants. */ var FUNC_ERROR_TEXT = \"Expected a function\";\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */ function memoize$1(func, resolver) {\n    if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function() {\n        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n    };\n    memoized.cache = new (memoize$1.Cache || MapCache);\n    return memoized;\n}\n// Expose `MapCache`.\nmemoize$1.Cache = MapCache;\nvar memoize_1 = memoize$1;\nvar memoize = memoize_1;\n/** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */ function memoizeCapped$1(func) {\n    var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n            cache.clear();\n        }\n        return key;\n    });\n    var cache = result.cache;\n    return result;\n}\nvar _memoizeCapped = memoizeCapped$1;\nvar memoizeCapped = _memoizeCapped;\n/** Used to match property names within property paths. */ var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n/** Used to match backslashes in property paths. */ var reEscapeChar = /\\\\(\\\\)?/g;\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */ var stringToPath$1 = memoizeCapped(function(string) {\n    var result = [];\n    if (string.charCodeAt(0) === 46 /* . */ ) {\n        result.push(\"\");\n    }\n    string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n    });\n    return result;\n});\nvar _stringToPath = stringToPath$1;\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */ function arrayMap$3(array, iteratee) {\n    var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n    while(++index < length){\n        result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n}\nvar _arrayMap = arrayMap$3;\nvar Symbol$2 = _Symbol, arrayMap$2 = _arrayMap, isArray$7 = isArray_1, isSymbol$2 = isSymbol_1;\n/** Used as references for various `Number` constants. */ var INFINITY$2 = 1 / 0;\n/** Used to convert symbols to primitives and strings. */ var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined, symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */ function baseToString$1(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == \"string\") {\n        return value;\n    }\n    if (isArray$7(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap$2(value, baseToString$1) + \"\";\n    }\n    if (isSymbol$2(value)) {\n        return symbolToString ? symbolToString.call(value) : \"\";\n    }\n    var result = value + \"\";\n    return result == \"0\" && 1 / value == -INFINITY$2 ? \"-0\" : result;\n}\nvar _baseToString = baseToString$1;\nvar baseToString = _baseToString;\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */ function toString$1(value) {\n    return value == null ? \"\" : baseToString(value);\n}\nvar toString_1 = toString$1;\nvar isArray$6 = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString = toString_1;\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */ function castPath$4(value, object) {\n    if (isArray$6(value)) {\n        return value;\n    }\n    return isKey$2(value, object) ? [\n        value\n    ] : stringToPath(toString(value));\n}\nvar _castPath = castPath$4;\nvar isSymbol$1 = isSymbol_1;\n/** Used as references for various `Number` constants. */ var INFINITY$1 = 1 / 0;\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */ function toKey$5(value) {\n    if (typeof value == \"string\" || isSymbol$1(value)) {\n        return value;\n    }\n    var result = value + \"\";\n    return result == \"0\" && 1 / value == -INFINITY$1 ? \"-0\" : result;\n}\nvar _toKey = toKey$5;\nvar castPath$3 = _castPath, toKey$4 = _toKey;\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */ function baseGet$4(object, path) {\n    path = castPath$3(path, object);\n    var index = 0, length = path.length;\n    while(object != null && index < length){\n        object = object[toKey$4(path[index++])];\n    }\n    return index && index == length ? object : undefined;\n}\nvar _baseGet = baseGet$4;\nvar baseGet$3 = _baseGet;\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */ function get$1(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet$3(object, path);\n    return result === undefined ? defaultValue : result;\n}\nvar get_1 = get$1;\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */ function baseHasIn$1(object, key) {\n    return object != null && key in Object(object);\n}\nvar _baseHasIn = baseHasIn$1;\nvar castPath$2 = _castPath, isArguments$1 = isArguments_1, isArray$5 = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$3 = _toKey;\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */ function hasPath$1(object, path, hasFunc) {\n    path = castPath$2(path, object);\n    var index = -1, length = path.length, result = false;\n    while(++index < length){\n        var key = toKey$3(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n            break;\n        }\n        object = object[key];\n    }\n    if (result || ++index != length) {\n        return result;\n    }\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex$1(key, length) && (isArray$5(object) || isArguments$1(object));\n}\nvar _hasPath = hasPath$1;\nvar baseHasIn = _baseHasIn, hasPath = _hasPath;\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */ function hasIn$1(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n}\nvar hasIn_1 = hasIn$1;\nvar baseIsEqual = _baseIsEqual, get = get_1, hasIn = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$2 = _toKey;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */ function baseMatchesProperty$1(path, srcValue) {\n    if (isKey$1(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey$2(path), srcValue);\n    }\n    return function(object) {\n        var objValue = get(object, path);\n        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n    };\n}\nvar _baseMatchesProperty = baseMatchesProperty$1;\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */ function identity$4(value) {\n    return value;\n}\nvar identity_1 = identity$4;\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */ function baseProperty$2(key) {\n    return function(object) {\n        return object == null ? undefined : object[key];\n    };\n}\nvar _baseProperty = baseProperty$2;\nvar baseGet$2 = _baseGet;\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */ function basePropertyDeep$1(path) {\n    return function(object) {\n        return baseGet$2(object, path);\n    };\n}\nvar _basePropertyDeep = basePropertyDeep$1;\nvar baseProperty$1 = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey$1 = _toKey;\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */ function property$1(path) {\n    return isKey(path) ? baseProperty$1(toKey$1(path)) : basePropertyDeep(path);\n}\nvar property_1 = property$1;\nvar baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$3 = identity_1, isArray$4 = isArray_1, property = property_1;\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */ function baseIteratee$4(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == \"function\") {\n        return value;\n    }\n    if (value == null) {\n        return identity$3;\n    }\n    if (typeof value == \"object\") {\n        return isArray$4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n    }\n    return property(value);\n}\nvar _baseIteratee = baseIteratee$4;\nvar baseFindKey = _baseFindKey, baseForOwn$2 = _baseForOwn, baseIteratee$3 = _baseIteratee;\n/**\n * This method is like `_.find` except that it returns the key of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Object\n * @param {Object} object The object to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {string|undefined} Returns the key of the matched element,\n *  else `undefined`.\n * @example\n *\n * var users = {\n *   'barney':  { 'age': 36, 'active': true },\n *   'fred':    { 'age': 40, 'active': false },\n *   'pebbles': { 'age': 1,  'active': true }\n * };\n *\n * _.findKey(users, function(o) { return o.age < 40; });\n * // => 'barney' (iteration order is not guaranteed)\n *\n * // The `_.matches` iteratee shorthand.\n * _.findKey(users, { 'age': 1, 'active': true });\n * // => 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findKey(users, ['active', false]);\n * // => 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.findKey(users, 'active');\n * // => 'barney'\n */ function findKey(object, predicate) {\n    return baseFindKey(object, baseIteratee$3(predicate), baseForOwn$2);\n}\nvar findKey_1 = findKey;\nvar findKey$1 = /*@__PURE__*/ getDefaultExportFromCjs(findKey_1);\nvar getNative = _getNative;\nvar defineProperty$2 = function() {\n    try {\n        var func = getNative(Object, \"defineProperty\");\n        func({}, \"\", {});\n        return func;\n    } catch (e) {}\n}();\nvar _defineProperty = defineProperty$2;\nvar defineProperty$1 = _defineProperty;\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function baseAssignValue$3(object, key, value) {\n    if (key == \"__proto__\" && defineProperty$1) {\n        defineProperty$1(object, key, {\n            \"configurable\": true,\n            \"enumerable\": true,\n            \"value\": value,\n            \"writable\": true\n        });\n    } else {\n        object[key] = value;\n    }\n}\nvar _baseAssignValue = baseAssignValue$3;\nvar baseAssignValue$2 = _baseAssignValue, baseForOwn$1 = _baseForOwn, baseIteratee$2 = _baseIteratee;\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */ function mapValues(object, iteratee) {\n    var result = {};\n    iteratee = baseIteratee$2(iteratee);\n    baseForOwn$1(object, function(value, key, object) {\n        baseAssignValue$2(result, key, iteratee(value, key, object));\n    });\n    return result;\n}\nvar mapValues_1 = mapValues;\nvar mapValues$1 = /*@__PURE__*/ getDefaultExportFromCjs(mapValues_1);\nvar bpVariablesScss = {\n    \"xs\": '\"36em\"',\n    \"sm\": '\"48em\"',\n    \"md\": '\"62em\"',\n    \"lg\": '\"75em\"',\n    \"xl\": '\"88em\"'\n};\nconst BP_VARIABLES = mapValues$1(bpVariablesScss, (value)=>value.replaceAll('\"', \"\"));\nlet isMountedGlobal = false;\nconst useClientMountedState = ()=>{\n    const [isMounted, setIsMounted] = (0, _react.useState)(isMountedGlobal);\n    (0, _react.useEffect)(()=>{\n        if ((0, _libutilities.isBrowser)()) {\n            setIsMounted(true);\n            isMountedGlobal = true;\n        }\n    }, []);\n    const isClient = (0, _react.useMemo)(()=>(0, _libutilities.isBrowser)(), []);\n    return {\n        isClient,\n        isMounted,\n        isMountedClient: isClient && isMounted\n    };\n};\nconst getMatchMedia = (matchString)=>(0, _libutilities.isBrowser)() ? window.matchMedia(matchString) : undefined;\nconst useMediaQuery = (matchString)=>{\n    const { isMountedClient } = useClientMountedState();\n    const [matches, setMatches] = (0, _react.useState)(getMatchMedia(matchString)?.matches || false);\n    const handleMediaChange = (0, _react.useCallback)(()=>{\n        const match = getMatchMedia(matchString);\n        if (match) {\n            setMatches(match.matches);\n        }\n    }, [\n        matchString\n    ]);\n    (0, _react.useEffect)(()=>{\n        if (isMountedClient) {\n            handleMediaChange();\n        }\n    }, [\n        isMountedClient,\n        handleMediaChange\n    ]);\n    (0, _react.useEffect)(()=>{\n        const match = getMatchMedia(matchString);\n        if (match) {\n            match.addEventListener(\"change\", handleMediaChange);\n        }\n        return ()=>{\n            if (match) {\n                match.removeEventListener(\"change\", handleMediaChange);\n            }\n        };\n    }, [\n        handleMediaChange,\n        matchString\n    ]);\n    return matches;\n};\nconst useThemeScreenSize = ({ size: requestedSize } = {})=>{\n    const xs = useMediaQuery(`(max-width: ${BP_VARIABLES.xs})`);\n    const sm = useMediaQuery(`(max-width: ${BP_VARIABLES.sm})`);\n    const md = useMediaQuery(`(max-width: ${BP_VARIABLES.md})`);\n    const lg = useMediaQuery(`(max-width: ${BP_VARIABLES.lg})`);\n    const xl = useMediaQuery(`(max-width: ${BP_VARIABLES.xl})`);\n    const xxl = useMediaQuery(`(min-width: ${BP_VARIABLES.xl})`);\n    const screenSizeObject = {\n        xs,\n        sm,\n        md,\n        lg,\n        xl,\n        xxl\n    };\n    const screenSize = findKey$1(screenSizeObject, (isScreenSize)=>!!isScreenSize);\n    const bpVariableKeys = Object.keys(screenSizeObject);\n    const indexOfRequestedSize = bpVariableKeys.indexOf(requestedSize || \"\");\n    const indexOfSize = bpVariableKeys.indexOf(screenSize || \"\");\n    const isValid = !!(requestedSize && indexOfRequestedSize && indexOfRequestedSize !== -1);\n    const isRequestedSize = isValid && screenSize === requestedSize;\n    const isLargerThan = isValid && indexOfRequestedSize > indexOfSize;\n    const isSmallerThan = isValid && indexOfRequestedSize < indexOfSize;\n    return {\n        size: screenSize,\n        isRequestedSize,\n        isSmallerThan,\n        isSmallerThanIncluding: isRequestedSize || isSmallerThan,\n        isLargerThan,\n        isLargerThanIncluding: isRequestedSize || isLargerThan\n    };\n};\nconst DEFAULT_BLUR_FUNC = ()=>false;\nconst defaultShouldBlurFunction = ({ e, blurElementRef, blurElement: blurElementParam })=>{\n    const target = e.target;\n    const relatedTarget = e.relatedTarget;\n    const blurElement = blurElementRef?.current || blurElementParam;\n    const targetContainedInBlur = blurElement?.contains(target);\n    const relatedTargetContainedInBlur = blurElement?.contains(relatedTarget);\n    return !targetContainedInBlur && !relatedTargetContainedInBlur;\n};\nconst handleBlur = ({ e, blurElement, blurElementRef, onBlur, shouldBlur, shouldDisableBlur = DEFAULT_BLUR_FUNC, shouldForceBlur = DEFAULT_BLUR_FUNC, returnBoolean = false })=>{\n    const target = e.target;\n    const relatedTarget = e.relatedTarget;\n    const defaultShouldBlur = shouldBlur ? shouldBlur({\n        e,\n        target,\n        relatedTarget\n    }) : defaultShouldBlurFunction({\n        e,\n        blurElementRef,\n        blurElement\n    });\n    if (defaultShouldBlur && !shouldDisableBlur?.({\n        e,\n        target,\n        relatedTarget\n    }) || shouldForceBlur?.({\n        e,\n        target,\n        relatedTarget\n    })) {\n        if (returnBoolean) {\n            return true;\n        }\n        return onBlur(e);\n    }\n    return false;\n};\nconst useOnBlur = ({ blurElementRef, blurElement, onBlur, enabled = false, shouldBlur, shouldDisableBlur = DEFAULT_BLUR_FUNC, shouldForceBlur = DEFAULT_BLUR_FUNC })=>{\n    const handleClickBlurListener = (0, _react.useCallback)((e)=>handleBlur({\n            e,\n            blurElement,\n            blurElementRef,\n            onBlur,\n            enabled,\n            shouldBlur,\n            shouldDisableBlur,\n            shouldForceBlur\n        }), [\n        enabled,\n        onBlur,\n        blurElement,\n        blurElementRef,\n        shouldDisableBlur,\n        shouldForceBlur,\n        shouldBlur\n    ]);\n    (0, _react.useEffect)(()=>{\n        if (enabled) {\n            window.addEventListener(\"mousedown\", handleClickBlurListener);\n        }\n        return ()=>{\n            window.removeEventListener(\"mousedown\", handleClickBlurListener);\n        };\n    }, [\n        enabled,\n        handleClickBlurListener\n    ]);\n    return null;\n};\nfunction useStateWithRef(initialValue, options) {\n    const [state, setState] = (0, _react.useState)(initialValue);\n    const stateRef = (0, _react.useRef)(initialValue);\n    const handleSetState = (0, _react.useCallback)((update)=>{\n        setState((prev)=>{\n            const rawNextValue = typeof update === \"function\" ? update(prev) : update;\n            const transformed = options?.setStateTransform ? options.setStateTransform(rawNextValue) : rawNextValue;\n            stateRef.current = transformed;\n            if (options?.onChange) {\n                options.onChange(transformed, {\n                    prevValue: prev\n                });\n            }\n            return transformed;\n        });\n    }, [\n        options\n    ]);\n    const handleGetState = (0, _react.useCallback)(()=>stateRef.current, []);\n    return (0, _react.useMemo)(()=>({\n            state,\n            setState: handleSetState,\n            getState: handleGetState\n        }), [\n        state,\n        handleGetState,\n        handleSetState\n    ]);\n}\nconst useScroll = ({ scrollContainerElementRef, scrollContainerElement: scrollContainerElementProp, disableStateUpdates, onScroll })=>{\n    const { isMountedClient } = useClientMountedState();\n    const [scrollTop, setScrollTop] = (0, _react.useState)(0);\n    const scrollTopRef = (0, _react.useRef)(0);\n    const element = (0, _react.useMemo)(()=>scrollContainerElementProp || scrollContainerElementRef?.current || (isMountedClient ? window : undefined), [\n        scrollContainerElementProp,\n        scrollContainerElementRef,\n        isMountedClient\n    ]);\n    const handleScroll = (0, _react.useCallback)(()=>{\n        const position = element && \"scrollTop\" in element ? element?.scrollTop || 0 : 0;\n        scrollTopRef.current = position;\n        if (onScroll) {\n            onScroll({\n                top: position,\n                left: 0\n            });\n        }\n        if (!disableStateUpdates) {\n            setScrollTop(position);\n        }\n        setScrollTop(position);\n    }, [\n        element,\n        disableStateUpdates,\n        onScroll\n    ]);\n    const getScrollTop = (0, _react.useCallback)(()=>scrollTopRef.current, []);\n    (0, _react.useEffect)(()=>{\n        if (element) {\n            element.addEventListener(\"scroll\", handleScroll, {\n                passive: true\n            });\n        }\n        return ()=>{\n            if (element) {\n                element.removeEventListener(\"scroll\", handleScroll);\n            }\n        };\n    }, [\n        element,\n        handleScroll,\n        scrollContainerElementRef\n    ]);\n    return (0, _react.useMemo)(()=>({\n            scrollTop,\n            getScrollTop\n        }), [\n        scrollTop,\n        getScrollTop\n    ]);\n};\nconst TooltipContext = /*#__PURE__*/ _react.createContext(null);\nconst useTooltipContext = ()=>{\n    const context = _react.useContext(TooltipContext);\n    if (context == null) {\n        throw new Error(\"Tooltip components must be wrapped in <Tooltip />\");\n    }\n    return context;\n};\nconst TOOLTIP_DELAY_DEFAULT = 500;\nconst useTooltip = (options = {})=>{\n    const { initialOpen = false, placement = \"top\", open: controlledOpen, onOpenChange: setControlledOpen, offset: offset$1 = 5, delay: delayFromOptions, disableHover, disableFocus } = options;\n    const [uncontrolledOpen, setUncontrolledOpen] = _react.useState(initialOpen);\n    const open = controlledOpen ?? uncontrolledOpen;\n    const setOpen = setControlledOpen ?? setUncontrolledOpen;\n    const { delay } = (0, _react1.useDelayGroupContext)();\n    const data = (0, _react1.useFloating)({\n        placement,\n        open,\n        onOpenChange: setOpen,\n        whileElementsMounted: _react1.autoUpdate,\n        middleware: [\n            (0, _react1.offset)(offset$1),\n            (0, _react1.flip)({\n                fallbackAxisSideDirection: \"start\",\n                padding: offset$1\n            }),\n            (0, _react1.shift)({\n                padding: offset$1\n            })\n        ]\n    });\n    const { context } = data;\n    const hover = (0, _react1.useHover)(context, {\n        move: false,\n        enabled: !disableHover,\n        delay: delay || delayFromOptions || TOOLTIP_DELAY_DEFAULT\n    });\n    const focus = (0, _react1.useFocus)(context, {\n        enabled: !disableFocus\n    });\n    const dismiss = (0, _react1.useDismiss)(context);\n    const role = (0, _react1.useRole)(context, {\n        role: \"tooltip\"\n    });\n    const interactions = (0, _react1.useInteractions)([\n        hover,\n        focus,\n        dismiss,\n        role\n    ]);\n    return _react.useMemo(()=>({\n            open,\n            setOpen,\n            ...interactions,\n            ...data,\n            options\n        }), [\n        open,\n        setOpen,\n        interactions,\n        data,\n        options\n    ]);\n};\nconst Tooltip = ({ children, tooltipRef, ...options })=>{\n    const tooltip = useTooltip(options);\n    (0, _react.useImperativeHandle)(tooltipRef, ()=>tooltip, [\n        tooltip\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(TooltipContext.Provider, {\n        value: tooltip\n    }, children);\n};\nvar stylesScss = {\n    \"tooltipTrigger\": \"Tooltip-module_tooltipTrigger__BHmWb\",\n    \"displayAsInlineText\": \"Tooltip-module_displayAsInlineText__zY9WY\",\n    \"tooltipContent\": \"Tooltip-module_tooltipContent__ZxzgY\",\n    \"skinny\": \"Tooltip-module_skinny__PmxPq\",\n    \"fitContent\": \"Tooltip-module_fitContent__qaHOb\",\n    \"stayOpenOnHover\": \"Tooltip-module_stayOpenOnHover__xvKqC\"\n};\nconst TooltipTrigger = /*#__PURE__*/ _react.default.forwardRef(({ children, asChild = false, className, displayAsInlineText, ...props }, propRef)=>{\n    const context = useTooltipContext();\n    const childrenRef = children.ref;\n    const ref = (0, _react1.useMergeRefs)([\n        context.refs.setReference,\n        propRef,\n        childrenRef\n    ]);\n    const propsToPass = (0, _react.useMemo)(()=>context.getReferenceProps(props), [\n        props,\n        context\n    ]);\n    // `asChild` allows the user to pass any element as the anchor\n    if (asChild && /*#__PURE__*/ _react.default.isValidElement(children)) {\n        return /*#__PURE__*/ _react.default.cloneElement(children, context.getReferenceProps({\n            ref,\n            ...props,\n            ...children.props,\n            \"data-state\": context.open ? \"open\" : \"closed\"\n        }));\n    }\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(className, stylesScss.tooltipTrigger, {\n            [stylesScss.displayAsInlineText]: displayAsInlineText\n        }),\n        \"data-state\": context.open ? \"open\" : \"closed\",\n        ref: ref,\n        ...propsToPass\n    }, children);\n});\nTooltipTrigger.displayName = \"TooltopTrigger\";\nconst TooltipContent = /*#__PURE__*/ _react.default.forwardRef(({ className, isSkinny = false, fitContent = false, style, renderHiddenChildrenWhenTooltipClosed = true, keepTooltipOpenOnHover, ...props }, propRef)=>{\n    const state = useTooltipContext();\n    const id = (0, _react1.useId)();\n    const { isInstantPhase, currentId } = (0, _react1.useDelayGroupContext)();\n    const ref = (0, _react1.useMergeRefs)([\n        state.refs.setFloating,\n        propRef\n    ]);\n    (0, _react1.useDelayGroup)(state.context, {\n        id\n    });\n    const instantDuration = 20;\n    const duration = 100;\n    const { isMounted, styles } = (0, _react1.useTransitionStyles)(state.context, {\n        duration: isInstantPhase ? {\n            open: instantDuration,\n            // `id` is this component's `id`\n            // `currentId` is the current group's `id`\n            close: currentId === id ? duration : instantDuration\n        } : duration,\n        initial: {\n            opacity: 0\n        }\n    });\n    const { children, ...propsFromState } = (0, _react.useMemo)(()=>state.getFloatingProps(props), [\n        props,\n        state\n    ]);\n    const handleClick = (0, _react.useCallback)(()=>state.setOpen(false), [\n        state\n    ]);\n    const styleToPass = (0, _react.useMemo)(()=>({\n            ...state.floatingStyles,\n            ...style,\n            ...styles,\n            filter: \"drop-shadow(4px 4px 6px rgba(0, 0, 0, 0.15))\"\n        }), [\n        state,\n        style,\n        styles\n    ]);\n    const propsToPass = (0, _react.useMemo)(()=>({\n            ...propsFromState\n        }), [\n        propsFromState\n    ]);\n    if (!isMounted) return null;\n    const hideContent = renderHiddenChildrenWhenTooltipClosed ? false : !isMounted;\n    return /*#__PURE__*/ _react.default.createElement(_react1.FloatingPortal, null, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(className, stylesScss.tooltipContent, {\n            [stylesScss.skinny]: isSkinny,\n            [stylesScss.fitContent]: fitContent,\n            [stylesScss.stayOpenOnHover]: keepTooltipOpenOnHover\n        }),\n        onClick: handleClick,\n        onKeyDown: undefined,\n        ref: ref,\n        style: styleToPass,\n        ...propsToPass\n    }, hideContent ? null : children));\n});\nTooltipContent.displayName = \"TooltipContent\";\nconst TooltipSimple = ({ children, content, isSkinny, fitContent, className, classNameContent, asChild, disable = false, contentRef, style, styleContent, renderHiddenChildrenWhenTooltipClosed, keepTooltipOpenOnHover = true, isClickToOpen, stateRef, open: openProp, contentRenderReliesOnBeingOpen, closeDelay, displayAsInlineText, ...props })=>{\n    const pointerLeaveTimeoutRef = (0, _react.useRef)();\n    const { onOpenChange, delay } = props;\n    const [open, setOpen] = (0, _react.useState)(false);\n    const handleOpenChange = (0, _react.useCallback)((newOpen)=>{\n        if (isClickToOpen ? false : newOpen) {\n            setOpen(newOpen);\n        }\n        if ((contentRenderReliesOnBeingOpen || !isClickToOpen) && !newOpen) {\n            setOpen(false);\n        }\n    }, [\n        contentRenderReliesOnBeingOpen,\n        isClickToOpen\n    ]);\n    const handlePointerEnter = (0, _react.useCallback)(()=>{\n        if (keepTooltipOpenOnHover) {\n            clearTimeout(pointerLeaveTimeoutRef.current);\n            setOpen(true);\n        }\n    }, [\n        keepTooltipOpenOnHover\n    ]);\n    const handlePointerLeave = (0, _react.useCallback)(()=>{\n        if (keepTooltipOpenOnHover) {\n            pointerLeaveTimeoutRef.current = setTimeout(()=>{\n                setOpen(false);\n            }, Math.max(250, closeDelay || delay || 0));\n        }\n    }, [\n        keepTooltipOpenOnHover,\n        delay,\n        closeDelay\n    ]);\n    const handleTriggerPointerEnter = (0, _react.useCallback)(()=>{\n        clearTimeout(pointerLeaveTimeoutRef.current);\n    }, []);\n    (0, _react.useEffect)(()=>{\n        onOpenChange?.(open);\n    }, [\n        onOpenChange,\n        open\n    ]);\n    (0, _react.useImperativeHandle)(stateRef, ()=>({\n            handlePointerEnter,\n            handlePointerLeave\n        }), [\n        handlePointerEnter,\n        handlePointerLeave\n    ]);\n    const propsToPass = (0, _react.useMemo)(()=>({\n            ...props,\n            onOpenChange: handleOpenChange,\n            ...{\n                open: openProp === undefined ? open : openProp\n            }\n        }), [\n        props,\n        handleOpenChange,\n        open,\n        openProp\n    ]);\n    return disable ? // eslint-disable-next-line\n    /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children) : /*#__PURE__*/ _react.default.createElement(Tooltip, {\n        ...propsToPass\n    }, /*#__PURE__*/ _react.default.createElement(TooltipTrigger, {\n        asChild: asChild,\n        className: className,\n        displayAsInlineText: displayAsInlineText,\n        onPointerEnter: keepTooltipOpenOnHover ? handleTriggerPointerEnter : undefined,\n        onPointerLeave: keepTooltipOpenOnHover ? handlePointerLeave : undefined,\n        style: style\n    }, children), !!content && /*#__PURE__*/ _react.default.createElement(TooltipContent, {\n        className: classNameContent,\n        fitContent: fitContent,\n        isSkinny: isSkinny,\n        keepTooltipOpenOnHover: keepTooltipOpenOnHover,\n        onPointerEnter: keepTooltipOpenOnHover ? handlePointerEnter : undefined,\n        onPointerLeave: keepTooltipOpenOnHover ? handlePointerLeave : undefined,\n        ref: contentRef,\n        renderHiddenChildrenWhenTooltipClosed: renderHiddenChildrenWhenTooltipClosed,\n        style: styleContent\n    }, content));\n};\nvar styles$o = {\n    \"flex\": \"Flex-module_flex__6nefX\",\n    \"isCenteredX\": \"Flex-module_isCenteredX__IvC9d\",\n    \"isCenteredY\": \"Flex-module_isCenteredY__YEeN2\",\n    \"isCentered\": \"Flex-module_isCentered__5F04-\",\n    \"isColumn\": \"Flex-module_isColumn__-HjR1\"\n};\nconst Flex = /*#__PURE__*/ (0, _react.forwardRef)(({ children, className, isColumn, isCentered, isCenteredX, isCenteredY, isFullWidth, isFullHeight, justifyContent, alignItems, style, ...props }, ref)=>{\n    const classNamesCombined = (0, _react.useMemo)(()=>(0, _classnames.default)(styles$o.flex, className, {\n            [styles$o.isCenteredX]: isCenteredX,\n            [styles$o.isCenteredY]: isCenteredY,\n            [styles$o.isCentered]: isCentered,\n            [styles$o.isColumn]: isColumn,\n            [styles$o.isFullWidth]: isFullWidth,\n            [styles$o.isFullHeight]: isFullHeight\n        }), [\n        className,\n        isCenteredX,\n        isCenteredY,\n        isCentered,\n        isColumn,\n        isFullWidth,\n        isFullHeight\n    ]);\n    const styleCombined = (0, _react.useMemo)(()=>({\n            ...style || {},\n            \"--justify-content\": justifyContent,\n            \"--align-items\": alignItems\n        }), [\n        style,\n        alignItems,\n        justifyContent\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        ...props,\n        className: classNamesCombined,\n        ref: ref,\n        style: styleCombined\n    }, children);\n});\nFlex.displayName = \"Flex\";\nvar styles$n = {\n    \"xs\": '\"36em\"',\n    \"sm\": '\"48em\"',\n    \"md\": '\"62em\"',\n    \"lg\": '\"75em\"',\n    \"xl\": '\"88em\"',\n    \"pagePaddingX\": \"PagePaddingX-module_pagePaddingX__ZOv8V\",\n    \"isDisabled\": \"PagePaddingX-module_isDisabled__LY-Hz\",\n    \"isDisabledRight\": \"PagePaddingX-module_isDisabledRight__0CePp\",\n    \"isDisabledLeft\": \"PagePaddingX-module_isDisabledLeft__LAIvR\"\n};\n/**\n * This is a component to provide standardised x-axis (left right) padding to page components\n */ const PagePaddingX = /*#__PURE__*/ (0, _react.forwardRef)(({ children, className, disable = false, disableLeft = false, disableRight = false, ...props }, ref)=>{\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        ...props,\n        className: (0, _classnames.default)(styles$n.pagePaddingX, className, {\n            [styles$n.isDisabled]: disable,\n            [styles$n.isDisabledRight]: disableRight,\n            [styles$n.isDisabledLeft]: disableLeft\n        }),\n        ref: ref\n    }, children);\n});\nPagePaddingX.displayName = \"PagePaddingX\";\nvar styles$m = {\n    \"spacer\": \"Spacer-module_spacer__tV589\",\n    \"sizeXS\": \"Spacer-module_sizeXS__OXIJa\",\n    \"sizeSM\": \"Spacer-module_sizeSM__RQQrc\",\n    \"sizeMD\": \"Spacer-module_sizeMD__T69gv\",\n    \"sizeLG\": \"Spacer-module_sizeLG__lfdWh\",\n    \"sizeXL\": \"Spacer-module_sizeXL__2mtv3\",\n    \"heightXS\": \"Spacer-module_heightXS__uxu4p\",\n    \"heightSM\": \"Spacer-module_heightSM__UZ5-U\",\n    \"heightMD\": \"Spacer-module_heightMD__WOtVW\",\n    \"heightLG\": \"Spacer-module_heightLG__21vsP\",\n    \"heightXL\": \"Spacer-module_heightXL__P10GW\",\n    \"widthXS\": \"Spacer-module_widthXS__xtyzq\",\n    \"widthSM\": \"Spacer-module_widthSM__NFUty\",\n    \"widthMD\": \"Spacer-module_widthMD__5MktO\",\n    \"widthLG\": \"Spacer-module_widthLG__9CGck\",\n    \"widthXL\": \"Spacer-module_widthXL__BJgI-\"\n};\nconst createSizeClassNameObj = (type, size)=>size ? {\n        [styles$m?.[`${type}${size?.toUpperCase()}`]]: !!size\n    } : {};\nconst Spacer = /*#__PURE__*/ (0, _react.forwardRef)(({ size, height, width, className, scaleFactor = 1, ...props }, ref)=>{\n    const sizeClassNames = (0, _react.useMemo)(()=>({\n            ...createSizeClassNameObj(\"size\", size),\n            ...createSizeClassNameObj(\"height\", height),\n            ...createSizeClassNameObj(\"width\", width)\n        }), [\n        size,\n        height,\n        width\n    ]);\n    const style = (0, _react.useMemo)(()=>({\n            \"--scale-factor\": scaleFactor\n        }), [\n        scaleFactor\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(\"span\", {\n        ...props,\n        className: (0, _classnames.default)(styles$m.spacer, className, sizeClassNames),\n        ref: ref,\n        style: style\n    });\n});\nSpacer.displayName = \"Spacer\";\nvar styles$l = {};\n/**\n * This is a component to provide standardised x-axis (left right) padding to page components\n */ const PagePaddingY = /*#__PURE__*/ (0, _react.forwardRef)(({ children, className, disable = false, disableTop = false, disableBottom = false, ...props }, ref)=>{\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        ...props,\n        className: (0, _classnames.default)(styles$l.pagePaddingY, className),\n        ref: ref\n    }, !disable && !disableTop && /*#__PURE__*/ _react.default.createElement(Spacer, {\n        height: \"xl\",\n        scaleFactor: 2\n    }), children, !disable && !disableBottom && /*#__PURE__*/ _react.default.createElement(Spacer, {\n        height: \"xl\",\n        scaleFactor: 2\n    }));\n});\nPagePaddingY.displayName = \"PagePaddingY\";\nvar styles$k = {\n    \"tooltipIcon\": \"TooltipHelpIcon-module_tooltipIcon__gD-lp\"\n};\nconst TooltipHelpIcon = ({ className, IconComponent = _reacticons.QuestionMarkCircledIcon, ...props })=>{\n    return /*#__PURE__*/ _react.default.createElement(IconComponent, {\n        ...props,\n        className: (0, _classnames.default)(className, styles$k.tooltipIcon)\n    });\n};\nvar styles$j = {\n    \"tooltipHelp\": \"TooltipHelp-module_tooltipHelp__KW7LC\"\n};\nconst TooltipHelp = ({ className, children, keepTooltipOpenOnHover = false, scale, style: styleProp, displayHelpIconAlongside, disable, ...props })=>{\n    const style = (0, _react.useMemo)(()=>{\n        return {\n            ...styleProp,\n            \"--scale\": scale || 1\n        };\n    }, [\n        scale,\n        styleProp\n    ]);\n    return disable ? // eslint-disable-next-line\n    /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children) : /*#__PURE__*/ _react.default.createElement(TooltipSimple, {\n        ...props,\n        className: (0, _classnames.default)(className, styles$j.tooltipHelp),\n        disable: disable,\n        keepTooltipOpenOnHover: keepTooltipOpenOnHover,\n        style: style\n    }, displayHelpIconAlongside ? /*#__PURE__*/ _react.default.createElement(Flex, null, children, /*#__PURE__*/ _react.default.createElement(Spacer, {\n        width: \"xs\"\n    }), /*#__PURE__*/ _react.default.createElement(TooltipHelpIcon, null)) : children || /*#__PURE__*/ _react.default.createElement(TooltipHelpIcon, null));\n};\nvar styles$i = {\n    \"button\": \"Button-module_button__bZShS\",\n    \"primary\": \"Button-module_primary__VXUhz\",\n    \"light\": \"Button-module_light__Gra4N\",\n    \"black\": \"Button-module_black__tDbjW\",\n    \"white\": \"Button-module_white__iQl-n\",\n    \"lightGray\": \"Button-module_lightGray__9q9kC\",\n    \"small\": \"Button-module_small__LNiuv\",\n    \"disabled\": \"Button-module_disabled__3ZvCY\",\n    \"disablePressEffectOnClick\": \"Button-module_disablePressEffectOnClick__pMvKm\",\n    \"disableWithoutChangingAppearance\": \"Button-module_disableWithoutChangingAppearance__9St0o\",\n    \"disablePadding\": \"Button-module_disablePadding__TnPpB\",\n    \"useSvgFill\": \"Button-module_useSvgFill__Kh4-h\",\n    \"wrapperButton\": \"Button-module_wrapperButton__jCtcS\"\n};\nconst Button = ({ children, className, type = \"button\", variant = \"base\", isWrapper = false, disablePadding = false, sizeVariant = \"default\", tooltipContent, tooltipPlacement, tooltipDelay, disabled = false, disableWithoutChangingAppearance = false, disablePressEffectOnClick = false, enableTooltipWhenDisabled = false, buttonRef, backgroundColor, backgroundColorShade, borderColor, borderColorShade, textColor, textColorShade, style: styleProp, onClick, tooltipProps, passDisabledAttribute = true, ...props })=>{\n    const tooltipRef = (0, _react.useRef)(null);\n    const { isMountedClient } = useClientMountedState();\n    const variantWithDefault = isWrapper ? variant : variant || \"base\";\n    const isBorderVariant = variantWithDefault === \"border\";\n    let background;\n    let color;\n    let border;\n    if (isBorderVariant || backgroundColor) {\n        background = isBorderVariant ? \"unset\" : getThemeVariable({\n            type: \"color\",\n            color: backgroundColor || \"primary\",\n            shade: backgroundColorShade || 7\n        });\n    }\n    if (isBorderVariant || textColor) {\n        color = getThemeVariable({\n            type: \"color\",\n            color: (isBorderVariant ? textColor || borderColor : textColor) || \"primary\",\n            shade: textColorShade || 9\n        });\n    }\n    if (isBorderVariant || borderColor) {\n        border = isBorderVariant || borderColor ? `1px solid ${getThemeVariable({\n            type: \"color\",\n            color: borderColor || \"primary\",\n            shade: borderColorShade || 9\n        })}` : undefined;\n    }\n    const style = (0, _react.useMemo)(()=>isMountedClient ? (0, _libutilities.removeUndefinedValuesFromObj)({\n            background,\n            color,\n            border,\n            ...styleProp\n        }) : {}, [\n        background,\n        border,\n        color,\n        styleProp,\n        isMountedClient\n    ]);\n    const handleClick = (0, _react.useCallback)((e)=>{\n        tooltipRef.current?.setOpen(false);\n        if (!disabled) {\n            onClick?.(e);\n        }\n    }, [\n        onClick,\n        disabled\n    ]);\n    const buttonChild = (0, _react.useMemo)(()=>/*#__PURE__*/ _react.default.createElement(\"button\", {\n            ...props,\n            className: (0, _classnames.default)(styles$i.button, className, styles$i[sizeVariant], {\n                [styles$i.useSvgFill]: !!border,\n                [styles$i.wrapperButton]: isWrapper,\n                [styles$i.disablePadding]: disablePadding,\n                [styles$i.base]: variantWithDefault?.includes(\"base\"),\n                [styles$i.light]: variantWithDefault?.includes(\"light\"),\n                [styles$i.inverse]: variantWithDefault?.includes(\"inverse\"),\n                [styles$i.primary]: variantWithDefault?.includes(\"primary\"),\n                [styles$i.disabled]: disabled,\n                [styles$i.disableWithoutChangingAppearance]: disableWithoutChangingAppearance,\n                [styles$i.disablePressEffectOnClick]: disablePressEffectOnClick\n            }),\n            disabled: passDisabledAttribute ? disabled : undefined,\n            onClick: handleClick,\n            ref: buttonRef,\n            style: style,\n            type: type\n        }, children), [\n        style,\n        children,\n        className,\n        sizeVariant,\n        isWrapper,\n        type,\n        props,\n        variantWithDefault,\n        disabled,\n        disablePadding,\n        buttonRef,\n        disablePressEffectOnClick,\n        disableWithoutChangingAppearance,\n        handleClick,\n        border,\n        passDisabledAttribute\n    ]);\n    return tooltipContent && (disabled ? enableTooltipWhenDisabled : true) ? /*#__PURE__*/ _react.default.createElement(TooltipSimple, {\n        asChild: true,\n        content: tooltipContent,\n        delay: tooltipDelay,\n        isSkinny: true,\n        keepTooltipOpenOnHover: false,\n        placement: tooltipPlacement,\n        tooltipRef: tooltipRef,\n        ...tooltipProps\n    }, buttonChild) : buttonChild;\n};\nvar styles$h = {\n    \"card\": \"Card-module_card__kQV3P\"\n};\nconst Card = ({ children, className, ...props })=>{\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        ...props,\n        className: (0, _classnames.default)(styles$h.card, className)\n    }, children);\n};\nvar styles$g = {\n    \"checkbox\": \"Checkbox-module_checkbox__TCkLo\",\n    \"disableFocusOutline\": \"Checkbox-module_disableFocusOutline__cwycH\",\n    \"disabled\": \"Checkbox-module_disabled__nngFo\",\n    \"checkboxIndicator\": \"Checkbox-module_checkboxIndicator__Obf1E\"\n};\nconst Checkbox = ({ children, className, renderChildWhenUnchecked = false, checked: checkedProp, defaultChecked = false, classNames: classNamesProp, onClick, disableFocusOutline = false, isSmall, disabled, ...props })=>{\n    const [checked, setChecked] = (0, _react.useState)(checkedProp || false);\n    (0, _react.useEffect)(()=>{\n        const newChecked = checkedProp || false;\n        if (checkedProp !== undefined && checked !== newChecked) {\n            setChecked(newChecked);\n        }\n    }, [\n        checkedProp,\n        checked\n    ]);\n    let checkedValue = checked || false;\n    if (renderChildWhenUnchecked) {\n        checkedValue = checked || \"indeterminate\";\n    }\n    let childrenToRender = children || /*#__PURE__*/ _react.default.createElement(_reacticons.CheckIcon, null);\n    if (_react.default.Children.count(children) === 2) {\n        childrenToRender = checkedValue === true ? _react.default.Children.toArray(children)[1] : _react.default.Children.toArray(children)[0];\n    }\n    const handleClick = (0, _react.useCallback)(()=>{\n        setChecked((prevValue)=>{\n            if (onClick) {\n                onClick(!prevValue);\n            }\n            return !prevValue;\n        });\n    }, [\n        onClick\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_reactcheckbox.Root, {\n        ...props,\n        checked: checkedValue,\n        className: (0, _classnames.default)(styles$g.checkbox, className, {\n            [classNamesProp?.checked || \"\"]: checkedValue === true,\n            [classNamesProp?.unchecked || \"\"]: checkedValue !== true,\n            [styles$g.disableFocusOutline]: !!disableFocusOutline,\n            [styles$g.isSmall]: !!isSmall,\n            [styles$g.disabled]: disabled\n        }),\n        defaultChecked: defaultChecked,\n        disabled: disabled,\n        onClick: handleClick\n    }, /*#__PURE__*/ _react.default.createElement(_reactcheckbox.Indicator, {\n        className: styles$g.checkboxIndicator\n    }, childrenToRender));\n};\nvar baseGetTag$1 = _baseGetTag, isArray$3 = isArray_1, isObjectLike$3 = isObjectLike_1;\n/** `Object#toString` result references. */ var stringTag$2 = \"[object String]\";\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */ function isString$1(value) {\n    return typeof value == \"string\" || !isArray$3(value) && isObjectLike$3(value) && baseGetTag$1(value) == stringTag$2;\n}\nvar isString_1 = isString$1;\nvar baseProperty = _baseProperty;\n/**\n * Gets the size of an ASCII `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */ var asciiSize$1 = baseProperty(\"length\");\nvar _asciiSize = asciiSize$1;\n/** Used to compose unicode character classes. */ var rsAstralRange$1 = \"\\ud800-\\udfff\", rsComboMarksRange$1 = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange$1 = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange$1 = \"\\\\u20d0-\\\\u20ff\", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */ var rsZWJ$1 = \"\\\\u200d\";\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */ var reHasUnicode = RegExp(\"[\" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + \"]\");\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */ function hasUnicode$1(string) {\n    return reHasUnicode.test(string);\n}\nvar _hasUnicode = hasUnicode$1;\n/** Used to compose unicode character classes. */ var rsAstralRange = \"\\ud800-\\udfff\", rsComboMarksRange = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */ var rsAstral = \"[\" + rsAstralRange + \"]\", rsCombo = \"[\" + rsComboRange + \"]\", rsFitz = \"\\ud83c[\\udffb-\\udfff]\", rsModifier = \"(?:\" + rsCombo + \"|\" + rsFitz + \")\", rsNonAstral = \"[^\" + rsAstralRange + \"]\", rsRegional = \"(?:\\ud83c[\\udde6-\\uddff]){2}\", rsSurrPair = \"[\\ud800-\\udbff][\\udc00-\\udfff]\", rsZWJ = \"\\\\u200d\";\n/** Used to compose unicode regexes. */ var reOptMod = rsModifier + \"?\", rsOptVar = \"[\" + rsVarRange + \"]?\", rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [\n    rsNonAstral,\n    rsRegional,\n    rsSurrPair\n].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = \"(?:\" + [\n    rsNonAstral + rsCombo + \"?\",\n    rsCombo,\n    rsRegional,\n    rsSurrPair,\n    rsAstral\n].join(\"|\") + \")\";\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */ var reUnicode = RegExp(rsFitz + \"(?=\" + rsFitz + \")|\" + rsSymbol + rsSeq, \"g\");\n/**\n * Gets the size of a Unicode `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */ function unicodeSize$1(string) {\n    var result = reUnicode.lastIndex = 0;\n    while(reUnicode.test(string)){\n        ++result;\n    }\n    return result;\n}\nvar _unicodeSize = unicodeSize$1;\nvar asciiSize = _asciiSize, hasUnicode = _hasUnicode, unicodeSize = _unicodeSize;\n/**\n * Gets the number of symbols in `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the string size.\n */ function stringSize$1(string) {\n    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);\n}\nvar _stringSize = stringSize$1;\nvar baseKeys = _baseKeys, getTag$3 = _getTag, isArrayLike$4 = isArrayLike_1, isString = isString_1, stringSize = _stringSize;\n/** `Object#toString` result references. */ var mapTag$3 = \"[object Map]\", setTag$3 = \"[object Set]\";\n/**\n * Gets the size of `collection` by returning its length for array-like\n * values or the number of own enumerable string keyed properties for objects.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @returns {number} Returns the collection size.\n * @example\n *\n * _.size([1, 2, 3]);\n * // => 3\n *\n * _.size({ 'a': 1, 'b': 2 });\n * // => 2\n *\n * _.size('pebbles');\n * // => 7\n */ function size(collection) {\n    if (collection == null) {\n        return 0;\n    }\n    if (isArrayLike$4(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n    }\n    var tag = getTag$3(collection);\n    if (tag == mapTag$3 || tag == setTag$3) {\n        return collection.size;\n    }\n    return baseKeys(collection).length;\n}\nvar size_1 = size;\nvar size$1 = /*@__PURE__*/ getDefaultExportFromCjs(size_1);\nvar styles$f = {\n    \"text\": \"Text-module_text__Ypn7e\"\n};\nconst Text = ({ children, className, bold, bold500 = false, bold600 = false, fontSize, italic = false, underline = false, inherit = true, textRef, useHeaderFont = false, color, style: styleProp, ...props })=>{\n    const style = (0, _react.useMemo)(()=>({\n            ...styleProp,\n            ...color ? {\n                color\n            } : {}\n        }), [\n        styleProp,\n        color\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(\"span\", {\n        ...props,\n        className: (0, _classnames.default)(styles$f.text, className, generateFontSizeClassName({\n            fontSize: inherit ? fontSize : fontSize || \"md\",\n            bold,\n            bold500,\n            bold600,\n            italic,\n            underline,\n            inherit,\n            useHeaderFont\n        })),\n        ref: textRef,\n        style: style\n    }, children);\n};\nvar styles$e = {\n    \"title\": \"Title-module_title__Gfll6\"\n};\nconst Title = ({ children, className, variant = \"h1\", fontSize = variant || \"h1\", bold, bold500, bold600, italic = false, underline = false, style, useHeaderFont = true, ...props })=>{\n    const propsToPass = (0, _react.useMemo)(()=>({\n            ...props,\n            style,\n            className: (0, _classnames.default)(styles$e.title, className, generateFontSizeClassName({\n                fontSize,\n                italic,\n                bold,\n                bold500,\n                bold600,\n                underline,\n                headerVariant: variant,\n                useHeaderFont\n            }))\n        }), [\n        bold,\n        bold500,\n        bold600,\n        underline,\n        italic,\n        fontSize,\n        className,\n        style,\n        props,\n        variant,\n        useHeaderFont\n    ]);\n    if (!variant) {\n        return /*#__PURE__*/ _react.default.createElement(Text, {\n            ...propsToPass\n        }, children);\n    }\n    if (variant === \"h1\") {\n        return /*#__PURE__*/ _react.default.createElement(\"h1\", {\n            ...propsToPass\n        }, children);\n    }\n    if (variant === \"h2\") {\n        return /*#__PURE__*/ _react.default.createElement(\"h2\", {\n            ...propsToPass\n        }, children);\n    }\n    if (variant === \"h3\") {\n        return /*#__PURE__*/ _react.default.createElement(\"h3\", {\n            ...propsToPass\n        }, children);\n    }\n    if (variant === \"h4\") {\n        return /*#__PURE__*/ _react.default.createElement(\"h4\", {\n            ...propsToPass\n        }, children);\n    }\n    if (variant === \"h5\") {\n        return /*#__PURE__*/ _react.default.createElement(\"h5\", {\n            ...propsToPass\n        }, children);\n    }\n    if (variant === \"h6\") {\n        return /*#__PURE__*/ _react.default.createElement(\"h6\", {\n            ...propsToPass\n        }, children);\n    }\n    return /*#__PURE__*/ _react.default.createElement(\"h1\", {\n        ...propsToPass\n    }, children);\n};\nvar styles$d = {\n    \"textInputComponent\": \"TextInput-module_textInputComponent__nR20q\",\n    \"textInputWrapper\": \"TextInput-module_textInputWrapper__NpzvT\",\n    \"textInput\": \"TextInput-module_textInput__w2NOZ\",\n    \"hasError\": \"TextInput-module_hasError__clZe6\",\n    \"isFocused\": \"TextInput-module_isFocused__6buNK\",\n    \"hasIconLeft\": \"TextInput-module_hasIconLeft__5S-dm\",\n    \"hasIconRight\": \"TextInput-module_hasIconRight__5hRUg\",\n    \"iconContainer\": \"TextInput-module_iconContainer__O6a2e\",\n    \"isLeft\": \"TextInput-module_isLeft__dYF9G\",\n    \"isRight\": \"TextInput-module_isRight__FuFzb\",\n    \"errorMessage\": \"TextInput-module_errorMessage__XCdnx\",\n    \"labelContainer\": \"TextInput-module_labelContainer__xjRIF\",\n    \"compact\": \"TextInput-module_compact__gojp2\",\n    \"label\": \"TextInput-module_label__Q9wmY\",\n    \"labelHelp\": \"TextInput-module_labelHelp__m7i-s\"\n};\nconst TextInput = ({ className, classNames: classNamesProp, icon, iconRight = false, type = \"text\", label, name, error, touched, onFocus, onBlur, onClick, inputRef, labelIsCompact, labelHelpTooltipContent, ...props })=>{\n    const [isFocused, setIsFocused] = (0, _react.useState)(false);\n    const handleFocus = (0, _react.useCallback)((e)=>{\n        onFocus?.(e);\n        setIsFocused(true);\n    }, [\n        onFocus\n    ]);\n    const handleClick = (0, _react.useCallback)((e)=>{\n        onClick?.(e);\n        setIsFocused(true);\n    }, [\n        onClick\n    ]);\n    const handleBlur = (0, _react.useCallback)((e)=>{\n        onBlur?.(e);\n        setIsFocused(false);\n    }, [\n        onBlur\n    ]);\n    const iconToRender = (0, _react.useMemo)(()=>/*#__PURE__*/ _react.default.createElement(\"span\", {\n            className: (0, _classnames.default)(classNamesProp?.iconContainer, styles$d.iconContainer, {\n                [styles$d.isLeft]: !iconRight,\n                [styles$d.isRight]: iconRight\n            })\n        }, icon), [\n        icon,\n        classNamesProp,\n        iconRight\n    ]);\n    const showError = !!touched && !!error && !isFocused;\n    return /*#__PURE__*/ _react.default.createElement(Flex, {\n        alignItems: \"flex-start\",\n        className: (0, _classnames.default)(styles$d.textInputComponent, className),\n        isColumn: true\n    }, !!label && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"label\", {\n        className: (0, _classnames.default)(styles$d.labelContainer, classNamesProp?.labelContainer, {\n            [styles$d.compact]: labelIsCompact\n        }),\n        htmlFor: name\n    }, /*#__PURE__*/ _react.default.createElement(Text, {\n        bold600: true,\n        className: (0, _classnames.default)(styles$d.label, classNamesProp?.label),\n        fontSize: \"sm\"\n    }, label), !!labelHelpTooltipContent && /*#__PURE__*/ _react.default.createElement(TooltipHelp, {\n        className: styles$d.labelHelp,\n        content: labelHelpTooltipContent\n    })), !labelIsCompact && /*#__PURE__*/ _react.default.createElement(Spacer, {\n        height: \"xs\",\n        scaleFactor: 0.5\n    })), /*#__PURE__*/ _react.default.createElement(Flex, {\n        alignItems: \"center\",\n        className: (0, _classnames.default)(styles$d.textInputWrapper, classNamesProp?.inputWrapper)\n    }, !!icon && !iconRight && iconToRender, /*#__PURE__*/ _react.default.createElement(\"input\", {\n        ...props,\n        className: (0, _classnames.default)(styles$d.textInput, classNamesProp?.input, {\n            [styles$d.isFocused]: isFocused,\n            [styles$d.hasIconLeft]: !!icon && !iconRight,\n            [styles$d.hasIconRight]: !!iconRight,\n            [styles$d.hasError]: !!showError\n        }),\n        onBlur: handleBlur,\n        onClick: handleClick,\n        onFocus: handleFocus,\n        onWheel: (e)=>e.target.blur(),\n        ref: inputRef,\n        type: type\n    }), !!icon && !!iconRight && iconToRender), !!showError && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Spacer, {\n        height: \"md\",\n        scaleFactor: 0.5\n    }), /*#__PURE__*/ _react.default.createElement(Text, {\n        className: (0, _classnames.default)(styles$d.errorMessage, classNamesProp?.errorMessage),\n        fontSize: \"xs\"\n    }, error)));\n};\nvar styles$c = {\n    \"wrapper\": \"DropDownWrapper-module_wrapper__mXxyE\",\n    \"dropDownButtonWrapper\": \"DropDownWrapper-module_dropDownButtonWrapper__i6JZJ\",\n    \"dropDown\": \"DropDownWrapper-module_dropDown__fIqzs\",\n    \"isOpen\": \"DropDownWrapper-module_isOpen__fA6c5\",\n    \"dropDownOptions\": \"DropDownWrapper-module_dropDownOptions__-b9-7\",\n    \"dropDownOption\": \"DropDownWrapper-module_dropDownOption__AybEx\",\n    \"selected\": \"DropDownWrapper-module_selected__GGbsv\",\n    \"search\": \"DropDownWrapper-module_search__3IpVC\",\n    \"clearInputButton\": \"DropDownWrapper-module_clearInputButton__spRU9\",\n    \"noResultsText\": \"DropDownWrapper-module_noResultsText__CPhvz\"\n};\nconst TypedFixedSizeList = _reactwindow.FixedSizeList;\nconst DEFAULT_VIRTUALISATION_PROPS = {\n    height: 120,\n    itemSize: 32,\n    width: \"100%\",\n    overscanCount: 100\n};\nconst DropDownWrapper = ({ buttonID, options, selectedID, className, classNames: classNamesProp, classNamesInput, optionDataAttribute, renderOption, enableOpening = true, children, onClickOption, forceOpen = false, onChangeOpen, searchEnabled, searchShowAllResultsOnEmpty = false, searchPlaceholder = \"Search for a value...\", searchFilterFunction, getFilterValueById, blurProps, virtualisationEnabled = false, virtualisationListProps, dropDownRef: dropDownRefProp, dropDownWrapperRef, focusSearchOnOpen = true })=>{\n    const selectorButtonRef = (0, _react.useRef)(null);\n    const dropDownRefInternal = (0, _react.useRef)(null);\n    const dropDownRef = dropDownRefProp || dropDownRefInternal;\n    const inputRef = (0, _react.useRef)(null);\n    const [dropDownIsOpen, setDropDownIsOpen] = (0, _react.useState)(false);\n    const [inputValue, setInputValue] = (0, _react.useState)(\"\");\n    const [debouncedInputValue, setDebouncedInputValue] = (0, _react.useState)(\"\");\n    const focusSearchBar = (0, _react.useCallback)(()=>{\n        inputRef?.current?.focus();\n    }, [\n        inputRef\n    ]);\n    const handleSetIsOpen = (0, _react.useCallback)((open)=>{\n        onChangeOpen?.(open);\n        setDropDownIsOpen(open);\n        setTimeout(()=>{\n            if (focusSearchOnOpen && !!open) {\n                focusSearchBar();\n            }\n        }, 100);\n    }, [\n        onChangeOpen,\n        focusSearchOnOpen,\n        focusSearchBar\n    ]);\n    const setInputValueDebounced = (0, _usedebounce.useDebouncedCallback)((value)=>{\n        setDebouncedInputValue?.(value);\n    }, 500);\n    const handleInputChange = (0, _react.useCallback)((value, forceUpdate)=>{\n        setInputValue(value);\n        setInputValueDebounced(value);\n        if (forceUpdate) {\n            setInputValueDebounced.flush();\n        }\n    }, [\n        setInputValueDebounced\n    ]);\n    const handleClose = (0, _react.useCallback)(()=>{\n        handleSetIsOpen(false);\n        handleInputChange(\"\", true);\n    }, [\n        handleSetIsOpen,\n        handleInputChange\n    ]);\n    const handleClickOption = (0, _react.useCallback)((option)=>{\n        handleClose();\n        onClickOption(option);\n    }, [\n        handleClose,\n        onClickOption\n    ]);\n    const filteredIds = (0, _react.useMemo)(()=>{\n        const normalisedDebouncedInputValue = debouncedInputValue.trim().toLowerCase();\n        if (!searchEnabled) {\n            return options;\n        }\n        if (!normalisedDebouncedInputValue) {\n            return searchShowAllResultsOnEmpty ? options : [];\n        }\n        return options.filter((option)=>{\n            const { id } = option;\n            const normalisedId = (getFilterValueById ? getFilterValueById({\n                id,\n                option,\n                debouncedInputValue\n            }) : id).trim().toLowerCase();\n            if (searchFilterFunction) {\n                return searchFilterFunction({\n                    id,\n                    option,\n                    debouncedInputValue\n                });\n            }\n            return (0, _libutilities.checkIfTextTermMatchesSingle)({\n                sourceValue: normalisedId,\n                inputValue: normalisedDebouncedInputValue\n            }).matches;\n        });\n    }, [\n        debouncedInputValue,\n        searchEnabled,\n        options,\n        searchShowAllResultsOnEmpty,\n        searchFilterFunction,\n        getFilterValueById\n    ]);\n    const isOpen = forceOpen || !!enableOpening && !!dropDownIsOpen;\n    const filteredIdsSliced = (0, _react.useMemo)(()=>(isOpen ? filteredIds : (filteredIds || []).slice(0, 10)) || [], [\n        filteredIds,\n        isOpen\n    ]);\n    const { onBlur, shouldDisableBlur, ...otherBlurProps } = blurProps || {};\n    const handleBlur = (0, _react.useCallback)((...args)=>{\n        onBlur?.(...args);\n        handleClose();\n    }, [\n        onBlur,\n        handleClose\n    ]);\n    const handleClickSelector = (0, _react.useCallback)(()=>{\n        if (dropDownIsOpen) {\n            handleBlur();\n        } else {\n            handleSetIsOpen(true);\n        }\n    }, [\n        dropDownIsOpen,\n        handleSetIsOpen,\n        handleBlur\n    ]);\n    const handleShouldDisableBlur = (0, _react.useCallback)((params)=>{\n        const { target, relatedTarget } = params;\n        return !!(selectorButtonRef.current?.contains(target) || selectorButtonRef.current?.contains(relatedTarget) || shouldDisableBlur?.(params));\n    }, [\n        shouldDisableBlur\n    ]);\n    useOnBlur({\n        blurElementRef: dropDownRef,\n        onBlur: handleBlur,\n        enabled: !!isOpen,\n        shouldDisableBlur: handleShouldDisableBlur,\n        ...otherBlurProps\n    });\n    const listComponentProps = (0, _react.useMemo)(()=>({\n            ...DEFAULT_VIRTUALISATION_PROPS,\n            ...virtualisationListProps,\n            itemCount: size$1(filteredIdsSliced),\n            itemData: filteredIdsSliced\n        }), [\n        filteredIdsSliced,\n        virtualisationListProps\n    ]);\n    const listRendered = (0, _react.useMemo)(()=>{\n        if (virtualisationEnabled) {\n            return /*#__PURE__*/ _react.default.createElement(TypedFixedSizeList, {\n                className: (0, _classnames.default)(styles$c.dropDownOptions, classNamesProp?.options?.()),\n                ...listComponentProps\n            }, ({ index, style, data })=>{\n                const option = data[index];\n                const id = option?.id;\n                return /*#__PURE__*/ _react.default.createElement(Button, {\n                    className: (0, _classnames.default)(styles$c.dropDownOption, classNamesProp?.option?.(option), {\n                        [styles$c.selected]: id === selectedID,\n                        selected: id === selectedID\n                    }),\n                    \"data-element-type\": optionDataAttribute,\n                    disablePadding: true,\n                    isWrapper: true,\n                    key: id,\n                    onClick: ()=>handleClickOption(option),\n                    style: style\n                }, renderOption ? renderOption({\n                    id,\n                    option,\n                    debouncedInputValue\n                }) : /*#__PURE__*/ _react.default.createElement(Text, {\n                    fontSize: \"sm\"\n                }, id));\n            });\n        }\n        return /*#__PURE__*/ _react.default.createElement(Flex, {\n            className: (0, _classnames.default)(styles$c.dropDownOptions, classNamesProp?.options?.()),\n            isColumn: true\n        }, filteredIdsSliced.map((option)=>/*#__PURE__*/ _react.default.createElement(Button, {\n                className: (0, _classnames.default)(styles$c.dropDownOption, classNamesProp?.option?.(option), {\n                    [styles$c.selected]: option?.id === selectedID,\n                    selected: option?.id === selectedID\n                }),\n                \"data-element-type\": optionDataAttribute,\n                disablePadding: true,\n                isWrapper: true,\n                key: option?.id,\n                onClick: ()=>handleClickOption(option)\n            }, renderOption ? renderOption({\n                id: option?.id,\n                option,\n                debouncedInputValue\n            }) : /*#__PURE__*/ _react.default.createElement(Text, {\n                fontSize: \"sm\"\n            }, option?.id))));\n    }, [\n        classNamesProp,\n        filteredIdsSliced,\n        handleClickOption,\n        listComponentProps,\n        optionDataAttribute,\n        renderOption,\n        selectedID,\n        virtualisationEnabled,\n        debouncedInputValue\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(styles$c.wrapper, className, {\n            open: isOpen\n        }),\n        ref: dropDownWrapperRef\n    }, /*#__PURE__*/ _react.default.createElement(Button, {\n        buttonRef: selectorButtonRef,\n        className: (0, _classnames.default)(styles$c.dropDownButtonWrapper, classNamesProp?.button?.()),\n        disabled: !enableOpening,\n        disablePadding: true,\n        id: buttonID,\n        isWrapper: true,\n        onClick: enableOpening ? handleClickSelector : undefined\n    }, children), !!enableOpening && /*#__PURE__*/ _react.default.createElement(Flex, {\n        className: (0, _classnames.default)(styles$c.dropDown, classNamesProp?.dropDown?.(), {\n            [styles$c.isOpen]: isOpen,\n            open: isOpen\n        }),\n        isColumn: true,\n        ref: dropDownRef\n    }, !!searchEnabled && /*#__PURE__*/ _react.default.createElement(TextInput, {\n        className: (0, _classnames.default)(styles$c.search, classNamesProp?.search?.()),\n        classNames: classNamesInput,\n        icon: /*#__PURE__*/ _react.default.createElement(Button, {\n            className: (0, _classnames.default)(styles$c.clearInputButton, {\n                [styles$c.isVisible]: !!inputValue\n            }),\n            isWrapper: true,\n            onClick: ()=>handleInputChange(\"\", true)\n        }, /*#__PURE__*/ _react.default.createElement(_reacticons.Cross2Icon, null)),\n        iconRight: true,\n        inputRef: inputRef,\n        onChange: (e)=>handleInputChange(e.target.value),\n        placeholder: searchPlaceholder,\n        type: \"text\",\n        value: inputValue\n    }), size$1(filteredIdsSliced) ? listRendered : /*#__PURE__*/ _react.default.createElement(Text, {\n        className: styles$c.noResultsText,\n        fontSize: \"xs\"\n    }, \"No results found...\")));\n};\nvar styles$b = {\n    \"headerBar\": \"HeaderBar-module_headerBar__aZzOK\",\n    \"headerBarRelativeWrapper\": \"HeaderBar-module_headerBarRelativeWrapper__MVkTS\",\n    \"headerBarContents\": \"HeaderBar-module_headerBarContents__IzvYl\",\n    \"title\": \"HeaderBar-module_title__KFzGK\",\n    \"headerTitle\": \"HeaderBar-module_headerTitle__4h3wH\",\n    \"headerBarItems\": \"HeaderBar-module_headerBarItems__11NHM\",\n    \"headerBarSubItems\": \"HeaderBar-module_headerBarSubItems__khEbO\",\n    \"link\": \"HeaderBar-module_link__RmvUi\",\n    \"disabled\": \"HeaderBar-module_disabled__TekfW\",\n    \"selectedItemBorder\": \"HeaderBar-module_selectedItemBorder__TnGZq\"\n};\nconst HeaderBarItem = ({ className, isSelected, isDisabled, href, child, text })=>{\n    return /*#__PURE__*/ _react.default.createElement(Anchor, {\n        className: (0, _classnames.default)(styles$b.link, className, {\n            [styles$b.selected]: isSelected\n        }),\n        disable: isDisabled,\n        href: href\n    }, child || /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Text, {\n        fontSize: \"xs\"\n    }, text), isSelected && /*#__PURE__*/ _react.default.createElement(\"span\", {\n        className: styles$b.selectedItemBorder\n    })));\n};\nconst HeaderBar = ({ items, headerTitleContent, headerTitleHref, rightHandContent, selectedId, disableHeaderTitleLink = false, className, classNames: classNamesProp, usePagePadding = true })=>{\n    const WrappingComponent = usePagePadding ? PagePaddingX : Flex;\n    return /*#__PURE__*/ _react.default.createElement(Flex, {\n        className: (0, _classnames.default)(styles$b.headerBar, className)\n    }, /*#__PURE__*/ _react.default.createElement(Flex, {\n        alignItems: \"center\",\n        className: (0, _classnames.default)(styles$b.headerBarRelativeWrapper, classNamesProp?.relativeWrapper)\n    }, /*#__PURE__*/ _react.default.createElement(WrappingComponent, {\n        className: (0, _classnames.default)(styles$b.headerBarContents, classNamesProp?.contents)\n    }, /*#__PURE__*/ _react.default.createElement(Flex, {\n        alignItems: \"center\",\n        className: (0, _classnames.default)(styles$b.headerBarItems, classNamesProp?.items)\n    }, /*#__PURE__*/ _react.default.createElement(Flex, {\n        alignItems: \"center\",\n        className: (0, _classnames.default)(styles$b.headerBarSubItems, classNamesProp?.subItems)\n    }, /*#__PURE__*/ _react.default.createElement(Anchor, {\n        className: (0, _classnames.default)(styles$b.link, classNamesProp?.link, {\n            [styles$b.disabled]: disableHeaderTitleLink\n        }),\n        disable: disableHeaderTitleLink,\n        href: headerTitleHref || \"/\"\n    }, /*#__PURE__*/ _react.default.createElement(Flex, {\n        alignItems: \"center\",\n        className: (0, _classnames.default)(styles$b.title, classNamesProp?.title)\n    }, typeof headerTitleContent === \"string\" ? /*#__PURE__*/ _react.default.createElement(Text, {\n        bold: true,\n        fontSize: \"sm\"\n    }, headerTitleContent) : headerTitleContent)), items.map(({ id, href, text, child })=>/*#__PURE__*/ _react.default.createElement(HeaderBarItem, {\n            child: child,\n            className: classNamesProp?.link,\n            href: href,\n            isDisabled: id === selectedId,\n            isSelected: id === selectedId,\n            key: id,\n            text: text\n        })))), rightHandContent)));\n};\nvar styles$a = {\n    \"knobWrapper\": \"KnobRotary-module_knobWrapper__10iev\",\n    \"knobSkinWrapper\": \"KnobRotary-module_knobSkinWrapper__8V2FH\",\n    \"isDisabled\": \"KnobRotary-module_isDisabled__1-yNK\",\n    \"knobValueWrapper\": \"KnobRotary-module_knobValueWrapper__RXNjQ\",\n    \"knobValue\": \"KnobRotary-module_knobValue__Yc6Ut\"\n};\n// Knobs taken from http://react-rotary-knob-skins-preview.surge.sh/\n// eslint-disable-next-line\nconst KnobSvgChild1 = ({ pointerColor })=>{\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"defs\", null, /*#__PURE__*/ _react.default.createElement(\"linearGradient\", {\n        id: \"f7066879-f57b-f7ab-0a62-b7e76659fc9a\",\n        x1: \"50%\",\n        x2: \"50%\",\n        y1: \"50%\",\n        y2: \"100%\"\n    }, /*#__PURE__*/ _react.default.createElement(\"stop\", {\n        offset: \"0%\",\n        stopColor: \"#444040\",\n        stopOpacity: \"0.51098279\"\n    }), /*#__PURE__*/ _react.default.createElement(\"stop\", {\n        offset: \"100%\",\n        stopColor: \"#131111\",\n        stopOpacity: \"0.893200861\"\n    })), /*#__PURE__*/ _react.default.createElement(\"circle\", {\n        cx: \"98.0400009\",\n        cy: \"98.0400009\",\n        id: \"969b1f52-759b-c83e-61ec-394ce88ab344\",\n        r: \"98.0400009\"\n    }), /*#__PURE__*/ _react.default.createElement(\"filter\", {\n        filterUnits: \"objectBoundingBox\",\n        height: \"106.6%\",\n        id: \"4400ad0d-4d36-0bc1-05b0-ba46e610ec97\",\n        width: \"106.6%\",\n        x: \"-3.3%\",\n        y: \"-3.3%\"\n    }, /*#__PURE__*/ _react.default.createElement(\"feMorphology\", {\n        in: \"SourceAlpha\",\n        operator: \"dilate\",\n        radius: \"0.5\",\n        result: \"shadowSpreadOuter1\"\n    }), /*#__PURE__*/ _react.default.createElement(\"feOffset\", {\n        dx: \"0\",\n        dy: \"0\",\n        in: \"shadowSpreadOuter1\",\n        result: \"shadowOffsetOuter1\"\n    }), /*#__PURE__*/ _react.default.createElement(\"feGaussianBlur\", {\n        in: \"shadowOffsetOuter1\",\n        result: \"shadowBlurOuter1\",\n        stdDeviation: \"2\"\n    }), /*#__PURE__*/ _react.default.createElement(\"feComposite\", {\n        in: \"shadowBlurOuter1\",\n        in2: \"SourceAlpha\",\n        operator: \"out\",\n        result: \"shadowBlurOuter1\"\n    }), /*#__PURE__*/ _react.default.createElement(\"feColorMatrix\", {\n        in: \"shadowBlurOuter1\",\n        type: \"matrix\",\n        values: \"0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.5 0\"\n    })), /*#__PURE__*/ _react.default.createElement(\"linearGradient\", {\n        id: \"666891d9-1c7d-33e0-6996-abfa6bc7e950\",\n        x1: \"50%\",\n        x2: \"50%\",\n        y1: \"0%\",\n        y2: \"100%\"\n    }, /*#__PURE__*/ _react.default.createElement(\"stop\", {\n        offset: \"0%\",\n        stopColor: \"#FFFFFF\",\n        stopOpacity: \"0.5\"\n    }), /*#__PURE__*/ _react.default.createElement(\"stop\", {\n        offset: \"100%\",\n        stopColor: \"#000000\",\n        stopOpacity: \"0.5\"\n    })), /*#__PURE__*/ _react.default.createElement(\"circle\", {\n        cx: \"98\",\n        cy: \"98\",\n        id: \"2ecb830f-8637-8aaf-9333-658361cb9f49\",\n        r: \"86\"\n    }), /*#__PURE__*/ _react.default.createElement(\"filter\", {\n        filterUnits: \"objectBoundingBox\",\n        height: \"108.1%\",\n        id: \"38812cc9-6961-10e7-6c57-df005b28946b\",\n        width: \"108.1%\",\n        x: \"-4.1%\",\n        y: \"-3.5%\"\n    }, /*#__PURE__*/ _react.default.createElement(\"feMorphology\", {\n        in: \"SourceAlpha\",\n        operator: \"dilate\",\n        radius: \"0.5\",\n        result: \"shadowSpreadOuter1\"\n    }), /*#__PURE__*/ _react.default.createElement(\"feOffset\", {\n        dx: \"0\",\n        dy: \"1\",\n        in: \"shadowSpreadOuter1\",\n        result: \"shadowOffsetOuter1\"\n    }), /*#__PURE__*/ _react.default.createElement(\"feGaussianBlur\", {\n        in: \"shadowOffsetOuter1\",\n        result: \"shadowBlurOuter1\",\n        stdDeviation: \"2\"\n    }), /*#__PURE__*/ _react.default.createElement(\"feComposite\", {\n        in: \"shadowBlurOuter1\",\n        in2: \"SourceAlpha\",\n        operator: \"out\",\n        result: \"shadowBlurOuter1\"\n    }), /*#__PURE__*/ _react.default.createElement(\"feColorMatrix\", {\n        in: \"shadowBlurOuter1\",\n        type: \"matrix\",\n        values: \"0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.5 0\"\n    }))), /*#__PURE__*/ _react.default.createElement(\"g\", {\n        fill: \"none\",\n        fillRule: \"evenodd\",\n        id: \"Page-1\",\n        stroke: \"none\",\n        strokeWidth: \"1\"\n    }, /*#__PURE__*/ _react.default.createElement(\"g\", {\n        id: \"s13\",\n        transform: \"translate(4.000000, 4.000000)\"\n    }, /*#__PURE__*/ _react.default.createElement(\"g\", {\n        id: \"container\"\n    }, /*#__PURE__*/ _react.default.createElement(\"g\", {\n        id: \"Oval-2\"\n    }, /*#__PURE__*/ _react.default.createElement(\"use\", {\n        fill: \"black\",\n        fillOpacity: \"1\",\n        filter: \"url(#4400ad0d-4d36-0bc1-05b0-ba46e610ec97)\",\n        xlinkHref: \"#969b1f52-759b-c83e-61ec-394ce88ab344\"\n    }), /*#__PURE__*/ _react.default.createElement(\"use\", {\n        fill: \"url(#f7066879-f57b-f7ab-0a62-b7e76659fc9a)\",\n        fillRule: \"evenodd\",\n        stroke: \"#979797\",\n        strokeWidth: \"1\",\n        xlinkHref: \"#969b1f52-759b-c83e-61ec-394ce88ab344\"\n    })), /*#__PURE__*/ _react.default.createElement(\"g\", {\n        id: \"Oval-2\"\n    }, /*#__PURE__*/ _react.default.createElement(\"use\", {\n        fill: \"black\",\n        fillOpacity: \"1\",\n        filter: \"url(#38812cc9-6961-10e7-6c57-df005b28946b)\",\n        xlinkHref: \"#2ecb830f-8637-8aaf-9333-658361cb9f49\"\n    }), /*#__PURE__*/ _react.default.createElement(\"use\", {\n        fill: \"\",\n        fillRule: \"evenodd\",\n        xlinkHref: \"#2ecb830f-8637-8aaf-9333-658361cb9f49\"\n    }), /*#__PURE__*/ _react.default.createElement(\"use\", {\n        fill: \"url(#666891d9-1c7d-33e0-6996-abfa6bc7e950)\",\n        fillRule: \"evenodd\",\n        stroke: \"#4A4A4A\",\n        strokeWidth: \"1\",\n        xlinkHref: \"#2ecb830f-8637-8aaf-9333-658361cb9f49\"\n    })), /*#__PURE__*/ _react.default.createElement(\"g\", {\n        id: \"knob\",\n        transform: \"translate(27.431373, 27.431373)\"\n    }, /*#__PURE__*/ _react.default.createElement(\"circle\", {\n        cx: \"71\",\n        cy: \"71\",\n        fill: \"#322E2E\",\n        r: \"71\"\n    }), /*#__PURE__*/ _react.default.createElement(\"path\", {\n        d: \"M70.0686275,4.17063061 L86.5686275,65.2689929 C81.3642501,66.811221 75.8642501,67.5735686 70.0686275,67.5560356 C64.2730048,67.5385027 58.7730048,66.7761551 53.5686275,65.2689929 L70.0686275,4.17063061 Z\",\n        fill: pointerColor,\n        id: \"knob-pointer\",\n        transform: \"translate(70.068627, 35.863481) scale(1, -1) translate(-70.068627, -35.863481) \"\n    }))))));\n};\nvar styles$9 = {\n    \"sliderMechanismWrapper\": \"SliderMechanism-module_sliderMechanismWrapper__vk17P\",\n    \"disabled\": \"SliderMechanism-module_disabled__5GX3M\",\n    \"sliderWrapper\": \"SliderMechanism-module_sliderWrapper__izVSq\",\n    \"slider\": \"SliderMechanism-module_slider__FfREF\",\n    \"enlarged\": \"SliderMechanism-module_enlarged__5pJCz\"\n};\nvar styles$8 = {\n    \"sliderWrapper\": \"Slider-module_sliderWrapper__NpzPu\",\n    \"vertical\": \"Slider-module_vertical__8XT2t\",\n    \"sliderLabel\": \"Slider-module_sliderLabel__aLDvx\",\n    \"slider\": \"Slider-module_slider__YGU5r\",\n    \"sliderTrack\": \"Slider-module_sliderTrack__CsxoP\",\n    \"sliderThumb\": \"Slider-module_sliderThumb__lDEDE\"\n};\nconst ReactSlider = _reactslider.default;\nconst Slider = ({ className, classNames: classNamesProp, orientation, wrapperRef, disabled, invert, ...props })=>{\n    const isVertical = orientation === \"vertical\";\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(styles$8.sliderWrapper, classNamesProp?.wrapper, className, {\n            [styles$8.vertical]: isVertical,\n            vertical: isVertical\n        }),\n        ref: wrapperRef\n    }, /*#__PURE__*/ _react.default.createElement(ReactSlider, {\n        ...props,\n        className: (0, _classnames.default)(styles$8.slider, classNamesProp?.slider, {\n            [styles$8.vertical]: isVertical,\n            vertical: isVertical\n        }),\n        disabled: disabled,\n        invert: invert === undefined ? isVertical : invert,\n        orientation: orientation,\n        snapDragDisabled: true,\n        thumbClassName: (0, _classnames.default)(styles$8.sliderThumb, classNamesProp?.sliderThumb, {\n            [styles$8.vertical]: isVertical,\n            vertical: isVertical\n        }),\n        trackClassName: (0, _classnames.default)(styles$8.sliderTrack, classNamesProp?.sliderTrack, {\n            [styles$8.vertical]: isVertical,\n            vertical: isVertical\n        })\n    }));\n};\nconst SliderMechanism = ({ initialValue = 0.5, value, minValue = 0, maxValue = 1, disabled, enlarged, className, sliderProps, onChange, onPointerDown, onMouseUp, sliderRef, children })=>{\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(styles$9.sliderMechanismWrapper, className, {\n            [styles$9.disabled]: disabled\n        }),\n        onPointerDown: onPointerDown,\n        onPointerUp: onMouseUp\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", null, !disabled && /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(styles$9.sliderWrapper, {\n            [styles$9.enlarged]: enlarged\n        })\n    }, /*#__PURE__*/ _react.default.createElement(Slider, {\n        className: styles$9.slider,\n        disabled: false,\n        initialValue: initialValue,\n        invert: true,\n        max: maxValue,\n        min: minValue,\n        onAfterChange: onMouseUp,\n        onChange: onChange,\n        orientation: \"vertical\",\n        snapDragDisabled: true,\n        step: (maxValue - minValue) / 100,\n        value: value,\n        wrapperRef: sliderRef,\n        ...sliderProps\n    }))), children);\n};\nconst useSliderMechanismState = ({ initialValue = 0.5, minValue = 0, maxValue = 1, onChange, value: valueProp, valueToRender, onPointerDown })=>{\n    const [valueInternal, setValueInternal] = (0, _react.useState)(initialValue);\n    const [enlarged, setEnlarged] = (0, _react.useState)(false);\n    const [hasSetFirstValue, setHasSetFirstValue] = (0, _react.useState)(false);\n    const isPressingRef = (0, _react.useRef)(false);\n    const sliderRef = (0, _react.useRef)(null);\n    let value = (0, _libutilities.isTruthyOrZero)(valueProp) ? valueProp : valueInternal;\n    let valueFormatted = (0, _libutilities.isTruthyOrZero)(value) ? value : initialValue;\n    const handlePointerDown = (0, _react.useCallback)((e)=>{\n        onPointerDown?.(e);\n        isPressingRef.current = true;\n    }, [\n        onPointerDown\n    ]);\n    const handleChange = (0, _react.useCallback)((newValue)=>{\n        if (isPressingRef.current) {\n            setEnlarged(true);\n        }\n        // Make sure no change is made until the slider has increased in size\n        if (enlarged) {\n            if (!hasSetFirstValue) {\n                // Do this to avoid jumping the value when the slider increases in size\n                setHasSetFirstValue(true);\n            } else {\n                setValueInternal(newValue);\n                onChange?.({\n                    value: newValue,\n                    min: minValue,\n                    max: maxValue\n                });\n            }\n        }\n    }, [\n        enlarged,\n        hasSetFirstValue,\n        onChange,\n        minValue,\n        maxValue\n    ]);\n    const handleMouseUp = (0, _react.useCallback)(()=>{\n        isPressingRef.current = false;\n        setEnlarged(false);\n        setHasSetFirstValue(false);\n    }, []);\n    const renderedValue = (0, _react.useMemo)(()=>valueToRender !== undefined ? valueToRender : valueFormatted, [\n        valueFormatted,\n        valueToRender\n    ]);\n    (0, _react.useEffect)(()=>{\n        if (enlarged) {\n            window.addEventListener(\"mouseup\", handleMouseUp);\n        }\n        return ()=>{\n            window.removeEventListener(\"mouseup\", handleMouseUp);\n        };\n    }, [\n        enlarged,\n        handleMouseUp\n    ]);\n    return (0, _react.useMemo)(()=>{\n        return {\n            values: {\n                value,\n                valueInternal,\n                setValueInternal,\n                enlarged,\n                setEnlarged,\n                hasSetFirstValue,\n                setHasSetFirstValue,\n                sliderRef,\n                handleChange,\n                handleMouseUp,\n                renderedValue\n            },\n            sliderMechanismProps: {\n                initialValue,\n                minValue,\n                maxValue,\n                onPointerDown: handlePointerDown,\n                onChange: handleChange,\n                onMouseUp: handleMouseUp,\n                value: renderedValue,\n                valueToRender,\n                enlarged,\n                sliderRef\n            }\n        };\n    }, [\n        value,\n        valueInternal,\n        setValueInternal,\n        enlarged,\n        setEnlarged,\n        hasSetFirstValue,\n        setHasSetFirstValue,\n        sliderRef,\n        handleChange,\n        handlePointerDown,\n        handleMouseUp,\n        renderedValue,\n        initialValue,\n        minValue,\n        maxValue,\n        valueToRender\n    ]);\n};\nconst LOWEST_ANGLE = -165;\nconst GREATEST_ANGLE = 165;\n/** NOTE: Consider switching to https://react-knob-headless.vercel.app/ */ const KnobRotary = ({ initialValue = 0.5, minValue = 0, maxValue = 1, onChange, disabled, className, value: valueProp, valueToRender, sliderProps, pointerColor, removeDefaultPointerColor, ...props })=>{\n    const { values, sliderMechanismProps } = useSliderMechanismState({\n        initialValue,\n        minValue,\n        maxValue,\n        onChange,\n        value: valueProp,\n        valueToRender\n    });\n    const rotation = (0, _react.useMemo)(()=>LOWEST_ANGLE + values.renderedValue / (maxValue - minValue) * (GREATEST_ANGLE - LOWEST_ANGLE), [\n        minValue,\n        maxValue,\n        values.renderedValue\n    ]);\n    const style = (0, _react.useMemo)(()=>({\n            \"--rotation\": `${rotation}deg`\n        }), [\n        rotation\n    ]);\n    const sliderMechanismPropsCombined = (0, _react.useMemo)(()=>{\n        return {\n            ...sliderMechanismProps,\n            disabled,\n            className: (0, _classnames.default)(styles$a.knobWrapper, className),\n            sliderProps\n        };\n    }, [\n        sliderMechanismProps,\n        className,\n        disabled,\n        sliderProps\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(SliderMechanism, {\n        ...sliderMechanismPropsCombined\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: styles$a.knobValueWrapper\n    }, /*#__PURE__*/ _react.default.createElement(Text, {\n        bold: true,\n        className: styles$a.knobValue,\n        fontSize: \"xs\"\n    }, values.renderedValue)), /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(styles$a.knobSkinWrapper, {\n            [styles$a.isDisabled]: disabled\n        }),\n        style: style\n    }, /*#__PURE__*/ _react.default.createElement(\"svg\", {\n        height: 208,\n        viewBox: \"0 0 208 208\",\n        width: 208,\n        xmlns: \"http://www.w3.org/2000/svg\",\n        xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n        ...props\n    }, /*#__PURE__*/ _react.default.createElement(KnobSvgChild1, {\n        pointerColor: (removeDefaultPointerColor ? undefined : pointerColor || getThemeVariable({\n            type: \"color\",\n            color: \"gray\",\n            shade: \"6\"\n        })) || undefined\n    }))));\n};\nvar styles$7 = {\n    \"knobWrapper\": \"KnobRotaryWithTicks-module_knobWrapper__BQ72Y\",\n    \"knobSkinWrapper\": \"KnobRotaryWithTicks-module_knobSkinWrapper__04hhz\",\n    \"isDisabled\": \"KnobRotaryWithTicks-module_isDisabled__W-LxB\",\n    \"knobValueWrapper\": \"KnobRotaryWithTicks-module_knobValueWrapper__nBtQn\",\n    \"knobValue\": \"KnobRotaryWithTicks-module_knobValue__jgnWG\"\n};\nvar styles$6 = {\n    \"knob\": \"KnobWithProgress-module_knob__mdeXN\",\n    \"knobOuter\": \"KnobWithProgress-module_knobOuter__cJRAg\",\n    \"knobInnerBackground\": \"KnobWithProgress-module_knobInnerBackground__vi2rn\",\n    \"knobInner\": \"KnobWithProgress-module_knobInner__dcxfY\",\n    \"grip\": \"KnobWithProgress-module_grip__Hy5mQ\",\n    \"ticks\": \"KnobWithProgress-module_ticks__9XGI9\",\n    \"tick\": \"KnobWithProgress-module_tick__--8x6\",\n    \"active\": \"KnobWithProgress-module_active__fQtj3\"\n};\nconst ACTIVE_TICK_OPACITY_MINIMUM = 0.66;\nconst convertRange = (oldMin, oldMax, newMin, newMax, oldValue)=>{\n    return (oldValue - oldMin) * (newMax - newMin) / (oldMax - oldMin) + newMin;\n};\nconst KnobWithProgress = ({ min = 0, max = 1, numTicks = 0, degrees = 260, value = min, disableGrip })=>{\n    const { // height: knobHeight,\n    width: knobWidth, ref: knobWrapperRef } = (0, _reactresizedetector.useResizeDetector)({\n        refreshMode: \"throttle\",\n        refreshRate: 25\n    });\n    const fullAngle = degrees;\n    const startAngle = (360 - degrees) / 2;\n    const endAngle = startAngle + degrees;\n    const currentDeg = Math.floor(convertRange(min, max, startAngle, endAngle, value));\n    const renderTicks = (0, _react.useCallback)(()=>{\n        let ticks = [];\n        const incr = fullAngle / numTicks;\n        const sizeCalculated = (knobWidth || 0) / 2;\n        for(let deg = startAngle; deg <= endAngle; deg += incr){\n            const tick = {\n                deg,\n                tickStyle: {\n                    height: sizeCalculated,\n                    left: sizeCalculated - 1.5,\n                    top: sizeCalculated,\n                    transform: `rotate(${deg}deg)`,\n                    transformOrigin: \"top\"\n                }\n            };\n            ticks.push(tick);\n        }\n        return ticks;\n    }, [\n        endAngle,\n        fullAngle,\n        startAngle,\n        numTicks,\n        knobWidth\n    ]);\n    const knobInnerStyle = (0, _react.useMemo)(()=>({\n            transform: `rotate(${currentDeg}deg)`\n        }), [\n        currentDeg\n    ]);\n    const percentage = (value - min) / (max - min);\n    const knobInnerBackgroundStyle = (0, _react.useMemo)(()=>({\n            opacity: 1 - percentage * 0.35\n        }), [\n        percentage\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: styles$6.knob,\n        id: \"knob\",\n        ref: knobWrapperRef\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: styles$6.ticks\n    }, numTicks ? renderTicks().map((tick)=>{\n        const tickIsActive = tick.deg < currentDeg || value === max;\n        return /*#__PURE__*/ _react.default.createElement(\"div\", {\n            className: (0, _classnames.default)(styles$6.tick, {\n                [styles$6.active]: tickIsActive\n            }),\n            key: tick.deg.toString(),\n            style: {\n                ...tick.tickStyle,\n                opacity: tickIsActive ? ACTIVE_TICK_OPACITY_MINIMUM + (1 - ACTIVE_TICK_OPACITY_MINIMUM) * ((tick.deg - startAngle) / (endAngle - startAngle)) : 1\n            }\n        });\n    }) : null), /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: styles$6.knobOuter\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: styles$6.knobInnerBackground,\n        style: knobInnerBackgroundStyle\n    }), /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: styles$6.knobInner,\n        style: knobInnerStyle\n    }, !disableGrip && /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: styles$6.grip\n    }))));\n};\nconst KNOB_VALUE_OPACITY_MINIMUM = 0.85;\n/** NOTE: Consider switching to https://react-knob-headless.vercel.app/ */ const KnobRotaryWithTicks = ({ minValue = 0, maxValue = 1, initialValue = minValue, onChange, disabled, className, value: valueProp, valueToRender, sliderProps, knobProps, onPointerDown })=>{\n    const { values, sliderMechanismProps } = useSliderMechanismState({\n        initialValue,\n        minValue,\n        maxValue,\n        onChange,\n        value: valueProp,\n        valueToRender,\n        onPointerDown\n    });\n    const progress = ((values.value || minValue) - minValue) / (maxValue - minValue);\n    const style = (0, _react.useMemo)(()=>{\n        const opacity = KNOB_VALUE_OPACITY_MINIMUM + (1 - KNOB_VALUE_OPACITY_MINIMUM) * progress;\n        const borderOpacity = 0.2 + progress * 0.05;\n        return {\n            opacity,\n            border: `1px solid rgba(255, 255, 255, ${borderOpacity})`\n        };\n    }, [\n        progress\n    ]);\n    const sliderMechanismPropsCombined = (0, _react.useMemo)(()=>{\n        return {\n            ...sliderMechanismProps,\n            disabled,\n            className: (0, _classnames.default)(styles$7.knobWrapper, className),\n            sliderProps\n        };\n    }, [\n        sliderMechanismProps,\n        className,\n        disabled,\n        sliderProps\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(SliderMechanism, {\n        ...sliderMechanismPropsCombined\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: styles$7.knobValueWrapper\n    }, /*#__PURE__*/ _react.default.createElement(Text, {\n        bold: true,\n        className: styles$7.knobValue,\n        fontSize: \"xs\",\n        style: style\n    }, values.renderedValue)), /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(styles$7.knobSkinWrapper, {\n            [styles$7.isDisabled]: disabled\n        })\n    }, /*#__PURE__*/ _react.default.createElement(KnobWithProgress, {\n        degrees: 260,\n        max: maxValue,\n        min: minValue,\n        numTicks: 20,\n        value: values.value,\n        ...knobProps\n    })));\n};\nvar styles$5 = {\n    \"line\": \"Line-module_line__Pz389\",\n    \"horizontal\": \"Line-module_horizontal__92SmS\",\n    \"vertical\": \"Line-module_vertical__ldrXe\"\n};\nconst Line = ({ orientation = \"horizontal\", className, backgroundColor })=>{\n    const style = (0, _react.useMemo)(()=>backgroundColor ? {\n            background: backgroundColor\n        } : {}, [\n        backgroundColor\n    ]);\n    const classNameCombibed = (0, _react.useMemo)(()=>(0, _classnames.default)(styles$5.line, className, {\n            [styles$5.horizontal]: orientation === \"horizontal\",\n            [styles$5.vertical]: orientation === \"vertical\"\n        }), [\n        className,\n        orientation\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(\"span\", {\n        className: classNameCombibed,\n        style: style\n    });\n};\nvar styles$4 = {\n    \"loadingSpinnerWrapper\": \"LoadingSpinner-module_loadingSpinnerWrapper__eblsX\",\n    \"fadein\": \"LoadingSpinner-module_fadein__A9Ktq\",\n    \"isAbsolute\": \"LoadingSpinner-module_isAbsolute__t3iRb\",\n    \"spanParent\": \"LoadingSpinner-module_spanParent__NIgIm\",\n    \"loadingSpinner\": \"LoadingSpinner-module_loadingSpinner__Jfwzt\"\n};\nconst LoadingSpinner = ({ size = \"6px\", className, classNameSpinner, spanParent = false, isAbsolute = false, height = \"48px\", width = \"48px\" })=>{\n    const style = {\n        \"--spinner-size\": size,\n        \"--height\": height,\n        \"--width\": width\n    };\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(styles$4.loadingSpinnerWrapper, className, {\n            [styles$4.spanParent]: spanParent,\n            [styles$4.isAbsolute]: isAbsolute\n        })\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(styles$4.loadingSpinner, classNameSpinner),\n        style: style\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", null), /*#__PURE__*/ _react.default.createElement(\"div\", null), /*#__PURE__*/ _react.default.createElement(\"div\", null), /*#__PURE__*/ _react.default.createElement(\"div\", null)));\n};\nconst useDelayedMount = ({ shouldMount = false, delayTime = 250 })=>{\n    const [shouldRender, setShouldRender] = (0, _react.useState)(false);\n    const [transitionComplete, setTransitionComplete] = (0, _react.useState)(false);\n    const timeoutRef = (0, _react.useRef)();\n    (0, _react.useEffect)(()=>{\n        if (shouldMount && !shouldRender) {\n            setShouldRender(true);\n        } else if (shouldMount && shouldRender && !transitionComplete) {\n            setTimeout(()=>setTransitionComplete(true), 0);\n        }\n    }, [\n        shouldMount,\n        shouldRender,\n        transitionComplete\n    ]);\n    (0, _react.useEffect)(()=>{\n        if (!shouldMount) {\n            setTransitionComplete(false);\n            timeoutRef.current = setTimeout(()=>setShouldRender(false), delayTime);\n        }\n        return ()=>clearTimeout(timeoutRef.current);\n    }, [\n        shouldMount,\n        delayTime,\n        shouldRender,\n        timeoutRef\n    ]);\n    return {\n        shouldRender,\n        transitionComplete\n    };\n};\nconst Context = /*#__PURE__*/ (0, _react.createContext)({\n    openModalZIndexes: [],\n    openModal: (_)=>_,\n    closeModal: (_)=>_\n});\nconst { Provider, Consumer } = Context;\nvar Symbol$1 = _Symbol, isArguments = isArguments_1, isArray$2 = isArray_1;\n/** Built-in value references. */ var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */ function isFlattenable$1(value) {\n    return isArray$2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\nvar _isFlattenable = isFlattenable$1;\nvar arrayPush$1 = _arrayPush, isFlattenable = _isFlattenable;\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */ function baseFlatten$2(array, depth, predicate, isStrict, result) {\n    var index = -1, length = array.length;\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n    while(++index < length){\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n            if (depth > 1) {\n                // Recursively flatten arrays (susceptible to call stack limits).\n                baseFlatten$2(value, depth - 1, predicate, isStrict, result);\n            } else {\n                arrayPush$1(result, value);\n            }\n        } else if (!isStrict) {\n            result[result.length] = value;\n        }\n    }\n    return result;\n}\nvar _baseFlatten = baseFlatten$2;\nvar isArrayLike$3 = isArrayLike_1;\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */ function createBaseEach$1(eachFunc, fromRight) {\n    return function(collection, iteratee) {\n        if (collection == null) {\n            return collection;\n        }\n        if (!isArrayLike$3(collection)) {\n            return eachFunc(collection, iteratee);\n        }\n        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);\n        while(fromRight ? index-- : ++index < length){\n            if (iteratee(iterable[index], index, iterable) === false) {\n                break;\n            }\n        }\n        return collection;\n    };\n}\nvar _createBaseEach = createBaseEach$1;\nvar baseForOwn = _baseForOwn, createBaseEach = _createBaseEach;\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */ var baseEach$1 = createBaseEach(baseForOwn);\nvar _baseEach = baseEach$1;\nvar baseEach = _baseEach, isArrayLike$2 = isArrayLike_1;\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */ function baseMap$1(collection, iteratee) {\n    var index = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];\n    baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n    });\n    return result;\n}\nvar _baseMap = baseMap$1;\n/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */ function baseSortBy$1(array, comparer) {\n    var length = array.length;\n    array.sort(comparer);\n    while(length--){\n        array[length] = array[length].value;\n    }\n    return array;\n}\nvar _baseSortBy = baseSortBy$1;\nvar isSymbol = isSymbol_1;\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */ function compareAscending$1(value, other) {\n    if (value !== other) {\n        var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);\n        var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);\n        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\n            return 1;\n        }\n        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\n            return -1;\n        }\n    }\n    return 0;\n}\nvar _compareAscending = compareAscending$1;\nvar compareAscending = _compareAscending;\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */ function compareMultiple$1(object, other, orders) {\n    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;\n    while(++index < length){\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n            if (index >= ordersLength) {\n                return result;\n            }\n            var order = orders[index];\n            return result * (order == \"desc\" ? -1 : 1);\n        }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value for\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    // for more details.\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n    return object.index - other.index;\n}\nvar _compareMultiple = compareMultiple$1;\nvar arrayMap$1 = _arrayMap, baseGet$1 = _baseGet, baseIteratee$1 = _baseIteratee, baseMap = _baseMap, baseSortBy = _baseSortBy, baseUnary$2 = _baseUnary, compareMultiple = _compareMultiple, identity$2 = identity_1, isArray$1 = isArray_1;\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */ function baseOrderBy$1(collection, iteratees, orders) {\n    if (iteratees.length) {\n        iteratees = arrayMap$1(iteratees, function(iteratee) {\n            if (isArray$1(iteratee)) {\n                return function(value) {\n                    return baseGet$1(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n                };\n            }\n            return iteratee;\n        });\n    } else {\n        iteratees = [\n            identity$2\n        ];\n    }\n    var index = -1;\n    iteratees = arrayMap$1(iteratees, baseUnary$2(baseIteratee$1));\n    var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap$1(iteratees, function(iteratee) {\n            return iteratee(value);\n        });\n        return {\n            \"criteria\": criteria,\n            \"index\": ++index,\n            \"value\": value\n        };\n    });\n    return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n    });\n}\nvar _baseOrderBy = baseOrderBy$1;\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */ function apply$1(func, thisArg, args) {\n    switch(args.length){\n        case 0:\n            return func.call(thisArg);\n        case 1:\n            return func.call(thisArg, args[0]);\n        case 2:\n            return func.call(thisArg, args[0], args[1]);\n        case 3:\n            return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n}\nvar _apply = apply$1;\nvar apply = _apply;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */ function overRest$2(func, start, transform) {\n    start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n    return function() {\n        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);\n        while(++index < length){\n            array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while(++index < start){\n            otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n    };\n}\nvar _overRest = overRest$2;\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */ function constant$1(value) {\n    return function() {\n        return value;\n    };\n}\nvar constant_1 = constant$1;\nvar constant = constant_1, defineProperty = _defineProperty, identity$1 = identity_1;\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */ var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {\n    return defineProperty(func, \"toString\", {\n        \"configurable\": true,\n        \"enumerable\": false,\n        \"value\": constant(string),\n        \"writable\": true\n    });\n};\nvar _baseSetToString = baseSetToString$1;\n/** Used to detect hot functions by number of calls within a span of milliseconds. */ var HOT_COUNT = 800, HOT_SPAN = 16;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeNow = Date.now;\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */ function shortOut$1(func) {\n    var count = 0, lastCalled = 0;\n    return function() {\n        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n        lastCalled = stamp;\n        if (remaining > 0) {\n            if (++count >= HOT_COUNT) {\n                return arguments[0];\n            }\n        } else {\n            count = 0;\n        }\n        return func.apply(undefined, arguments);\n    };\n}\nvar _shortOut = shortOut$1;\nvar baseSetToString = _baseSetToString, shortOut = _shortOut;\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */ var setToString$2 = shortOut(baseSetToString);\nvar _setToString = setToString$2;\nvar identity = identity_1, overRest$1 = _overRest, setToString$1 = _setToString;\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */ function baseRest$1(func, start) {\n    return setToString$1(overRest$1(func, start, identity), func + \"\");\n}\nvar _baseRest = baseRest$1;\nvar eq$1 = eq_1, isArrayLike$1 = isArrayLike_1, isIndex = _isIndex, isObject$3 = isObject_1;\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */ function isIterateeCall$1(value, index, object) {\n    if (!isObject$3(object)) {\n        return false;\n    }\n    var type = typeof index;\n    if (type == \"number\" ? isArrayLike$1(object) && isIndex(index, object.length) : type == \"string\" && index in object) {\n        return eq$1(object[index], value);\n    }\n    return false;\n}\nvar _isIterateeCall = isIterateeCall$1;\nvar baseFlatten$1 = _baseFlatten, baseOrderBy = _baseOrderBy, baseRest = _baseRest, isIterateeCall = _isIterateeCall;\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 30 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n */ var sortBy = baseRest(function(collection, iteratees) {\n    if (collection == null) {\n        return [];\n    }\n    var length = iteratees.length;\n    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [\n            iteratees[0]\n        ];\n    }\n    return baseOrderBy(collection, baseFlatten$1(iteratees, 1), []);\n});\nvar sortBy_1 = sortBy;\nvar sortBy$1 = /*@__PURE__*/ getDefaultExportFromCjs(sortBy_1);\nconst DEFAULT_Z_INDEX = 100;\nconst ModalProvider = ({ children })=>{\n    const [openModalZIndexes, setOpenModalZIndexes] = (0, _react.useState)([]);\n    const openModal = (0, _react.useCallback)(({ id, zIndex })=>setOpenModalZIndexes((oldOpenModalZIndexes)=>{\n            const newOpenModalZIndexes = sortBy$1([\n                ...oldOpenModalZIndexes,\n                {\n                    id,\n                    zIndex\n                }\n            ], ({ zIndex: z = DEFAULT_Z_INDEX })=>-z);\n            /** Enable any css filters to the app content here if needed */ return newOpenModalZIndexes;\n        }), []);\n    const closeModal = (0, _react.useCallback)(({ id })=>{\n        setOpenModalZIndexes((oldOpenModalZIndexes)=>{\n            const newOpenModalZIndexes = oldOpenModalZIndexes.filter(({ id: idInArray })=>idInArray !== id);\n            if (!newOpenModalZIndexes.length) ;\n            return newOpenModalZIndexes;\n        });\n    }, []);\n    const value = (0, _react.useMemo)(()=>({\n            openModal,\n            closeModal,\n            openModalZIndexes\n        }), [\n        openModal,\n        closeModal,\n        openModalZIndexes\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(Provider, {\n        value: value\n    }, children);\n};\nconst useModalState = ()=>{\n    const value = (0, _react.useContext)(Context);\n    return value;\n};\nvar styles$3 = {\n    \"modal\": \"styles-module_modal__pKmlX\",\n    \"isOpen\": \"styles-module_isOpen__WonH8\"\n};\nconst MODAL_DEFAULT_Z_INDEX = 50;\nconst Modal = ({ open, children, onClick, onBlur, id, zIndex = MODAL_DEFAULT_Z_INDEX, className, modalRootElementId, delayTime = 350, disableAnimations })=>{\n    const { isMountedClient } = useClientMountedState();\n    const { openModal, closeModal, openModalZIndexes } = useModalState();\n    const { shouldRender, transitionComplete } = useDelayedMount({\n        shouldMount: open,\n        delayTime\n    });\n    const isUnderAnotherModal = openModalZIndexes[0]?.id !== id;\n    (0, _react.useEffect)(()=>{\n        if (open) {\n            openModal({\n                id,\n                zIndex\n            });\n        }\n        return ()=>{\n            if (open) {\n                closeModal({\n                    id\n                });\n            }\n        };\n    }, [\n        open,\n        id,\n        zIndex,\n        openModal,\n        closeModal\n    ]);\n    const style = (0, _react.useMemo)(()=>({\n            zIndex\n        }), [\n        zIndex\n    ]);\n    return (disableAnimations ? isMountedClient : shouldRender) && /*#__PURE__*/ (0, _reactdom.createPortal)(/*#__PURE__*/ _react.default.createElement(\"div\", {\n        className: (0, _classnames.default)(styles$3.modal, className, {\n            [styles$3.underAnotherModal]: isUnderAnotherModal,\n            [styles$3.isOpen]: disableAnimations ? open : transitionComplete\n        }),\n        id: id,\n        onBlur: onBlur,\n        onClick: onClick,\n        onKeyDown: (_)=>_,\n        role: \"button\",\n        style: style,\n        tabIndex: 0\n    }, children), modalRootElementId ? document.getElementById(modalRootElementId) || document.body : document.body);\n};\nvar styles$2 = {\n    \"pill\": \"Pill-module_pill__afGqD\",\n    \"base\": \"Pill-module_base__AtmrT\",\n    \"light\": \"Pill-module_light__ycSPx\",\n    \"inverse\": \"Pill-module_inverse__1Svri\",\n    \"primary\": \"Pill-module_primary__-h-P9\"\n};\nconst Pill = ({ children, className, variant = \"base\", ...props })=>{\n    return /*#__PURE__*/ _react.default.createElement(\"div\", {\n        ...props,\n        className: (0, _classnames.default)(styles$2.pill, className, {\n            [styles$2.base]: variant?.includes(\"base\"),\n            [styles$2.light]: variant?.includes(\"light\"),\n            [styles$2.inverse]: variant?.includes(\"inverse\"),\n            [styles$2.primary]: variant?.includes(\"primary\")\n        })\n    }, children);\n};\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */ function baseFindIndex$1(array, predicate, fromIndex, fromRight) {\n    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);\n    while(fromRight ? index-- : ++index < length){\n        if (predicate(array[index], index, array)) {\n            return index;\n        }\n    }\n    return -1;\n}\nvar _baseFindIndex = baseFindIndex$1;\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */ function baseIsNaN$1(value) {\n    return value !== value;\n}\nvar _baseIsNaN = baseIsNaN$1;\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */ function strictIndexOf$1(array, value, fromIndex) {\n    var index = fromIndex - 1, length = array.length;\n    while(++index < length){\n        if (array[index] === value) {\n            return index;\n        }\n    }\n    return -1;\n}\nvar _strictIndexOf = strictIndexOf$1;\nvar baseFindIndex = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */ function baseIndexOf$1(array, value, fromIndex) {\n    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);\n}\nvar _baseIndexOf = baseIndexOf$1;\nvar baseIndexOf = _baseIndexOf;\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */ function arrayIncludes$1(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n}\nvar _arrayIncludes = arrayIncludes$1;\n/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */ function arrayIncludesWith$1(array, value, comparator) {\n    var index = -1, length = array == null ? 0 : array.length;\n    while(++index < length){\n        if (comparator(value, array[index])) {\n            return true;\n        }\n    }\n    return false;\n}\nvar _arrayIncludesWith = arrayIncludesWith$1;\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */ function noop$1() {\n// No operation performed.\n}\nvar noop_1 = noop$1;\nvar Set$1 = _Set, noop = noop_1, setToArray$1 = _setToArray;\n/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */ var createSet$1 = !(Set$1 && 1 / setToArray$1(new Set$1([\n    ,\n    -0\n]))[1] == INFINITY) ? noop : function(values) {\n    return new Set$1(values);\n};\nvar _createSet = createSet$1;\nvar SetCache = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas = _cacheHas, createSet = _createSet, setToArray = _setToArray;\n/** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */ function baseUniq$1(array, iteratee, comparator) {\n    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;\n    if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n    } else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n            return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n    } else {\n        seen = iteratee ? [] : result;\n    }\n    outer: while(++index < length){\n        var value = array[index], computed = iteratee ? iteratee(value) : value;\n        value = comparator || value !== 0 ? value : 0;\n        if (isCommon && computed === computed) {\n            var seenIndex = seen.length;\n            while(seenIndex--){\n                if (seen[seenIndex] === computed) {\n                    continue outer;\n                }\n            }\n            if (iteratee) {\n                seen.push(computed);\n            }\n            result.push(value);\n        } else if (!includes(seen, computed, comparator)) {\n            if (seen !== result) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n    }\n    return result;\n}\nvar _baseUniq = baseUniq$1;\nvar baseIteratee = _baseIteratee, baseUniq = _baseUniq;\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */ function uniqBy(array, iteratee) {\n    return array && array.length ? baseUniq(array, baseIteratee(iteratee)) : [];\n}\nvar uniqBy_1 = uniqBy;\nvar uniqBy$1 = /*@__PURE__*/ getDefaultExportFromCjs(uniqBy_1);\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */ function arrayEach$1(array, iteratee) {\n    var index = -1, length = array == null ? 0 : array.length;\n    while(++index < length){\n        if (iteratee(array[index], index, array) === false) {\n            break;\n        }\n    }\n    return array;\n}\nvar _arrayEach = arrayEach$1;\nvar baseAssignValue$1 = _baseAssignValue, eq = eq_1;\n/** Used for built-in method references. */ var objectProto$3 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function assignValue$2(object, key, value) {\n    var objValue = object[key];\n    if (!(hasOwnProperty$3.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n        baseAssignValue$1(object, key, value);\n    }\n}\nvar _assignValue = assignValue$2;\nvar assignValue$1 = _assignValue, baseAssignValue = _baseAssignValue;\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */ function copyObject$5(source, props, object, customizer) {\n    var isNew = !object;\n    object || (object = {});\n    var index = -1, length = props.length;\n    while(++index < length){\n        var key = props[index];\n        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;\n        if (newValue === undefined) {\n            newValue = source[key];\n        }\n        if (isNew) {\n            baseAssignValue(object, key, newValue);\n        } else {\n            assignValue$1(object, key, newValue);\n        }\n    }\n    return object;\n}\nvar _copyObject = copyObject$5;\nvar copyObject$4 = _copyObject, keys$1 = keys_1;\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */ function baseAssign$1(object, source) {\n    return object && copyObject$4(source, keys$1(source), object);\n}\nvar _baseAssign = baseAssign$1;\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function nativeKeysIn$1(object) {\n    var result = [];\n    if (object != null) {\n        for(var key in Object(object)){\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _nativeKeysIn = nativeKeysIn$1;\nvar isObject$2 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;\n/** Used for built-in method references. */ var objectProto$2 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function baseKeysIn$1(object) {\n    if (!isObject$2(object)) {\n        return nativeKeysIn(object);\n    }\n    var isProto = isPrototype$1(object), result = [];\n    for(var key in object){\n        if (!(key == \"constructor\" && (isProto || !hasOwnProperty$2.call(object, key)))) {\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _baseKeysIn = baseKeysIn$1;\nvar arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike = isArrayLike_1;\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */ function keysIn$3(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\nvar keysIn_1 = keysIn$3;\nvar copyObject$3 = _copyObject, keysIn$2 = keysIn_1;\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */ function baseAssignIn$1(object, source) {\n    return object && copyObject$3(source, keysIn$2(source), object);\n}\nvar _baseAssignIn = baseAssignIn$1;\nvar _cloneBuffer = {\n    exports: {}\n};\n_cloneBuffer.exports;\n(function(module, exports1) {\n    var root = _root;\n    /** Detect free variable `exports`. */ var freeExports = exports1 && !exports1.nodeType && exports1;\n    /** Detect free variable `module`. */ var freeModule = freeExports && \"object\" == \"object\" && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n    /**\n\t * Creates a clone of  `buffer`.\n\t *\n\t * @private\n\t * @param {Buffer} buffer The buffer to clone.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Buffer} Returns the cloned buffer.\n\t */ function cloneBuffer(buffer, isDeep) {\n        if (isDeep) {\n            return buffer.slice();\n        }\n        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n        buffer.copy(result);\n        return result;\n    }\n    module.exports = cloneBuffer;\n})(_cloneBuffer, _cloneBuffer.exports);\nvar _cloneBufferExports = _cloneBuffer.exports;\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */ function copyArray$1(source, array) {\n    var index = -1, length = source.length;\n    array || (array = Array(length));\n    while(++index < length){\n        array[index] = source[index];\n    }\n    return array;\n}\nvar _copyArray = copyArray$1;\nvar copyObject$2 = _copyObject, getSymbols$1 = _getSymbols;\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */ function copySymbols$1(source, object) {\n    return copyObject$2(source, getSymbols$1(source), object);\n}\nvar _copySymbols = copySymbols$1;\nvar overArg = _overArg;\n/** Built-in value references. */ var getPrototype$3 = overArg(Object.getPrototypeOf, Object);\nvar _getPrototype = getPrototype$3;\nvar arrayPush = _arrayPush, getPrototype$2 = _getPrototype, getSymbols = _getSymbols, stubArray = stubArray_1;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols;\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */ var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {\n    var result = [];\n    while(object){\n        arrayPush(result, getSymbols(object));\n        object = getPrototype$2(object);\n    }\n    return result;\n};\nvar _getSymbolsIn = getSymbolsIn$2;\nvar copyObject$1 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */ function copySymbolsIn$1(source, object) {\n    return copyObject$1(source, getSymbolsIn$1(source), object);\n}\nvar _copySymbolsIn = copySymbolsIn$1;\nvar baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */ function getAllKeysIn$2(object) {\n    return baseGetAllKeys(object, keysIn$1, getSymbolsIn);\n}\nvar _getAllKeysIn = getAllKeysIn$2;\n/** Used for built-in method references. */ var objectProto$1 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */ function initCloneArray$1(array) {\n    var length = array.length, result = new array.constructor(length);\n    // Add properties assigned by `RegExp#exec`.\n    if (length && typeof array[0] == \"string\" && hasOwnProperty$1.call(array, \"index\")) {\n        result.index = array.index;\n        result.input = array.input;\n    }\n    return result;\n}\nvar _initCloneArray = initCloneArray$1;\nvar Uint8Array = _Uint8Array;\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */ function cloneArrayBuffer$3(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n    return result;\n}\nvar _cloneArrayBuffer = cloneArrayBuffer$3;\nvar cloneArrayBuffer$2 = _cloneArrayBuffer;\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */ function cloneDataView$1(dataView, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\nvar _cloneDataView = cloneDataView$1;\n/** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\\w*$/;\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */ function cloneRegExp$1(regexp) {\n    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n    result.lastIndex = regexp.lastIndex;\n    return result;\n}\nvar _cloneRegExp = cloneRegExp$1;\nvar Symbol = _Symbol;\n/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */ function cloneSymbol$1(symbol) {\n    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\nvar _cloneSymbol = cloneSymbol$1;\nvar cloneArrayBuffer$1 = _cloneArrayBuffer;\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */ function cloneTypedArray$1(typedArray, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\nvar _cloneTypedArray = cloneTypedArray$1;\nvar cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;\n/** `Object#toString` result references. */ var boolTag$1 = \"[object Boolean]\", dateTag$1 = \"[object Date]\", mapTag$2 = \"[object Map]\", numberTag$1 = \"[object Number]\", regexpTag$1 = \"[object RegExp]\", setTag$2 = \"[object Set]\", stringTag$1 = \"[object String]\", symbolTag$1 = \"[object Symbol]\";\nvar arrayBufferTag$1 = \"[object ArrayBuffer]\", dataViewTag$1 = \"[object DataView]\", float32Tag$1 = \"[object Float32Array]\", float64Tag$1 = \"[object Float64Array]\", int8Tag$1 = \"[object Int8Array]\", int16Tag$1 = \"[object Int16Array]\", int32Tag$1 = \"[object Int32Array]\", uint8Tag$1 = \"[object Uint8Array]\", uint8ClampedTag$1 = \"[object Uint8ClampedArray]\", uint16Tag$1 = \"[object Uint16Array]\", uint32Tag$1 = \"[object Uint32Array]\";\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */ function initCloneByTag$1(object, tag, isDeep) {\n    var Ctor = object.constructor;\n    switch(tag){\n        case arrayBufferTag$1:\n            return cloneArrayBuffer(object);\n        case boolTag$1:\n        case dateTag$1:\n            return new Ctor(+object);\n        case dataViewTag$1:\n            return cloneDataView(object, isDeep);\n        case float32Tag$1:\n        case float64Tag$1:\n        case int8Tag$1:\n        case int16Tag$1:\n        case int32Tag$1:\n        case uint8Tag$1:\n        case uint8ClampedTag$1:\n        case uint16Tag$1:\n        case uint32Tag$1:\n            return cloneTypedArray(object, isDeep);\n        case mapTag$2:\n            return new Ctor;\n        case numberTag$1:\n        case stringTag$1:\n            return new Ctor(object);\n        case regexpTag$1:\n            return cloneRegExp(object);\n        case setTag$2:\n            return new Ctor;\n        case symbolTag$1:\n            return cloneSymbol(object);\n    }\n}\nvar _initCloneByTag = initCloneByTag$1;\nvar isObject$1 = isObject_1;\n/** Built-in value references. */ var objectCreate = Object.create;\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */ var baseCreate$1 = function() {\n    function object() {}\n    return function(proto) {\n        if (!isObject$1(proto)) {\n            return {};\n        }\n        if (objectCreate) {\n            return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n    };\n}();\nvar _baseCreate = baseCreate$1;\nvar baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype = _isPrototype;\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */ function initCloneObject$1(object) {\n    return typeof object.constructor == \"function\" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};\n}\nvar _initCloneObject = initCloneObject$1;\nvar getTag$2 = _getTag, isObjectLike$2 = isObjectLike_1;\n/** `Object#toString` result references. */ var mapTag$1 = \"[object Map]\";\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */ function baseIsMap$1(value) {\n    return isObjectLike$2(value) && getTag$2(value) == mapTag$1;\n}\nvar _baseIsMap = baseIsMap$1;\nvar baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtilExports;\n/* Node.js helper references. */ var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */ var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;\nvar isMap_1 = isMap$1;\nvar getTag$1 = _getTag, isObjectLike$1 = isObjectLike_1;\n/** `Object#toString` result references. */ var setTag$1 = \"[object Set]\";\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */ function baseIsSet$1(value) {\n    return isObjectLike$1(value) && getTag$1(value) == setTag$1;\n}\nvar _baseIsSet = baseIsSet$1;\nvar baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;\n/* Node.js helper references. */ var nodeIsSet = nodeUtil && nodeUtil.isSet;\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */ var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\nvar isSet_1 = isSet$1;\nvar Stack = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBufferExports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn$1 = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray = isArray_1, isBuffer = isBufferExports, isMap = isMap_1, isObject = isObject_1, isSet = isSet_1, keys = keys_1, keysIn = keysIn_1;\n/** Used to compose bitmasks for cloning. */ var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$1 = 4;\n/** `Object#toString` result references. */ var argsTag = \"[object Arguments]\", arrayTag = \"[object Array]\", boolTag = \"[object Boolean]\", dateTag = \"[object Date]\", errorTag = \"[object Error]\", funcTag = \"[object Function]\", genTag = \"[object GeneratorFunction]\", mapTag = \"[object Map]\", numberTag = \"[object Number]\", objectTag$1 = \"[object Object]\", regexpTag = \"[object RegExp]\", setTag = \"[object Set]\", stringTag = \"[object String]\", symbolTag = \"[object Symbol]\", weakMapTag = \"[object WeakMap]\";\nvar arrayBufferTag = \"[object ArrayBuffer]\", dataViewTag = \"[object DataView]\", float32Tag = \"[object Float32Array]\", float64Tag = \"[object Float64Array]\", int8Tag = \"[object Int8Array]\", int16Tag = \"[object Int16Array]\", int32Tag = \"[object Int32Array]\", uint8Tag = \"[object Uint8Array]\", uint8ClampedTag = \"[object Uint8ClampedArray]\", uint16Tag = \"[object Uint16Array]\", uint32Tag = \"[object Uint32Array]\";\n/** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag$1] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */ function baseClone$1(value, bitmask, customizer, key, object, stack) {\n    var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;\n    if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n    }\n    if (result !== undefined) {\n        return result;\n    }\n    if (!isObject(value)) {\n        return value;\n    }\n    var isArr = isArray(value);\n    if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n            return copyArray(value, result);\n        }\n    } else {\n        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;\n        if (isBuffer(value)) {\n            return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag$1 || tag == argsTag || isFunc && !object) {\n            result = isFlat || isFunc ? {} : initCloneObject(value);\n            if (!isDeep) {\n                return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));\n            }\n        } else {\n            if (!cloneableTags[tag]) {\n                return object ? value : {};\n            }\n            result = initCloneByTag(value, tag, isDeep);\n        }\n    }\n    // Check for circular references and return its corresponding clone.\n    stack || (stack = new Stack);\n    var stacked = stack.get(value);\n    if (stacked) {\n        return stacked;\n    }\n    stack.set(value, result);\n    if (isSet(value)) {\n        value.forEach(function(subValue) {\n            result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));\n        });\n    } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n            result.set(key, baseClone$1(subValue, bitmask, customizer, key, value, stack));\n        });\n    }\n    var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn : keys;\n    var props = isArr ? undefined : keysFunc(value);\n    arrayEach(props || value, function(subValue, key) {\n        if (props) {\n            key = subValue;\n            subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone$1(subValue, bitmask, customizer, key, value, stack));\n    });\n    return result;\n}\nvar _baseClone = baseClone$1;\n/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */ function last$1(array) {\n    var length = array == null ? 0 : array.length;\n    return length ? array[length - 1] : undefined;\n}\nvar last_1 = last$1;\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */ function baseSlice$1(array, start, end) {\n    var index = -1, length = array.length;\n    if (start < 0) {\n        start = -start > length ? 0 : length + start;\n    }\n    end = end > length ? length : end;\n    if (end < 0) {\n        end += length;\n    }\n    length = start > end ? 0 : end - start >>> 0;\n    start >>>= 0;\n    var result = Array(length);\n    while(++index < length){\n        result[index] = array[index + start];\n    }\n    return result;\n}\nvar _baseSlice = baseSlice$1;\nvar baseGet = _baseGet, baseSlice = _baseSlice;\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */ function parent$1(object, path) {\n    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\nvar _parent = parent$1;\nvar castPath$1 = _castPath, last = last_1, parent = _parent, toKey = _toKey;\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The property path to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */ function baseUnset$1(object, path) {\n    path = castPath$1(path, object);\n    object = parent(object, path);\n    return object == null || delete object[toKey(last(path))];\n}\nvar _baseUnset = baseUnset$1;\nvar baseGetTag = _baseGetTag, getPrototype = _getPrototype, isObjectLike = isObjectLike_1;\n/** `Object#toString` result references. */ var objectTag = \"[object Object]\";\n/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;\n/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n/** Used to infer the `Object` constructor. */ var objectCtorString = funcToString.call(Object);\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */ function isPlainObject$1(value) {\n    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n    }\n    var proto = getPrototype(value);\n    if (proto === null) {\n        return true;\n    }\n    var Ctor = hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n    return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n}\nvar isPlainObject_1 = isPlainObject$1;\nvar isPlainObject = isPlainObject_1;\n/**\n * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n * objects.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {string} key The key of the property to inspect.\n * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n */ function customOmitClone$1(value) {\n    return isPlainObject(value) ? undefined : value;\n}\nvar _customOmitClone = customOmitClone$1;\nvar baseFlatten = _baseFlatten;\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */ function flatten$1(array) {\n    var length = array == null ? 0 : array.length;\n    return length ? baseFlatten(array, 1) : [];\n}\nvar flatten_1 = flatten$1;\nvar flatten = flatten_1, overRest = _overRest, setToString = _setToString;\n/**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */ function flatRest$1(func) {\n    return setToString(overRest(func, undefined, flatten), func + \"\");\n}\nvar _flatRest = flatRest$1;\nvar arrayMap = _arrayMap, baseClone = _baseClone, baseUnset = _baseUnset, castPath = _castPath, copyObject = _copyObject, customOmitClone = _customOmitClone, flatRest = _flatRest, getAllKeysIn = _getAllKeysIn;\n/** Used to compose bitmasks for cloning. */ var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;\n/**\n * The opposite of `_.pick`; this method creates an object composed of the\n * own and inherited enumerable property paths of `object` that are not omitted.\n *\n * **Note:** This method is considerably slower than `_.pick`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to omit.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omit(object, ['a', 'c']);\n * // => { 'b': '2' }\n */ var omit = flatRest(function(object, paths) {\n    var result = {};\n    if (object == null) {\n        return result;\n    }\n    var isDeep = false;\n    paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n    });\n    copyObject(object, getAllKeysIn(object), result);\n    if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n    }\n    var length = paths.length;\n    while(length--){\n        baseUnset(result, paths[length]);\n    }\n    return result;\n});\nvar omit_1 = omit;\nvar omit$1 = /*@__PURE__*/ getDefaultExportFromCjs(omit_1);\nconst useDynamicRefs = (params)=>{\n    const ids = \"ids\" in params ? params.ids : [\n        ...Array(params.count)\n    ].map((_v, i)=>i.toString());\n    // Manually construct the dynamicRefs object with a strict type\n    const dynamicRefs = (0, _react.useRef)(ids.reduce((acc, id)=>{\n        acc[id] = /*#__PURE__*/ (0, _react.createRef)();\n        return acc;\n    }, {}));\n    // getRef returns the .current property of the ref for the given id\n    const getRef = (0, _react.useCallback)((id)=>dynamicRefs.current[id]?.current ?? null, []);\n    // setRef returns the RefObject itself so it can be assigned directly\n    const setRef = (0, _react.useCallback)((id)=>dynamicRefs.current[id], []);\n    return [\n        getRef,\n        setRef\n    ];\n};\nvar styles$1 = {\n    \"indicatorContainer\": \"Select-module_indicatorContainer__Bexwq\",\n    \"clearIndicator\": \"Select-module_clearIndicator__mAv-8\",\n    \"hide\": \"Select-module_hide__hcymn\",\n    \"dropdownIndicator\": \"Select-module_dropdownIndicator__s0wnm\",\n    \"isOpen\": \"Select-module_isOpen__7sz2l\",\n    \"isDisabled\": \"Select-module_isDisabled__27gU1\",\n    \"input\": \"Select-module_input__eVcsu\",\n    \"inputTypeIsText\": \"Select-module_inputTypeIsText__Lhdpa\",\n    \"loadingIndicator\": \"Select-module_loadingIndicator__oCBdR\",\n    \"multiValue\": \"Select-module_multiValue__FvpPn\",\n    \"multiValueRemove\": \"Select-module_multiValueRemove__VYwhK\",\n    \"noOptionsMessage\": \"Select-module_noOptionsMessage__O7jlZ\",\n    \"placeholder\": \"Select-module_placeholder__EQ1R2\",\n    \"valueContainer\": \"Select-module_valueContainer__AuO49\",\n    \"allowMultiSelectedOptionsHeightToExpand\": \"Select-module_allowMultiSelectedOptionsHeightToExpand__oww3U\",\n    \"isScrollable\": \"Select-module_isScrollable__L2lPl\",\n    \"menu\": \"Select-module_menu__0LCSf\",\n    \"menuList\": \"Select-module_menuList__XsuJc\",\n    \"option\": \"Select-module_option__dx419\",\n    \"isFocused\": \"Select-module_isFocused__RUXnq\",\n    \"isSelected\": \"Select-module_isSelected__QXJIY\",\n    \"wrapper\": \"Select-module_wrapper__uQULS\",\n    \"isGroupMode\": \"Select-module_isGroupMode__hsGWj\",\n    \"groupsDropDown\": \"Select-module_groupsDropDown__eOCmC\",\n    \"groupWrapper\": \"Select-module_groupWrapper__bjZ7J\",\n    \"group\": \"Select-module_group__7Uofz\",\n    \"isEmpty\": \"Select-module_isEmpty__fzMK-\",\n    \"label\": \"Select-module_label__0IzJB\",\n    \"containerItemsGroup\": \"Select-module_containerItemsGroup__QzPPG\",\n    \"control\": \"Select-module_control__25bF2\",\n    \"isHidden\": \"Select-module_isHidden__KD3Oj\",\n    \"groupsDropDownContents\": \"Select-module_groupsDropDownContents__ayXEM\",\n    \"isMultiSelect\": \"Select-module_isMultiSelect__i5lUl\",\n    \"disableInputHeight\": \"Select-module_disableInputHeight__pbs--\",\n    \"container\": \"Select-module_container__khC3Y\",\n    \"hideTextBlinker\": \"Select-module_hideTextBlinker__6PKXP\",\n    \"optionTooltip\": \"Select-module_optionTooltip__Iafd1\",\n    \"valueContainerTooltip\": \"Select-module_valueContainerTooltip__kl5a4\",\n    \"labelContainer\": \"Select-module_labelContainer__mvmMR\",\n    \"compact\": \"Select-module_compact__1qXd-\",\n    \"labelHelp\": \"Select-module_labelHelp__BMFo7\",\n    \"optionSpan\": \"Select-module_optionSpan__Lr2iX\",\n    \"optionSpanContent\": \"Select-module_optionSpanContent__SR4dp\",\n    \"fullWidth\": \"Select-module_fullWidth__vxPfm\",\n    \"optionHelpTooltip\": \"Select-module_optionHelpTooltip__gk3MF\"\n};\nconst DELAY_FOR_CLOSING_DROP_DOWN = 250;\nconst DEFAULT_FILTER = (0, _reactselect.createFilter)();\nconst createOptionKey = ({ groupId, value })=>groupId ? (0, _libutilities.createCustomKeyFromObject)({\n        groupId,\n        value\n    }) : (0, _libutilities.createCustomKeyFromObject)({\n        value\n    });\nconst VALID_ACTIONS_FOR_CALLING_INPUT_CHANGE = [\n    \"input-change\",\n    \"set-value\"\n];\nconst MenuListGrouped = ({ children, className, ...props })=>{\n    const { id, groupId, onRenderedItemsChange, groupLabel, allGroupsEmpty, forceEmptyMessage, isSearchOnly, maxOptions, classNames: classNamesProp } = props.selectProps;\n    let render = Array.isArray(children) ? children.slice(0, maxOptions) : [\n        children\n    ];\n    if (isSearchOnly) {\n        render = [];\n    }\n    const valuesRendered = (isArray$d(render) ? render : []).flatMap((child)=>child?.props?.data?.value || []);\n    const count = valuesRendered.length;\n    const isEmpty = !count;\n    (0, _react.useEffect)(()=>{\n        onRenderedItemsChange?.({\n            groupId,\n            values: valuesRendered.length ? valuesRendered : null,\n            count\n        });\n    }, [\n        count,\n        groupId,\n        onRenderedItemsChange,\n        valuesRendered\n    ]);\n    const renderNothing = allGroupsEmpty ? !forceEmptyMessage : false;\n    const renderEmptyMessage = allGroupsEmpty ? forceEmptyMessage : false;\n    if (renderNothing) {\n        return null;\n    }\n    return /*#__PURE__*/ _react.default.createElement(Flex, {\n        className: (0, _classnames.default)(styles$1.group, classNamesProp?.group?.({}), {\n            [styles$1.isEmpty]: isEmpty\n        }),\n        isColumn: true,\n        key: id\n    }, !renderEmptyMessage && !!groupLabel && !isEmpty && /*#__PURE__*/ _react.default.createElement(Text, {\n        className: (0, _classnames.default)(styles$1.label, classNamesProp?.groupLabel?.({}))\n    }, groupLabel), /*#__PURE__*/ _react.default.createElement(_reactselect.components.MenuList, {\n        className: (0, _classnames.default)(styles$1.className, className, styles$1.menuListComponent, {\n            [styles$1.forceScrollBars]: false\n        }),\n        ...props\n    }, render));\n};\nconst Option = ({ children, ...props })=>{\n    const { label, value } = props.data;\n    const { keepOptionTooltipOpenOnHover = false } = props.selectProps;\n    const content = (0, _react.useMemo)(()=>{\n        const { getOptionTooltip } = props.selectProps;\n        return getOptionTooltip?.({\n            label,\n            value\n        });\n    }, [\n        props.selectProps,\n        label,\n        value\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(TooltipSimple, {\n        className: styles$1.optionTooltip,\n        content: content,\n        delay: 750,\n        disable: !content,\n        keepTooltipOpenOnHover: keepOptionTooltipOpenOnHover\n    }, /*#__PURE__*/ _react.default.createElement(_reactselect.components.Option, {\n        ...props\n    }, /*#__PURE__*/ _react.default.createElement(\"span\", {\n        className: styles$1.optionSpan,\n        title: typeof children === \"string\" ? children : undefined\n    }, /*#__PURE__*/ _react.default.createElement(\"span\", {\n        className: (0, _classnames.default)(styles$1.optionSpanContent, {\n            [styles$1.fullWidth]: !content\n        })\n    }, children), !!content && /*#__PURE__*/ _react.default.createElement(TooltipHelpIcon, {\n        className: styles$1.optionHelpTooltip\n    }))));\n};\nconst ValueContainer = ({ children, ...props })=>{\n    const { selectProps } = props;\n    const { value, isMulti, displayTooltipForSelectedItem, getOptionTooltip } = selectProps;\n    const content = (0, _react.useMemo)(()=>{\n        const selected = (isArray$d(value) ? value : [\n            value\n        ])?.[0];\n        return !isMulti && !!selected && displayTooltipForSelectedItem ? getOptionTooltip?.(selected) : null;\n    }, [\n        getOptionTooltip,\n        displayTooltipForSelectedItem,\n        value,\n        isMulti\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(TooltipSimple, {\n        className: styles$1.valueContainerTooltip,\n        content: content,\n        disable: !content\n    }, /*#__PURE__*/ _react.default.createElement(_reactselect.components.ValueContainer, {\n        ...props\n    }, children));\n};\nconst DropdownIndicator = ({ innerProps: innerPropsProp, ...props })=>{\n    const { groupedIsOpen, onMenuClose } = props.selectProps;\n    const handlePointerDown = (0, _react.useCallback)(()=>{\n        if (groupedIsOpen) {\n            onMenuClose();\n        }\n    }, [\n        onMenuClose,\n        groupedIsOpen\n    ]);\n    const innerProps = (0, _react.useMemo)(()=>({\n            ...innerPropsProp,\n            onPointerDown: handlePointerDown\n        }), [\n        innerPropsProp,\n        handlePointerDown\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_reactselect.components.DropdownIndicator, {\n        innerProps: innerProps,\n        ...props\n    });\n};\nconst ClearIndicator = ({ innerProps: innerPropsProp, children, ...props })=>{\n    const { renderClearIndicator, clearIndicatorTooltipContent } = props.selectProps;\n    return /*#__PURE__*/ _react.default.createElement(TooltipSimple, {\n        content: clearIndicatorTooltipContent || \"Clear selected\"\n    }, /*#__PURE__*/ _react.default.createElement(_reactselect.components.ClearIndicator, {\n        innerProps: innerPropsProp,\n        ...props\n    }, renderClearIndicator === undefined ? children : renderClearIndicator?.()));\n};\nconst Select = ({ options: optionsProp, className, placeholder = \"Choose an option...\", noOptionsMessage = ()=>\"No matching options...\", disableNoOptionsMessage = false, isLoading = false, menuIsOpen = false, classNames: classNamesProp, allGroupsEmpty = false, inputTypeIsText = false, onlyCallOnChangeForEdits = true, onInputChange, onInputChangeDebounced, formatValue, isDisabled = false, inputValue: inputValueProp, debounceTime = 300, onKeyDown, disableInternalFilter, filterOption, isSearchable = false, isMulti = false, closeMenuOnSelect = !isMulti, value: valueProp, onChange, hideDropdownIndicator: hideDropdownIndicatorProp, hideClearButton, showEmptyMessageForEmptyInputValue = false, hideMenuOnEmptySearchTerm = false, label, labelHelpTooltipContent, labelIsCompact = true, displayTooltipForSelectedItem = false, keepInputValueOnBlur = false, maxOptions, allowMultiSelectedOptionsHeightToExpand, keepLabelHelpTooltipOpenOnHover, ...props })=>{\n    const [isOpen, setIsOpen] = (0, _react.useState)(false);\n    const [inputValueInternal, setInputValueInternal] = (0, _react.useState)(inputValueProp);\n    const [renderedItemsCountByGroupId, setRenderedItemsCountByGroupId] = (0, _react.useState)({});\n    const [renderedValuesByGroupId, setRenderedValuesByGroupId] = (0, _react.useState)({});\n    const [selected, setSelected] = (0, _react.useState)(valueProp || []);\n    // This tracks the currently focussed select box\n    // There are N Groups + 1 boxes\n    const [groupSelectBoxFocusIndex, setGroupSelectBoxFocusIndex] = (0, _react.useState)(0);\n    const closingDropDownDisabledRef = (0, _react.useRef)(false);\n    const closingDropDownDisabledTimeoutRef = (0, _react.useRef)();\n    const inputValue = (inputValueProp === undefined ? inputValueInternal : inputValueProp) || \"\";\n    const inputValueEmpty = !(inputValue || \"\").trim();\n    const open = isSearchable && hideMenuOnEmptySearchTerm && inputValueEmpty ? false : menuIsOpen || isOpen;\n    const optionsAreGrouped = (options)=>\"groupId\" in (options?.[0] || {}) && \"options\" in (options?.[0] || {});\n    const parseGroupedOptions = (options)=>optionsAreGrouped(options) ? options : undefined;\n    const optionsAreNonGrouped = (options)=>!optionsAreGrouped(options);\n    const parseNonGroupedOptions = (options)=>optionsAreNonGrouped(options) ? options : undefined;\n    const nonGroupedOptions = parseNonGroupedOptions(optionsProp);\n    const groupedOptions = parseGroupedOptions(optionsProp)?.map(({ groupId, options: opts, ...rest })=>({\n            ...rest,\n            groupId,\n            options: opts.map((opt)=>({\n                    ...opt,\n                    groupId\n                }))\n        }));\n    const groupsCount = groupedOptions?.length || 0;\n    const [getGroupedSelectRef, setGroupedSelectRef] = useDynamicRefs({\n        ids: [\n            ...Array((groupedOptions || []).length + 1)\n        ].map((v, i)=>i.toString())\n    });\n    (0, _react.useEffect)(()=>{\n        setGroupSelectBoxFocusIndex(0);\n    }, [\n        open\n    ]);\n    const combinedOptions = (0, _react.useMemo)(()=>groupedOptions ? groupedOptions?.flatMap(({ groupId, options: opts })=>opts.map((opt)=>({\n                    ...opt,\n                    groupId\n                }))) : nonGroupedOptions?.map((opt)=>({\n                ...opt,\n                groupId: undefined\n            })), [\n        groupedOptions,\n        nonGroupedOptions\n    ]);\n    const hideDropdownIndicator = hideDropdownIndicatorProp || // Hide the drop down indicator if multi select and all elements are selected\n    !!selected.length && isMulti && !groupedOptions && selected.length === (combinedOptions || []).length;\n    const optionsByKey = (0, _libutilities.keyByWithUndefined)(combinedOptions, ({ groupId, value })=>createOptionKey({\n            groupId,\n            value\n        }));\n    const selectedOptionsByKey = (0, _libutilities.keyByWithUndefined)(selected, ({ groupId, value })=>createOptionKey({\n            groupId,\n            value\n        }));\n    const setInputValueInternalDebounced = (0, _usedebounce.useDebouncedCallback)((value)=>onInputChangeDebounced?.(value), debounceTime);\n    const handleInputChange = (0, _react.useCallback)((value, action)=>{\n        // setGroupSelectBoxFocusIndex(0);\n        if (onlyCallOnChangeForEdits ? VALID_ACTIONS_FOR_CALLING_INPUT_CHANGE.some((v)=>v === action?.action) : true) {\n            const formattedValue = (formatValue ? formatValue(value) : value) || \"\";\n            setInputValueInternal(formattedValue);\n            setInputValueInternalDebounced(formattedValue);\n            onInputChange?.(formattedValue, action);\n        }\n    }, [\n        onInputChange,\n        onlyCallOnChangeForEdits,\n        setInputValueInternalDebounced,\n        formatValue\n    ]);\n    // TODO: CHECK AND FIX THIS\n    const handleBlur = (0, _react.useCallback)(()=>{\n        if (isSearchable && !keepInputValueOnBlur && !closingDropDownDisabledRef.current) {\n            setTimeout(()=>{\n                handleInputChange(\"\", {\n                    action: \"input-change\",\n                    prevInputValue: inputValue\n                });\n            }, DELAY_FOR_CLOSING_DROP_DOWN);\n        }\n    }, [\n        isSearchable,\n        handleInputChange,\n        inputValue,\n        keepInputValueOnBlur\n    ]);\n    const updateSelectedOptions = (0, _react.useCallback)(({ selected: newSel, overwrite = !groupedOptions || groupedOptions && !isMulti, groupId })=>{\n        const newSelIsArray = isArray$d(newSel);\n        let newSelected = (newSelIsArray ? newSel : [\n            newSel\n        ]) || [];\n        if (!groupedOptions && isMulti) {\n            // TODO: Why is this coming through as an array nested within an array?\n            newSelected = newSel[0] || [];\n        }\n        newSelected = newSelected.filter(({ value })=>!!(value || \"\").trim());\n        return setSelected((prevSelected)=>{\n            let result = prevSelected;\n            if (overwrite) {\n                result = newSelected;\n            } else if (groupedOptions) {\n                result = [\n                    ...uniqBy$1([\n                        ...prevSelected.filter((item)=>item.groupId === groupId),\n                        ...newSelected || []\n                    ], ({ value, groupId: gId })=>createOptionKey({\n                            groupId: gId,\n                            value\n                        })),\n                    ...prevSelected.filter((item)=>item.groupId !== groupId)\n                ];\n            } else {\n                result = [\n                    ...uniqBy$1([\n                        ...prevSelected,\n                        ...newSelected\n                    ], ({ value, groupId: gId })=>createOptionKey({\n                            groupId: gId,\n                            value\n                        }))\n                ];\n            }\n            // Use callback for controlled mode\n            onChange?.(result);\n            return result;\n        });\n    }, [\n        isMulti,\n        groupedOptions,\n        onChange\n    ]);\n    const clearSelectedOptions = (0, _react.useCallback)(()=>updateSelectedOptions({\n            selected: [],\n            overwrite: true\n        }), [\n        updateSelectedOptions\n    ]);\n    const handleFilterOption = (0, _react.useCallback)((option, inputValueForFilter)=>{\n        if (isMulti && !!selectedOptionsByKey[createOptionKey({\n            groupId: option.data.groupId,\n            value: option.data.value\n        })]) {\n            return false;\n        }\n        if (disableInternalFilter) {\n            return true;\n        }\n        if (filterOption) {\n            return filterOption?.(option, inputValueForFilter);\n        }\n        return DEFAULT_FILTER(option, inputValueForFilter);\n    }, [\n        filterOption,\n        disableInternalFilter,\n        selectedOptionsByKey,\n        isMulti\n    ]);\n    const classNamesInternal = (0, _react.useMemo)(()=>({\n            clearIndicator: ()=>(0, _classnames.default)(styles$1.clearIndicator, {\n                    [styles$1.hide]: hideClearButton\n                }),\n            container: ({ isFocused })=>(0, _classnames.default)(className, styles$1.container, {\n                    [styles$1.isFocused]: isFocused\n                }),\n            control: ({ isFocused })=>(0, _classnames.default)(styles$1.control, {\n                    [styles$1.allGroupsEmptyTextBlinker]: !isSearchable,\n                    [styles$1.isDisabled]: isDisabled,\n                    [styles$1.inputTypeIsText]: inputTypeIsText,\n                    [styles$1.isFocused]: isSearchable ? isFocused : open && isFocused\n                }),\n            dropdownIndicator: ()=>(0, _classnames.default)(styles$1.dropdownIndicator, {\n                    [styles$1.isOpen]: open,\n                    [styles$1.allGroupsEmpty]: allGroupsEmpty,\n                    [styles$1.isDisabled]: isDisabled,\n                    [styles$1.hide]: hideDropdownIndicator\n                }),\n            input: ()=>(0, _classnames.default)(styles$1.input, {\n                    [styles$1.isDisabled]: isDisabled,\n                    [styles$1.inputTypeIsText]: inputTypeIsText\n                }),\n            loadingIndicator: ()=>styles$1.loadingIndicator,\n            menu: ()=>styles$1.menu,\n            menuList: ()=>styles$1.menuList,\n            multiValue: ()=>styles$1.multiValue,\n            multiValueLabel: ()=>styles$1.multiValueLabel,\n            multiValueRemove: ()=>styles$1.multiValueRemove,\n            noOptionsMessage: ()=>styles$1.noOptionsMessage,\n            option: ({ data, isFocused, selectProps })=>{\n                return (0, _classnames.default)(styles$1.option, {\n                    [styles$1.isSelected]: !!selectedOptionsByKey[createOptionKey({\n                        groupId: data.groupId,\n                        value: data.value\n                    })],\n                    [styles$1.isFocused]: selectProps.isFocused && isFocused\n                });\n            },\n            placeholder: ()=>(0, _classnames.default)(styles$1.placeholder, {\n                    [styles$1.isDisabled]: isDisabled\n                }),\n            valueContainer: ()=>(0, _classnames.default)(styles$1.valueContainer, {\n                    [styles$1.isDisabled]: isDisabled,\n                    [styles$1.isScrollable]: isMulti,\n                    [styles$1.allowMultiSelectedOptionsHeightToExpand]: isMulti && allowMultiSelectedOptionsHeightToExpand\n                })\n        }), [\n        className,\n        allGroupsEmpty,\n        inputTypeIsText,\n        isDisabled,\n        open,\n        isSearchable,\n        hideDropdownIndicator,\n        selectedOptionsByKey,\n        isMulti,\n        hideClearButton,\n        allowMultiSelectedOptionsHeightToExpand\n    ]);\n    const onMenuClose = (0, _react.useCallback)(()=>{\n        // This timeout ensures that when using grouped mode,\n        // the clicked option is registered before the menu is blurred and closed\n        setTimeout(()=>{\n            if (!closingDropDownDisabledRef.current) {\n                setIsOpen(false);\n            }\n        }, DELAY_FOR_CLOSING_DROP_DOWN);\n    }, []);\n    const onMenuOpen = (0, _react.useCallback)(()=>{\n        setIsOpen(true);\n    }, []);\n    const clearInputValue = (0, _react.useCallback)(()=>{\n        setInputValueInternal(\"\");\n        setInputValueInternalDebounced(\"\");\n        setInputValueInternalDebounced.flush();\n    }, [\n        setInputValueInternalDebounced\n    ]);\n    const getCurrentFocusedOption = (0, _react.useCallback)(()=>{\n        const focusedOption = getGroupedSelectRef(groupSelectBoxFocusIndex)?.state?.focusedOption;\n        return focusedOption;\n    }, [\n        groupSelectBoxFocusIndex,\n        getGroupedSelectRef\n    ]);\n    const getCurrentFocusedGroupIndex = (0, _react.useCallback)(()=>{\n        const { groupId } = getCurrentFocusedOption() || {};\n        const focusedGroupIndex = groupedOptions?.findIndex(({ groupId: gId })=>groupId === gId);\n        return focusedGroupIndex === undefined ? -1 : focusedGroupIndex;\n    }, [\n        groupedOptions,\n        getCurrentFocusedOption\n    ]);\n    const getCurrentFocusedGroup = (0, _react.useCallback)(()=>groupedOptions?.[getCurrentFocusedGroupIndex()], [\n        groupedOptions,\n        getCurrentFocusedGroupIndex\n    ]);\n    const getCurrentFocusedOptionIndex = (0, _react.useCallback)(()=>{\n        const { value } = getCurrentFocusedOption() || {};\n        const focusedGroup = getCurrentFocusedGroup();\n        const focusedIndex = focusedGroup?.options.findIndex(({ value: v })=>v === value);\n        return focusedIndex === undefined ? -1 : focusedIndex;\n    }, [\n        getCurrentFocusedOption,\n        getCurrentFocusedGroup\n    ]);\n    const getVisibleOptionsCountForGroupIndex = (0, _react.useCallback)((groupSelectBoxIndex)=>{\n        return getGroupedSelectRef(groupSelectBoxIndex)?.state?.focusableOptionsWithIds?.length;\n    }, [\n        getGroupedSelectRef\n    ]);\n    const temporarilyDisableClosingGroupedSelect = (0, _react.useCallback)(()=>{\n        if (groupedOptions) {\n            clearTimeout(closingDropDownDisabledTimeoutRef.current);\n            closingDropDownDisabledRef.current = true;\n            closingDropDownDisabledTimeoutRef.current = setTimeout(()=>{\n                closingDropDownDisabledRef.current = false;\n            }, DELAY_FOR_CLOSING_DROP_DOWN + 50);\n        }\n    }, [\n        groupedOptions\n    ]);\n    const incrementGroupSelectFocusIndex = (0, _react.useCallback)(()=>{\n        setGroupSelectBoxFocusIndex((i)=>{\n            const getNewIndex = (oldIndex)=>{\n                let newIndex = groupsCount ? (oldIndex + 1) % (groupsCount + 1) : 0;\n                if (newIndex === 0) {\n                    onMenuClose();\n                    return 0;\n                }\n                temporarilyDisableClosingGroupedSelect();\n                const reachedSearchBox = oldIndex === groupsCount;\n                const newIndexHasNoOptions = (isSearchable ? !!inputValue : false) && !reachedSearchBox && !getVisibleOptionsCountForGroupIndex(newIndex);\n                if (!reachedSearchBox && newIndexHasNoOptions) {\n                    // This new group is empty, so iterate again\n                    return getNewIndex(newIndex);\n                }\n                return newIndex;\n            };\n            const newIndex = getNewIndex(i);\n            getGroupedSelectRef(newIndex)?.focus();\n            return newIndex;\n        });\n    }, [\n        groupsCount,\n        onMenuClose,\n        getGroupedSelectRef,\n        temporarilyDisableClosingGroupedSelect,\n        getVisibleOptionsCountForGroupIndex,\n        inputValue,\n        isSearchable\n    ]);\n    const decrementGroupSelectFocusIndex = (0, _react.useCallback)(()=>{\n        setGroupSelectBoxFocusIndex((i)=>{\n            temporarilyDisableClosingGroupedSelect();\n            const getNewIndex = (oldIndex)=>{\n                let newIndex = groupsCount ? (i - 1) % (groupsCount + 1) : 0;\n                const reachedSearchBox = newIndex === 0;\n                const reachedEnd = oldIndex === groupsCount;\n                const newIndexHasNoOptions = !reachedSearchBox && !getVisibleOptionsCountForGroupIndex(newIndex);\n                if (!reachedSearchBox && !reachedEnd && newIndexHasNoOptions) {\n                    // This new group is empty, so iterate again\n                    return getNewIndex(newIndex);\n                }\n                return newIndex;\n            };\n            const newIndex = getNewIndex(i);\n            getGroupedSelectRef(newIndex)?.focus();\n            return newIndex;\n        });\n    }, [\n        groupsCount,\n        getGroupedSelectRef,\n        getVisibleOptionsCountForGroupIndex,\n        temporarilyDisableClosingGroupedSelect\n    ]);\n    const handleKeyDown = (0, _react.useCallback)((event)=>{\n        onKeyDown?.(event);\n        if (event.code === \"Tab\") {\n            if (groupedOptions && open) {\n                event.preventDefault();\n                // Handle shift tab (back)\n                if (event.shiftKey) {\n                    if (groupSelectBoxFocusIndex === 0) {\n                        onMenuClose();\n                    } else {\n                        decrementGroupSelectFocusIndex();\n                    }\n                } else {\n                    incrementGroupSelectFocusIndex();\n                }\n            }\n        } else if (event.code === \"ArrowDown\") {\n            if (groupedOptions) {\n                const focusedIndex = getCurrentFocusedOptionIndex();\n                const newFocusedIndex = focusedIndex + 1;\n                const groupOptionsCount = Math.min(getVisibleOptionsCountForGroupIndex(groupSelectBoxFocusIndex) ?? Infinity, maxOptions || Infinity);\n                if (groupSelectBoxFocusIndex === 0 && !open) {\n                    // Must open the drop down first\n                    setIsOpen(true);\n                    setTimeout(()=>{\n                        incrementGroupSelectFocusIndex();\n                    }, 100);\n                } else if (open && newFocusedIndex > groupOptionsCount - 1) {\n                    incrementGroupSelectFocusIndex();\n                }\n            }\n        } else if (event.code === \"ArrowUp\") {\n            if (groupedOptions) {\n                const focusedIndex = getCurrentFocusedOptionIndex();\n                const newFocusedIndex = focusedIndex - 1;\n                if (groupSelectBoxFocusIndex === 0) ;\n                else if (open && newFocusedIndex < 0) {\n                    decrementGroupSelectFocusIndex();\n                }\n            }\n        } else if (event.code === \"Enter\") {\n            if (groupSelectBoxFocusIndex === 0 && open) {\n                /** Pressed the enter key */ clearInputValue();\n                onMenuClose();\n            }\n            // If pressing enter on the search bar itself\n            if (groupedOptions && groupSelectBoxFocusIndex === 0 && !inputValueEmpty) {\n                const firstAvailableGroupId = Object.keys(renderedValuesByGroupId)[0];\n                const firstAvailableItemId = (renderedValuesByGroupId[firstAvailableGroupId] || [])[0];\n                const firstAvailableItem = optionsByKey[createOptionKey({\n                    groupId: firstAvailableGroupId,\n                    value: firstAvailableItemId\n                })];\n                const newSelected = firstAvailableItem ? [\n                    firstAvailableItem\n                ] : [];\n                const groupId = firstAvailableGroupId;\n                updateSelectedOptions({\n                    selected: newSelected,\n                    groupId\n                });\n            }\n        }\n    }, [\n        onKeyDown,\n        inputValueEmpty,\n        groupedOptions,\n        onMenuClose,\n        renderedValuesByGroupId,\n        optionsByKey,\n        updateSelectedOptions,\n        groupSelectBoxFocusIndex,\n        open,\n        clearInputValue,\n        decrementGroupSelectFocusIndex,\n        incrementGroupSelectFocusIndex,\n        getCurrentFocusedOptionIndex,\n        getVisibleOptionsCountForGroupIndex,\n        maxOptions\n    ]);\n    const renderSelect = (0, _react.useCallback)((opts, { classNames: cn = {}, ...customProps })=>{\n        return(// TODO: Properly type this component\n        // eslint-disable-next-line\n        // @ts-ignore\n        /*#__PURE__*/ _react.default.createElement(_reactselect.default, {\n            ...props,\n            classNames: (0, _libutilities.mergeClassNamesFunctionsDeep)({\n                classNames1: (0, _libutilities.mergeClassNamesFunctionsDeep)({\n                    classNames1: classNamesProp,\n                    classNames2: cn\n                }),\n                classNames2: classNamesInternal\n            }),\n            filterOption: filterOption || isMulti || disableInternalFilter ? handleFilterOption : undefined,\n            groupedIsOpen: open,\n            inputValue: inputValue,\n            instanceId: \"select\",\n            isDisabled: isDisabled,\n            isLoading: isLoading,\n            isSearchable: isSearchable,\n            key: props.id,\n            menuIsOpen: open,\n            noOptionsMessage: disableNoOptionsMessage ? ()=>null : noOptionsMessage,\n            onKeyDown: handleKeyDown,\n            options: opts,\n            placeholder: placeholder,\n            unstyled: true,\n            ...customProps\n        }));\n    }, [\n        props,\n        placeholder,\n        noOptionsMessage,\n        disableNoOptionsMessage,\n        isLoading,\n        isDisabled,\n        inputValue,\n        filterOption,\n        isSearchable,\n        classNamesInternal,\n        classNamesProp,\n        handleFilterOption,\n        disableInternalFilter,\n        handleKeyDown,\n        open,\n        isMulti\n    ]);\n    const handleChangeOnSearchBarForGroupedMode = (0, _react.useCallback)((sel)=>{\n        updateSelectedOptions({\n            selected: (sel || []).map(({ itemValue, value, ...s })=>({\n                    ...s,\n                    value: itemValue,\n                    groupId: optionsByKey[value]?.groupId\n                })),\n            overwrite: true\n        });\n    }, [\n        optionsByKey,\n        updateSelectedOptions\n    ]);\n    const handleChangeOnList = (0, _react.useCallback)((sel, { groupId })=>{\n        // Enabled this code block if we want to keep the menu open on item selection\n        if (groupedOptions && !closeMenuOnSelect) {\n            temporarilyDisableClosingGroupedSelect();\n        }\n        if (groupedOptions) {\n            clearInputValue();\n        }\n        if (!sel || isArray$d(sel) && !sel.length) {\n            return clearSelectedOptions();\n        }\n        const newSelected = groupedOptions ? (isArray$d(sel) ? sel : [\n            sel\n        ]).map((item)=>({\n                ...item,\n                groupId\n            })) : [\n            sel\n        ];\n        return updateSelectedOptions({\n            selected: newSelected,\n            groupId\n        });\n    }, [\n        groupedOptions,\n        clearSelectedOptions,\n        updateSelectedOptions,\n        closeMenuOnSelect,\n        clearInputValue,\n        temporarilyDisableClosingGroupedSelect\n    ]);\n    const internalValue = isMulti ? selected.map((s)=>({\n            ...s,\n            ...groupedOptions ? {\n                itemValue: s.value,\n                value: createOptionKey({\n                    groupId: s.groupId,\n                    value: s.value\n                })\n            } : {}\n        })) : selected[0];\n    let externalValue = null;\n    if (valueProp !== null) {\n        externalValue = isMulti ? (valueProp || []).map((s)=>({\n                ...s,\n                ...groupedOptions ? {\n                    itemValue: s.value,\n                    value: createOptionKey({\n                        groupId: s.groupId,\n                        value: s.value\n                    })\n                } : {}\n            })) : (valueProp || [])[0];\n    }\n    const valueRaw = valueProp === undefined && externalValue !== null ? internalValue : externalValue;\n    const value = (0, _react.useMemo)(()=>{\n        if (valueRaw === null) {\n            return null;\n        }\n        return isArray$d(valueRaw) ? valueRaw : [\n            valueRaw\n        ].flatMap((v)=>v || []);\n    }, [\n        valueRaw\n    ]);\n    const coreSelectCommonProps = (0, _react.useMemo)(()=>({\n            onInputChange: handleInputChange,\n            onMenuClose,\n            onMenuOpen,\n            isMulti,\n            closeMenuOnSelect,\n            value,\n            onBlur: handleBlur,\n            tabSelectsValue: false\n        }), [\n        handleInputChange,\n        isMulti,\n        onMenuClose,\n        onMenuOpen,\n        closeMenuOnSelect,\n        value,\n        handleBlur\n    ]);\n    const nonGroupedSelectProps = (0, _react.useMemo)(()=>({\n            ...coreSelectCommonProps,\n            menuIsOpen: open,\n            // TODO: Fix typings on this onChange\n            onChange: (newSelected)=>handleChangeOnList(newSelected, {\n                    groupId: undefined\n                }),\n            components: {\n                Option,\n                ClearIndicator,\n                ValueContainer\n            },\n            displayTooltipForSelectedItem\n        }), [\n        coreSelectCommonProps,\n        handleChangeOnList,\n        open,\n        displayTooltipForSelectedItem\n    ]);\n    const groupedSelectProps = (0, _react.useMemo)(()=>({\n            ...coreSelectCommonProps,\n            ref: setGroupedSelectRef(0),\n            value,\n            classNames: {\n                container: ()=>styles$1.containerSearchGroup\n            },\n            maxOptions: 0,\n            isSearchOnly: true,\n            menuIsOpen: false,\n            // TODO: Fix typings on this onChange\n            onChange: handleChangeOnSearchBarForGroupedMode,\n            // autoFocus: groupSelectBoxFocusIndex === 0,\n            components: {\n                DropdownIndicator,\n                ClearIndicator\n            },\n            isFocused: groupedOptions ? groupSelectBoxFocusIndex === 0 : true\n        }), [\n        coreSelectCommonProps,\n        groupSelectBoxFocusIndex,\n        handleChangeOnSearchBarForGroupedMode,\n        value,\n        setGroupedSelectRef,\n        groupedOptions\n    ]);\n    const labelRendered = (0, _react.useMemo)(()=>/*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"label\", {\n            className: (0, _classnames.default)(styles$1.labelContainer, classNamesProp?.labelContainer?.({}), {\n                [styles$1.compact]: labelIsCompact\n            }),\n            htmlFor: props.name\n        }, /*#__PURE__*/ _react.default.createElement(Text, {\n            bold600: true,\n            className: (0, _classnames.default)(styles$1.label, classNamesProp?.label?.({})),\n            fontSize: \"sm\"\n        }, label), !!labelHelpTooltipContent && /*#__PURE__*/ _react.default.createElement(TooltipHelp, {\n            className: styles$1.labelHelp,\n            content: labelHelpTooltipContent,\n            keepTooltipOpenOnHover: keepLabelHelpTooltipOpenOnHover\n        })), !labelIsCompact && /*#__PURE__*/ _react.default.createElement(Spacer, {\n            height: \"xs\",\n            scaleFactor: 0.5\n        })), [\n        classNamesProp,\n        label,\n        labelIsCompact,\n        labelHelpTooltipContent,\n        props.name,\n        keepLabelHelpTooltipOpenOnHover\n    ]);\n    const commonWrapperStyles = (0, _react.useMemo)(()=>(0, _classnames.default)(styles$1.wrapper, classNamesProp?.wrapper?.({}), {\n            [styles$1.isMultiSelect]: isMulti,\n            [styles$1.disableInputHeight]: !isOpen && isMulti && !!selected.length\n        }), [\n        classNamesProp,\n        isMulti,\n        isOpen,\n        selected\n    ]);\n    if (groupedOptions) {\n        const allGroupsEmpty = (groupedOptions || []).reduce((allGroupsEmptyValue, { groupId })=>{\n            const isEmpty = !renderedItemsCountByGroupId[groupId];\n            return allGroupsEmptyValue && isEmpty;\n        }, true);\n        return /*#__PURE__*/ _react.default.createElement(Flex, {\n            className: (0, _classnames.default)(commonWrapperStyles, styles$1.isGroupMode),\n            isColumn: true\n        }, !!label && labelRendered, renderSelect([], groupedSelectProps), !!open && /*#__PURE__*/ _react.default.createElement(Flex, {\n            className: styles$1.groupsDropDown,\n            isColumn: true\n        }, /*#__PURE__*/ _react.default.createElement(Flex, {\n            className: styles$1.groupsDropDownContents,\n            isColumn: true\n        }, (groupedOptions || []).map(({ groupId, label: groupedOptionLabel, options: opts }, index)=>{\n            const isFocused = groupSelectBoxFocusIndex === index + 1;\n            const isEmpty = !renderedItemsCountByGroupId[groupId];\n            const forceEmptyMessage = allGroupsEmpty ? index === 0 && (showEmptyMessageForEmptyInputValue ? true : !inputValueEmpty) : false;\n            return /*#__PURE__*/ _react.default.createElement(Flex, {\n                className: styles$1.groupWrapper,\n                isColumn: true,\n                key: groupId\n            }, renderSelect(opts.map((opt)=>({\n                    ...opt,\n                    groupId\n                })), {\n                id: groupId,\n                ref: setGroupedSelectRef(index + 1),\n                isFocused: groupedOptions ? groupSelectBoxFocusIndex === index + 1 : true,\n                groupId,\n                groupLabel: groupedOptionLabel,\n                allGroupsEmpty,\n                forceEmptyMessage,\n                classNames: {\n                    container: ()=>styles$1.containerItemsGroup,\n                    menuList: isFocused ? ()=>styles$1.isFocused : undefined,\n                    menu: !forceEmptyMessage && isEmpty ? ()=>styles$1.isHidden : undefined\n                },\n                components: {\n                    MenuList: MenuListGrouped,\n                    Option\n                },\n                maxOptions,\n                onRenderedItemsChange: ({ groupId: gId, values, count })=>{\n                    if (gId && renderedItemsCountByGroupId[gId] !== count) {\n                        setRenderedItemsCountByGroupId((old)=>({\n                                ...old,\n                                [gId]: count\n                            }));\n                        setRenderedValuesByGroupId((old)=>{\n                            const newValues = {\n                                ...old,\n                                [gId]: values || []\n                            };\n                            return values ? newValues : omit$1(newValues, [\n                                gId\n                            ]);\n                        });\n                    }\n                },\n                // TODO: Fix the typings on this onChange\n                onChange: (newSelected)=>handleChangeOnList(newSelected, {\n                        groupId\n                    }),\n                // autoFocus: isFocused,\n                onBlur: (e)=>{\n                    if (groupedOptions) {\n                        if (e.relatedTarget === null) {\n                            onMenuClose();\n                            handleBlur();\n                        }\n                    }\n                }\n            }));\n        }))));\n    }\n    return /*#__PURE__*/ _react.default.createElement(Flex, {\n        className: commonWrapperStyles,\n        isColumn: true\n    }, !!label && labelRendered, renderSelect(nonGroupedOptions || [], nonGroupedSelectProps));\n};\nvar styles = {\n    \"textAreaComponent\": \"TextArea-module_textAreaComponent__sbuvC\",\n    \"textAreaWrapper\": \"TextArea-module_textAreaWrapper__BYwhs\",\n    \"textArea\": \"TextArea-module_textArea__41I8Q\",\n    \"hasError\": \"TextArea-module_hasError__VxJLi\",\n    \"isFocused\": \"TextArea-module_isFocused__7ZALl\",\n    \"errorMessage\": \"TextArea-module_errorMessage__axYEI\"\n};\nconst TextArea = ({ className, classNames: classNamesProp, label, name, error, touched, onFocus, onBlur, onClick, ...props })=>{\n    const [isFocused, setIsFocused] = (0, _react.useState)(false);\n    const handleFocus = (0, _react.useCallback)((e)=>{\n        onFocus?.(e);\n        setIsFocused(true);\n    }, [\n        onFocus\n    ]);\n    const handleClick = (0, _react.useCallback)((e)=>{\n        onClick?.(e);\n        setIsFocused(true);\n    }, [\n        onClick\n    ]);\n    const handleBlur = (0, _react.useCallback)((e)=>{\n        onBlur?.(e);\n        setIsFocused(false);\n    }, [\n        onBlur\n    ]);\n    const showError = !!touched && !!error && !isFocused;\n    return /*#__PURE__*/ _react.default.createElement(Flex, {\n        alignItems: \"flex-start\",\n        className: (0, _classnames.default)(styles.textAreaComponent, className),\n        isColumn: true\n    }, !!label && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"label\", {\n        htmlFor: name\n    }, /*#__PURE__*/ _react.default.createElement(Text, {\n        bold500: true,\n        className: (0, _classnames.default)(styles.label, classNamesProp?.label),\n        fontSize: \"sm\"\n    }, label)), /*#__PURE__*/ _react.default.createElement(Spacer, {\n        height: \"xs\",\n        scaleFactor: 0.5\n    })), /*#__PURE__*/ _react.default.createElement(Flex, {\n        alignItems: \"center\",\n        className: (0, _classnames.default)(styles.textAreaWrapper, classNamesProp?.inputWrapper)\n    }, /*#__PURE__*/ _react.default.createElement(\"textarea\", {\n        ...props,\n        className: (0, _classnames.default)(styles.textArea, classNamesProp?.input, {\n            [styles.isFocused]: isFocused,\n            [styles.hasError]: !!showError\n        }),\n        onBlur: handleBlur,\n        onClick: handleClick,\n        onFocus: handleFocus,\n        onWheel: (e)=>e.target.blur()\n    })), !!showError && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Spacer, {\n        height: \"md\",\n        scaleFactor: 0.5\n    }), /*#__PURE__*/ _react.default.createElement(Text, {\n        className: (0, _classnames.default)(styles.errorMessage, classNamesProp?.errorMessage),\n        fontSize: \"xs\"\n    }, error)));\n};\nvar commonStyles = {\n    \"icon\": \"Icon-module_icon__wiLNi\"\n};\nconst generateSvgProps = ({ props, className, id })=>{\n    const { className: propsClassName } = props;\n    return {\n        ...props,\n        className: (0, _classnames.default)(commonStyles.icon, className, propsClassName),\n        id: `icon-${id}`,\n        xmlns: \"http://www.w3.org/2000/svg\",\n        xmlnsXlink: \"http://www.w3.org/1999/xlink\"\n    };\n};\nconst generateColorProps = (colors = [], defaults = [])=>[\n        ...Array(10)\n    ].map((color, index)=>({\n            \"data-color-index\": index.toString(),\n            fill: colors[index] || defaults[index]\n        }));\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYXBwLWZyb250LWVuZC1jb21wb25lbnRzL2xpYi9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7SUFLK0JBLHlCQUF5QjtlQUEvQ0MsMEJBQWtCOztJQSt4VWxCQyxNQUFNO2VBQU5BOztJQUFRQyxNQUFNO2VBQU5BOztJQUFRQyxJQUFJO2VBQUpBOztJQUFNQyxRQUFRO2VBQVJBOztJQUFVQyxlQUFlO2VBQWZBOztJQUFpQkMsSUFBSTtlQUFKQTs7SUFBTUMsU0FBUztlQUFUQTs7SUFBV0MsYUFBYTtlQUFiQTs7SUFBZUMsVUFBVTtlQUFWQTs7SUFBWUMsbUJBQW1CO2VBQW5CQTs7SUFBcUJDLElBQUk7ZUFBSkE7O0lBQU1DLGNBQWM7ZUFBZEE7O0lBQWdCQyxxQkFBcUI7ZUFBckJBOztJQUF1QkMsS0FBSztlQUFMQTs7SUFBT0MsYUFBYTtlQUFiQTs7SUFBZUMsWUFBWTtlQUFaQTs7SUFBY0MsWUFBWTtlQUFaQTs7SUFBY0MsSUFBSTtlQUFKQTs7SUFBTUMsTUFBTTtlQUFOQTs7SUFBUUMsTUFBTTtlQUFOQTs7SUFBUUMsZUFBZTtlQUFmQTs7SUFBaUJDLE1BQU07ZUFBTkE7O0lBQVFDLElBQUk7ZUFBSkE7O0lBQU1DLFFBQVE7ZUFBUkE7O0lBQVVDLFNBQVM7ZUFBVEE7O0lBQVdDLEtBQUs7ZUFBTEE7O0lBQU9DLE9BQU87ZUFBUEE7O0lBQVNDLGNBQWM7ZUFBZEE7O0lBQWdCQyxhQUFhO2VBQWJBOztJQUFlQyxjQUFjO2VBQWRBOztJQUFnQkMseUJBQXlCO2VBQXpCQTs7SUFBMkJDLGtCQUFrQjtlQUFsQkE7O0lBQW9CQyxrQkFBa0I7ZUFBbEJBOztJQUFvQkMseUJBQXlCO2VBQXpCQTs7SUFBMkJDLGdCQUFnQjtlQUFoQkE7O0lBQWtCQyxnQkFBZ0I7ZUFBaEJBOztJQUFrQkMsVUFBVTtlQUFWQTs7SUFBWUMscUJBQXFCO2VBQXJCQTs7SUFBdUJDLGFBQWE7ZUFBYkE7O0lBQWVDLFNBQVM7ZUFBVEE7O0lBQVdDLFNBQVM7ZUFBVEE7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SCxHQUFHQSxLQUFLO1FBQ1JzZCxXQUFXTyxJQUFBQSxtQkFBVSxFQUFDZzVELGFBQWEzM0IsSUFBSSxFQUFFNWhDLFdBQVd3NUQ7UUFDcER4bEUsSUFBSSxDQUFDLEtBQUssRUFBRUEsR0FBRyxDQUFDO1FBQ2hCbzZDLE9BQU87UUFDUEMsWUFBWTtJQUNoQjtBQUNKO0FBQ0EsTUFBTWgyRCxxQkFBcUIsQ0FBQ29oRixTQUFTLEVBQUUsRUFBRUMsV0FBVyxFQUFFLEdBQUs7V0FBSW4rRSxNQUFNO0tBQUksQ0FBQzZMLEdBQUcsQ0FBQyxDQUFDMGEsT0FBTzFXLFFBQVc7WUFDN0Ysb0JBQW9CQSxNQUFNbVgsUUFBUTtZQUNsQ2dvQyxNQUFNa3ZCLE1BQU0sQ0FBQ3J1RSxNQUFNLElBQUlzdUUsUUFBUSxDQUFDdHVFLE1BQU07UUFDMUM7Q0FHQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4uL2FwcC1mcm9udC1lbmQtY29tcG9uZW50cy9saWIvaW5kZXguZXNtLmpzPzVmMzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0X19kZWZhdWx0LCB7IHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIGZvcndhcmRSZWYsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIGNyZWF0ZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgZ2V0TlJhbmRvbUVsZW1lbnRzRnJvbUFycmF5LCBpc0Jyb3dzZXIsIHJlbW92ZVVuZGVmaW5lZFZhbHVlc0Zyb21PYmosIGNoZWNrSWZUZXh0VGVybU1hdGNoZXNTaW5nbGUsIGlzVHJ1dGh5T3JaZXJvLCBrZXlCeVdpdGhVbmRlZmluZWQsIG1lcmdlQ2xhc3NOYW1lc0Z1bmN0aW9uc0RlZXAsIGNyZWF0ZUN1c3RvbUtleUZyb21PYmplY3QgfSBmcm9tICdAZngvbGliLXV0aWxpdGllcyc7XG5pbXBvcnQgeyB1c2VEZWxheUdyb3VwQ29udGV4dCwgdXNlRmxvYXRpbmcsIGF1dG9VcGRhdGUsIG9mZnNldCwgZmxpcCwgc2hpZnQsIHVzZUhvdmVyLCB1c2VGb2N1cywgdXNlRGlzbWlzcywgdXNlUm9sZSwgdXNlSW50ZXJhY3Rpb25zLCB1c2VNZXJnZVJlZnMsIHVzZUlkLCB1c2VEZWxheUdyb3VwLCB1c2VUcmFuc2l0aW9uU3R5bGVzLCBGbG9hdGluZ1BvcnRhbCB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdCc7XG5leHBvcnQgeyBGbG9hdGluZ0RlbGF5R3JvdXAgYXMgVG9vbHRpcEZsb2F0aW5nRGVsYXlHcm91cCB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdCc7XG5pbXBvcnQgeyBRdWVzdGlvbk1hcmtDaXJjbGVkSWNvbiwgQ2hlY2tJY29uLCBDcm9zczJJY29uIH0gZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWljb25zJztcbmltcG9ydCAqIGFzIENoZWNrYm94UmFkaXggZnJvbSAnQHJhZGl4LXVpL3JlYWN0LWNoZWNrYm94JztcbmltcG9ydCB7IHVzZURlYm91bmNlZENhbGxiYWNrIH0gZnJvbSAndXNlLWRlYm91bmNlJztcbmltcG9ydCB7IEZpeGVkU2l6ZUxpc3QgfSBmcm9tICdyZWFjdC13aW5kb3cnO1xuaW1wb3J0IF9SZWFjdFNsaWRlciBmcm9tICdyZWFjdC1zbGlkZXInO1xuaW1wb3J0IHsgdXNlUmVzaXplRGV0ZWN0b3IgfSBmcm9tICdyZWFjdC1yZXNpemUtZGV0ZWN0b3InO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBSZWFjdFNlbGVjdCwgeyBjcmVhdGVGaWx0ZXIsIGNvbXBvbmVudHMgfSBmcm9tICdyZWFjdC1zZWxlY3QnO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIGxpbmskMSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQkMSA9IHt9O1xuXG5faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQkMS5fID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0JDEuX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0O1xuZnVuY3Rpb24gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9O1xufVxuXG52YXIgcmVzb2x2ZUhyZWYgPSB7ZXhwb3J0czoge319O1xuXG52YXIgcXVlcnlzdHJpbmcgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkUXVlcnlzdHJpbmc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVRdWVyeXN0cmluZyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFF1ZXJ5c3RyaW5nKSByZXR1cm4gcXVlcnlzdHJpbmc7XG5cdGhhc1JlcXVpcmVkUXVlcnlzdHJpbmcgPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgICAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRmdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG5cdFx0ICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuXHRcdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgICAgIGdldDogYWxsW25hbWVdXG5cdFx0ICAgIH0pO1xuXHRcdH1cblx0XHRfZXhwb3J0KGV4cG9ydHMsIHtcblx0XHQgICAgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeTogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeTtcblx0XHQgICAgfSxcblx0XHQgICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcztcblx0XHQgICAgfSxcblx0XHQgICAgYXNzaWduOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBhc3NpZ247XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcykge1xuXHRcdCAgICBjb25zdCBxdWVyeSA9IHt9O1xuXHRcdCAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9Pntcblx0XHQgICAgICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdCAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZTtcblx0XHQgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuXHRcdCAgICAgICAgICAgIHF1ZXJ5W2tleV0ucHVzaCh2YWx1ZSk7XG5cdFx0ICAgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSBbXG5cdFx0ICAgICAgICAgICAgICAgIHF1ZXJ5W2tleV0sXG5cdFx0ICAgICAgICAgICAgICAgIHZhbHVlXG5cdFx0ICAgICAgICAgICAgXTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfSk7XG5cdFx0ICAgIHJldHVybiBxdWVyeTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShwYXJhbSkge1xuXHRcdCAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4ocGFyYW0pIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHQgICAgICAgIHJldHVybiBTdHJpbmcocGFyYW0pO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgcmV0dXJuIFwiXCI7XG5cdFx0ICAgIH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyh1cmxRdWVyeSkge1xuXHRcdCAgICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG5cdFx0ICAgIE9iamVjdC5lbnRyaWVzKHVybFF1ZXJ5KS5mb3JFYWNoKChwYXJhbSk9Pntcblx0XHQgICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBwYXJhbTtcblx0XHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdCAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pPT5yZXN1bHQuYXBwZW5kKGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShpdGVtKSkpO1xuXHRcdCAgICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9KTtcblx0XHQgICAgcmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuXHRcdCAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzZWFyY2hQYXJhbXNMaXN0ID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuXHRcdCAgICAgICAgc2VhcmNoUGFyYW1zTGlzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG5cdFx0ICAgIH1cblx0XHQgICAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpPT57XG5cdFx0ICAgICAgICBBcnJheS5mcm9tKHNlYXJjaFBhcmFtcy5rZXlzKCkpLmZvckVhY2goKGtleSk9PnRhcmdldC5kZWxldGUoa2V5KSk7XG5cdFx0ICAgICAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSk9PnRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSkpO1xuXHRcdCAgICB9KTtcblx0XHQgICAgcmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRcblx0fSAocXVlcnlzdHJpbmcpKTtcblx0cmV0dXJuIHF1ZXJ5c3RyaW5nO1xufVxuXG52YXIgZm9ybWF0VXJsID0ge307XG5cbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0ge307XG5cbnZhciBoYXNSZXF1aXJlZF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCkgcmV0dXJuIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQ7XG5cdGhhc1JlcXVpcmVkX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IDE7XG5cblx0ZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7XG5cdCAgICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG5cblx0ICAgIHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7XG5cdCAgICB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7XG5cblx0ICAgIHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24obm9kZUludGVyb3ApIHtcblx0ICAgICAgICByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7XG5cdCAgICB9KShub2RlSW50ZXJvcCk7XG5cdH1cblx0X2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCQxO1xuXHRmdW5jdGlvbiBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkJDEob2JqLCBub2RlSW50ZXJvcCkge1xuXHQgICAgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHJldHVybiBvYmo7XG5cdCAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4geyBkZWZhdWx0OiBvYmogfTtcblxuXHQgICAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTtcblxuXHQgICAgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG5cblx0ICAgIHZhciBuZXdPYmogPSB7fTtcblx0ICAgIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuXHQgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgICAgIGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcblx0ICAgICAgICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cdCAgICAgICAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG5cdCAgICAgICAgICAgIGVsc2UgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuXG5cdCAgICBpZiAoY2FjaGUpIGNhY2hlLnNldChvYmosIG5ld09iaik7XG5cblx0ICAgIHJldHVybiBuZXdPYmo7XG5cdH1cblx0cmV0dXJuIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQ7XG59XG5cbnZhciBoYXNSZXF1aXJlZEZvcm1hdFVybDtcblxuZnVuY3Rpb24gcmVxdWlyZUZvcm1hdFVybCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEZvcm1hdFVybCkgcmV0dXJuIGZvcm1hdFVybDtcblx0aGFzUmVxdWlyZWRGb3JtYXRVcmwgPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgICAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRmdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG5cdFx0ICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuXHRcdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgICAgIGdldDogYWxsW25hbWVdXG5cdFx0ICAgIH0pO1xuXHRcdH1cblx0XHRfZXhwb3J0KGV4cG9ydHMsIHtcblx0XHQgICAgZm9ybWF0VXJsOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBmb3JtYXRVcmw7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIHVybE9iamVjdEtleXM6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIHVybE9iamVjdEtleXM7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBmb3JtYXRXaXRoVmFsaWRhdGlvbjtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCgpO1xuXHRcdGNvbnN0IF9xdWVyeXN0cmluZyA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmVRdWVyeXN0cmluZygpKTtcblx0XHRjb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvO1xuXHRcdGZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmopIHtcblx0XHQgICAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9iajtcblx0XHQgICAgbGV0IHByb3RvY29sID0gdXJsT2JqLnByb3RvY29sIHx8IFwiXCI7XG5cdFx0ICAgIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCBcIlwiO1xuXHRcdCAgICBsZXQgaGFzaCA9IHVybE9iai5oYXNoIHx8IFwiXCI7XG5cdFx0ICAgIGxldCBxdWVyeSA9IHVybE9iai5xdWVyeSB8fCBcIlwiO1xuXHRcdCAgICBsZXQgaG9zdCA9IGZhbHNlO1xuXHRcdCAgICBhdXRoID0gYXV0aCA/IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKS5yZXBsYWNlKC8lM0EvaSwgXCI6XCIpICsgXCJAXCIgOiBcIlwiO1xuXHRcdCAgICBpZiAodXJsT2JqLmhvc3QpIHtcblx0XHQgICAgICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3Q7XG5cdFx0ICAgIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcblx0XHQgICAgICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKFwiOlwiKSA/IFwiW1wiICsgaG9zdG5hbWUgKyBcIl1cIiA6IGhvc3RuYW1lKTtcblx0XHQgICAgICAgIGlmICh1cmxPYmoucG9ydCkge1xuXHRcdCAgICAgICAgICAgIGhvc3QgKz0gXCI6XCIgKyB1cmxPYmoucG9ydDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSBcIm9iamVjdFwiKSB7XG5cdFx0ICAgICAgICBxdWVyeSA9IFN0cmluZyhfcXVlcnlzdHJpbmcudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhxdWVyeSkpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGxldCBzZWFyY2ggPSB1cmxPYmouc2VhcmNoIHx8IHF1ZXJ5ICYmIFwiP1wiICsgcXVlcnkgfHwgXCJcIjtcblx0XHQgICAgaWYgKHByb3RvY29sICYmICFwcm90b2NvbC5lbmRzV2l0aChcIjpcIikpIHByb3RvY29sICs9IFwiOlwiO1xuXHRcdCAgICBpZiAodXJsT2JqLnNsYXNoZXMgfHwgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuXHRcdCAgICAgICAgaG9zdCA9IFwiLy9cIiArIChob3N0IHx8IFwiXCIpO1xuXHRcdCAgICAgICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lWzBdICE9PSBcIi9cIikgcGF0aG5hbWUgPSBcIi9cIiArIHBhdGhuYW1lO1xuXHRcdCAgICB9IGVsc2UgaWYgKCFob3N0KSB7XG5cdFx0ICAgICAgICBob3N0ID0gXCJcIjtcblx0XHQgICAgfVxuXHRcdCAgICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSBcIiNcIikgaGFzaCA9IFwiI1wiICsgaGFzaDtcblx0XHQgICAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09IFwiP1wiKSBzZWFyY2ggPSBcIj9cIiArIHNlYXJjaDtcblx0XHQgICAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG5cdFx0ICAgIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKFwiI1wiLCBcIiUyM1wiKTtcblx0XHQgICAgcmV0dXJuIFwiXCIgKyBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG5cdFx0fVxuXHRcdGNvbnN0IHVybE9iamVjdEtleXMgPSBbXG5cdFx0ICAgIFwiYXV0aFwiLFxuXHRcdCAgICBcImhhc2hcIixcblx0XHQgICAgXCJob3N0XCIsXG5cdFx0ICAgIFwiaG9zdG5hbWVcIixcblx0XHQgICAgXCJocmVmXCIsXG5cdFx0ICAgIFwicGF0aFwiLFxuXHRcdCAgICBcInBhdGhuYW1lXCIsXG5cdFx0ICAgIFwicG9ydFwiLFxuXHRcdCAgICBcInByb3RvY29sXCIsXG5cdFx0ICAgIFwicXVlcnlcIixcblx0XHQgICAgXCJzZWFyY2hcIixcblx0XHQgICAgXCJzbGFzaGVzXCJcblx0XHRdO1xuXHRcdGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybCkge1xuXHRcdCAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuXHRcdCAgICAgICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiKSB7XG5cdFx0ICAgICAgICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpPT57XG5cdFx0ICAgICAgICAgICAgICAgIGlmICghdXJsT2JqZWN0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIGtleSBwYXNzZWQgdmlhIHVybE9iamVjdCBpbnRvIHVybC5mb3JtYXQ6IFwiICsga2V5KTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiBmb3JtYXRVcmwodXJsKTtcblx0XHR9XG5cblx0XHRcblx0fSAoZm9ybWF0VXJsKSk7XG5cdHJldHVybiBmb3JtYXRVcmw7XG59XG5cbnZhciBvbWl0JDIgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkT21pdDtcblxuZnVuY3Rpb24gcmVxdWlyZU9taXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRPbWl0KSByZXR1cm4gb21pdCQyO1xuXHRoYXNSZXF1aXJlZE9taXQgPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgICAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvbWl0XCIsIHtcblx0XHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBvbWl0O1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0ZnVuY3Rpb24gb21pdChvYmplY3QsIGtleXMpIHtcblx0XHQgICAgY29uc3Qgb21pdHRlZCA9IHt9O1xuXHRcdCAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goKGtleSk9Pntcblx0XHQgICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG5cdFx0ICAgICAgICAgICAgb21pdHRlZFtrZXldID0gb2JqZWN0W2tleV07XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgICByZXR1cm4gb21pdHRlZDtcblx0XHR9XG5cblx0XHRcblx0fSAob21pdCQyKSk7XG5cdHJldHVybiBvbWl0JDI7XG59XG5cbnZhciB1dGlscyQxID0ge307XG5cbnZhciBoYXNSZXF1aXJlZFV0aWxzJDE7XG5cbmZ1bmN0aW9uIHJlcXVpcmVVdGlscyQxICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVXRpbHMkMSkgcmV0dXJuIHV0aWxzJDE7XG5cdGhhc1JlcXVpcmVkVXRpbHMkMSA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdGZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcblx0XHQgICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG5cdFx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICAgICAgZ2V0OiBhbGxbbmFtZV1cblx0XHQgICAgfSk7XG5cdFx0fVxuXHRcdF9leHBvcnQoZXhwb3J0cywge1xuXHRcdCAgICBXRUJfVklUQUxTOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBXRUJfVklUQUxTO1xuXHRcdCAgICB9LFxuXHRcdCAgICBleGVjT25jZTogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gZXhlY09uY2U7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIGlzQWJzb2x1dGVVcmw6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIGlzQWJzb2x1dGVVcmw7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIGdldExvY2F0aW9uT3JpZ2luOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBnZXRMb2NhdGlvbk9yaWdpbjtcblx0XHQgICAgfSxcblx0XHQgICAgZ2V0VVJMOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBnZXRVUkw7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZTtcblx0XHQgICAgfSxcblx0XHQgICAgaXNSZXNTZW50OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBpc1Jlc1NlbnQ7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlczogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzO1xuXHRcdCAgICB9LFxuXHRcdCAgICBsb2FkR2V0SW5pdGlhbFByb3BzOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzO1xuXHRcdCAgICB9LFxuXHRcdCAgICBTUDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gU1A7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIFNUOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBTVDtcblx0XHQgICAgfSxcblx0XHQgICAgRGVjb2RlRXJyb3I6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIERlY29kZUVycm9yO1xuXHRcdCAgICB9LFxuXHRcdCAgICBOb3JtYWxpemVFcnJvcjogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gTm9ybWFsaXplRXJyb3I7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIFBhZ2VOb3RGb3VuZEVycm9yOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBQYWdlTm90Rm91bmRFcnJvcjtcblx0XHQgICAgfSxcblx0XHQgICAgTWlzc2luZ1N0YXRpY1BhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIE1pc3NpbmdTdGF0aWNQYWdlO1xuXHRcdCAgICB9LFxuXHRcdCAgICBNaWRkbGV3YXJlTm90Rm91bmRFcnJvcjogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gTWlkZGxld2FyZU5vdEZvdW5kRXJyb3I7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIHN0cmluZ2lmeUVycm9yOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBzdHJpbmdpZnlFcnJvcjtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGNvbnN0IFdFQl9WSVRBTFMgPSBbXG5cdFx0ICAgIFwiQ0xTXCIsXG5cdFx0ICAgIFwiRkNQXCIsXG5cdFx0ICAgIFwiRklEXCIsXG5cdFx0ICAgIFwiSU5QXCIsXG5cdFx0ICAgIFwiTENQXCIsXG5cdFx0ICAgIFwiVFRGQlwiXG5cdFx0XTtcblx0XHRmdW5jdGlvbiBleGVjT25jZShmbikge1xuXHRcdCAgICBsZXQgdXNlZCA9IGZhbHNlO1xuXHRcdCAgICBsZXQgcmVzdWx0O1xuXHRcdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG5cdFx0ICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICghdXNlZCkge1xuXHRcdCAgICAgICAgICAgIHVzZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0XHQgICAgfTtcblx0XHR9XG5cdFx0Ly8gU2NoZW1lOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMVxuXHRcdC8vIEFic29sdXRlIFVSTDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi00LjNcblx0XHRjb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi87XG5cdFx0Y29uc3QgaXNBYnNvbHV0ZVVybCA9ICh1cmwpPT5BQlNPTFVURV9VUkxfUkVHRVgudGVzdCh1cmwpO1xuXHRcdGZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuXHRcdCAgICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uO1xuXHRcdCAgICByZXR1cm4gcHJvdG9jb2wgKyBcIi8vXCIgKyBob3N0bmFtZSArIChwb3J0ID8gXCI6XCIgKyBwb3J0IDogXCJcIik7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGdldFVSTCgpIHtcblx0XHQgICAgY29uc3QgeyBocmVmIH0gPSB3aW5kb3cubG9jYXRpb247XG5cdFx0ICAgIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKCk7XG5cdFx0ICAgIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KSB7XG5cdFx0ICAgIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiID8gQ29tcG9uZW50IDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiVW5rbm93blwiO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBpc1Jlc1NlbnQocmVzKSB7XG5cdFx0ICAgIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50O1xuXHRcdH1cblx0XHRmdW5jdGlvbiBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXModXJsKSB7XG5cdFx0ICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KFwiP1wiKTtcblx0XHQgICAgY29uc3QgdXJsTm9RdWVyeSA9IHVybFBhcnRzWzBdO1xuXHRcdCAgICByZXR1cm4gdXJsTm9RdWVyeS8vIGZpcnN0IHdlIHJlcGxhY2UgYW55IG5vbi1lbmNvZGVkIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZFxuXHRcdCAgICAvLyB0aGVuIG5vcm1hbGl6ZSByZXBlYXRlZCBmb3J3YXJkIHNsYXNoZXNcblx0XHQgICAgLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpICsgKHVybFBhcnRzWzFdID8gXCI/XCIgKyB1cmxQYXJ0cy5zbGljZSgxKS5qb2luKFwiP1wiKSA6IFwiXCIpO1xuXHRcdH1cblx0XHRhc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgY3R4KSB7XG5cdFx0ICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcblx0XHQgICAgICAgIHZhciBfQXBwX3Byb3RvdHlwZTtcblx0XHQgICAgICAgIGlmICgoX0FwcF9wcm90b3R5cGUgPSBBcHAucHJvdG90eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX0FwcF9wcm90b3R5cGUuZ2V0SW5pdGlhbFByb3BzKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdcIicgKyBnZXREaXNwbGF5TmFtZShBcHApICsgJy5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLic7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcblx0XHQgICAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCBjdHguY3R4ICYmIGN0eC5jdHgucmVzO1xuXHRcdCAgICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcblx0XHQgICAgICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcblx0XHQgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0XHQgICAgICAgICAgICAgICAgcGFnZVByb3BzOiBhd2FpdCBsb2FkR2V0SW5pdGlhbFByb3BzKGN0eC5Db21wb25lbnQsIGN0eC5jdHgpXG5cdFx0ICAgICAgICAgICAgfTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiB7fTtcblx0XHQgICAgfVxuXHRcdCAgICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KTtcblx0XHQgICAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuXHRcdCAgICAgICAgcmV0dXJuIHByb3BzO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmICghcHJvcHMpIHtcblx0XHQgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnXCInICsgZ2V0RGlzcGxheU5hbWUoQXBwKSArICcuZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIicgKyBwcm9wcyArICdcIiBpbnN0ZWFkLic7XG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuXHRcdCAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcblx0XHQgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcIiArIGdldERpc3BsYXlOYW1lKEFwcCkgKyBcIiByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBgZ2V0SW5pdGlhbFByb3BzYC4gVGhpcyBkZS1vcHRpbWl6ZXMgYW5kIHByZXZlbnRzIGF1dG9tYXRpYyBzdGF0aWMgb3B0aW1pemF0aW9uLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzXCIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiBwcm9wcztcblx0XHR9XG5cdFx0Y29uc3QgU1AgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCI7XG5cdFx0Y29uc3QgU1QgPSBTUCAmJiBbXG5cdFx0ICAgIFwibWFya1wiLFxuXHRcdCAgICBcIm1lYXN1cmVcIixcblx0XHQgICAgXCJnZXRFbnRyaWVzQnlOYW1lXCJcblx0XHRdLmV2ZXJ5KChtZXRob2QpPT50eXBlb2YgcGVyZm9ybWFuY2VbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiKTtcblx0XHRjbGFzcyBEZWNvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcblx0XHR9XG5cdFx0Y2xhc3MgTm9ybWFsaXplRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdFx0fVxuXHRcdGNsYXNzIFBhZ2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRcdCAgICBjb25zdHJ1Y3RvcihwYWdlKXtcblx0XHQgICAgICAgIHN1cGVyKCk7XG5cdFx0ICAgICAgICB0aGlzLmNvZGUgPSBcIkVOT0VOVFwiO1xuXHRcdCAgICAgICAgdGhpcy5uYW1lID0gXCJQYWdlTm90Rm91bmRFcnJvclwiO1xuXHRcdCAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJDYW5ub3QgZmluZCBtb2R1bGUgZm9yIHBhZ2U6IFwiICsgcGFnZTtcblx0XHQgICAgfVxuXHRcdH1cblx0XHRjbGFzcyBNaXNzaW5nU3RhdGljUGFnZSBleHRlbmRzIEVycm9yIHtcblx0XHQgICAgY29uc3RydWN0b3IocGFnZSwgbWVzc2FnZSl7XG5cdFx0ICAgICAgICBzdXBlcigpO1xuXHRcdCAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJGYWlsZWQgdG8gbG9hZCBzdGF0aWMgZmlsZSBmb3IgcGFnZTogXCIgKyBwYWdlICsgXCIgXCIgKyBtZXNzYWdlO1xuXHRcdCAgICB9XG5cdFx0fVxuXHRcdGNsYXNzIE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRcdCAgICBjb25zdHJ1Y3Rvcigpe1xuXHRcdCAgICAgICAgc3VwZXIoKTtcblx0XHQgICAgICAgIHRoaXMuY29kZSA9IFwiRU5PRU5UXCI7XG5cdFx0ICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkNhbm5vdCBmaW5kIHRoZSBtaWRkbGV3YXJlIG1vZHVsZVwiO1xuXHRcdCAgICB9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHN0cmluZ2lmeUVycm9yKGVycm9yKSB7XG5cdFx0ICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG5cdFx0ICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuXHRcdCAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXG5cdFx0ICAgIH0pO1xuXHRcdH1cblxuXHRcdFxuXHR9ICh1dGlscyQxKSk7XG5cdHJldHVybiB1dGlscyQxO1xufVxuXG52YXIgbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciByZW1vdmVUcmFpbGluZ1NsYXNoID0ge307XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgdHJhaWxpbmcgc2xhc2ggZm9yIGEgZ2l2ZW4gcm91dGUgb3IgcGFnZSBwYXRoLiBQcmVzZXJ2ZXMgdGhlXG4gKiByb290IHBhZ2UuIEV4YW1wbGVzOlxuICogICAtIGAvZm9vL2Jhci9gIC0+IGAvZm9vL2JhcmBcbiAqICAgLSBgL2Zvby9iYXJgIC0+IGAvZm9vL2JhcmBcbiAqICAgLSBgL2AgLT4gYC9gXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkUmVtb3ZlVHJhaWxpbmdTbGFzaDtcblxuZnVuY3Rpb24gcmVxdWlyZVJlbW92ZVRyYWlsaW5nU2xhc2ggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRSZW1vdmVUcmFpbGluZ1NsYXNoKSByZXR1cm4gcmVtb3ZlVHJhaWxpbmdTbGFzaDtcblx0aGFzUmVxdWlyZWRSZW1vdmVUcmFpbGluZ1NsYXNoID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlVHJhaWxpbmdTbGFzaFwiLCB7XG5cdFx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gcmVtb3ZlVHJhaWxpbmdTbGFzaDtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2xhc2gocm91dGUpIHtcblx0XHQgICAgcmV0dXJuIHJvdXRlLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSB8fCBcIi9cIjtcblx0XHR9XG5cblx0XHRcblx0fSAocmVtb3ZlVHJhaWxpbmdTbGFzaCkpO1xuXHRyZXR1cm4gcmVtb3ZlVHJhaWxpbmdTbGFzaDtcbn1cblxudmFyIHBhcnNlUGF0aCA9IHt9O1xuXG4vKipcbiAqIEdpdmVuIGEgcGF0aCB0aGlzIGZ1bmN0aW9uIHdpbGwgZmluZCB0aGUgcGF0aG5hbWUsIHF1ZXJ5IGFuZCBoYXNoIGFuZCByZXR1cm5cbiAqIHRoZW0uIFRoaXMgaXMgdXNlZnVsIHRvIHBhcnNlIGZ1bGwgcGF0aHMgb24gdGhlIGNsaWVudCBzaWRlLlxuICogQHBhcmFtIHBhdGggQSBwYXRoIHRvIHBhcnNlIGUuZy4gL2Zvby9iYXI/aWQ9MSNoYXNoXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkUGFyc2VQYXRoO1xuXG5mdW5jdGlvbiByZXF1aXJlUGFyc2VQYXRoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkUGFyc2VQYXRoKSByZXR1cm4gcGFyc2VQYXRoO1xuXHRoYXNSZXF1aXJlZFBhcnNlUGF0aCA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlUGF0aFwiLCB7XG5cdFx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gcGFyc2VQYXRoO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0ZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcblx0XHQgICAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKTtcblx0XHQgICAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG5cdFx0ICAgIGNvbnN0IGhhc1F1ZXJ5ID0gcXVlcnlJbmRleCA+IC0xICYmIChoYXNoSW5kZXggPCAwIHx8IHF1ZXJ5SW5kZXggPCBoYXNoSW5kZXgpO1xuXHRcdCAgICBpZiAoaGFzUXVlcnkgfHwgaGFzaEluZGV4ID4gLTEpIHtcblx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0ICAgICAgICAgICAgcGF0aG5hbWU6IHBhdGguc3Vic3RyaW5nKDAsIGhhc1F1ZXJ5ID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCksXG5cdFx0ICAgICAgICAgICAgcXVlcnk6IGhhc1F1ZXJ5ID8gcGF0aC5zdWJzdHJpbmcocXVlcnlJbmRleCwgaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiB1bmRlZmluZWQpIDogXCJcIixcblx0XHQgICAgICAgICAgICBoYXNoOiBoYXNoSW5kZXggPiAtMSA/IHBhdGguc2xpY2UoaGFzaEluZGV4KSA6IFwiXCJcblx0XHQgICAgICAgIH07XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIHtcblx0XHQgICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuXHRcdCAgICAgICAgcXVlcnk6IFwiXCIsXG5cdFx0ICAgICAgICBoYXNoOiBcIlwiXG5cdFx0ICAgIH07XG5cdFx0fVxuXG5cdFx0XG5cdH0gKHBhcnNlUGF0aCkpO1xuXHRyZXR1cm4gcGFyc2VQYXRoO1xufVxuXG52YXIgaGFzUmVxdWlyZWROb3JtYWxpemVUcmFpbGluZ1NsYXNoO1xuXG5mdW5jdGlvbiByZXF1aXJlTm9ybWFsaXplVHJhaWxpbmdTbGFzaCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZE5vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpIHJldHVybiBub3JtYWxpemVUcmFpbGluZ1NsYXNoLmV4cG9ydHM7XG5cdGhhc1JlcXVpcmVkTm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IDE7XG5cdChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2hcIiwge1xuXHRcdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlUmVtb3ZlVHJhaWxpbmdTbGFzaCgpO1xuXHRcdGNvbnN0IF9wYXJzZXBhdGggPSByZXF1aXJlUGFyc2VQYXRoKCk7XG5cdFx0Y29uc3Qgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggPSAocGF0aCk9Pntcblx0XHQgICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpIHx8IHByb2Nlc3MuZW52Ll9fTkVYVF9NQU5VQUxfVFJBSUxJTkdfU0xBU0gpIHtcblx0XHQgICAgICAgIHJldHVybiBwYXRoO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoIH0gPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHBhdGgpO1xuXHRcdCAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKSB7XG5cdFx0ICAgICAgICBpZiAoL1xcLlteL10rXFwvPyQvLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpICsgcXVlcnkgKyBoYXNoO1xuXHRcdCAgICAgICAgfSBlbHNlIGlmIChwYXRobmFtZS5lbmRzV2l0aChcIi9cIikpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gXCJcIiArIHBhdGhuYW1lICsgcXVlcnkgKyBoYXNoO1xuXHRcdCAgICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcGF0aG5hbWUgKyBcIi9cIiArIHF1ZXJ5ICsgaGFzaDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gXCJcIiArICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSkgKyBxdWVyeSArIGhhc2g7XG5cdFx0fTtcblxuXHRcdGlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuXHRcdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRcdCAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuXHRcdCAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cdFx0fVxuXG5cdFx0XG5cdH0gKG5vcm1hbGl6ZVRyYWlsaW5nU2xhc2gsIG5vcm1hbGl6ZVRyYWlsaW5nU2xhc2guZXhwb3J0cykpO1xuXHRyZXR1cm4gbm9ybWFsaXplVHJhaWxpbmdTbGFzaC5leHBvcnRzO1xufVxuXG52YXIgaXNMb2NhbFVybCA9IHt9O1xuXG52YXIgaGFzQmFzZVBhdGggPSB7ZXhwb3J0czoge319O1xuXG52YXIgcGF0aEhhc1ByZWZpeCA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRQYXRoSGFzUHJlZml4O1xuXG5mdW5jdGlvbiByZXF1aXJlUGF0aEhhc1ByZWZpeCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFBhdGhIYXNQcmVmaXgpIHJldHVybiBwYXRoSGFzUHJlZml4O1xuXHRoYXNSZXF1aXJlZFBhdGhIYXNQcmVmaXggPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgICAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXRoSGFzUHJlZml4XCIsIHtcblx0XHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBwYXRoSGFzUHJlZml4O1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3QgX3BhcnNlcGF0aCA9IHJlcXVpcmVQYXJzZVBhdGgoKTtcblx0XHRmdW5jdGlvbiBwYXRoSGFzUHJlZml4KHBhdGgsIHByZWZpeCkge1xuXHRcdCAgICBpZiAodHlwZW9mIHBhdGggIT09IFwic3RyaW5nXCIpIHtcblx0XHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgfVxuXHRcdCAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHBhdGgpO1xuXHRcdCAgICByZXR1cm4gcGF0aG5hbWUgPT09IHByZWZpeCB8fCBwYXRobmFtZS5zdGFydHNXaXRoKHByZWZpeCArIFwiL1wiKTtcblx0XHR9XG5cblx0XHRcblx0fSAocGF0aEhhc1ByZWZpeCkpO1xuXHRyZXR1cm4gcGF0aEhhc1ByZWZpeDtcbn1cblxudmFyIGhhc1JlcXVpcmVkSGFzQmFzZVBhdGg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVIYXNCYXNlUGF0aCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEhhc0Jhc2VQYXRoKSByZXR1cm4gaGFzQmFzZVBhdGguZXhwb3J0cztcblx0aGFzUmVxdWlyZWRIYXNCYXNlUGF0aCA9IDE7XG5cdChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzQmFzZVBhdGhcIiwge1xuXHRcdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIGhhc0Jhc2VQYXRoO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3QgX3BhdGhoYXNwcmVmaXggPSByZXF1aXJlUGF0aEhhc1ByZWZpeCgpO1xuXHRcdGNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuXHRcdGZ1bmN0aW9uIGhhc0Jhc2VQYXRoKHBhdGgpIHtcblx0XHQgICAgcmV0dXJuICgwLCBfcGF0aGhhc3ByZWZpeC5wYXRoSGFzUHJlZml4KShwYXRoLCBiYXNlUGF0aCk7XG5cdFx0fVxuXG5cdFx0aWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG5cdFx0ICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblx0XHR9XG5cblx0XHRcblx0fSAoaGFzQmFzZVBhdGgsIGhhc0Jhc2VQYXRoLmV4cG9ydHMpKTtcblx0cmV0dXJuIGhhc0Jhc2VQYXRoLmV4cG9ydHM7XG59XG5cbnZhciBoYXNSZXF1aXJlZElzTG9jYWxVcmw7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJc0xvY2FsVXJsICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSXNMb2NhbFVybCkgcmV0dXJuIGlzTG9jYWxVcmw7XG5cdGhhc1JlcXVpcmVkSXNMb2NhbFVybCA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzTG9jYWxVUkxcIiwge1xuXHRcdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIGlzTG9jYWxVUkw7XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRjb25zdCBfdXRpbHMgPSByZXF1aXJlVXRpbHMkMSgpO1xuXHRcdGNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmVIYXNCYXNlUGF0aCgpO1xuXHRcdGZ1bmN0aW9uIGlzTG9jYWxVUkwodXJsKSB7XG5cdFx0ICAgIC8vIHByZXZlbnQgYSBoeWRyYXRpb24gbWlzbWF0Y2ggb24gaHJlZiBmb3IgdXJsIHdpdGggYW5jaG9yIHJlZnNcblx0XHQgICAgaWYgKCEoMCwgX3V0aWxzLmlzQWJzb2x1dGVVcmwpKHVybCkpIHJldHVybiB0cnVlO1xuXHRcdCAgICB0cnkge1xuXHRcdCAgICAgICAgLy8gYWJzb2x1dGUgdXJscyBjYW4gYmUgbG9jYWwgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgb3JpZ2luXG5cdFx0ICAgICAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG5cdFx0ICAgICAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbik7XG5cdFx0ICAgICAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShyZXNvbHZlZC5wYXRobmFtZSk7XG5cdFx0ICAgIH0gY2F0Y2ggKF8pIHtcblx0XHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgfVxuXHRcdH1cblxuXHRcdFxuXHR9IChpc0xvY2FsVXJsKSk7XG5cdHJldHVybiBpc0xvY2FsVXJsO1xufVxuXG52YXIgdXRpbHMgPSB7fTtcblxudmFyIHNvcnRlZFJvdXRlcyA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRTb3J0ZWRSb3V0ZXM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVTb3J0ZWRSb3V0ZXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRTb3J0ZWRSb3V0ZXMpIHJldHVybiBzb3J0ZWRSb3V0ZXM7XG5cdGhhc1JlcXVpcmVkU29ydGVkUm91dGVzID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0U29ydGVkUm91dGVzXCIsIHtcblx0XHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBnZXRTb3J0ZWRSb3V0ZXM7XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRjbGFzcyBVcmxOb2RlIHtcblx0XHQgICAgaW5zZXJ0KHVybFBhdGgpIHtcblx0XHQgICAgICAgIHRoaXMuX2luc2VydCh1cmxQYXRoLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbiksIFtdLCBmYWxzZSk7XG5cdFx0ICAgIH1cblx0XHQgICAgc21vb3NoKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIHRoaXMuX3Ntb29zaCgpO1xuXHRcdCAgICB9XG5cdFx0ICAgIF9zbW9vc2gocHJlZml4KSB7XG5cdFx0ICAgICAgICBpZiAocHJlZml4ID09PSB2b2lkIDApIHByZWZpeCA9IFwiL1wiO1xuXHRcdCAgICAgICAgY29uc3QgY2hpbGRyZW5QYXRocyA9IFtcblx0XHQgICAgICAgICAgICAuLi50aGlzLmNoaWxkcmVuLmtleXMoKVxuXHRcdCAgICAgICAgXS5zb3J0KCk7XG5cdFx0ICAgICAgICBpZiAodGhpcy5zbHVnTmFtZSAhPT0gbnVsbCkge1xuXHRcdCAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIltdXCIpLCAxKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh0aGlzLnJlc3RTbHVnTmFtZSAhPT0gbnVsbCkge1xuXHRcdCAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZihcIlsuLi5dXCIpLCAxKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9PSBudWxsKSB7XG5cdFx0ICAgICAgICAgICAgY2hpbGRyZW5QYXRocy5zcGxpY2UoY2hpbGRyZW5QYXRocy5pbmRleE9mKFwiW1suLi5dXVwiKSwgMSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjb25zdCByb3V0ZXMgPSBjaGlsZHJlblBhdGhzLm1hcCgoYyk9PnRoaXMuY2hpbGRyZW4uZ2V0KGMpLl9zbW9vc2goXCJcIiArIHByZWZpeCArIGMgKyBcIi9cIikpLnJlZHVjZSgocHJldiwgY3Vycik9Pltcblx0XHQgICAgICAgICAgICAgICAgLi4ucHJldixcblx0XHQgICAgICAgICAgICAgICAgLi4uY3VyclxuXHRcdCAgICAgICAgICAgIF0sIFtdKTtcblx0XHQgICAgICAgIGlmICh0aGlzLnNsdWdOYW1lICE9PSBudWxsKSB7XG5cdFx0ICAgICAgICAgICAgcm91dGVzLnB1c2goLi4udGhpcy5jaGlsZHJlbi5nZXQoXCJbXVwiKS5fc21vb3NoKHByZWZpeCArIFwiW1wiICsgdGhpcy5zbHVnTmFtZSArIFwiXS9cIikpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKCF0aGlzLnBsYWNlaG9sZGVyKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgciA9IHByZWZpeCA9PT0gXCIvXCIgPyBcIi9cIiA6IHByZWZpeC5zbGljZSgwLCAtMSk7XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT0gbnVsbCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgZGVmaW5lIGEgcm91dGUgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2l0eSBhcyBhIG9wdGlvbmFsIGNhdGNoLWFsbCByb3V0ZSAoXCInICsgciArICdcIiBhbmQgXCInICsgciArIFwiW1suLi5cIiArIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgKyAnXV1cIikuJyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHJvdXRlcy51bnNoaWZ0KHIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHRoaXMucmVzdFNsdWdOYW1lICE9PSBudWxsKSB7XG5cdFx0ICAgICAgICAgICAgcm91dGVzLnB1c2goLi4udGhpcy5jaGlsZHJlbi5nZXQoXCJbLi4uXVwiKS5fc21vb3NoKHByZWZpeCArIFwiWy4uLlwiICsgdGhpcy5yZXN0U2x1Z05hbWUgKyBcIl0vXCIpKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9PSBudWxsKSB7XG5cdFx0ICAgICAgICAgICAgcm91dGVzLnB1c2goLi4udGhpcy5jaGlsZHJlbi5nZXQoXCJbWy4uLl1dXCIpLl9zbW9vc2gocHJlZml4ICsgXCJbWy4uLlwiICsgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSArIFwiXV0vXCIpKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiByb3V0ZXM7XG5cdFx0ICAgIH1cblx0XHQgICAgX2luc2VydCh1cmxQYXRocywgc2x1Z05hbWVzLCBpc0NhdGNoQWxsKSB7XG5cdFx0ICAgICAgICBpZiAodXJsUGF0aHMubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChpc0NhdGNoQWxsKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2F0Y2gtYWxsIG11c3QgYmUgdGhlIGxhc3QgcGFydCBvZiB0aGUgVVJMLlwiKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIFRoZSBuZXh0IHNlZ21lbnQgaW4gdGhlIHVybFBhdGhzIGxpc3Rcblx0XHQgICAgICAgIGxldCBuZXh0U2VnbWVudCA9IHVybFBhdGhzWzBdO1xuXHRcdCAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNlZ21lbnQgbWF0Y2hlcyBgW3NvbWV0aGluZ11gXG5cdFx0ICAgICAgICBpZiAobmV4dFNlZ21lbnQuc3RhcnRzV2l0aChcIltcIikgJiYgbmV4dFNlZ21lbnQuZW5kc1dpdGgoXCJdXCIpKSB7XG5cdFx0ICAgICAgICAgICAgLy8gU3RyaXAgYFtgIGFuZCBgXWAsIGxlYXZpbmcgb25seSBgc29tZXRoaW5nYFxuXHRcdCAgICAgICAgICAgIGxldCBzZWdtZW50TmFtZSA9IG5leHRTZWdtZW50LnNsaWNlKDEsIC0xKTtcblx0XHQgICAgICAgICAgICBsZXQgaXNPcHRpb25hbCA9IGZhbHNlO1xuXHRcdCAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiW1wiKSAmJiBzZWdtZW50TmFtZS5lbmRzV2l0aChcIl1cIikpIHtcblx0XHQgICAgICAgICAgICAgICAgLy8gU3RyaXAgb3B0aW9uYWwgYFtgIGFuZCBgXWAsIGxlYXZpbmcgb25seSBgc29tZXRoaW5nYFxuXHRcdCAgICAgICAgICAgICAgICBzZWdtZW50TmFtZSA9IHNlZ21lbnROYW1lLnNsaWNlKDEsIC0xKTtcblx0XHQgICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGlmIChzZWdtZW50TmFtZS5zdGFydHNXaXRoKFwiLi4uXCIpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIC8vIFN0cmlwIGAuLi5gLCBsZWF2aW5nIG9ubHkgYHNvbWV0aGluZ2Bcblx0XHQgICAgICAgICAgICAgICAgc2VnbWVudE5hbWUgPSBzZWdtZW50TmFtZS5zdWJzdHJpbmcoMyk7XG5cdFx0ICAgICAgICAgICAgICAgIGlzQ2F0Y2hBbGwgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAoc2VnbWVudE5hbWUuc3RhcnRzV2l0aChcIltcIikgfHwgc2VnbWVudE5hbWUuZW5kc1dpdGgoXCJdXCIpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlZ21lbnQgbmFtZXMgbWF5IG5vdCBzdGFydCBvciBlbmQgd2l0aCBleHRyYSBicmFja2V0cyAoJ1wiICsgc2VnbWVudE5hbWUgKyBcIicpLlwiKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKHNlZ21lbnROYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlZ21lbnQgbmFtZXMgbWF5IG5vdCBzdGFydCB3aXRoIGVycm9uZW91cyBwZXJpb2RzICgnXCIgKyBzZWdtZW50TmFtZSArIFwiJykuXCIpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVTbHVnKHByZXZpb3VzU2x1ZywgbmV4dFNsdWcpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU2x1ZyAhPT0gbnVsbCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNwZWNpZmljIHNlZ21lbnQgYWxyZWFkeSBoYXMgYSBzbHVnIGJ1dCB0aGUgc2x1ZyBpcyBub3QgYHNvbWV0aGluZ2Bcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgY29sbGlzaW9ucyBsaWtlOlxuXHRcdCAgICAgICAgICAgICAgICAgICAgLy8gcGFnZXMvW3Bvc3RdL2luZGV4LmpzXG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBwYWdlcy9baWRdL2luZGV4LmpzXG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGN1cnJlbnRseSBtdWx0aXBsZSBkeW5hbWljIHBhcmFtcyBvbiB0aGUgc2FtZSBzZWdtZW50IGxldmVsIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNTbHVnICE9PSBuZXh0U2x1Zykge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXJyb3Igc2VlbXMgdG8gYmUgY29uZnVzaW5nIGZvciB1c2VycywgbmVlZHMgYW4gZXJyb3IgbGluaywgdGhlIGRlc2NyaXB0aW9uIGNhbiBiZSBiYXNlZCBvbiBhYm92ZSBjb21tZW50LlxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgdXNlIGRpZmZlcmVudCBzbHVnIG5hbWVzIGZvciB0aGUgc2FtZSBkeW5hbWljIHBhdGggKCdcIiArIHByZXZpb3VzU2x1ZyArIFwiJyAhPT0gJ1wiICsgbmV4dFNsdWcgKyBcIicpLlwiKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBzbHVnTmFtZXMuZm9yRWFjaCgoc2x1Zyk9Pntcblx0XHQgICAgICAgICAgICAgICAgICAgIGlmIChzbHVnID09PSBuZXh0U2x1Zykge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBoYXZlIHRoZSBzYW1lIHNsdWcgbmFtZSBcIicgKyBuZXh0U2x1ZyArICdcIiByZXBlYXQgd2l0aGluIGEgc2luZ2xlIGR5bmFtaWMgcGF0aCcpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgaWYgKHNsdWcucmVwbGFjZSgvXFxXL2csIFwiXCIpID09PSBuZXh0U2VnbWVudC5yZXBsYWNlKC9cXFcvZywgXCJcIikpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgaGF2ZSB0aGUgc2x1ZyBuYW1lcyBcIicgKyBzbHVnICsgJ1wiIGFuZCBcIicgKyBuZXh0U2x1ZyArICdcIiBkaWZmZXIgb25seSBieSBub24td29yZCBzeW1ib2xzIHdpdGhpbiBhIHNpbmdsZSBkeW5hbWljIHBhdGgnKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5wdXNoKG5leHRTbHVnKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgaWYgKGlzQ2F0Y2hBbGwpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3RTbHVnTmFtZSAhPSBudWxsKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBib3RoIGFuIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBjYXRjaC1hbGwgcm91dGUgYXQgdGhlIHNhbWUgbGV2ZWwgKFwiWy4uLicgKyB0aGlzLnJlc3RTbHVnTmFtZSArICddXCIgYW5kIFwiJyArIHVybFBhdGhzWzBdICsgJ1wiICkuJyk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICBoYW5kbGVTbHVnKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUsIHNlZ21lbnROYW1lKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIHNsdWdOYW1lIGlzIGtlcHQgYXMgaXQgY2FuIG9ubHkgYmUgb25lIHBhcnRpY3VsYXIgc2x1Z05hbWVcblx0XHQgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgPSBzZWdtZW50TmFtZTtcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIG5leHRTZWdtZW50IGlzIG92ZXJ3cml0dGVuIHRvIFtbLi4uXV0gc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgc29ydGVkIHNwZWNpZmljYWxseVxuXHRcdCAgICAgICAgICAgICAgICAgICAgbmV4dFNlZ21lbnQgPSBcIltbLi4uXV1cIjtcblx0XHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9IG51bGwpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgdXNlIGJvdGggYW4gb3B0aW9uYWwgYW5kIHJlcXVpcmVkIGNhdGNoLWFsbCByb3V0ZSBhdCB0aGUgc2FtZSBsZXZlbCAoXCJbWy4uLicgKyB0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICsgJ11dXCIgYW5kIFwiJyArIHVybFBhdGhzWzBdICsgJ1wiKS4nKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgIGhhbmRsZVNsdWcodGhpcy5yZXN0U2x1Z05hbWUsIHNlZ21lbnROYW1lKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIHNsdWdOYW1lIGlzIGtlcHQgYXMgaXQgY2FuIG9ubHkgYmUgb25lIHBhcnRpY3VsYXIgc2x1Z05hbWVcblx0XHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdFNsdWdOYW1lID0gc2VnbWVudE5hbWU7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBuZXh0U2VnbWVudCBpcyBvdmVyd3JpdHRlbiB0byBbLi4uXSBzbyB0aGF0IGl0IGNhbiBsYXRlciBiZSBzb3J0ZWQgc3BlY2lmaWNhbGx5XG5cdFx0ICAgICAgICAgICAgICAgICAgICBuZXh0U2VnbWVudCA9IFwiWy4uLl1cIjtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmIChpc09wdGlvbmFsKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbmFsIHJvdXRlIHBhcmFtZXRlcnMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIChcIicgKyB1cmxQYXRoc1swXSArICdcIikuJyk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgaGFuZGxlU2x1Zyh0aGlzLnNsdWdOYW1lLCBzZWdtZW50TmFtZSk7XG5cdFx0ICAgICAgICAgICAgICAgIC8vIHNsdWdOYW1lIGlzIGtlcHQgYXMgaXQgY2FuIG9ubHkgYmUgb25lIHBhcnRpY3VsYXIgc2x1Z05hbWVcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5zbHVnTmFtZSA9IHNlZ21lbnROYW1lO1xuXHRcdCAgICAgICAgICAgICAgICAvLyBuZXh0U2VnbWVudCBpcyBvdmVyd3JpdHRlbiB0byBbXSBzbyB0aGF0IGl0IGNhbiBsYXRlciBiZSBzb3J0ZWQgc3BlY2lmaWNhbGx5XG5cdFx0ICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gXCJbXVwiO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIElmIHRoaXMgVXJsTm9kZSBkb2Vzbid0IGhhdmUgdGhlIG5leHRTZWdtZW50IHlldCB3ZSBjcmVhdGUgYSBuZXcgY2hpbGQgVXJsTm9kZVxuXHRcdCAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuLmhhcyhuZXh0U2VnbWVudCkpIHtcblx0XHQgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNldChuZXh0U2VnbWVudCwgbmV3IFVybE5vZGUoKSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB0aGlzLmNoaWxkcmVuLmdldChuZXh0U2VnbWVudCkuX2luc2VydCh1cmxQYXRocy5zbGljZSgxKSwgc2x1Z05hbWVzLCBpc0NhdGNoQWxsKTtcblx0XHQgICAgfVxuXHRcdCAgICBjb25zdHJ1Y3Rvcigpe1xuXHRcdCAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHRydWU7XG5cdFx0ICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IE1hcCgpO1xuXHRcdCAgICAgICAgdGhpcy5zbHVnTmFtZSA9IG51bGw7XG5cdFx0ICAgICAgICB0aGlzLnJlc3RTbHVnTmFtZSA9IG51bGw7XG5cdFx0ICAgICAgICB0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lID0gbnVsbDtcblx0XHQgICAgfVxuXHRcdH1cblx0XHRmdW5jdGlvbiBnZXRTb3J0ZWRSb3V0ZXMobm9ybWFsaXplZFBhZ2VzKSB7XG5cdFx0ICAgIC8vIEZpcnN0IHRoZSBVcmxOb2RlIGlzIGNyZWF0ZWQsIGFuZCBldmVyeSBVcmxOb2RlIGNhbiBoYXZlIG9ubHkgMSBkeW5hbWljIHNlZ21lbnRcblx0XHQgICAgLy8gRWcgeW91IGNhbid0IGhhdmUgcGFnZXMvW3Bvc3RdL2FiYy5qcyBhbmQgcGFnZXMvW2hlbGxvXS9zb21ldGhpbmctZWxzZS5qc1xuXHRcdCAgICAvLyBPbmx5IDEgZHluYW1pYyBzZWdtZW50IHBlciBuZXN0aW5nIGxldmVsXG5cdFx0ICAgIC8vIFNvIGluIHRoZSBjYXNlIHRoYXQgaXMgdGVzdC9pbnRlZ3JhdGlvbi9keW5hbWljLXJvdXRpbmcgaXQnbGwgYmUgdGhpczpcblx0XHQgICAgLy8gcGFnZXMvW3Bvc3RdL2NvbW1lbnRzLmpzXG5cdFx0ICAgIC8vIHBhZ2VzL2Jsb2cvW3Bvc3RdL2NvbW1lbnQvW2lkXS5qc1xuXHRcdCAgICAvLyBCb3RoIGFyZSBmaW5lIGJlY2F1c2UgYHBhZ2VzL1twb3N0XWAgYW5kIGBwYWdlcy9ibG9nYCBhcmUgb24gdGhlIHNhbWUgbGV2ZWxcblx0XHQgICAgLy8gU28gaW4gdGhpcyBjYXNlIGBVcmxOb2RlYCBjcmVhdGVkIGhlcmUgaGFzIGB0aGlzLnNsdWdOYW1lID09PSAncG9zdCdgXG5cdFx0ICAgIC8vIEFuZCBzaW5jZSB5b3VyIFBSIHBhc3NlZCB0aHJvdWdoIGBzbHVnTmFtZWAgYXMgYW4gYXJyYXkgYmFzaWNhbGx5IGl0J2QgaW5jbHVkaW5nIGl0IGluIHRvbyBtYW55IHBvc3NpYmlsaXRpZXNcblx0XHQgICAgLy8gSW5zdGVhZCB3aGF0IGhhcyB0byBiZSBwYXNzZWQgdGhyb3VnaCBpcyB0aGUgdXB3YXJkcyBwYXRoJ3MgZHluYW1pYyBuYW1lc1xuXHRcdCAgICBjb25zdCByb290ID0gbmV3IFVybE5vZGUoKTtcblx0XHQgICAgLy8gSGVyZSB0aGUgYHJvb3RgIGdldHMgaW5qZWN0ZWQgbXVsdGlwbGUgcGF0aHMsIGFuZCBpbnNlcnQgd2lsbCBicmVhayB0aGVtIHVwIGludG8gc3VibGV2ZWxzXG5cdFx0ICAgIG5vcm1hbGl6ZWRQYWdlcy5mb3JFYWNoKChwYWdlUGF0aCk9PnJvb3QuaW5zZXJ0KHBhZ2VQYXRoKSk7XG5cdFx0ICAgIC8vIFNtb29zaCB3aWxsIHRoZW4gc29ydCB0aG9zZSBzdWJsZXZlbHMgdXAgdG8gdGhlIHBvaW50IHdoZXJlIHlvdSBnZXQgdGhlIGNvcnJlY3Qgcm91dGUgZGVmaW5pdGlvbiBwcmlvcml0eVxuXHRcdCAgICByZXR1cm4gcm9vdC5zbW9vc2goKTtcblx0XHR9XG5cblx0XHRcblx0fSAoc29ydGVkUm91dGVzKSk7XG5cdHJldHVybiBzb3J0ZWRSb3V0ZXM7XG59XG5cbnZhciBpc0R5bmFtaWMgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkSXNEeW5hbWljO1xuXG5mdW5jdGlvbiByZXF1aXJlSXNEeW5hbWljICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSXNEeW5hbWljKSByZXR1cm4gaXNEeW5hbWljO1xuXHRoYXNSZXF1aXJlZElzRHluYW1pYyA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRHluYW1pY1JvdXRlXCIsIHtcblx0XHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBpc0R5bmFtaWNSb3V0ZTtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGNvbnN0IFRFU1RfUk9VVEUgPSAvXFwvXFxbW14vXSs/XFxdKD89XFwvfCQpLztcblx0XHRmdW5jdGlvbiBpc0R5bmFtaWNSb3V0ZShyb3V0ZSkge1xuXHRcdCAgICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKTtcblx0XHR9XG5cblx0XHRcblx0fSAoaXNEeW5hbWljKSk7XG5cdHJldHVybiBpc0R5bmFtaWM7XG59XG5cbnZhciBoYXNSZXF1aXJlZFV0aWxzO1xuXG5mdW5jdGlvbiByZXF1aXJlVXRpbHMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRVdGlscykgcmV0dXJuIHV0aWxzO1xuXHRoYXNSZXF1aXJlZFV0aWxzID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0ZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuXHRcdCAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcblx0XHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuXHRcdCAgICB9KTtcblx0XHR9XG5cdFx0X2V4cG9ydChleHBvcnRzLCB7XG5cdFx0ICAgIGdldFNvcnRlZFJvdXRlczogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gX3NvcnRlZHJvdXRlcy5nZXRTb3J0ZWRSb3V0ZXM7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIGlzRHluYW1pY1JvdXRlOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3QgX3NvcnRlZHJvdXRlcyA9IHJlcXVpcmVTb3J0ZWRSb3V0ZXMoKTtcblx0XHRjb25zdCBfaXNkeW5hbWljID0gcmVxdWlyZUlzRHluYW1pYygpO1xuXG5cdFx0XG5cdH0gKHV0aWxzKSk7XG5cdHJldHVybiB1dGlscztcbn1cblxudmFyIGludGVycG9sYXRlQXMgPSB7fTtcblxudmFyIHJvdXRlTWF0Y2hlciA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRSb3V0ZU1hdGNoZXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVSb3V0ZU1hdGNoZXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRSb3V0ZU1hdGNoZXIpIHJldHVybiByb3V0ZU1hdGNoZXI7XG5cdGhhc1JlcXVpcmVkUm91dGVNYXRjaGVyID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Um91dGVNYXRjaGVyXCIsIHtcblx0XHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBnZXRSb3V0ZU1hdGNoZXI7XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRjb25zdCBfdXRpbHMgPSByZXF1aXJlVXRpbHMkMSgpO1xuXHRcdGZ1bmN0aW9uIGdldFJvdXRlTWF0Y2hlcihwYXJhbSkge1xuXHRcdCAgICBsZXQgeyByZSwgZ3JvdXBzIH0gPSBwYXJhbTtcblx0XHQgICAgcmV0dXJuIChwYXRobmFtZSk9Pntcblx0XHQgICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcblx0XHQgICAgICAgIGlmICghcm91dGVNYXRjaCkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGNvbnN0IGRlY29kZSA9IChwYXJhbSk9Pntcblx0XHQgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKTtcblx0XHQgICAgICAgICAgICB9IGNhdGNoIChfKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBfdXRpbHMuRGVjb2RlRXJyb3IoXCJmYWlsZWQgdG8gZGVjb2RlIHBhcmFtXCIpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICBjb25zdCBwYXJhbXMgPSB7fTtcblx0XHQgICAgICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaCgoc2x1Z05hbWUpPT57XG5cdFx0ICAgICAgICAgICAgY29uc3QgZyA9IGdyb3Vwc1tzbHVnTmFtZV07XG5cdFx0ICAgICAgICAgICAgY29uc3QgbSA9IHJvdXRlTWF0Y2hbZy5wb3NdO1xuXHRcdCAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcblx0XHQgICAgICAgICAgICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IH5tLmluZGV4T2YoXCIvXCIpID8gbS5zcGxpdChcIi9cIikubWFwKChlbnRyeSk9PmRlY29kZShlbnRyeSkpIDogZy5yZXBlYXQgPyBbXG5cdFx0ICAgICAgICAgICAgICAgICAgICBkZWNvZGUobSlcblx0XHQgICAgICAgICAgICAgICAgXSA6IGRlY29kZShtKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHJldHVybiBwYXJhbXM7XG5cdFx0ICAgIH07XG5cdFx0fVxuXG5cdFx0XG5cdH0gKHJvdXRlTWF0Y2hlcikpO1xuXHRyZXR1cm4gcm91dGVNYXRjaGVyO1xufVxuXG52YXIgcm91dGVSZWdleCA9IHt9O1xuXG52YXIgaW50ZXJjZXB0aW9uUm91dGVzID0ge307XG5cbnZhciBhcHBQYXRocyA9IHt9O1xuXG52YXIgZW5zdXJlTGVhZGluZ1NsYXNoID0ge307XG5cbi8qKlxuICogRm9yIGEgZ2l2ZW4gcGFnZSBwYXRoLCB0aGlzIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBhIGxlYWRpbmcgc2xhc2guXG4gKiBJZiB0aGVyZSBpcyBub3QgYSBsZWFkaW5nIHNsYXNoLCBvbmUgaXMgYWRkZWQsIG90aGVyd2lzZSBpdCBpcyBub29wLlxuICovXG5cbnZhciBoYXNSZXF1aXJlZEVuc3VyZUxlYWRpbmdTbGFzaDtcblxuZnVuY3Rpb24gcmVxdWlyZUVuc3VyZUxlYWRpbmdTbGFzaCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEVuc3VyZUxlYWRpbmdTbGFzaCkgcmV0dXJuIGVuc3VyZUxlYWRpbmdTbGFzaDtcblx0aGFzUmVxdWlyZWRFbnN1cmVMZWFkaW5nU2xhc2ggPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgICAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbnN1cmVMZWFkaW5nU2xhc2hcIiwge1xuXHRcdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIGVuc3VyZUxlYWRpbmdTbGFzaDtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGZ1bmN0aW9uIGVuc3VyZUxlYWRpbmdTbGFzaChwYXRoKSB7XG5cdFx0ICAgIHJldHVybiBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpID8gcGF0aCA6IFwiL1wiICsgcGF0aDtcblx0XHR9XG5cblx0XHRcblx0fSAoZW5zdXJlTGVhZGluZ1NsYXNoKSk7XG5cdHJldHVybiBlbnN1cmVMZWFkaW5nU2xhc2g7XG59XG5cbnZhciBzZWdtZW50ID0ge307XG5cbnZhciBoYXNSZXF1aXJlZFNlZ21lbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVTZWdtZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkU2VnbWVudCkgcmV0dXJuIHNlZ21lbnQ7XG5cdGhhc1JlcXVpcmVkU2VnbWVudCA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzR3JvdXBTZWdtZW50XCIsIHtcblx0XHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBpc0dyb3VwU2VnbWVudDtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGZ1bmN0aW9uIGlzR3JvdXBTZWdtZW50KHNlZ21lbnQpIHtcblx0XHQgICAgLy8gVXNlIGFycmF5WzBdIGZvciBwZXJmb3JtYW50IHB1cnBvc2Vcblx0XHQgICAgcmV0dXJuIHNlZ21lbnRbMF0gPT09IFwiKFwiICYmIHNlZ21lbnQuZW5kc1dpdGgoXCIpXCIpO1xuXHRcdH1cblxuXHRcdFxuXHR9IChzZWdtZW50KSk7XG5cdHJldHVybiBzZWdtZW50O1xufVxuXG52YXIgaGFzUmVxdWlyZWRBcHBQYXRocztcblxuZnVuY3Rpb24gcmVxdWlyZUFwcFBhdGhzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQXBwUGF0aHMpIHJldHVybiBhcHBQYXRocztcblx0aGFzUmVxdWlyZWRBcHBQYXRocyA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdGZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcblx0XHQgICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG5cdFx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICAgICAgZ2V0OiBhbGxbbmFtZV1cblx0XHQgICAgfSk7XG5cdFx0fVxuXHRcdF9leHBvcnQoZXhwb3J0cywge1xuXHRcdCAgICBub3JtYWxpemVBcHBQYXRoOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBub3JtYWxpemVBcHBQYXRoO1xuXHRcdCAgICB9LFxuXHRcdCAgICBub3JtYWxpemVSc2NQYXRoOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBub3JtYWxpemVSc2NQYXRoO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3QgX2Vuc3VyZWxlYWRpbmdzbGFzaCA9IHJlcXVpcmVFbnN1cmVMZWFkaW5nU2xhc2goKTtcblx0XHRjb25zdCBfc2VnbWVudCA9IHJlcXVpcmVTZWdtZW50KCk7XG5cdFx0ZnVuY3Rpb24gbm9ybWFsaXplQXBwUGF0aChyb3V0ZSkge1xuXHRcdCAgICByZXR1cm4gKDAsIF9lbnN1cmVsZWFkaW5nc2xhc2guZW5zdXJlTGVhZGluZ1NsYXNoKShyb3V0ZS5zcGxpdChcIi9cIikucmVkdWNlKChwYXRobmFtZSwgc2VnbWVudCwgaW5kZXgsIHNlZ21lbnRzKT0+e1xuXHRcdCAgICAgICAgLy8gRW1wdHkgc2VnbWVudHMgYXJlIGlnbm9yZWQuXG5cdFx0ICAgICAgICBpZiAoIXNlZ21lbnQpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBHcm91cHMgYXJlIGlnbm9yZWQuXG5cdFx0ICAgICAgICBpZiAoKDAsIF9zZWdtZW50LmlzR3JvdXBTZWdtZW50KShzZWdtZW50KSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBwYXRobmFtZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIFBhcmFsbGVsIHNlZ21lbnRzIGFyZSBpZ25vcmVkLlxuXHRcdCAgICAgICAgaWYgKHNlZ21lbnRbMF0gPT09IFwiQFwiKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gVGhlIGxhc3Qgc2VnbWVudCAoaWYgaXQncyBhIGxlYWYpIHNob3VsZCBiZSBpZ25vcmVkLlxuXHRcdCAgICAgICAgaWYgKChzZWdtZW50ID09PSBcInBhZ2VcIiB8fCBzZWdtZW50ID09PSBcInJvdXRlXCIpICYmIGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGggLSAxKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIHBhdGhuYW1lICsgXCIvXCIgKyBzZWdtZW50O1xuXHRcdCAgICB9LCBcIlwiKSk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG5vcm1hbGl6ZVJzY1BhdGgocGF0aG5hbWUsIGVuYWJsZWQpIHtcblx0XHQgICAgcmV0dXJuIGVuYWJsZWQgPyBwYXRobmFtZS5yZXBsYWNlKC9cXC5yc2MoJHxcXD8pLywgLy8gJDEgZW5zdXJlcyBgP2AgaXMgcHJlc2VydmVkXG5cdFx0ICAgIFwiJDFcIikgOiBwYXRobmFtZTtcblx0XHR9XG5cblx0XHRcblx0fSAoYXBwUGF0aHMpKTtcblx0cmV0dXJuIGFwcFBhdGhzO1xufVxuXG52YXIgaGFzUmVxdWlyZWRJbnRlcmNlcHRpb25Sb3V0ZXM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbnRlcmNlcHRpb25Sb3V0ZXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbnRlcmNlcHRpb25Sb3V0ZXMpIHJldHVybiBpbnRlcmNlcHRpb25Sb3V0ZXM7XG5cdGhhc1JlcXVpcmVkSW50ZXJjZXB0aW9uUm91dGVzID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0ZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuXHRcdCAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcblx0XHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuXHRcdCAgICB9KTtcblx0XHR9XG5cdFx0X2V4cG9ydChleHBvcnRzLCB7XG5cdFx0ICAgIElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUztcblx0XHQgICAgfSxcblx0XHQgICAgaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIGlzSW50ZXJjZXB0aW9uUm91dGVBcHBQYXRoO1xuXHRcdCAgICB9LFxuXHRcdCAgICBleHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gZXh0cmFjdEludGVyY2VwdGlvblJvdXRlSW5mb3JtYXRpb247XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRjb25zdCBfYXBwcGF0aHMgPSByZXF1aXJlQXBwUGF0aHMoKTtcblx0XHRjb25zdCBJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyA9IFtcblx0XHQgICAgXCIoLi4pKC4uKVwiLFxuXHRcdCAgICBcIiguKVwiLFxuXHRcdCAgICBcIiguLilcIixcblx0XHQgICAgXCIoLi4uKVwiXG5cdFx0XTtcblx0XHRmdW5jdGlvbiBpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aChwYXRoKSB7XG5cdFx0ICAgIC8vIFRPRE8tQVBQOiBhZGQgbW9yZSBzZXJpb3VzIHZhbGlkYXRpb25cblx0XHQgICAgcmV0dXJuIHBhdGguc3BsaXQoXCIvXCIpLmZpbmQoKHNlZ21lbnQpPT5JTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5maW5kKChtKT0+c2VnbWVudC5zdGFydHNXaXRoKG0pKSkgIT09IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZXh0cmFjdEludGVyY2VwdGlvblJvdXRlSW5mb3JtYXRpb24ocGF0aCkge1xuXHRcdCAgICBsZXQgaW50ZXJjZXB0aW5nUm91dGUsIG1hcmtlciwgaW50ZXJjZXB0ZWRSb3V0ZTtcblx0XHQgICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHBhdGguc3BsaXQoXCIvXCIpKXtcblx0XHQgICAgICAgIG1hcmtlciA9IElOVEVSQ0VQVElPTl9ST1VURV9NQVJLRVJTLmZpbmQoKG0pPT5zZWdtZW50LnN0YXJ0c1dpdGgobSkpO1xuXHRcdCAgICAgICAgaWYgKG1hcmtlcikge1xuXHRcdCAgICAgICAgICAgIFtpbnRlcmNlcHRpbmdSb3V0ZSwgaW50ZXJjZXB0ZWRSb3V0ZV0gPSBwYXRoLnNwbGl0KG1hcmtlciwgMik7XG5cdFx0ICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgaWYgKCFpbnRlcmNlcHRpbmdSb3V0ZSB8fCAhbWFya2VyIHx8ICFpbnRlcmNlcHRlZFJvdXRlKSB7XG5cdFx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW50ZXJjZXB0aW9uIHJvdXRlOiAke3BhdGh9LiBNdXN0IGJlIGluIHRoZSBmb3JtYXQgLzxpbnRlcmNlcHRpbmcgcm91dGU+LyguLnwuLi58Li4pKC4uKS88aW50ZXJjZXB0ZWQgcm91dGU+YCk7XG5cdFx0ICAgIH1cblx0XHQgICAgaW50ZXJjZXB0aW5nUm91dGUgPSAoMCwgX2FwcHBhdGhzLm5vcm1hbGl6ZUFwcFBhdGgpKGludGVyY2VwdGluZ1JvdXRlKSAvLyBub3JtYWxpemUgdGhlIHBhdGgsIGUuZy4gLyhibG9nKS9mZWVkIC0+IC9mZWVkXG5cdFx0ICAgIDtcblx0XHQgICAgc3dpdGNoKG1hcmtlcil7XG5cdFx0ICAgICAgICBjYXNlIFwiKC4pXCI6XG5cdFx0ICAgICAgICAgICAgLy8gKC4pIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZCBtYXRjaCB3aXRoIHNpYmxpbmcgcm91dGVzLCBzbyB3ZSBqdXN0IG5lZWQgdG8gYXBwZW5kIHRoZSBpbnRlcmNlcHRlZCByb3V0ZSB0byB0aGUgaW50ZXJjZXB0aW5nIHJvdXRlXG5cdFx0ICAgICAgICAgICAgaWYgKGludGVyY2VwdGluZ1JvdXRlID09PSBcIi9cIikge1xuXHRcdCAgICAgICAgICAgICAgICBpbnRlcmNlcHRlZFJvdXRlID0gYC8ke2ludGVyY2VwdGVkUm91dGV9YDtcblx0XHQgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICBpbnRlcmNlcHRlZFJvdXRlID0gaW50ZXJjZXB0aW5nUm91dGUgKyBcIi9cIiArIGludGVyY2VwdGVkUm91dGU7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGJyZWFrO1xuXHRcdCAgICAgICAgY2FzZSBcIiguLilcIjpcblx0XHQgICAgICAgICAgICAvLyAoLi4pIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZCBtYXRjaCBhdCBvbmUgbGV2ZWwgdXAsIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGludGVyY2VwdGluZyByb3V0ZVxuXHRcdCAgICAgICAgICAgIGlmIChpbnRlcmNlcHRpbmdSb3V0ZSA9PT0gXCIvXCIpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtwYXRofS4gQ2Fubm90IHVzZSAoLi4pIG1hcmtlciBhdCB0aGUgcm9vdCBsZXZlbCwgdXNlICguKSBpbnN0ZWFkLmApO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpbnRlcmNlcHRlZFJvdXRlID0gaW50ZXJjZXB0aW5nUm91dGUuc3BsaXQoXCIvXCIpLnNsaWNlKDAsIC0xKS5jb25jYXQoaW50ZXJjZXB0ZWRSb3V0ZSkuam9pbihcIi9cIik7XG5cdFx0ICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICBjYXNlIFwiKC4uLilcIjpcblx0XHQgICAgICAgICAgICAvLyAoLi4uKSB3aWxsIG1hdGNoIHRoZSByb3V0ZSBzZWdtZW50IGluIHRoZSByb290IGRpcmVjdG9yeSwgc28gd2UgbmVlZCB0byB1c2UgdGhlIHJvb3QgZGlyZWN0b3J5IHRvIHByZXBlbmQgdGhlIGludGVyY2VwdGVkIHJvdXRlXG5cdFx0ICAgICAgICAgICAgaW50ZXJjZXB0ZWRSb3V0ZSA9IFwiL1wiICsgaW50ZXJjZXB0ZWRSb3V0ZTtcblx0XHQgICAgICAgICAgICBicmVhaztcblx0XHQgICAgICAgIGNhc2UgXCIoLi4pKC4uKVwiOlxuXHRcdCAgICAgICAgICAgIC8vICguLikoLi4pIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZCBtYXRjaCBhdCB0d28gbGV2ZWxzIHVwLCBzbyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgbGFzdCB0d28gc2VnbWVudHMgb2YgdGhlIGludGVyY2VwdGluZyByb3V0ZVxuXHRcdCAgICAgICAgICAgIGNvbnN0IHNwbGl0SW50ZXJjZXB0aW5nUm91dGUgPSBpbnRlcmNlcHRpbmdSb3V0ZS5zcGxpdChcIi9cIik7XG5cdFx0ICAgICAgICAgICAgaWYgKHNwbGl0SW50ZXJjZXB0aW5nUm91dGUubGVuZ3RoIDw9IDIpIHtcblx0XHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGludGVyY2VwdGlvbiByb3V0ZTogJHtwYXRofS4gQ2Fubm90IHVzZSAoLi4pKC4uKSBtYXJrZXIgYXQgdGhlIHJvb3QgbGV2ZWwgb3Igb25lIGxldmVsIHVwLmApO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpbnRlcmNlcHRlZFJvdXRlID0gc3BsaXRJbnRlcmNlcHRpbmdSb3V0ZS5zbGljZSgwLCAtMikuY29uY2F0KGludGVyY2VwdGVkUm91dGUpLmpvaW4oXCIvXCIpO1xuXHRcdCAgICAgICAgICAgIGJyZWFrO1xuXHRcdCAgICAgICAgZGVmYXVsdDpcblx0XHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhcmlhbnQ6IHVuZXhwZWN0ZWQgbWFya2VyXCIpO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiB7XG5cdFx0ICAgICAgICBpbnRlcmNlcHRpbmdSb3V0ZSxcblx0XHQgICAgICAgIGludGVyY2VwdGVkUm91dGVcblx0XHQgICAgfTtcblx0XHR9XG5cblx0XHRcblx0fSAoaW50ZXJjZXB0aW9uUm91dGVzKSk7XG5cdHJldHVybiBpbnRlcmNlcHRpb25Sb3V0ZXM7XG59XG5cbnZhciBlc2NhcGVSZWdleHAgPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkRXNjYXBlUmVnZXhwO1xuXG5mdW5jdGlvbiByZXF1aXJlRXNjYXBlUmVnZXhwICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRXNjYXBlUmVnZXhwKSByZXR1cm4gZXNjYXBlUmVnZXhwO1xuXHRoYXNSZXF1aXJlZEVzY2FwZVJlZ2V4cCA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVN0cmluZ1JlZ2V4cFwiLCB7XG5cdFx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gZXNjYXBlU3RyaW5nUmVnZXhwO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3QgcmVIYXNSZWdFeHAgPSAvW3xcXFxce30oKVtcXF1eJCsqPy4tXS87XG5cdFx0Y29uc3QgcmVSZXBsYWNlUmVnRXhwID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vZztcblx0XHRmdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyKSB7XG5cdFx0ICAgIC8vIHNlZSBhbHNvOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzJkYTAyNGMzYjRmOTk0N2E0ODUxNzYzOWRlNzU2MDQ1N2NkNGVjNmMvZXNjYXBlUmVnRXhwLmpzI0wyM1xuXHRcdCAgICBpZiAocmVIYXNSZWdFeHAudGVzdChzdHIpKSB7XG5cdFx0ICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVSZXBsYWNlUmVnRXhwLCBcIlxcXFwkJlwiKTtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gc3RyO1xuXHRcdH1cblxuXHRcdFxuXHR9IChlc2NhcGVSZWdleHApKTtcblx0cmV0dXJuIGVzY2FwZVJlZ2V4cDtcbn1cblxudmFyIGhhc1JlcXVpcmVkUm91dGVSZWdleDtcblxuZnVuY3Rpb24gcmVxdWlyZVJvdXRlUmVnZXggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRSb3V0ZVJlZ2V4KSByZXR1cm4gcm91dGVSZWdleDtcblx0aGFzUmVxdWlyZWRSb3V0ZVJlZ2V4ID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0ZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuXHRcdCAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcblx0XHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuXHRcdCAgICB9KTtcblx0XHR9XG5cdFx0X2V4cG9ydChleHBvcnRzLCB7XG5cdFx0ICAgIGdldFJvdXRlUmVnZXg6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIGdldFJvdXRlUmVnZXg7XG5cdFx0ICAgIH0sXG5cdFx0ICAgIGdldE5hbWVkUm91dGVSZWdleDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gZ2V0TmFtZWRSb3V0ZVJlZ2V4O1xuXHRcdCAgICB9LFxuXHRcdCAgICBnZXROYW1lZE1pZGRsZXdhcmVSZWdleDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg7XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRjb25zdCBfaW50ZXJjZXB0aW9ucm91dGVzID0gcmVxdWlyZUludGVyY2VwdGlvblJvdXRlcygpO1xuXHRcdGNvbnN0IF9lc2NhcGVyZWdleHAgPSByZXF1aXJlRXNjYXBlUmVnZXhwKCk7XG5cdFx0Y29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlUmVtb3ZlVHJhaWxpbmdTbGFzaCgpO1xuXHRcdGNvbnN0IE5FWFRfUVVFUllfUEFSQU1fUFJFRklYID0gXCJueHRQXCI7XG5cdFx0Y29uc3QgTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA9IFwibnh0SVwiO1xuXHRcdC8qKlxuXHRcdCAqIFBhcnNlcyBhIGdpdmVuIHBhcmFtZXRlciBmcm9tIGEgcm91dGUgdG8gYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGNhbiBiZSB1c2VkXG5cdFx0ICogdG8gZ2VuZXJhdGUgdGhlIHBhcmFtZXRyaXplZCByb3V0ZS4gRXhhbXBsZXM6XG5cdFx0ICogICAtIGBbLi4uc2x1Z11gIC0+IGB7IGtleTogJ3NsdWcnLCByZXBlYXQ6IHRydWUsIG9wdGlvbmFsOiB0cnVlIH1gXG5cdFx0ICogICAtIGAuLi5zbHVnYCAtPiBgeyBrZXk6ICdzbHVnJywgcmVwZWF0OiB0cnVlLCBvcHRpb25hbDogZmFsc2UgfWBcblx0XHQgKiAgIC0gYFtmb29dYCAtPiBgeyBrZXk6ICdmb28nLCByZXBlYXQ6IGZhbHNlLCBvcHRpb25hbDogdHJ1ZSB9YFxuXHRcdCAqICAgLSBgYmFyYCAtPiBgeyBrZXk6ICdiYXInLCByZXBlYXQ6IGZhbHNlLCBvcHRpb25hbDogZmFsc2UgfWBcblx0XHQgKi8gZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIocGFyYW0pIHtcblx0XHQgICAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKFwiW1wiKSAmJiBwYXJhbS5lbmRzV2l0aChcIl1cIik7XG5cdFx0ICAgIGlmIChvcHRpb25hbCkge1xuXHRcdCAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgxLCAtMSk7XG5cdFx0ICAgIH1cblx0XHQgICAgY29uc3QgcmVwZWF0ID0gcGFyYW0uc3RhcnRzV2l0aChcIi4uLlwiKTtcblx0XHQgICAgaWYgKHJlcGVhdCkge1xuXHRcdCAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgzKTtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4ge1xuXHRcdCAgICAgICAga2V5OiBwYXJhbSxcblx0XHQgICAgICAgIHJlcGVhdCxcblx0XHQgICAgICAgIG9wdGlvbmFsXG5cdFx0ICAgIH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGdldFBhcmFtZXRyaXplZFJvdXRlKHJvdXRlKSB7XG5cdFx0ICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHJvdXRlKS5zbGljZSgxKS5zcGxpdChcIi9cIik7XG5cdFx0ICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuXHRcdCAgICBsZXQgZ3JvdXBJbmRleCA9IDE7XG5cdFx0ICAgIHJldHVybiB7XG5cdFx0ICAgICAgICBwYXJhbWV0ZXJpemVkUm91dGU6IHNlZ21lbnRzLm1hcCgoc2VnbWVudCk9Pntcblx0XHQgICAgICAgICAgICBjb25zdCBtYXJrZXJNYXRjaCA9IF9pbnRlcmNlcHRpb25yb3V0ZXMuSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMuZmluZCgobSk9PnNlZ21lbnQuc3RhcnRzV2l0aChtKSk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcGFyYW1NYXRjaGVzID0gc2VnbWVudC5tYXRjaCgvXFxbKCg/OlxcWy4qXFxdKXwuKylcXF0vKSAvLyBDaGVjayBmb3IgcGFyYW1ldGVyc1xuXHRcdCAgICAgICAgICAgIDtcblx0XHQgICAgICAgICAgICBpZiAobWFya2VyTWF0Y2ggJiYgcGFyYW1NYXRjaGVzKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihwYXJhbU1hdGNoZXNbMV0pO1xuXHRcdCAgICAgICAgICAgICAgICBncm91cHNba2V5XSA9IHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHBvczogZ3JvdXBJbmRleCsrLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgcmVwZWF0LFxuXHRcdCAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxcblx0XHQgICAgICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShtYXJrZXJNYXRjaCkgKyBcIihbXi9dKz8pXCI7XG5cdFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbU1hdGNoZXMpIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc3QgeyBrZXksIHJlcGVhdCwgb3B0aW9uYWwgfSA9IHBhcnNlUGFyYW1ldGVyKHBhcmFtTWF0Y2hlc1sxXSk7XG5cdFx0ICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0ge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcG9zOiBncm91cEluZGV4KyssXG5cdFx0ICAgICAgICAgICAgICAgICAgICByZXBlYXQsXG5cdFx0ICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFxuXHRcdCAgICAgICAgICAgICAgICB9O1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gcmVwZWF0ID8gb3B0aW9uYWwgPyBcIig/Oi8oLis/KSk/XCIgOiBcIi8oLis/KVwiIDogXCIvKFteL10rPylcIjtcblx0XHQgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCIgKyAoMCwgX2VzY2FwZXJlZ2V4cC5lc2NhcGVTdHJpbmdSZWdleHApKHNlZ21lbnQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0pLmpvaW4oXCJcIiksXG5cdFx0ICAgICAgICBncm91cHNcblx0XHQgICAgfTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZ2V0Um91dGVSZWdleChub3JtYWxpemVkUm91dGUpIHtcblx0XHQgICAgY29uc3QgeyBwYXJhbWV0ZXJpemVkUm91dGUsIGdyb3VwcyB9ID0gZ2V0UGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlKTtcblx0XHQgICAgcmV0dXJuIHtcblx0XHQgICAgICAgIHJlOiBuZXcgUmVnRXhwKFwiXlwiICsgcGFyYW1ldGVyaXplZFJvdXRlICsgXCIoPzovKT8kXCIpLFxuXHRcdCAgICAgICAgZ3JvdXBzOiBncm91cHNcblx0XHQgICAgfTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogQnVpbGRzIGEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsXG5cdFx0ICogbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG5cdFx0ICovIGZ1bmN0aW9uIGJ1aWxkR2V0U2FmZVJvdXRlS2V5KCkge1xuXHRcdCAgICBsZXQgaSA9IDA7XG5cdFx0ICAgIHJldHVybiAoKT0+e1xuXHRcdCAgICAgICAgbGV0IHJvdXRlS2V5ID0gXCJcIjtcblx0XHQgICAgICAgIGxldCBqID0gKytpO1xuXHRcdCAgICAgICAgd2hpbGUoaiA+IDApe1xuXHRcdCAgICAgICAgICAgIHJvdXRlS2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyAoaiAtIDEpICUgMjYpO1xuXHRcdCAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKChqIC0gMSkgLyAyNik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gcm91dGVLZXk7XG5cdFx0ICAgIH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGdldFNhZmVLZXlGcm9tU2VnbWVudChwYXJhbSkge1xuXHRcdCAgICBsZXQgeyBnZXRTYWZlUm91dGVLZXksIHNlZ21lbnQsIHJvdXRlS2V5cywga2V5UHJlZml4IH0gPSBwYXJhbTtcblx0XHQgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQpO1xuXHRcdCAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG5cdFx0ICAgIC8vIHRoZSBuYW1lZCByZWdleFxuXHRcdCAgICBsZXQgY2xlYW5lZEtleSA9IGtleS5yZXBsYWNlKC9cXFcvZywgXCJcIik7XG5cdFx0ICAgIGlmIChrZXlQcmVmaXgpIHtcblx0XHQgICAgICAgIGNsZWFuZWRLZXkgPSBcIlwiICsga2V5UHJlZml4ICsgY2xlYW5lZEtleTtcblx0XHQgICAgfVxuXHRcdCAgICBsZXQgaW52YWxpZEtleSA9IGZhbHNlO1xuXHRcdCAgICAvLyBjaGVjayBpZiB0aGUga2V5IGlzIHN0aWxsIGludmFsaWQgYW5kIGZhbGxiYWNrIHRvIHVzaW5nIGEga25vd25cblx0XHQgICAgLy8gc2FmZSBrZXlcblx0XHQgICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcblx0XHQgICAgICAgIGludmFsaWRLZXkgPSB0cnVlO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zbGljZSgwLCAxKSkpKSB7XG5cdFx0ICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZTtcblx0XHQgICAgfVxuXHRcdCAgICBpZiAoaW52YWxpZEtleSkge1xuXHRcdCAgICAgICAgY2xlYW5lZEtleSA9IGdldFNhZmVSb3V0ZUtleSgpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmIChrZXlQcmVmaXgpIHtcblx0XHQgICAgICAgIHJvdXRlS2V5c1tjbGVhbmVkS2V5XSA9IFwiXCIgKyBrZXlQcmVmaXggKyBrZXk7XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBcIlwiICsga2V5O1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiByZXBlYXQgPyBvcHRpb25hbCA/IFwiKD86Lyg/PFwiICsgY2xlYW5lZEtleSArIFwiPi4rPykpP1wiIDogXCIvKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+Lis/KVwiIDogXCIvKD88XCIgKyBjbGVhbmVkS2V5ICsgXCI+W14vXSs/KVwiO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlKHJvdXRlLCBwcmVmaXhSb3V0ZUtleXMpIHtcblx0XHQgICAgY29uc3Qgc2VnbWVudHMgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocm91dGUpLnNsaWNlKDEpLnNwbGl0KFwiL1wiKTtcblx0XHQgICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gYnVpbGRHZXRTYWZlUm91dGVLZXkoKTtcblx0XHQgICAgY29uc3Qgcm91dGVLZXlzID0ge307XG5cdFx0ICAgIHJldHVybiB7XG5cdFx0ICAgICAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGhhc0ludGVyY2VwdGlvbk1hcmtlciA9IF9pbnRlcmNlcHRpb25yb3V0ZXMuSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMuc29tZSgobSk9PnNlZ21lbnQuc3RhcnRzV2l0aChtKSk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcGFyYW1NYXRjaGVzID0gc2VnbWVudC5tYXRjaCgvXFxbKCg/OlxcWy4qXFxdKXwuKylcXF0vKSAvLyBDaGVjayBmb3IgcGFyYW1ldGVyc1xuXHRcdCAgICAgICAgICAgIDtcblx0XHQgICAgICAgICAgICBpZiAoaGFzSW50ZXJjZXB0aW9uTWFya2VyICYmIHBhcmFtTWF0Y2hlcykge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2FmZUtleUZyb21TZWdtZW50KHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGdldFNhZmVSb3V0ZUtleSxcblx0XHQgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHBhcmFtTWF0Y2hlc1sxXSxcblx0XHQgICAgICAgICAgICAgICAgICAgIHJvdXRlS2V5cyxcblx0XHQgICAgICAgICAgICAgICAgICAgIGtleVByZWZpeDogcHJlZml4Um91dGVLZXlzID8gTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA6IHVuZGVmaW5lZFxuXHRcdCAgICAgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtTWF0Y2hlcykge1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2FmZUtleUZyb21TZWdtZW50KHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGdldFNhZmVSb3V0ZUtleSxcblx0XHQgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHBhcmFtTWF0Y2hlc1sxXSxcblx0XHQgICAgICAgICAgICAgICAgICAgIHJvdXRlS2V5cyxcblx0XHQgICAgICAgICAgICAgICAgICAgIGtleVByZWZpeDogcHJlZml4Um91dGVLZXlzID8gTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVggOiB1bmRlZmluZWRcblx0XHQgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShzZWdtZW50KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9KS5qb2luKFwiXCIpLFxuXHRcdCAgICAgICAgcm91dGVLZXlzXG5cdFx0ICAgIH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGdldE5hbWVkUm91dGVSZWdleChub3JtYWxpemVkUm91dGUsIHByZWZpeFJvdXRlS2V5KSB7XG5cdFx0ICAgIGNvbnN0IHJlc3VsdCA9IGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlLCBwcmVmaXhSb3V0ZUtleSk7XG5cdFx0ICAgIHJldHVybiB7XG5cdFx0ICAgICAgICAuLi5nZXRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSksXG5cdFx0ICAgICAgICBuYW1lZFJlZ2V4OiBcIl5cIiArIHJlc3VsdC5uYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSArIFwiKD86Lyk/JFwiLFxuXHRcdCAgICAgICAgcm91dGVLZXlzOiByZXN1bHQucm91dGVLZXlzXG5cdFx0ICAgIH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgb3B0aW9ucykge1xuXHRcdCAgICBjb25zdCB7IHBhcmFtZXRlcml6ZWRSb3V0ZSB9ID0gZ2V0UGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlKTtcblx0XHQgICAgY29uc3QgeyBjYXRjaEFsbCA9IHRydWUgfSA9IG9wdGlvbnM7XG5cdFx0ICAgIGlmIChwYXJhbWV0ZXJpemVkUm91dGUgPT09IFwiL1wiKSB7XG5cdFx0ICAgICAgICBsZXQgY2F0Y2hBbGxSZWdleCA9IGNhdGNoQWxsID8gXCIuKlwiIDogXCJcIjtcblx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0ICAgICAgICAgICAgbmFtZWRSZWdleDogXCJeL1wiICsgY2F0Y2hBbGxSZWdleCArIFwiJFwiXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IHsgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgfSA9IGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlLCBmYWxzZSk7XG5cdFx0ICAgIGxldCBjYXRjaEFsbEdyb3VwZWRSZWdleCA9IGNhdGNoQWxsID8gXCIoPzooLy4qKT8pXCIgOiBcIlwiO1xuXHRcdCAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgbmFtZWRSZWdleDogXCJeXCIgKyBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSArIGNhdGNoQWxsR3JvdXBlZFJlZ2V4ICsgXCIkXCJcblx0XHQgICAgfTtcblx0XHR9XG5cblx0XHRcblx0fSAocm91dGVSZWdleCkpO1xuXHRyZXR1cm4gcm91dGVSZWdleDtcbn1cblxudmFyIGhhc1JlcXVpcmVkSW50ZXJwb2xhdGVBcztcblxuZnVuY3Rpb24gcmVxdWlyZUludGVycG9sYXRlQXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJbnRlcnBvbGF0ZUFzKSByZXR1cm4gaW50ZXJwb2xhdGVBcztcblx0aGFzUmVxdWlyZWRJbnRlcnBvbGF0ZUFzID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW50ZXJwb2xhdGVBc1wiLCB7XG5cdFx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVBcztcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGNvbnN0IF9yb3V0ZW1hdGNoZXIgPSByZXF1aXJlUm91dGVNYXRjaGVyKCk7XG5cdFx0Y29uc3QgX3JvdXRlcmVnZXggPSByZXF1aXJlUm91dGVSZWdleCgpO1xuXHRcdGZ1bmN0aW9uIGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSB7XG5cdFx0ICAgIGxldCBpbnRlcnBvbGF0ZWRSb3V0ZSA9IFwiXCI7XG5cdFx0ICAgIGNvbnN0IGR5bmFtaWNSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG5cdFx0ICAgIGNvbnN0IGR5bmFtaWNHcm91cHMgPSBkeW5hbWljUmVnZXguZ3JvdXBzO1xuXHRcdCAgICBjb25zdCBkeW5hbWljTWF0Y2hlcyA9IC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcblx0XHQgICAgKGFzUGF0aG5hbWUgIT09IHJvdXRlID8gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogXCJcIikgfHwgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG5cdFx0ICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cblx0XHQgICAgcXVlcnk7XG5cdFx0ICAgIGludGVycG9sYXRlZFJvdXRlID0gcm91dGU7XG5cdFx0ICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5rZXlzKGR5bmFtaWNHcm91cHMpO1xuXHRcdCAgICBpZiAoIXBhcmFtcy5ldmVyeSgocGFyYW0pPT57XG5cdFx0ICAgICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgXCJcIjtcblx0XHQgICAgICAgIGNvbnN0IHsgcmVwZWF0LCBvcHRpb25hbCB9ID0gZHluYW1pY0dyb3Vwc1twYXJhbV07XG5cdFx0ICAgICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcblx0XHQgICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcblx0XHQgICAgICAgIGxldCByZXBsYWNlZCA9IFwiW1wiICsgKHJlcGVhdCA/IFwiLi4uXCIgOiBcIlwiKSArIHBhcmFtICsgXCJdXCI7XG5cdFx0ICAgICAgICBpZiAob3B0aW9uYWwpIHtcblx0XHQgICAgICAgICAgICByZXBsYWNlZCA9ICghdmFsdWUgPyBcIi9cIiA6IFwiXCIpICsgXCJbXCIgKyByZXBsYWNlZCArIFwiXVwiO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKHJlcGVhdCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW1xuXHRcdCAgICAgICAgICAgIHZhbHVlXG5cdFx0ICAgICAgICBdO1xuXHRcdCAgICAgICAgcmV0dXJuIChvcHRpb25hbCB8fCBwYXJhbSBpbiBkeW5hbWljTWF0Y2hlcykgJiYgLy8gSW50ZXJwb2xhdGUgZ3JvdXAgaW50byBkYXRhIFVSTCBpZiBwcmVzZW50XG5cdFx0ICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPSBpbnRlcnBvbGF0ZWRSb3V0ZS5yZXBsYWNlKHJlcGxhY2VkLCByZXBlYXQgPyB2YWx1ZS5tYXAoLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuXHRcdCAgICAgICAgLy8gcGF0aCBkZWxpbWl0ZXIgZXNjYXBlZCBzaW5jZSB0aGV5IGFyZSBiZWluZyBpbnNlcnRlZFxuXHRcdCAgICAgICAgLy8gaW50byB0aGUgVVJMIGFuZCB3ZSBleHBlY3QgVVJMIGVuY29kZWQgc2VnbWVudHNcblx0XHQgICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuXHRcdCAgICAgICAgKHNlZ21lbnQpPT5lbmNvZGVVUklDb21wb25lbnQoc2VnbWVudCkpLmpvaW4oXCIvXCIpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSkgfHwgXCIvXCIpO1xuXHRcdCAgICB9KSkge1xuXHRcdCAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUgPSBcIlwiIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG5cdFx0ICAgICAgICA7XG5cdFx0ICAgIC8vIG4uYi4gV2UgaWdub3JlIHRoaXMgZXJyb3IgYmVjYXVzZSB3ZSBoYW5kbGUgd2FybmluZyBmb3IgdGhpcyBjYXNlIGluXG5cdFx0ICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIHtcblx0XHQgICAgICAgIHBhcmFtcyxcblx0XHQgICAgICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGVcblx0XHQgICAgfTtcblx0XHR9XG5cblx0XHRcblx0fSAoaW50ZXJwb2xhdGVBcykpO1xuXHRyZXR1cm4gaW50ZXJwb2xhdGVBcztcbn1cblxudmFyIGhhc1JlcXVpcmVkUmVzb2x2ZUhyZWY7XG5cbmZ1bmN0aW9uIHJlcXVpcmVSZXNvbHZlSHJlZiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFJlc29sdmVIcmVmKSByZXR1cm4gcmVzb2x2ZUhyZWYuZXhwb3J0cztcblx0aGFzUmVxdWlyZWRSZXNvbHZlSHJlZiA9IDE7XG5cdChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVzb2x2ZUhyZWZcIiwge1xuXHRcdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIHJlc29sdmVIcmVmO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3QgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZVF1ZXJ5c3RyaW5nKCk7XG5cdFx0Y29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmVGb3JtYXRVcmwoKTtcblx0XHRjb25zdCBfb21pdCA9IHJlcXVpcmVPbWl0KCk7XG5cdFx0Y29uc3QgX3V0aWxzID0gcmVxdWlyZVV0aWxzJDEoKTtcblx0XHRjb25zdCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmVOb3JtYWxpemVUcmFpbGluZ1NsYXNoKCk7XG5cdFx0Y29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlSXNMb2NhbFVybCgpO1xuXHRcdGNvbnN0IF91dGlsczEgPSByZXF1aXJlVXRpbHMoKTtcblx0XHRjb25zdCBfaW50ZXJwb2xhdGVhcyA9IHJlcXVpcmVJbnRlcnBvbGF0ZUFzKCk7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZUhyZWYocm91dGVyLCBocmVmLCByZXNvbHZlQXMpIHtcblx0XHQgICAgLy8gd2UgdXNlIGEgZHVtbXkgYmFzZSB1cmwgZm9yIHJlbGF0aXZlIHVybHNcblx0XHQgICAgbGV0IGJhc2U7XG5cdFx0ICAgIGxldCB1cmxBc1N0cmluZyA9IHR5cGVvZiBocmVmID09PSBcInN0cmluZ1wiID8gaHJlZiA6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShocmVmKTtcblx0XHQgICAgLy8gcmVwZWF0ZWQgc2xhc2hlcyBhbmQgYmFja3NsYXNoZXMgaW4gdGhlIFVSTCBhcmUgY29uc2lkZXJlZFxuXHRcdCAgICAvLyBpbnZhbGlkIGFuZCB3aWxsIG5ldmVyIG1hdGNoIGEgTmV4dC5qcyBwYWdlL2ZpbGVcblx0XHQgICAgY29uc3QgdXJsUHJvdG9NYXRjaCA9IHVybEFzU3RyaW5nLm1hdGNoKC9eW2EtekEtWl17MSx9OlxcL1xcLy8pO1xuXHRcdCAgICBjb25zdCB1cmxBc1N0cmluZ05vUHJvdG8gPSB1cmxQcm90b01hdGNoID8gdXJsQXNTdHJpbmcuc2xpY2UodXJsUHJvdG9NYXRjaFswXS5sZW5ndGgpIDogdXJsQXNTdHJpbmc7XG5cdFx0ICAgIGNvbnN0IHVybFBhcnRzID0gdXJsQXNTdHJpbmdOb1Byb3RvLnNwbGl0KFwiP1wiKTtcblx0XHQgICAgaWYgKCh1cmxQYXJ0c1swXSB8fCBcIlwiKS5tYXRjaCgvKFxcL1xcL3xcXFxcKS8pKSB7XG5cdFx0ICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBocmVmICdcIiArIHVybEFzU3RyaW5nICsgXCInIHBhc3NlZCB0byBuZXh0L3JvdXRlciBpbiBwYWdlOiAnXCIgKyByb3V0ZXIucGF0aG5hbWUgKyBcIicuIFJlcGVhdGVkIGZvcndhcmQtc2xhc2hlcyAoLy8pIG9yIGJhY2tzbGFzaGVzIFxcXFwgYXJlIG5vdCB2YWxpZCBpbiB0aGUgaHJlZi5cIik7XG5cdFx0ICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gKDAsIF91dGlscy5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMpKHVybEFzU3RyaW5nTm9Qcm90byk7XG5cdFx0ICAgICAgICB1cmxBc1N0cmluZyA9ICh1cmxQcm90b01hdGNoID8gdXJsUHJvdG9NYXRjaFswXSA6IFwiXCIpICsgbm9ybWFsaXplZFVybDtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBSZXR1cm4gYmVjYXVzZSBpdCBjYW5ub3QgYmUgcm91dGVkIGJ5IHRoZSBOZXh0LmpzIHJvdXRlclxuXHRcdCAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKSh1cmxBc1N0cmluZykpIHtcblx0XHQgICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG5cdFx0ICAgICAgICAgICAgdXJsQXNTdHJpbmdcblx0XHQgICAgICAgIF0gOiB1cmxBc1N0cmluZztcblx0XHQgICAgfVxuXHRcdCAgICB0cnkge1xuXHRcdCAgICAgICAgYmFzZSA9IG5ldyBVUkwodXJsQXNTdHJpbmcuc3RhcnRzV2l0aChcIiNcIikgPyByb3V0ZXIuYXNQYXRoIDogcm91dGVyLnBhdGhuYW1lLCBcImh0dHA6Ly9uXCIpO1xuXHRcdCAgICB9IGNhdGNoIChfKSB7XG5cdFx0ICAgICAgICAvLyBmYWxsYmFjayB0byAvIGZvciBpbnZhbGlkIGFzUGF0aCB2YWx1ZXMgZS5nLiAvL1xuXHRcdCAgICAgICAgYmFzZSA9IG5ldyBVUkwoXCIvXCIsIFwiaHR0cDovL25cIik7XG5cdFx0ICAgIH1cblx0XHQgICAgdHJ5IHtcblx0XHQgICAgICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSk7XG5cdFx0ICAgICAgICBmaW5hbFVybC5wYXRobmFtZSA9ICgwLCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaC5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCkoZmluYWxVcmwucGF0aG5hbWUpO1xuXHRcdCAgICAgICAgbGV0IGludGVycG9sYXRlZEFzID0gXCJcIjtcblx0XHQgICAgICAgIGlmICgoMCwgX3V0aWxzMS5pc0R5bmFtaWNSb3V0ZSkoZmluYWxVcmwucGF0aG5hbWUpICYmIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJiByZXNvbHZlQXMpIHtcblx0XHQgICAgICAgICAgICBjb25zdCBxdWVyeSA9ICgwLCBfcXVlcnlzdHJpbmcuc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSkoZmluYWxVcmwuc2VhcmNoUGFyYW1zKTtcblx0XHQgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSAoMCwgX2ludGVycG9sYXRlYXMuaW50ZXJwb2xhdGVBcykoZmluYWxVcmwucGF0aG5hbWUsIGZpbmFsVXJsLnBhdGhuYW1lLCBxdWVyeSk7XG5cdFx0ICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuXHRcdCAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRBcyA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogcmVzdWx0LFxuXHRcdCAgICAgICAgICAgICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcblx0XHQgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoMCwgX29taXQub21pdCkocXVlcnksIHBhcmFtcylcblx0XHQgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcblx0XHQgICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW4gPyBmaW5hbFVybC5ocmVmLnNsaWNlKGZpbmFsVXJsLm9yaWdpbi5sZW5ndGgpIDogZmluYWxVcmwuaHJlZjtcblx0XHQgICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG5cdFx0ICAgICAgICAgICAgcmVzb2x2ZWRIcmVmLFxuXHRcdCAgICAgICAgICAgIGludGVycG9sYXRlZEFzIHx8IHJlc29sdmVkSHJlZlxuXHRcdCAgICAgICAgXSA6IHJlc29sdmVkSHJlZjtcblx0XHQgICAgfSBjYXRjaCAoXykge1xuXHRcdCAgICAgICAgcmV0dXJuIHJlc29sdmVBcyA/IFtcblx0XHQgICAgICAgICAgICB1cmxBc1N0cmluZ1xuXHRcdCAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuXHRcdCAgICB9XG5cdFx0fVxuXG5cdFx0aWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG5cdFx0ICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblx0XHR9XG5cblx0XHRcblx0fSAocmVzb2x2ZUhyZWYsIHJlc29sdmVIcmVmLmV4cG9ydHMpKTtcblx0cmV0dXJuIHJlc29sdmVIcmVmLmV4cG9ydHM7XG59XG5cbnZhciBhZGRMb2NhbGUkMSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBhZGRMb2NhbGUgPSB7fTtcblxudmFyIGFkZFBhdGhQcmVmaXggPSB7fTtcblxudmFyIGhhc1JlcXVpcmVkQWRkUGF0aFByZWZpeDtcblxuZnVuY3Rpb24gcmVxdWlyZUFkZFBhdGhQcmVmaXggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRBZGRQYXRoUHJlZml4KSByZXR1cm4gYWRkUGF0aFByZWZpeDtcblx0aGFzUmVxdWlyZWRBZGRQYXRoUHJlZml4ID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkUGF0aFByZWZpeFwiLCB7XG5cdFx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gYWRkUGF0aFByZWZpeDtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGNvbnN0IF9wYXJzZXBhdGggPSByZXF1aXJlUGFyc2VQYXRoKCk7XG5cdFx0ZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoLCBwcmVmaXgpIHtcblx0XHQgICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpIHx8ICFwcmVmaXgpIHtcblx0XHQgICAgICAgIHJldHVybiBwYXRoO1xuXHRcdCAgICB9XG5cdFx0ICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoIH0gPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHBhdGgpO1xuXHRcdCAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIHBhdGhuYW1lICsgcXVlcnkgKyBoYXNoO1xuXHRcdH1cblxuXHRcdFxuXHR9IChhZGRQYXRoUHJlZml4KSk7XG5cdHJldHVybiBhZGRQYXRoUHJlZml4O1xufVxuXG52YXIgaGFzUmVxdWlyZWRBZGRMb2NhbGUkMTtcblxuZnVuY3Rpb24gcmVxdWlyZUFkZExvY2FsZSQxICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQWRkTG9jYWxlJDEpIHJldHVybiBhZGRMb2NhbGU7XG5cdGhhc1JlcXVpcmVkQWRkTG9jYWxlJDEgPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgICAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRMb2NhbGVcIiwge1xuXHRcdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIGFkZExvY2FsZTtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGNvbnN0IF9hZGRwYXRocHJlZml4ID0gcmVxdWlyZUFkZFBhdGhQcmVmaXgoKTtcblx0XHRjb25zdCBfcGF0aGhhc3ByZWZpeCA9IHJlcXVpcmVQYXRoSGFzUHJlZml4KCk7XG5cdFx0ZnVuY3Rpb24gYWRkTG9jYWxlKHBhdGgsIGxvY2FsZSwgZGVmYXVsdExvY2FsZSwgaWdub3JlUHJlZml4KSB7XG5cdFx0ICAgIC8vIElmIG5vIGxvY2FsZSB3YXMgZ2l2ZW4gb3IgdGhlIGxvY2FsZSBpcyB0aGUgZGVmYXVsdCBsb2NhbGUsIHdlIGRvbid0IG5lZWRcblx0XHQgICAgLy8gdG8gcHJlZml4IHRoZSBwYXRoLlxuXHRcdCAgICBpZiAoIWxvY2FsZSB8fCBsb2NhbGUgPT09IGRlZmF1bHRMb2NhbGUpIHJldHVybiBwYXRoO1xuXHRcdCAgICBjb25zdCBsb3dlciA9IHBhdGgudG9Mb3dlckNhc2UoKTtcblx0XHQgICAgLy8gSWYgdGhlIHBhdGggaXMgYW4gQVBJIHBhdGggb3IgdGhlIHBhdGggYWxyZWFkeSBoYXMgdGhlIGxvY2FsZSBwcmVmaXgsIHdlXG5cdFx0ICAgIC8vIGRvbid0IG5lZWQgdG8gcHJlZml4IHRoZSBwYXRoLlxuXHRcdCAgICBpZiAoIWlnbm9yZVByZWZpeCkge1xuXHRcdCAgICAgICAgaWYgKCgwLCBfcGF0aGhhc3ByZWZpeC5wYXRoSGFzUHJlZml4KShsb3dlciwgXCIvYXBpXCIpKSByZXR1cm4gcGF0aDtcblx0XHQgICAgICAgIGlmICgoMCwgX3BhdGhoYXNwcmVmaXgucGF0aEhhc1ByZWZpeCkobG93ZXIsIFwiL1wiICsgbG9jYWxlLnRvTG93ZXJDYXNlKCkpKSByZXR1cm4gcGF0aDtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBBZGQgdGhlIGxvY2FsZSBwcmVmaXggdG8gdGhlIHBhdGguXG5cdFx0ICAgIHJldHVybiAoMCwgX2FkZHBhdGhwcmVmaXguYWRkUGF0aFByZWZpeCkocGF0aCwgXCIvXCIgKyBsb2NhbGUpO1xuXHRcdH1cblxuXHRcdFxuXHR9IChhZGRMb2NhbGUpKTtcblx0cmV0dXJuIGFkZExvY2FsZTtcbn1cblxudmFyIGhhc1JlcXVpcmVkQWRkTG9jYWxlO1xuXG5mdW5jdGlvbiByZXF1aXJlQWRkTG9jYWxlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQWRkTG9jYWxlKSByZXR1cm4gYWRkTG9jYWxlJDEuZXhwb3J0cztcblx0aGFzUmVxdWlyZWRBZGRMb2NhbGUgPSAxO1xuXHQoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZExvY2FsZVwiLCB7XG5cdFx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gYWRkTG9jYWxlO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlTm9ybWFsaXplVHJhaWxpbmdTbGFzaCgpO1xuXHRcdGNvbnN0IGFkZExvY2FsZSA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHQgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcblx0XHQgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG5cdFx0ICAgICAgICByZXR1cm4gKDAsIF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKShyZXF1aXJlQWRkTG9jYWxlJDEoKS5hZGRMb2NhbGUocGF0aCwgLi4uYXJncykpO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiBwYXRoO1xuXHRcdH07XG5cblx0XHRpZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0XHQgIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcblx0XHQgIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXHRcdH1cblxuXHRcdFxuXHR9IChhZGRMb2NhbGUkMSwgYWRkTG9jYWxlJDEuZXhwb3J0cykpO1xuXHRyZXR1cm4gYWRkTG9jYWxlJDEuZXhwb3J0cztcbn1cblxudmFyIHJvdXRlckNvbnRleHRfc2hhcmVkUnVudGltZSA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRSb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVSb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRSb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWUpIHJldHVybiByb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWU7XG5cdGhhc1JlcXVpcmVkUm91dGVyQ29udGV4dF9zaGFyZWRSdW50aW1lID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUm91dGVyQ29udGV4dFwiLCB7XG5cdFx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gUm91dGVyQ29udGV4dDtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCQxO1xuXHRcdGNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8oUmVhY3RfX2RlZmF1bHQpO1xuXHRcdGNvbnN0IFJvdXRlckNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXHRcdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcblx0XHQgICAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVyQ29udGV4dFwiO1xuXHRcdH1cblxuXHRcdFxuXHR9IChyb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWUpKTtcblx0cmV0dXJuIHJvdXRlckNvbnRleHRfc2hhcmVkUnVudGltZTtcbn1cblxudmFyIGFwcFJvdXRlckNvbnRleHRfc2hhcmVkUnVudGltZSA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRBcHBSb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVBcHBSb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRBcHBSb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWUpIHJldHVybiBhcHBSb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWU7XG5cdGhhc1JlcXVpcmVkQXBwUm91dGVyQ29udGV4dF9zaGFyZWRSdW50aW1lID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0XCJ1c2UgY2xpZW50XCI7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0ZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuXHRcdCAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcblx0XHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuXHRcdCAgICB9KTtcblx0XHR9XG5cdFx0X2V4cG9ydChleHBvcnRzLCB7XG5cdFx0ICAgIENhY2hlU3RhdGVzOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBDYWNoZVN0YXRlcztcblx0XHQgICAgfSxcblx0XHQgICAgQXBwUm91dGVyQ29udGV4dDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gQXBwUm91dGVyQ29udGV4dDtcblx0XHQgICAgfSxcblx0XHQgICAgTGF5b3V0Um91dGVyQ29udGV4dDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gTGF5b3V0Um91dGVyQ29udGV4dDtcblx0XHQgICAgfSxcblx0XHQgICAgR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dDtcblx0XHQgICAgfSxcblx0XHQgICAgVGVtcGxhdGVDb250ZXh0OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBUZW1wbGF0ZUNvbnRleHQ7XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRjb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQkMTtcblx0XHRjb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKFJlYWN0X19kZWZhdWx0KTtcblx0XHR2YXIgQ2FjaGVTdGF0ZXM7XG5cdFx0KGZ1bmN0aW9uKENhY2hlU3RhdGVzKSB7XG5cdFx0ICAgIENhY2hlU3RhdGVzW1wiTEFaWV9JTklUSUFMSVpFRFwiXSA9IFwiTEFaWUlOSVRJQUxJWkVEXCI7XG5cdFx0ICAgIENhY2hlU3RhdGVzW1wiREFUQV9GRVRDSFwiXSA9IFwiREFUQUZFVENIXCI7XG5cdFx0ICAgIENhY2hlU3RhdGVzW1wiUkVBRFlcIl0gPSBcIlJFQURZXCI7XG5cdFx0fSkoQ2FjaGVTdGF0ZXMgfHwgKENhY2hlU3RhdGVzID0ge30pKTtcblx0XHRjb25zdCBBcHBSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcblx0XHRjb25zdCBMYXlvdXRSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcblx0XHRjb25zdCBHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcblx0XHRjb25zdCBUZW1wbGF0ZUNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXHRcdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcblx0XHQgICAgQXBwUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQXBwUm91dGVyQ29udGV4dFwiO1xuXHRcdCAgICBMYXlvdXRSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJMYXlvdXRSb3V0ZXJDb250ZXh0XCI7XG5cdFx0ICAgIEdsb2JhbExheW91dFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkdsb2JhbExheW91dFJvdXRlckNvbnRleHRcIjtcblx0XHQgICAgVGVtcGxhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJUZW1wbGF0ZUNvbnRleHRcIjtcblx0XHR9XG5cblx0XHRcblx0fSAoYXBwUm91dGVyQ29udGV4dF9zaGFyZWRSdW50aW1lKSk7XG5cdHJldHVybiBhcHBSb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWU7XG59XG5cbnZhciB1c2VJbnRlcnNlY3Rpb24gPSB7ZXhwb3J0czoge319O1xuXG52YXIgcmVxdWVzdElkbGVDYWxsYmFjayA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBoYXNSZXF1aXJlZFJlcXVlc3RJZGxlQ2FsbGJhY2s7XG5cbmZ1bmN0aW9uIHJlcXVpcmVSZXF1ZXN0SWRsZUNhbGxiYWNrICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkUmVxdWVzdElkbGVDYWxsYmFjaykgcmV0dXJuIHJlcXVlc3RJZGxlQ2FsbGJhY2suZXhwb3J0cztcblx0aGFzUmVxdWlyZWRSZXF1ZXN0SWRsZUNhbGxiYWNrID0gMTtcblx0KGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgICAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRmdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG5cdFx0ICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuXHRcdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgICAgIGdldDogYWxsW25hbWVdXG5cdFx0ICAgIH0pO1xuXHRcdH1cblx0XHRfZXhwb3J0KGV4cG9ydHMsIHtcblx0XHQgICAgcmVxdWVzdElkbGVDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gcmVxdWVzdElkbGVDYWxsYmFjaztcblx0XHQgICAgfSxcblx0XHQgICAgY2FuY2VsSWRsZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBjYW5jZWxJZGxlQ2FsbGJhY2s7XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRjb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrID0gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrICYmIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjay5iaW5kKHdpbmRvdykgfHwgZnVuY3Rpb24oY2IpIHtcblx0XHQgICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcblx0XHQgICAgcmV0dXJuIHNlbGYuc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIGNiKHtcblx0XHQgICAgICAgICAgICBkaWRUaW1lb3V0OiBmYWxzZSxcblx0XHQgICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9LCAxKTtcblx0XHR9O1xuXHRcdGNvbnN0IGNhbmNlbElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuXHRcdCAgICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKTtcblx0XHR9O1xuXG5cdFx0aWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG5cdFx0ICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblx0XHR9XG5cblx0XHRcblx0fSAocmVxdWVzdElkbGVDYWxsYmFjaywgcmVxdWVzdElkbGVDYWxsYmFjay5leHBvcnRzKSk7XG5cdHJldHVybiByZXF1ZXN0SWRsZUNhbGxiYWNrLmV4cG9ydHM7XG59XG5cbnZhciBoYXNSZXF1aXJlZFVzZUludGVyc2VjdGlvbjtcblxuZnVuY3Rpb24gcmVxdWlyZVVzZUludGVyc2VjdGlvbiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFVzZUludGVyc2VjdGlvbikgcmV0dXJuIHVzZUludGVyc2VjdGlvbi5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZFVzZUludGVyc2VjdGlvbiA9IDE7XG5cdChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlSW50ZXJzZWN0aW9uXCIsIHtcblx0XHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiB1c2VJbnRlcnNlY3Rpb247XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRjb25zdCBfcmVhY3QgPSBSZWFjdF9fZGVmYXVsdDtcblx0XHRjb25zdCBfcmVxdWVzdGlkbGVjYWxsYmFjayA9IHJlcXVpcmVSZXF1ZXN0SWRsZUNhbGxiYWNrKCk7XG5cdFx0Y29uc3QgaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwiZnVuY3Rpb25cIjtcblx0XHRjb25zdCBvYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG5cdFx0Y29uc3QgaWRMaXN0ID0gW107XG5cdFx0ZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucykge1xuXHRcdCAgICBjb25zdCBpZCA9IHtcblx0XHQgICAgICAgIHJvb3Q6IG9wdGlvbnMucm9vdCB8fCBudWxsLFxuXHRcdCAgICAgICAgbWFyZ2luOiBvcHRpb25zLnJvb3RNYXJnaW4gfHwgXCJcIlxuXHRcdCAgICB9O1xuXHRcdCAgICBjb25zdCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuXHRcdCAgICBsZXQgaW5zdGFuY2U7XG5cdFx0ICAgIGlmIChleGlzdGluZykge1xuXHRcdCAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcblx0XHQgICAgICAgIGlmIChpbnN0YW5jZSkge1xuXHRcdCAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgICBjb25zdCBlbGVtZW50cyA9IG5ldyBNYXAoKTtcblx0XHQgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG5cdFx0ICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gZWxlbWVudHMuZ2V0KGVudHJ5LnRhcmdldCk7XG5cdFx0ICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuXHRcdCAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcblx0XHQgICAgICAgICAgICAgICAgY2FsbGJhY2soaXNWaXNpYmxlKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfSwgb3B0aW9ucyk7XG5cdFx0ICAgIGluc3RhbmNlID0ge1xuXHRcdCAgICAgICAgaWQsXG5cdFx0ICAgICAgICBvYnNlcnZlcixcblx0XHQgICAgICAgIGVsZW1lbnRzXG5cdFx0ICAgIH07XG5cdFx0ICAgIGlkTGlzdC5wdXNoKGlkKTtcblx0XHQgICAgb2JzZXJ2ZXJzLnNldChpZCwgaW5zdGFuY2UpO1xuXHRcdCAgICByZXR1cm4gaW5zdGFuY2U7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcblx0XHQgICAgY29uc3QgeyBpZCwgb2JzZXJ2ZXIsIGVsZW1lbnRzIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKTtcblx0XHQgICAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrKTtcblx0XHQgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcblx0XHQgICAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcblx0XHQgICAgICAgIGVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KTtcblx0XHQgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcblx0XHQgICAgICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcblx0XHQgICAgICAgIGlmIChlbGVtZW50cy5zaXplID09PSAwKSB7XG5cdFx0ICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHRcdCAgICAgICAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaWRMaXN0LmZpbmRJbmRleCgob2JqKT0+b2JqLnJvb3QgPT09IGlkLnJvb3QgJiYgb2JqLm1hcmdpbiA9PT0gaWQubWFyZ2luKTtcblx0XHQgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuXHRcdCAgICAgICAgICAgICAgICBpZExpc3Quc3BsaWNlKGluZGV4LCAxKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbihwYXJhbSkge1xuXHRcdCAgICBsZXQgeyByb290UmVmLCByb290TWFyZ2luLCBkaXNhYmxlZCB9ID0gcGFyYW07XG5cdFx0ICAgIGNvbnN0IGlzRGlzYWJsZWQgPSBkaXNhYmxlZCB8fCAhaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG5cdFx0ICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtcblx0XHQgICAgY29uc3QgZWxlbWVudFJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShudWxsKTtcblx0XHQgICAgY29uc3Qgc2V0RWxlbWVudCA9ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKChlbGVtZW50KT0+e1xuXHRcdCAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcblx0XHQgICAgfSwgW10pO1xuXHRcdCAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9Pntcblx0XHQgICAgICAgIGlmIChoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuXHRcdCAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVybjtcblx0XHQgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudFJlZi5jdXJyZW50O1xuXHRcdCAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSkge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zdCB1bm9ic2VydmUgPSBvYnNlcnZlKGVsZW1lbnQsIChpc1Zpc2libGUpPT5pc1Zpc2libGUgJiYgc2V0VmlzaWJsZShpc1Zpc2libGUpLCB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByb290OiByb290UmVmID09IG51bGwgPyB2b2lkIDAgOiByb290UmVmLmN1cnJlbnQsXG5cdFx0ICAgICAgICAgICAgICAgICAgICByb290TWFyZ2luXG5cdFx0ICAgICAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gdW5vYnNlcnZlO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNvbnN0IGlkbGVDYWxsYmFjayA9ICgwLCBfcmVxdWVzdGlkbGVjYWxsYmFjay5yZXF1ZXN0SWRsZUNhbGxiYWNrKSgoKT0+c2V0VmlzaWJsZSh0cnVlKSk7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiAoKT0+KDAsIF9yZXF1ZXN0aWRsZWNhbGxiYWNrLmNhbmNlbElkbGVDYWxsYmFjaykoaWRsZUNhbGxiYWNrKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcblx0XHQgICAgfSwgW1xuXHRcdCAgICAgICAgaXNEaXNhYmxlZCxcblx0XHQgICAgICAgIHJvb3RNYXJnaW4sXG5cdFx0ICAgICAgICByb290UmVmLFxuXHRcdCAgICAgICAgdmlzaWJsZSxcblx0XHQgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudFxuXHRcdCAgICBdKTtcblx0XHQgICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKCk9Pntcblx0XHQgICAgICAgIHNldFZpc2libGUoZmFsc2UpO1xuXHRcdCAgICB9LCBbXSk7XG5cdFx0ICAgIHJldHVybiBbXG5cdFx0ICAgICAgICBzZXRFbGVtZW50LFxuXHRcdCAgICAgICAgdmlzaWJsZSxcblx0XHQgICAgICAgIHJlc2V0VmlzaWJsZVxuXHRcdCAgICBdO1xuXHRcdH1cblxuXHRcdGlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuXHRcdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRcdCAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuXHRcdCAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cdFx0fVxuXG5cdFx0XG5cdH0gKHVzZUludGVyc2VjdGlvbiwgdXNlSW50ZXJzZWN0aW9uLmV4cG9ydHMpKTtcblx0cmV0dXJuIHVzZUludGVyc2VjdGlvbi5leHBvcnRzO1xufVxuXG52YXIgZ2V0RG9tYWluTG9jYWxlID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIG5vcm1hbGl6ZUxvY2FsZVBhdGgkMSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBub3JtYWxpemVMb2NhbGVQYXRoID0ge307XG5cbnZhciBoYXNSZXF1aXJlZE5vcm1hbGl6ZUxvY2FsZVBhdGgkMTtcblxuZnVuY3Rpb24gcmVxdWlyZU5vcm1hbGl6ZUxvY2FsZVBhdGgkMSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZE5vcm1hbGl6ZUxvY2FsZVBhdGgkMSkgcmV0dXJuIG5vcm1hbGl6ZUxvY2FsZVBhdGg7XG5cdGhhc1JlcXVpcmVkTm9ybWFsaXplTG9jYWxlUGF0aCQxID0gMTtcblx0KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9ybWFsaXplTG9jYWxlUGF0aFwiLCB7XG5cdFx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbm9ybWFsaXplTG9jYWxlUGF0aDtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aG5hbWUsIGxvY2FsZXMpIHtcblx0XHQgICAgbGV0IGRldGVjdGVkTG9jYWxlO1xuXHRcdCAgICAvLyBmaXJzdCBpdGVtIHdpbGwgYmUgZW1wdHkgc3RyaW5nIGZyb20gc3BsaXR0aW5nIGF0IGZpcnN0IGNoYXJcblx0XHQgICAgY29uc3QgcGF0aG5hbWVQYXJ0cyA9IHBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcblx0XHQgICAgKGxvY2FsZXMgfHwgW10pLnNvbWUoKGxvY2FsZSk9Pntcblx0XHQgICAgICAgIGlmIChwYXRobmFtZVBhcnRzWzFdICYmIHBhdGhuYW1lUGFydHNbMV0udG9Mb3dlckNhc2UoKSA9PT0gbG9jYWxlLnRvTG93ZXJDYXNlKCkpIHtcblx0XHQgICAgICAgICAgICBkZXRlY3RlZExvY2FsZSA9IGxvY2FsZTtcblx0XHQgICAgICAgICAgICBwYXRobmFtZVBhcnRzLnNwbGljZSgxLCAxKTtcblx0XHQgICAgICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lUGFydHMuam9pbihcIi9cIikgfHwgXCIvXCI7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgIH0pO1xuXHRcdCAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgcGF0aG5hbWUsXG5cdFx0ICAgICAgICBkZXRlY3RlZExvY2FsZVxuXHRcdCAgICB9O1xuXHRcdH1cblxuXHRcdFxuXHR9IChub3JtYWxpemVMb2NhbGVQYXRoKSk7XG5cdHJldHVybiBub3JtYWxpemVMb2NhbGVQYXRoO1xufVxuXG52YXIgaGFzUmVxdWlyZWROb3JtYWxpemVMb2NhbGVQYXRoO1xuXG5mdW5jdGlvbiByZXF1aXJlTm9ybWFsaXplTG9jYWxlUGF0aCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZE5vcm1hbGl6ZUxvY2FsZVBhdGgpIHJldHVybiBub3JtYWxpemVMb2NhbGVQYXRoJDEuZXhwb3J0cztcblx0aGFzUmVxdWlyZWROb3JtYWxpemVMb2NhbGVQYXRoID0gMTtcblx0KGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgICAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJub3JtYWxpemVMb2NhbGVQYXRoXCIsIHtcblx0XHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBub3JtYWxpemVMb2NhbGVQYXRoO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3Qgbm9ybWFsaXplTG9jYWxlUGF0aCA9IChwYXRobmFtZSwgbG9jYWxlcyk9Pntcblx0XHQgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcblx0XHQgICAgICAgIHJldHVybiByZXF1aXJlTm9ybWFsaXplTG9jYWxlUGF0aCQxKCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXRobmFtZSwgbG9jYWxlcyk7XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIHtcblx0XHQgICAgICAgIHBhdGhuYW1lLFxuXHRcdCAgICAgICAgZGV0ZWN0ZWRMb2NhbGU6IHVuZGVmaW5lZFxuXHRcdCAgICB9O1xuXHRcdH07XG5cblx0XHRpZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0XHQgIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcblx0XHQgIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xuXHRcdH1cblxuXHRcdFxuXHR9IChub3JtYWxpemVMb2NhbGVQYXRoJDEsIG5vcm1hbGl6ZUxvY2FsZVBhdGgkMS5leHBvcnRzKSk7XG5cdHJldHVybiBub3JtYWxpemVMb2NhbGVQYXRoJDEuZXhwb3J0cztcbn1cblxudmFyIGRldGVjdERvbWFpbkxvY2FsZSQxID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGRldGVjdERvbWFpbkxvY2FsZSA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWREZXRlY3REb21haW5Mb2NhbGUkMTtcblxuZnVuY3Rpb24gcmVxdWlyZURldGVjdERvbWFpbkxvY2FsZSQxICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRGV0ZWN0RG9tYWluTG9jYWxlJDEpIHJldHVybiBkZXRlY3REb21haW5Mb2NhbGU7XG5cdGhhc1JlcXVpcmVkRGV0ZWN0RG9tYWluTG9jYWxlJDEgPSAxO1xuXHQoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgICAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXRlY3REb21haW5Mb2NhbGVcIiwge1xuXHRcdCAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIGRldGVjdERvbWFpbkxvY2FsZTtcblx0XHQgICAgfVxuXHRcdH0pO1xuXHRcdGZ1bmN0aW9uIGRldGVjdERvbWFpbkxvY2FsZShkb21haW5JdGVtcywgaG9zdG5hbWUsIGRldGVjdGVkTG9jYWxlKSB7XG5cdFx0ICAgIGlmICghZG9tYWluSXRlbXMpIHJldHVybjtcblx0XHQgICAgaWYgKGRldGVjdGVkTG9jYWxlKSB7XG5cdFx0ICAgICAgICBkZXRlY3RlZExvY2FsZSA9IGRldGVjdGVkTG9jYWxlLnRvTG93ZXJDYXNlKCk7XG5cdFx0ICAgIH1cblx0XHQgICAgZm9yIChjb25zdCBpdGVtIG9mIGRvbWFpbkl0ZW1zKXtcblx0XHQgICAgICAgIHZhciBfaXRlbV9kb21haW4sIF9pdGVtX2xvY2FsZXM7XG5cdFx0ICAgICAgICAvLyByZW1vdmUgcG9ydCBpZiBwcmVzZW50XG5cdFx0ICAgICAgICBjb25zdCBkb21haW5Ib3N0bmFtZSA9IChfaXRlbV9kb21haW4gPSBpdGVtLmRvbWFpbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pdGVtX2RvbWFpbi5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcblx0XHQgICAgICAgIGlmIChob3N0bmFtZSA9PT0gZG9tYWluSG9zdG5hbWUgfHwgZGV0ZWN0ZWRMb2NhbGUgPT09IGl0ZW0uZGVmYXVsdExvY2FsZS50b0xvd2VyQ2FzZSgpIHx8ICgoX2l0ZW1fbG9jYWxlcyA9IGl0ZW0ubG9jYWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pdGVtX2xvY2FsZXMuc29tZSgobG9jYWxlKT0+bG9jYWxlLnRvTG93ZXJDYXNlKCkgPT09IGRldGVjdGVkTG9jYWxlKSkpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gaXRlbTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfVxuXHRcdH1cblxuXHRcdFxuXHR9IChkZXRlY3REb21haW5Mb2NhbGUpKTtcblx0cmV0dXJuIGRldGVjdERvbWFpbkxvY2FsZTtcbn1cblxudmFyIGhhc1JlcXVpcmVkRGV0ZWN0RG9tYWluTG9jYWxlO1xuXG5mdW5jdGlvbiByZXF1aXJlRGV0ZWN0RG9tYWluTG9jYWxlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRGV0ZWN0RG9tYWluTG9jYWxlKSByZXR1cm4gZGV0ZWN0RG9tYWluTG9jYWxlJDEuZXhwb3J0cztcblx0aGFzUmVxdWlyZWREZXRlY3REb21haW5Mb2NhbGUgPSAxO1xuXHQoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRldGVjdERvbWFpbkxvY2FsZVwiLCB7XG5cdFx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gZGV0ZWN0RG9tYWluTG9jYWxlO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3QgZGV0ZWN0RG9tYWluTG9jYWxlID0gZnVuY3Rpb24oKSB7XG5cdFx0ICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcblx0XHQgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdFx0ICAgIH1cblx0XHQgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcblx0XHQgICAgICAgIHJldHVybiByZXF1aXJlRGV0ZWN0RG9tYWluTG9jYWxlJDEoKS5kZXRlY3REb21haW5Mb2NhbGUoLi4uYXJncyk7XG5cdFx0ICAgIH1cblx0XHR9O1xuXG5cdFx0aWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG5cdFx0ICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblx0XHR9XG5cblx0XHRcblx0fSAoZGV0ZWN0RG9tYWluTG9jYWxlJDEsIGRldGVjdERvbWFpbkxvY2FsZSQxLmV4cG9ydHMpKTtcblx0cmV0dXJuIGRldGVjdERvbWFpbkxvY2FsZSQxLmV4cG9ydHM7XG59XG5cbnZhciBoYXNSZXF1aXJlZEdldERvbWFpbkxvY2FsZTtcblxuZnVuY3Rpb24gcmVxdWlyZUdldERvbWFpbkxvY2FsZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEdldERvbWFpbkxvY2FsZSkgcmV0dXJuIGdldERvbWFpbkxvY2FsZS5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZEdldERvbWFpbkxvY2FsZSA9IDE7XG5cdChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0ICAgIHZhbHVlOiB0cnVlXG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RG9tYWluTG9jYWxlXCIsIHtcblx0XHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBnZXREb21haW5Mb2NhbGU7XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRjb25zdCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmVOb3JtYWxpemVUcmFpbGluZ1NsYXNoKCk7XG5cdFx0Y29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8IFwiXCI7XG5cdFx0ZnVuY3Rpb24gZ2V0RG9tYWluTG9jYWxlKHBhdGgsIGxvY2FsZSwgbG9jYWxlcywgZG9tYWluTG9jYWxlcykge1xuXHRcdCAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuXHRcdCAgICAgICAgY29uc3Qgbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmVOb3JtYWxpemVMb2NhbGVQYXRoKCkubm9ybWFsaXplTG9jYWxlUGF0aDtcblx0XHQgICAgICAgIGNvbnN0IGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmVEZXRlY3REb21haW5Mb2NhbGUoKS5kZXRlY3REb21haW5Mb2NhbGU7XG5cdFx0ICAgICAgICBjb25zdCB0YXJnZXQgPSBsb2NhbGUgfHwgbm9ybWFsaXplTG9jYWxlUGF0aChwYXRoLCBsb2NhbGVzKS5kZXRlY3RlZExvY2FsZTtcblx0XHQgICAgICAgIGNvbnN0IGRvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIHRhcmdldCk7XG5cdFx0ICAgICAgICBpZiAoZG9tYWluKSB7XG5cdFx0ICAgICAgICAgICAgY29uc3QgcHJvdG8gPSBcImh0dHBcIiArIChkb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiO1xuXHRcdCAgICAgICAgICAgIGNvbnN0IGZpbmFsTG9jYWxlID0gdGFyZ2V0ID09PSBkb21haW4uZGVmYXVsdExvY2FsZSA/IFwiXCIgOiBcIi9cIiArIHRhcmdldDtcblx0XHQgICAgICAgICAgICByZXR1cm4gXCJcIiArIHByb3RvICsgZG9tYWluLmRvbWFpbiArICgwLCBfbm9ybWFsaXpldHJhaWxpbmdzbGFzaC5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCkoXCJcIiArIGJhc2VQYXRoICsgZmluYWxMb2NhbGUgKyBwYXRoKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0XHQgICAgfVxuXHRcdH1cblxuXHRcdGlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuXHRcdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRcdCAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuXHRcdCAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG5cdFx0fVxuXG5cdFx0XG5cdH0gKGdldERvbWFpbkxvY2FsZSwgZ2V0RG9tYWluTG9jYWxlLmV4cG9ydHMpKTtcblx0cmV0dXJuIGdldERvbWFpbkxvY2FsZS5leHBvcnRzO1xufVxuXG52YXIgYWRkQmFzZVBhdGggPSB7ZXhwb3J0czoge319O1xuXG52YXIgaGFzUmVxdWlyZWRBZGRCYXNlUGF0aDtcblxuZnVuY3Rpb24gcmVxdWlyZUFkZEJhc2VQYXRoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQWRkQmFzZVBhdGgpIHJldHVybiBhZGRCYXNlUGF0aC5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZEFkZEJhc2VQYXRoID0gMTtcblx0KGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHQgICAgdmFsdWU6IHRydWVcblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRCYXNlUGF0aFwiLCB7XG5cdFx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gYWRkQmFzZVBhdGg7XG5cdFx0ICAgIH1cblx0XHR9KTtcblx0XHRjb25zdCBfYWRkcGF0aHByZWZpeCA9IHJlcXVpcmVBZGRQYXRoUHJlZml4KCk7XG5cdFx0Y29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlTm9ybWFsaXplVHJhaWxpbmdTbGFzaCgpO1xuXHRcdGNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuXHRcdGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGgsIHJlcXVpcmVkKSB7XG5cdFx0ICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2gubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gpKHByb2Nlc3MuZW52Ll9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCAmJiAhcmVxdWlyZWQgPyBwYXRoIDogKDAsIF9hZGRwYXRocHJlZml4LmFkZFBhdGhQcmVmaXgpKHBhdGgsIGJhc2VQYXRoKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG5cdFx0ICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblx0XHR9XG5cblx0XHRcblx0fSAoYWRkQmFzZVBhdGgsIGFkZEJhc2VQYXRoLmV4cG9ydHMpKTtcblx0cmV0dXJuIGFkZEJhc2VQYXRoLmV4cG9ydHM7XG59XG5cbnZhciByb3V0ZXJSZWR1Y2VyVHlwZXMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaGFzUmVxdWlyZWRSb3V0ZXJSZWR1Y2VyVHlwZXM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVSb3V0ZXJSZWR1Y2VyVHlwZXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRSb3V0ZXJSZWR1Y2VyVHlwZXMpIHJldHVybiByb3V0ZXJSZWR1Y2VyVHlwZXMuZXhwb3J0cztcblx0aGFzUmVxdWlyZWRSb3V0ZXJSZWR1Y2VyVHlwZXMgPSAxO1xuXHQoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdCAgICB2YWx1ZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdGZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcblx0XHQgICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG5cdFx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICAgICAgZ2V0OiBhbGxbbmFtZV1cblx0XHQgICAgfSk7XG5cdFx0fVxuXHRcdF9leHBvcnQoZXhwb3J0cywge1xuXHRcdCAgICBQcmVmZXRjaEtpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIFByZWZldGNoS2luZDtcblx0XHQgICAgfSxcblx0XHQgICAgQUNUSU9OX1JFRlJFU0g6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIEFDVElPTl9SRUZSRVNIO1xuXHRcdCAgICB9LFxuXHRcdCAgICBBQ1RJT05fTkFWSUdBVEU6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIEFDVElPTl9OQVZJR0FURTtcblx0XHQgICAgfSxcblx0XHQgICAgQUNUSU9OX1JFU1RPUkU6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIEFDVElPTl9SRVNUT1JFO1xuXHRcdCAgICB9LFxuXHRcdCAgICBBQ1RJT05fU0VSVkVSX1BBVENIOiBmdW5jdGlvbigpIHtcblx0XHQgICAgICAgIHJldHVybiBBQ1RJT05fU0VSVkVSX1BBVENIO1xuXHRcdCAgICB9LFxuXHRcdCAgICBBQ1RJT05fUFJFRkVUQ0g6IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIEFDVElPTl9QUkVGRVRDSDtcblx0XHQgICAgfSxcblx0XHQgICAgQUNUSU9OX0ZBU1RfUkVGUkVTSDogZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgICByZXR1cm4gQUNUSU9OX0ZBU1RfUkVGUkVTSDtcblx0XHQgICAgfSxcblx0XHQgICAgQUNUSU9OX1NFUlZFUl9BQ1RJT046IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIEFDVElPTl9TRVJWRVJfQUNUSU9OO1xuXHRcdCAgICB9XG5cdFx0fSk7XG5cdFx0Y29uc3QgQUNUSU9OX1JFRlJFU0ggPSBcInJlZnJlc2hcIjtcblx0XHRjb25zdCBBQ1RJT05fTkFWSUdBVEUgPSBcIm5hdmlnYXRlXCI7XG5cdFx0Y29uc3QgQUNUSU9OX1JFU1RPUkUgPSBcInJlc3RvcmVcIjtcblx0XHRjb25zdCBBQ1RJT05fU0VSVkVSX1BBVENIID0gXCJzZXJ2ZXItcGF0Y2hcIjtcblx0XHRjb25zdCBBQ1RJT05fUFJFRkVUQ0ggPSBcInByZWZldGNoXCI7XG5cdFx0Y29uc3QgQUNUSU9OX0ZBU1RfUkVGUkVTSCA9IFwiZmFzdC1yZWZyZXNoXCI7XG5cdFx0Y29uc3QgQUNUSU9OX1NFUlZFUl9BQ1RJT04gPSBcInNlcnZlci1hY3Rpb25cIjtcblx0XHR2YXIgUHJlZmV0Y2hLaW5kO1xuXHRcdChmdW5jdGlvbihQcmVmZXRjaEtpbmQpIHtcblx0XHQgICAgUHJlZmV0Y2hLaW5kW1wiQVVUT1wiXSA9IFwiYXV0b1wiO1xuXHRcdCAgICBQcmVmZXRjaEtpbmRbXCJGVUxMXCJdID0gXCJmdWxsXCI7XG5cdFx0ICAgIFByZWZldGNoS2luZFtcIlRFTVBPUkFSWVwiXSA9IFwidGVtcG9yYXJ5XCI7XG5cdFx0fSkoUHJlZmV0Y2hLaW5kIHx8IChQcmVmZXRjaEtpbmQgPSB7fSkpO1xuXG5cdFx0aWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFx0ICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG5cdFx0ICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblx0XHR9XG5cblx0XHRcblx0fSAocm91dGVyUmVkdWNlclR5cGVzLCByb3V0ZXJSZWR1Y2VyVHlwZXMuZXhwb3J0cykpO1xuXHRyZXR1cm4gcm91dGVyUmVkdWNlclR5cGVzLmV4cG9ydHM7XG59XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIGNsaWVudFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcblx0ICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiBfZGVmYXVsdDtcblx0ICAgIH1cblx0fSk7XG5cdGNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCQxO1xuXHRjb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKFJlYWN0X19kZWZhdWx0KTtcblx0Y29uc3QgX3Jlc29sdmVocmVmID0gcmVxdWlyZVJlc29sdmVIcmVmKCk7XG5cdGNvbnN0IF9pc2xvY2FsdXJsID0gcmVxdWlyZUlzTG9jYWxVcmwoKTtcblx0Y29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmVGb3JtYXRVcmwoKTtcblx0Y29uc3QgX3V0aWxzID0gcmVxdWlyZVV0aWxzJDEoKTtcblx0Y29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmVBZGRMb2NhbGUoKTtcblx0Y29uc3QgX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZVJvdXRlckNvbnRleHRfc2hhcmVkUnVudGltZSgpO1xuXHRjb25zdCBfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlQXBwUm91dGVyQ29udGV4dF9zaGFyZWRSdW50aW1lKCk7XG5cdGNvbnN0IF91c2VpbnRlcnNlY3Rpb24gPSByZXF1aXJlVXNlSW50ZXJzZWN0aW9uKCk7XG5cdGNvbnN0IF9nZXRkb21haW5sb2NhbGUgPSByZXF1aXJlR2V0RG9tYWluTG9jYWxlKCk7XG5cdGNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmVBZGRCYXNlUGF0aCgpO1xuXHRjb25zdCBfcm91dGVycmVkdWNlcnR5cGVzID0gcmVxdWlyZVJvdXRlclJlZHVjZXJUeXBlcygpO1xuXHRjb25zdCBwcmVmZXRjaGVkID0gbmV3IFNldCgpO1xuXHRmdW5jdGlvbiBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCBvcHRpb25zLCBhcHBPcHRpb25zLCBpc0FwcFJvdXRlcikge1xuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICAvLyBhcHAtcm91dGVyIHN1cHBvcnRzIGV4dGVybmFsIHVybHMgb3V0IG9mIHRoZSBib3ggc28gaXQgc2hvdWxkbid0IHNob3J0LWNpcmN1aXQgaGVyZSBhcyBzdXBwb3J0IGZvciBlLmcuIGByZXBsYWNlYCBpcyBhZGRlZCBpbiB0aGUgYXBwLXJvdXRlci5cblx0ICAgIGlmICghaXNBcHBSb3V0ZXIgJiYgISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShocmVmKSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIC8vIFdlIHNob3VsZCBvbmx5IGRlZHVwZSByZXF1ZXN0cyB3aGVuIGV4cGVyaW1lbnRhbC5vcHRpbWlzdGljQ2xpZW50Q2FjaGUgaXNcblx0ICAgIC8vIGRpc2FibGVkLlxuXHQgICAgaWYgKCFvcHRpb25zLmJ5cGFzc1ByZWZldGNoZWRDaGVjaykge1xuXHQgICAgICAgIGNvbnN0IGxvY2FsZSA9IC8vIExldCB0aGUgbGluaydzIGxvY2FsZSBwcm9wIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHJvdXRlciBsb2NhbGUuXG5cdCAgICAgICAgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb2NhbGUgOiBcImxvY2FsZVwiIGluIHJvdXRlciA/IHJvdXRlci5sb2NhbGUgOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgY29uc3QgcHJlZmV0Y2hlZEtleSA9IGhyZWYgKyBcIiVcIiArIGFzICsgXCIlXCIgKyBsb2NhbGU7XG5cdCAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBmZXRjaGVkIHRoZSBrZXksIHRoZW4gZG9uJ3QgcHJlZmV0Y2ggaXQgYWdhaW4hXG5cdCAgICAgICAgaWYgKHByZWZldGNoZWQuaGFzKHByZWZldGNoZWRLZXkpKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTWFyayB0aGlzIFVSTCBhcyBwcmVmZXRjaGVkLlxuXHQgICAgICAgIHByZWZldGNoZWQuYWRkKHByZWZldGNoZWRLZXkpO1xuXHQgICAgfVxuXHQgICAgY29uc3QgcHJlZmV0Y2hQcm9taXNlID0gaXNBcHBSb3V0ZXIgPyByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXBwT3B0aW9ucykgOiByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpO1xuXHQgICAgLy8gUHJlZmV0Y2ggdGhlIEpTT04gcGFnZSBpZiBhc2tlZCAob25seSBpbiB0aGUgY2xpZW50KVxuXHQgICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuXHQgICAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG5cdCAgICAvLyB3YW50IHRvIGZvcmNlIG5hdmlnYXRpb24gc2luY2UgdGhpcyBpcyBvbmx5IGEgcHJlZmV0Y2hcblx0ICAgIFByb21pc2UucmVzb2x2ZShwcmVmZXRjaFByb21pc2UpLmNhdGNoKChlcnIpPT57XG5cdCAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuXHQgICAgICAgICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG5cdCAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcblx0ICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcblx0ICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblx0ICAgIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0ICE9PSBcIl9zZWxmXCIgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuXHQgICAgZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDI7XG5cdH1cblx0ZnVuY3Rpb24gbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGlzQXBwUm91dGVyLCBwcmVmZXRjaEVuYWJsZWQpIHtcblx0ICAgIGNvbnN0IHsgbm9kZU5hbWUgfSA9IGUuY3VycmVudFRhcmdldDtcblx0ICAgIC8vIGFuY2hvcnMgaW5zaWRlIGFuIHN2ZyBoYXZlIGEgbG93ZXJjYXNlIG5vZGVOYW1lXG5cdCAgICBjb25zdCBpc0FuY2hvck5vZGVOYW1lID0gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJBXCI7XG5cdCAgICBpZiAoaXNBbmNob3JOb2RlTmFtZSAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8IC8vIGFwcC1yb3V0ZXIgc3VwcG9ydHMgZXh0ZXJuYWwgdXJscyBvdXQgb2YgdGhlIGJveCBzbyBpdCBzaG91bGRuJ3Qgc2hvcnQtY2lyY3VpdCBoZXJlIGFzIHN1cHBvcnQgZm9yIGUuZy4gYHJlcGxhY2VgIGlzIGFkZGVkIGluIHRoZSBhcHAtcm91dGVyLlxuXHQgICAgIWlzQXBwUm91dGVyICYmICEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoaHJlZikpKSB7XG5cdCAgICAgICAgLy8gaWdub3JlIGNsaWNrIGZvciBicm93c2Vy4oCZcyBkZWZhdWx0IGJlaGF2aW9yXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgY29uc3QgbmF2aWdhdGUgPSAoKT0+e1xuXHQgICAgICAgIC8vIElmIHRoZSByb3V0ZXIgaXMgYW4gTmV4dFJvdXRlciBpbnN0YW5jZSBpdCB3aWxsIGhhdmUgYGJlZm9yZVBvcFN0YXRlYFxuXHQgICAgICAgIGNvbnN0IHJvdXRlclNjcm9sbCA9IHNjcm9sbCAhPSBudWxsID8gc2Nyb2xsIDogdHJ1ZTtcblx0ICAgICAgICBpZiAoXCJiZWZvcmVQb3BTdGF0ZVwiIGluIHJvdXRlcikge1xuXHQgICAgICAgICAgICByb3V0ZXJbcmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJwdXNoXCJdKGhyZWYsIGFzLCB7XG5cdCAgICAgICAgICAgICAgICBzaGFsbG93LFxuXHQgICAgICAgICAgICAgICAgbG9jYWxlLFxuXHQgICAgICAgICAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcm91dGVyW3JlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiXShhcyB8fCBocmVmLCB7XG5cdCAgICAgICAgICAgICAgICBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uOiAhcHJlZmV0Y2hFbmFibGVkLFxuXHQgICAgICAgICAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIGlmIChpc0FwcFJvdXRlcikge1xuXHQgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbihuYXZpZ2F0ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIG5hdmlnYXRlKCk7XG5cdCAgICB9XG5cdH1cblx0ZnVuY3Rpb24gZm9ybWF0U3RyaW5nT3JVcmwodXJsT2JqT3JTdHJpbmcpIHtcblx0ICAgIGlmICh0eXBlb2YgdXJsT2JqT3JTdHJpbmcgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICByZXR1cm4gdXJsT2JqT3JTdHJpbmc7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKDAsIF9mb3JtYXR1cmwuZm9ybWF0VXJsKSh1cmxPYmpPclN0cmluZyk7XG5cdH1cblx0LyoqXG5cdCAqIFJlYWN0IENvbXBvbmVudCB0aGF0IGVuYWJsZXMgY2xpZW50LXNpZGUgdHJhbnNpdGlvbnMgYmV0d2VlbiByb3V0ZXMuXG5cdCAqLyBjb25zdCBMaW5rID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpbmtDb21wb25lbnQocHJvcHMsIGZvcndhcmRlZFJlZikge1xuXHQgICAgbGV0IGNoaWxkcmVuO1xuXHQgICAgY29uc3QgeyBocmVmOiBocmVmUHJvcCwgYXM6IGFzUHJvcCwgY2hpbGRyZW46IGNoaWxkcmVuUHJvcCwgcHJlZmV0Y2g6IHByZWZldGNoUHJvcCA9IG51bGwsIHBhc3NIcmVmLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSwgb25DbGljaywgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJQcm9wLCBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydFByb3AsIGxlZ2FjeUJlaGF2aW9yID0gZmFsc2UsIC4uLnJlc3RQcm9wcyB9ID0gcHJvcHM7XG5cdCAgICBjaGlsZHJlbiA9IGNoaWxkcmVuUHJvcDtcblx0ICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJudW1iZXJcIikpIHtcblx0ICAgICAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgbnVsbCwgY2hpbGRyZW4pO1xuXHQgICAgfVxuXHQgICAgY29uc3QgcGFnZXNSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5Sb3V0ZXJDb250ZXh0KTtcblx0ICAgIGNvbnN0IGFwcFJvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkFwcFJvdXRlckNvbnRleHQpO1xuXHQgICAgY29uc3Qgcm91dGVyID0gcGFnZXNSb3V0ZXIgIT0gbnVsbCA/IHBhZ2VzUm91dGVyIDogYXBwUm91dGVyO1xuXHQgICAgLy8gV2UncmUgaW4gdGhlIGFwcCBkaXJlY3RvcnkgaWYgdGhlcmUgaXMgbm8gcGFnZXMgcm91dGVyLlxuXHQgICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXI7XG5cdCAgICBjb25zdCBwcmVmZXRjaEVuYWJsZWQgPSBwcmVmZXRjaFByb3AgIT09IGZhbHNlO1xuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgcG9zc2libGUgc3RhdGVzIGZvciBwcmVmZXRjaCBhcmU6XG5cdCAgICAgKiAtIG51bGw6IHRoaXMgaXMgdGhlIGRlZmF1bHQgXCJhdXRvXCIgbW9kZSwgd2hlcmUgd2Ugd2lsbCBwcmVmZXRjaCBwYXJ0aWFsbHkgaWYgdGhlIGxpbmsgaXMgaW4gdGhlIHZpZXdwb3J0XG5cdCAgICAgKiAtIHRydWU6IHdlIHdpbGwgcHJlZmV0Y2ggaWYgdGhlIGxpbmsgaXMgdmlzaWJsZSBhbmQgcHJlZmV0Y2ggdGhlIGZ1bGwgcGFnZSwgbm90IGp1c3QgcGFydGlhbGx5XG5cdCAgICAgKiAtIGZhbHNlOiB3ZSB3aWxsIG5vdCBwcmVmZXRjaCBpZiBpbiB0aGUgdmlld3BvcnQgYXQgYWxsXG5cdCAgICAgKi8gY29uc3QgYXBwUHJlZmV0Y2hLaW5kID0gcHJlZmV0Y2hQcm9wID09PSBudWxsID8gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuQVVUTyA6IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkZVTEw7XG5cdCAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3MpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIGBcIiArIGFyZ3Mua2V5ICsgXCJgIGV4cGVjdHMgYSBcIiArIGFyZ3MuZXhwZWN0ZWQgKyBcIiBpbiBgPExpbms+YCwgYnV0IGdvdCBgXCIgKyBhcmdzLmFjdHVhbCArIFwiYCBpbnN0ZWFkLlwiICsgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiBcIlwiKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG5cdCAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wc0d1YXJkID0ge1xuXHQgICAgICAgICAgICBocmVmOiB0cnVlXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzID0gT2JqZWN0LmtleXMocmVxdWlyZWRQcm9wc0d1YXJkKTtcblx0ICAgICAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleSk9Pntcblx0ICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJocmVmXCIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldID09IG51bGwgfHwgdHlwZW9mIHByb3BzW2tleV0gIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBzdHJpbmdgIG9yIGBvYmplY3RgXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHByb3BzW2tleV1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG5cdCAgICAgICAgY29uc3Qgb3B0aW9uYWxQcm9wc0d1YXJkID0ge1xuXHQgICAgICAgICAgICBhczogdHJ1ZSxcblx0ICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcblx0ICAgICAgICAgICAgc2Nyb2xsOiB0cnVlLFxuXHQgICAgICAgICAgICBzaGFsbG93OiB0cnVlLFxuXHQgICAgICAgICAgICBwYXNzSHJlZjogdHJ1ZSxcblx0ICAgICAgICAgICAgcHJlZmV0Y2g6IHRydWUsXG5cdCAgICAgICAgICAgIGxvY2FsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgb25DbGljazogdHJ1ZSxcblx0ICAgICAgICAgICAgb25Nb3VzZUVudGVyOiB0cnVlLFxuXHQgICAgICAgICAgICBvblRvdWNoU3RhcnQ6IHRydWUsXG5cdCAgICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBjb25zdCBvcHRpb25hbFByb3BzID0gT2JqZWN0LmtleXMob3B0aW9uYWxQcm9wc0d1YXJkKTtcblx0ICAgICAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleSk9Pntcblx0ICAgICAgICAgICAgY29uc3QgdmFsVHlwZSA9IHR5cGVvZiBwcm9wc1trZXldO1xuXHQgICAgICAgICAgICBpZiAoa2V5ID09PSBcImFzXCIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09IFwic3RyaW5nXCIgJiYgdmFsVHlwZSAhPT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYHN0cmluZ2Agb3IgYG9iamVjdGBcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImxvY2FsZVwiKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgc3RyaW5nYFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwib25DbGlja1wiIHx8IGtleSA9PT0gXCJvbk1vdXNlRW50ZXJcIiB8fCBrZXkgPT09IFwib25Ub3VjaFN0YXJ0XCIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYGZ1bmN0aW9uYFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwicmVwbGFjZVwiIHx8IGtleSA9PT0gXCJzY3JvbGxcIiB8fCBrZXkgPT09IFwic2hhbGxvd1wiIHx8IGtleSA9PT0gXCJwYXNzSHJlZlwiIHx8IGtleSA9PT0gXCJwcmVmZXRjaFwiIHx8IGtleSA9PT0gXCJsZWdhY3lCZWhhdmlvclwiKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgYm9vbGVhbmBcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSA7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcblx0ICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3Ncblx0ICAgICAgICBjb25zdCBoYXNXYXJuZWQgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoZmFsc2UpO1xuXHQgICAgICAgIGlmIChwcm9wcy5wcmVmZXRjaCAmJiAhaGFzV2FybmVkLmN1cnJlbnQgJiYgIWlzQXBwUm91dGVyKSB7XG5cdCAgICAgICAgICAgIGhhc1dhcm5lZC5jdXJyZW50ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTmV4dC5qcyBhdXRvLXByZWZldGNoZXMgYXV0b21hdGljYWxseSBiYXNlZCBvbiB2aWV3cG9ydC4gVGhlIHByZWZldGNoIGF0dHJpYnV0ZSBpcyBubyBsb25nZXIgbmVlZGVkLiBNb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wcmVmZXRjaC10cnVlLWRlcHJlY2F0ZWRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuXHQgICAgICAgIGlmIChpc0FwcFJvdXRlciAmJiAhYXNQcm9wKSB7XG5cdCAgICAgICAgICAgIGxldCBocmVmO1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGhyZWZQcm9wID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICBocmVmID0gaHJlZlByb3A7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhyZWZQcm9wID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBocmVmUHJvcC5wYXRobmFtZSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgaHJlZiA9IGhyZWZQcm9wLnBhdGhuYW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChocmVmKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBoYXNEeW5hbWljU2VnbWVudCA9IGhyZWYuc3BsaXQoXCIvXCIpLnNvbWUoKHNlZ21lbnQpPT5zZWdtZW50LnN0YXJ0c1dpdGgoXCJbXCIpICYmIHNlZ21lbnQuZW5kc1dpdGgoXCJdXCIpKTtcblx0ICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljU2VnbWVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgaHJlZiBgXCIgKyBocmVmICsgXCJgIGZvdW5kIGluIDxMaW5rPiB3aGlsZSB1c2luZyB0aGUgYC9hcHBgIHJvdXRlciwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2FwcC1kaXItZHluYW1pYy1ocmVmXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgY29uc3QgeyBocmVmLCBhcyB9ID0gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuXHQgICAgICAgIGlmICghcGFnZXNSb3V0ZXIpIHtcblx0ICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZm9ybWF0U3RyaW5nT3JVcmwoaHJlZlByb3ApO1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuXHQgICAgICAgICAgICAgICAgYXM6IGFzUHJvcCA/IGZvcm1hdFN0cmluZ09yVXJsKGFzUHJvcCkgOiByZXNvbHZlZEhyZWZcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShwYWdlc1JvdXRlciwgaHJlZlByb3AsIHRydWUpO1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcblx0ICAgICAgICAgICAgYXM6IGFzUHJvcCA/ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHBhZ2VzUm91dGVyLCBhc1Byb3ApIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcblx0ICAgICAgICB9O1xuXHQgICAgfSwgW1xuXHQgICAgICAgIHBhZ2VzUm91dGVyLFxuXHQgICAgICAgIGhyZWZQcm9wLFxuXHQgICAgICAgIGFzUHJvcFxuXHQgICAgXSk7XG5cdCAgICBjb25zdCBwcmV2aW91c0hyZWYgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoaHJlZik7XG5cdCAgICBjb25zdCBwcmV2aW91c0FzID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGFzKTtcblx0ICAgIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuXHQgICAgbGV0IGNoaWxkO1xuXHQgICAgaWYgKGxlZ2FjeUJlaGF2aW9yKSB7XG5cdCAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcblx0ICAgICAgICAgICAgaWYgKG9uQ2xpY2spIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignXCJvbkNsaWNrXCIgd2FzIHBhc3NlZCB0byA8TGluaz4gd2l0aCBgaHJlZmAgb2YgYCcgKyBocmVmUHJvcCArICdgIGJ1dCBcImxlZ2FjeUJlaGF2aW9yXCIgd2FzIHNldC4gVGhlIGxlZ2FjeSBiZWhhdmlvciByZXF1aXJlcyBvbkNsaWNrIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKG9uTW91c2VFbnRlclByb3ApIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignXCJvbk1vdXNlRW50ZXJcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgJyArIGhyZWZQcm9wICsgJ2AgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uTW91c2VFbnRlciBiZSBzZXQgb24gdGhlIGNoaWxkIG9mIG5leHQvbGluaycpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGlsZHJlbiB3ZXJlIHBhc3NlZCB0byA8TGluaz4gd2l0aCBgaHJlZmAgb2YgYFwiICsgaHJlZlByb3AgKyBcImAgYnV0IG9uZSBjaGlsZCBpcyByZXF1aXJlZCBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9saW5rLW5vLWNoaWxkcmVuXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGBcIiArIGhyZWZQcm9wICsgXCJgIGJ1dCBvbmx5IG9uZSBjaGlsZCBpcyBzdXBwb3J0ZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1tdWx0aXBsZS1jaGlsZHJlblwiICsgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBcIiBcXG5PcGVuIHlvdXIgYnJvd3NlcidzIGNvbnNvbGUgdG8gdmlldyB0aGUgQ29tcG9uZW50IHN0YWNrIHRyYWNlLlwiIDogXCJcIikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcblx0ICAgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG5cdCAgICAgICAgICAgIGlmICgoY2hpbGRyZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkcmVuLnR5cGUpID09PSBcImFcIikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCA8TGluaz4gd2l0aCA8YT4gY2hpbGQuIFBsZWFzZSByZW1vdmUgPGE+IG9yIHVzZSA8TGluayBsZWdhY3lCZWhhdmlvcj4uXFxuTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1uZXctbGluay13aXRoLWV4dHJhLWFuY2hvclwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGNvbnN0IGNoaWxkUmVmID0gbGVnYWN5QmVoYXZpb3IgPyBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgY2hpbGQucmVmIDogZm9yd2FyZGVkUmVmO1xuXHQgICAgY29uc3QgW3NldEludGVyc2VjdGlvblJlZiwgaXNWaXNpYmxlLCByZXNldFZpc2libGVdID0gKDAsIF91c2VpbnRlcnNlY3Rpb24udXNlSW50ZXJzZWN0aW9uKSh7XG5cdCAgICAgICAgcm9vdE1hcmdpbjogXCIyMDBweFwiXG5cdCAgICB9KTtcblx0ICAgIGNvbnN0IHNldFJlZiA9IF9yZWFjdC5kZWZhdWx0LnVzZUNhbGxiYWNrKChlbCk9Pntcblx0ICAgICAgICAvLyBCZWZvcmUgdGhlIGxpbmsgZ2V0dGluZyBvYnNlcnZlZCwgY2hlY2sgaWYgdmlzaWJsZSBzdGF0ZSBuZWVkIHRvIGJlIHJlc2V0XG5cdCAgICAgICAgaWYgKHByZXZpb3VzQXMuY3VycmVudCAhPT0gYXMgfHwgcHJldmlvdXNIcmVmLmN1cnJlbnQgIT09IGhyZWYpIHtcblx0ICAgICAgICAgICAgcmVzZXRWaXNpYmxlKCk7XG5cdCAgICAgICAgICAgIHByZXZpb3VzQXMuY3VycmVudCA9IGFzO1xuXHQgICAgICAgICAgICBwcmV2aW91c0hyZWYuY3VycmVudCA9IGhyZWY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNldEludGVyc2VjdGlvblJlZihlbCk7XG5cdCAgICAgICAgaWYgKGNoaWxkUmVmKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09IFwiZnVuY3Rpb25cIikgY2hpbGRSZWYoZWwpO1xuXHQgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0sIFtcblx0ICAgICAgICBhcyxcblx0ICAgICAgICBjaGlsZFJlZixcblx0ICAgICAgICBocmVmLFxuXHQgICAgICAgIHJlc2V0VmlzaWJsZSxcblx0ICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWZcblx0ICAgIF0pO1xuXHQgICAgLy8gUHJlZmV0Y2ggdGhlIFVSTCBpZiB3ZSBoYXZlbid0IGFscmVhZHkgYW5kIGl0J3MgdmlzaWJsZS5cblx0ICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuXHQgICAgICAgIC8vIGluIGRldiwgd2Ugb25seSBwcmVmZXRjaCBvbiBob3ZlciB0byBhdm9pZCB3YXN0aW5nIHJlc291cmNlcyBhcyB0aGUgcHJlZmV0Y2ggd2lsbCB0cmlnZ2VyIGNvbXBpbGluZyB0aGUgcGFnZS5cblx0ICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFyb3V0ZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBJZiB3ZSBkb24ndCBuZWVkIHRvIHByZWZldGNoIHRoZSBVUkwsIGRvbid0IGRvIHByZWZldGNoLlxuXHQgICAgICAgIGlmICghaXNWaXNpYmxlIHx8ICFwcmVmZXRjaEVuYWJsZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBQcmVmZXRjaCB0aGUgVVJMLlxuXHQgICAgICAgIHByZWZldGNoKHJvdXRlciwgaHJlZiwgYXMsIHtcblx0ICAgICAgICAgICAgbG9jYWxlXG5cdCAgICAgICAgfSwge1xuXHQgICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcblx0ICAgICAgICB9LCBpc0FwcFJvdXRlcik7XG5cdCAgICB9LCBbXG5cdCAgICAgICAgYXMsXG5cdCAgICAgICAgaHJlZixcblx0ICAgICAgICBpc1Zpc2libGUsXG5cdCAgICAgICAgbG9jYWxlLFxuXHQgICAgICAgIHByZWZldGNoRW5hYmxlZCxcblx0ICAgICAgICBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlLFxuXHQgICAgICAgIHJvdXRlcixcblx0ICAgICAgICBpc0FwcFJvdXRlcixcblx0ICAgICAgICBhcHBQcmVmZXRjaEtpbmRcblx0ICAgIF0pO1xuXHQgICAgY29uc3QgY2hpbGRQcm9wcyA9IHtcblx0ICAgICAgICByZWY6IHNldFJlZixcblx0ICAgICAgICBvbkNsaWNrIChlKSB7XG5cdCAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IHJlbmRlcmVkIGluc2lkZSBuZXh0L2xpbmsgaGFzIHRvIHBhc3MgY2xpY2sgZXZlbnQgdG8gXCJvbkNsaWNrXCIgcHJvcC4nKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbkNsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgIG9uQ2xpY2soZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUsIGlzQXBwUm91dGVyLCBwcmVmZXRjaEVuYWJsZWQpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgb25Nb3VzZUVudGVyIChlKSB7XG5cdCAgICAgICAgICAgIGlmICghbGVnYWN5QmVoYXZpb3IgJiYgdHlwZW9mIG9uTW91c2VFbnRlclByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyUHJvcChlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobGVnYWN5QmVoYXZpb3IgJiYgY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoKCFwcmVmZXRjaEVuYWJsZWQgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikgJiYgaXNBcHBSb3V0ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG5cdCAgICAgICAgICAgICAgICBsb2NhbGUsXG5cdCAgICAgICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgIC8vIEBzZWUge2h0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9kaXNjdXNzaW9ucy80MDI2OD9zb3J0PXRvcCNkaXNjdXNzaW9uY29tbWVudC0zNTcyNjQyfVxuXHQgICAgICAgICAgICAgICAgYnlwYXNzUHJlZmV0Y2hlZENoZWNrOiB0cnVlXG5cdCAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgIGtpbmQ6IGFwcFByZWZldGNoS2luZFxuXHQgICAgICAgICAgICB9LCBpc0FwcFJvdXRlcik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBvblRvdWNoU3RhcnQgKGUpIHtcblx0ICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25Ub3VjaFN0YXJ0UHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgICAgICBvblRvdWNoU3RhcnRQcm9wKGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Ub3VjaFN0YXJ0ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIXJvdXRlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghcHJlZmV0Y2hFbmFibGVkICYmIGlzQXBwUm91dGVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuXHQgICAgICAgICAgICAgICAgbG9jYWxlLFxuXHQgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAvLyBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvZGlzY3Vzc2lvbnMvNDAyNjg/c29ydD10b3AjZGlzY3Vzc2lvbmNvbW1lbnQtMzU3MjY0Mn1cblx0ICAgICAgICAgICAgICAgIGJ5cGFzc1ByZWZldGNoZWRDaGVjazogdHJ1ZVxuXHQgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcblx0ICAgICAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcblx0ICAgIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlci5cblx0ICAgIC8vIElmIHRoZSB1cmwgaXMgYWJzb2x1dGUsIHdlIGNhbiBieXBhc3MgdGhlIGxvZ2ljIHRvIHByZXBlbmQgdGhlIGRvbWFpbiBhbmQgbG9jYWxlLlxuXHQgICAgaWYgKCgwLCBfdXRpbHMuaXNBYnNvbHV0ZVVybCkoYXMpKSB7XG5cdCAgICAgICAgY2hpbGRQcm9wcy5ocmVmID0gYXM7XG5cdCAgICB9IGVsc2UgaWYgKCFsZWdhY3lCZWhhdmlvciB8fCBwYXNzSHJlZiB8fCBjaGlsZC50eXBlID09PSBcImFcIiAmJiAhKFwiaHJlZlwiIGluIGNoaWxkLnByb3BzKSkge1xuXHQgICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBsb2NhbGUgOiBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlO1xuXHQgICAgICAgIC8vIHdlIG9ubHkgcmVuZGVyIGRvbWFpbiBsb2NhbGVzIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gYSBkb21haW4gbG9jYWxlXG5cdCAgICAgICAgLy8gc28gdGhhdCBsb2NhbGUgbGlua3MgYXJlIHN0aWxsIHZpc2l0YWJsZSBpbiBkZXZlbG9wbWVudC9wcmV2aWV3IGVudnNcblx0ICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSAocGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmlzTG9jYWxlRG9tYWluKSAmJiAoMCwgX2dldGRvbWFpbmxvY2FsZS5nZXREb21haW5Mb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGVzLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuZG9tYWluTG9jYWxlcyk7XG5cdCAgICAgICAgY2hpbGRQcm9wcy5ocmVmID0gbG9jYWxlRG9tYWluIHx8ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXMsIGN1ckxvY2FsZSwgcGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmRlZmF1bHRMb2NhbGUpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwge1xuXHQgICAgICAgIC4uLnJlc3RQcm9wcyxcblx0ICAgICAgICAuLi5jaGlsZFByb3BzXG5cdCAgICB9LCBjaGlsZHJlbik7XG5cdH0pO1xuXHRjb25zdCBfZGVmYXVsdCA9IExpbms7XG5cblx0aWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHQgIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcblx0fVxuXG5cdFxufSAobGluayQxLCBsaW5rJDEuZXhwb3J0cykpO1xuXG52YXIgbGlua0V4cG9ydHMgPSBsaW5rJDEuZXhwb3J0cztcblxudmFyIGxpbmsgPSBsaW5rRXhwb3J0cztcblxudmFyIExpbmsgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobGluayk7XG5cbnZhciBzdHlsZXMkcCA9IHtcImFuY2hvclwiOlwiQW5jaG9yLW1vZHVsZV9hbmNob3JfX2h6bW5lXCIsXCJpc1NwYW5cIjpcIkFuY2hvci1tb2R1bGVfaXNTcGFuX19KQU8zZlwifTtcblxuY29uc3QgQSA9ICh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9KSA9PiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IC4uLnByb3BzIH0sIGNoaWxkcmVuKTtcbmNvbnN0IEFuY2hvciA9ICh7IGlkLCBocmVmLCBvcGVuc0luTmV3VGFiID0gZmFsc2UsIGNsYXNzTmFtZSwgY2xhc3NOYW1lQW5jaG9yLCBjaGlsZHJlbiwgdXNlTmV4dEpTTGluayA9IHRydWUsIGFzLCBkaXNhYmxlID0gZmFsc2UsIG9uQ2xpY2ssIHVzZVNwYW5JbmxpbmUgPSBmYWxzZSwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHVzZU5leHRKUyA9IHVzZU5leHRKU0xpbmsgJiYgIW9wZW5zSW5OZXdUYWI7XG4gICAgY29uc3QgTGlua0NvbXBvbmVudCA9IHVzZU5leHRKUyA/IExpbmsgOiBBO1xuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBvbkNsaWNrPy4oZSk7XG4gICAgfSwgW29uQ2xpY2ssIGRpc2FibGVdKTtcbiAgICBjb25zdCBjaGlsZCA9IHVzZU1lbW8oKCkgPT4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTGlua0NvbXBvbmVudCwgeyAuLi5wcm9wcywgYXM6IGFzLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoY2xhc3NOYW1lQW5jaG9yLCBzdHlsZXMkcC5hbmNob3IsIHtcbiAgICAgICAgICAgIFtzdHlsZXMkcC5pc1NwYW5dOiB1c2VTcGFuSW5saW5lLFxuICAgICAgICB9KSwgaHJlZjogaHJlZiwgb25DbGljazogaGFuZGxlQ2xpY2ssIHJlbDogXCJub3JlZmVycmVyXCIsIHRhcmdldDogb3BlbnNJbk5ld1RhYiA/ICdfYmxhbmsnIDogJycgfSwgY2hpbGRyZW4pKSwgW1xuICAgICAgICBMaW5rQ29tcG9uZW50LFxuICAgICAgICBhcyxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNsYXNzTmFtZUFuY2hvcixcbiAgICAgICAgaGFuZGxlQ2xpY2ssXG4gICAgICAgIGhyZWYsXG4gICAgICAgIG9wZW5zSW5OZXdUYWIsXG4gICAgICAgIHByb3BzLFxuICAgICAgICB1c2VTcGFuSW5saW5lLFxuICAgIF0pO1xuICAgIHJldHVybiB1c2VTcGFuSW5saW5lID8gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNsYXNzTmFtZSwgc3R5bGVzJHAuYW5jaG9yV3JhcHBlciksIGlkOiBpZCB9LCBjaGlsZCkpIDogKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoY2xhc3NOYW1lLCBzdHlsZXMkcC5hbmNob3JXcmFwcGVyKSwgaWQ6IGlkIH0sIGNoaWxkKSk7XG59O1xuXG5jb25zdCBleHRyYWN0U3RhdGljSW1hZ2UgPSAoaW1hZ2VJbXBvcnQpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuU1RPUllCT09LICYmIHR5cGVvZiBpbWFnZUltcG9ydCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGltYWdlSW1wb3J0Py5zcmM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW1hZ2VJbXBvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbWFnZUltcG9ydDtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcblxuY29uc3QgSEVBREVSX1NJWkVTID0gWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNiddO1xuY29uc3QgZ2VuZXJhdGVGb250U2l6ZUNsYXNzTmFtZSA9ICh7IGZvbnRTaXplLCBib2xkLCBpdGFsaWMgPSBmYWxzZSwgYm9sZDUwMCA9IGZhbHNlLCBib2xkNjAwID0gZmFsc2UsIHVuZGVybGluZSA9IGZhbHNlLCBpbmhlcml0ID0gdHJ1ZSwgbm90Qm9sZCA9IGJvbGQgPT09IGZhbHNlLCBoZWFkZXJWYXJpYW50LCB1c2VIZWFkZXJGb250ID0gZmFsc2UsIH0pID0+IGNsYXNzTmFtZXMoJ2ZvbnQnLCBgZm9udC1zaXplLSR7Zm9udFNpemV9YCwge1xuICAgIGhlYWRlcjogdXNlSGVhZGVyRm9udCB8fCBIRUFERVJfU0laRVMuaW5jbHVkZXMoaGVhZGVyVmFyaWFudCB8fCAnJyksXG4gICAgYm9sZCxcbiAgICBib2xkNTAwLFxuICAgIGJvbGQ2MDAsXG4gICAgbm90Qm9sZCxcbiAgICBpdGFsaWMsXG4gICAgdW5kZXJsaW5lLFxuICAgIGluaGVyaXQsXG59KTtcblxuY29uc3QgUE9TU0lCTEVfQ09MT1JTID0gW1xuICAgICd3aGl0ZScsXG4gICAgJ2JsYWNrJyxcbiAgICAnZGFyaycsXG4gICAgJ2dyYXknLFxuICAgICdyZWQnLFxuICAgICdwaW5rJyxcbiAgICAnZ3JhcGUnLFxuICAgICd2aW9sZXQnLFxuICAgICdpbmRpZ28nLFxuICAgICdibHVlJyxcbiAgICAnY3lhbicsXG4gICAgJ3RlYWwnLFxuICAgICdncmVlbicsXG4gICAgJ2xpbWUnLFxuICAgICd5ZWxsb3cnLFxuICAgICdvcmFuZ2UnLFxuXTtcbmNvbnN0IFBPU1NJQkxFX1NIQURFUyA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XTtcbmNvbnN0IGdldENzc1ZhcmlhYmxlRm9yQ29sb3IgPSAoY29sb3IsIHNoYWRlKSA9PiB7XG4gICAgaWYgKGNvbG9yID09PSAnd2hpdGUnKSB7XG4gICAgICAgIHJldHVybiAnLS10aGVtZS1jb2xvci13aGl0ZSc7XG4gICAgfVxuICAgIGlmIChjb2xvciA9PT0gJ2JsYWNrJykge1xuICAgICAgICByZXR1cm4gJy0tdGhlbWUtY29sb3ItYmxhY2snO1xuICAgIH1cbiAgICByZXR1cm4gYC0tdGhlbWUtY29sb3ItJHtjb2xvcn0tJHtzaGFkZX1gO1xufTtcbmNvbnN0IGdldFRoZW1lVmFyaWFibGUgPSAocGFyYW1zT2JqKSA9PiB7XG4gICAgbGV0IGNzc1ZhcmlhYmxlS2V5O1xuICAgIHN3aXRjaCAocGFyYW1zT2JqLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29sb3InOiB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbG9yLCBzaGFkZSwgZXhjbHVkZUNvbG9ycywgZXhjbHVkZVNoYWRlcyB9ID0gcGFyYW1zT2JqO1xuICAgICAgICAgICAgaWYgKGNvbG9yID09PSAncmFuZG9tJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmRvbUNvbG9yID0gZ2V0TlJhbmRvbUVsZW1lbnRzRnJvbUFycmF5KFBPU1NJQkxFX0NPTE9SUy5maWx0ZXIoKGNvbCkgPT4gIShleGNsdWRlQ29sb3JzIHx8IFtdKS5zb21lKChjKSA9PiBjLnRvU3RyaW5nKCkgPT09IGNvbC50b1N0cmluZygpKSksIDEpWzBdO1xuICAgICAgICAgICAgICAgIGNzc1ZhcmlhYmxlS2V5ID0gZ2V0Q3NzVmFyaWFibGVGb3JDb2xvcihyYW5kb21Db2xvciwgc2hhZGUgPT09ICdyYW5kb20nXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0TlJhbmRvbUVsZW1lbnRzRnJvbUFycmF5KFBPU1NJQkxFX1NIQURFUy5maWx0ZXIoKGNvbCkgPT4gIShleGNsdWRlU2hhZGVzIHx8IFtdKS5zb21lKChjKSA9PiBjLnRvU3RyaW5nKCkgPT09IGNvbC50b1N0cmluZygpKSksIDEpWzBdXG4gICAgICAgICAgICAgICAgICAgIDogc2hhZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3NzVmFyaWFibGVLZXkgPSBnZXRDc3NWYXJpYWJsZUZvckNvbG9yKGNvbG9yLCBzaGFkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdmb250LXNpemUnOiB7XG4gICAgICAgICAgICBjb25zdCB7IHNpemUgfSA9IHBhcmFtc09iajtcbiAgICAgICAgICAgIGNzc1ZhcmlhYmxlS2V5ID0gYC0tdGhlbWUtJHtzaXplfS1mb250LXNpemVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbGluZS1oZWlnaHQnOiB7XG4gICAgICAgICAgICBjb25zdCB7IHNpemUgfSA9IHBhcmFtc09iajtcbiAgICAgICAgICAgIGlmIChbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10uaW5jbHVkZXMoc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBjc3NWYXJpYWJsZUtleSA9IGAtLXRoZW1lLWxpbmUtaGVpZ2h0YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNzc1ZhcmlhYmxlS2V5ID0gYC0tdGhlbWUtJHtzaXplfS1saW5lLWhlaWdodGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzaGFkb3cnOiB7XG4gICAgICAgICAgICBjb25zdCB7IHNpemUgfSA9IHBhcmFtc09iajtcbiAgICAgICAgICAgIGNzc1ZhcmlhYmxlS2V5ID0gYC0tdGhlbWUtc2hhZG93LWJhc2UtJHtzaXplfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyYWRpdXMnOiB7XG4gICAgICAgICAgICBjb25zdCB7IHNpemUgfSA9IHBhcmFtc09iajtcbiAgICAgICAgICAgIGNzc1ZhcmlhYmxlS2V5ID0gYC0tdGhlbWUtcmFkaXVzLSR7c2l6ZX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzQnJvd3NlcigpICYmIGNzc1ZhcmlhYmxlS2V5XG4gICAgICAgID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkuZ2V0UHJvcGVydHlWYWx1ZShjc3NWYXJpYWJsZUtleSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5maW5kS2V5YCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICogdXNpbmcgYGVhY2hGdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5cbmZ1bmN0aW9uIGJhc2VGaW5kS2V5JDEoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYykge1xuICB2YXIgcmVzdWx0O1xuICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZUZpbmRLZXkgPSBiYXNlRmluZEtleSQxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQmFzZUZvciQxKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IkMTtcblxudmFyIGNyZWF0ZUJhc2VGb3IgPSBfY3JlYXRlQmFzZUZvcjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yJDEgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbnZhciBfYmFzZUZvciA9IGJhc2VGb3IkMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cblxuZnVuY3Rpb24gYmFzZVRpbWVzJDEobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZVRpbWVzID0gYmFzZVRpbWVzJDE7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG5cbnZhciBmcmVlR2xvYmFsJDEgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cbnZhciBfZnJlZUdsb2JhbCA9IGZyZWVHbG9iYWwkMTtcblxudmFyIGZyZWVHbG9iYWwgPSBfZnJlZUdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290JDggPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBfcm9vdCA9IHJvb3QkODtcblxudmFyIHJvb3QkNyA9IF9yb290O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wkNiA9IHJvb3QkNy5TeW1ib2w7XG5cbnZhciBfU3ltYm9sID0gU3ltYm9sJDY7XG5cbnZhciBTeW1ib2wkNSA9IF9TeW1ib2w7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRmID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkYyA9IG9iamVjdFByb3RvJGYuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kZi50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IFN5bWJvbCQ1ID8gU3ltYm9sJDUudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnJDEodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkkYy5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyQxKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZyQxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cbnZhciBvYmplY3RQcm90byRlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8kZS50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nJDEodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG52YXIgX29iamVjdFRvU3RyaW5nID0gb2JqZWN0VG9TdHJpbmckMTtcblxudmFyIFN5bWJvbCQ0ID0gX1N5bWJvbCxcbiAgICBnZXRSYXdUYWcgPSBfZ2V0UmF3VGFnLFxuICAgIG9iamVjdFRvU3RyaW5nID0gX29iamVjdFRvU3RyaW5nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wkNCA/IFN5bWJvbCQ0LnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyQ3KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxudmFyIF9iYXNlR2V0VGFnID0gYmFzZUdldFRhZyQ3O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdExpa2UkOSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbnZhciBpc09iamVjdExpa2VfMSA9IGlzT2JqZWN0TGlrZSQ5O1xuXG52YXIgYmFzZUdldFRhZyQ2ID0gX2Jhc2VHZXRUYWcsXG4gICAgaXNPYmplY3RMaWtlJDggPSBpc09iamVjdExpa2VfMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWckMyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyQxKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UkOCh2YWx1ZSkgJiYgYmFzZUdldFRhZyQ2KHZhbHVlKSA9PSBhcmdzVGFnJDM7XG59XG5cbnZhciBfYmFzZUlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzJDE7XG5cbnZhciBiYXNlSXNBcmd1bWVudHMgPSBfYmFzZUlzQXJndW1lbnRzLFxuICAgIGlzT2JqZWN0TGlrZSQ3ID0gaXNPYmplY3RMaWtlXzE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRkID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkYiA9IG9iamVjdFByb3RvJGQuaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlJDEgPSBvYmplY3RQcm90byRkLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMkMyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UkNyh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkkYi5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUkMS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG52YXIgaXNBcmd1bWVudHNfMSA9IGlzQXJndW1lbnRzJDM7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG52YXIgaXNBcnJheSRjID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGlzQXJyYXlfMSA9IGlzQXJyYXkkYztcblxudmFyIGlzQXJyYXkkZCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpc0FycmF5XzEpO1xuXG52YXIgaXNCdWZmZXIkMyA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgc3R1YkZhbHNlXzEgPSBzdHViRmFsc2U7XG5cbmlzQnVmZmVyJDMuZXhwb3J0cztcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0dmFyIHJvb3QgPSBfcm9vdCxcblx0ICAgIHN0dWJGYWxzZSA9IHN0dWJGYWxzZV8xO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG5cdHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG5cdC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cdHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG5cdC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblx0dmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4zLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHR2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjsgXG59IChpc0J1ZmZlciQzLCBpc0J1ZmZlciQzLmV4cG9ydHMpKTtcblxudmFyIGlzQnVmZmVyRXhwb3J0cyA9IGlzQnVmZmVyJDMuZXhwb3J0cztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSJDEgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgkMyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIkMSA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbnZhciBfaXNJbmRleCA9IGlzSW5kZXgkMztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoJDModmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxudmFyIGlzTGVuZ3RoXzEgPSBpc0xlbmd0aCQzO1xuXG52YXIgYmFzZUdldFRhZyQ1ID0gX2Jhc2VHZXRUYWcsXG4gICAgaXNMZW5ndGgkMiA9IGlzTGVuZ3RoXzEsXG4gICAgaXNPYmplY3RMaWtlJDYgPSBpc09iamVjdExpa2VfMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWckMiA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnJDIgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWckMyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnJDMgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWckMiA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyQyID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWckNiA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyQzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnJDQgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWckMyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyQ2ID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnJDQgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnJDIgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyQzID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyQ0ID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnJDIgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnJDIgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnJDIgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyQyID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnJDIgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWckMiA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWckMiA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnJDIgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyQyID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnJDJdID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZyQyXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnJDJdID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWckMl0gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWckMl0gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZyQyXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWckMl0gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWckMl0gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnJDJdID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWckMl0gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZyQyXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZyQzXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWckM10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWckNF0gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnJDNdID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnJDJdID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZyQyXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWckNl0gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWckM10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnJDRdID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnJDNdID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZyQ2XSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZyQ0XSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnJDJdID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkkMSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlJDYodmFsdWUpICYmXG4gICAgaXNMZW5ndGgkMih2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyQ1KHZhbHVlKV07XG59XG5cbnZhciBfYmFzZUlzVHlwZWRBcnJheSA9IGJhc2VJc1R5cGVkQXJyYXkkMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBiYXNlVW5hcnkkNChmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxudmFyIF9iYXNlVW5hcnkgPSBiYXNlVW5hcnkkNDtcblxudmFyIF9ub2RlVXRpbCA9IHtleHBvcnRzOiB7fX07XG5cbl9ub2RlVXRpbC5leHBvcnRzO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHR2YXIgZnJlZUdsb2JhbCA9IF9mcmVlR2xvYmFsO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG5cdHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG5cdC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cdHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuXHR2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuXHQvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cblx0dmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuXHQgIHRyeSB7XG5cdCAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cblx0ICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG5cdCAgICBpZiAodHlwZXMpIHtcblx0ICAgICAgcmV0dXJuIHR5cGVzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuXHQgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuXHQgIH0gY2F0Y2ggKGUpIHt9XG5cdH0oKSk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDsgXG59IChfbm9kZVV0aWwsIF9ub2RlVXRpbC5leHBvcnRzKSk7XG5cbnZhciBfbm9kZVV0aWxFeHBvcnRzID0gX25vZGVVdGlsLmV4cG9ydHM7XG5cbnZhciBiYXNlSXNUeXBlZEFycmF5ID0gX2Jhc2VJc1R5cGVkQXJyYXksXG4gICAgYmFzZVVuYXJ5JDMgPSBfYmFzZVVuYXJ5LFxuICAgIG5vZGVVdGlsJDIgPSBfbm9kZVV0aWxFeHBvcnRzO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCQyICYmIG5vZGVVdGlsJDIuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5JDIgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5JDMobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG52YXIgaXNUeXBlZEFycmF5XzEgPSBpc1R5cGVkQXJyYXkkMjtcblxudmFyIGJhc2VUaW1lcyA9IF9iYXNlVGltZXMsXG4gICAgaXNBcmd1bWVudHMkMiA9IGlzQXJndW1lbnRzXzEsXG4gICAgaXNBcnJheSRiID0gaXNBcnJheV8xLFxuICAgIGlzQnVmZmVyJDIgPSBpc0J1ZmZlckV4cG9ydHMsXG4gICAgaXNJbmRleCQyID0gX2lzSW5kZXgsXG4gICAgaXNUeXBlZEFycmF5JDEgPSBpc1R5cGVkQXJyYXlfMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGMgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSRhID0gb2JqZWN0UHJvdG8kYy5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyQyKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSRiKHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzJDIodmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlciQyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkkMSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkkYS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgkMihrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYXJyYXlMaWtlS2V5cyA9IGFycmF5TGlrZUtleXMkMjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXG52YXIgb2JqZWN0UHJvdG8kYiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSQzKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90byRiO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbnZhciBfaXNQcm90b3R5cGUgPSBpc1Byb3RvdHlwZSQzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBvdmVyQXJnJDIoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbnZhciBfb3ZlckFyZyA9IG92ZXJBcmckMjtcblxudmFyIG92ZXJBcmckMSA9IF9vdmVyQXJnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyQxID0gb3ZlckFyZyQxKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG52YXIgX25hdGl2ZUtleXMgPSBuYXRpdmVLZXlzJDE7XG5cbnZhciBpc1Byb3RvdHlwZSQyID0gX2lzUHJvdG90eXBlLFxuICAgIG5hdGl2ZUtleXMgPSBfbmF0aXZlS2V5cztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ5ID0gb2JqZWN0UHJvdG8kYS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzJDIob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUkMihvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQ5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VLZXlzID0gYmFzZUtleXMkMjtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdCQ3KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0JDc7XG5cbnZhciBiYXNlR2V0VGFnJDQgPSBfYmFzZUdldFRhZyxcbiAgICBpc09iamVjdCQ2ID0gaXNPYmplY3RfMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWckMSA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnJDEgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24kMih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0JDYodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWckNCh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyQxIHx8IHRhZyA9PSBnZW5UYWckMSB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG52YXIgaXNGdW5jdGlvbl8xID0gaXNGdW5jdGlvbiQyO1xuXG52YXIgaXNGdW5jdGlvbiQxID0gaXNGdW5jdGlvbl8xLFxuICAgIGlzTGVuZ3RoJDEgPSBpc0xlbmd0aF8xO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSQ2KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoJDEodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbiQxKHZhbHVlKTtcbn1cblxudmFyIGlzQXJyYXlMaWtlXzEgPSBpc0FycmF5TGlrZSQ2O1xuXG52YXIgYXJyYXlMaWtlS2V5cyQxID0gX2FycmF5TGlrZUtleXMsXG4gICAgYmFzZUtleXMkMSA9IF9iYXNlS2V5cyxcbiAgICBpc0FycmF5TGlrZSQ1ID0gaXNBcnJheUxpa2VfMTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzJDUob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZSQ1KG9iamVjdCkgPyBhcnJheUxpa2VLZXlzJDEob2JqZWN0KSA6IGJhc2VLZXlzJDEob2JqZWN0KTtcbn1cblxudmFyIGtleXNfMSA9IGtleXMkNTtcblxudmFyIGJhc2VGb3IgPSBfYmFzZUZvcixcbiAgICBrZXlzJDQgPSBrZXlzXzE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93biQzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMkNCk7XG59XG5cbnZhciBfYmFzZUZvck93biA9IGJhc2VGb3JPd24kMztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyJDEoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxudmFyIF9saXN0Q2FjaGVDbGVhciA9IGxpc3RDYWNoZUNsZWFyJDE7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuXG5mdW5jdGlvbiBlcSQ0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxudmFyIGVxXzEgPSBlcSQ0O1xuXG52YXIgZXEkMyA9IGVxXzE7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZiQ0KGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxJDMoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgX2Fzc29jSW5kZXhPZiA9IGFzc29jSW5kZXhPZiQ0O1xuXG52YXIgYXNzb2NJbmRleE9mJDMgPSBfYXNzb2NJbmRleE9mO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZSQxKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZiQzKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgX2xpc3RDYWNoZURlbGV0ZSA9IGxpc3RDYWNoZURlbGV0ZSQxO1xuXG52YXIgYXNzb2NJbmRleE9mJDIgPSBfYXNzb2NJbmRleE9mO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQkMShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YkMihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxudmFyIF9saXN0Q2FjaGVHZXQgPSBsaXN0Q2FjaGVHZXQkMTtcblxudmFyIGFzc29jSW5kZXhPZiQxID0gX2Fzc29jSW5kZXhPZjtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyQxKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mJDEodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG52YXIgX2xpc3RDYWNoZUhhcyA9IGxpc3RDYWNoZUhhcyQxO1xuXG52YXIgYXNzb2NJbmRleE9mID0gX2Fzc29jSW5kZXhPZjtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQkMShrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfbGlzdENhY2hlU2V0ID0gbGlzdENhY2hlU2V0JDE7XG5cbnZhciBsaXN0Q2FjaGVDbGVhciA9IF9saXN0Q2FjaGVDbGVhcixcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSBfbGlzdENhY2hlRGVsZXRlLFxuICAgIGxpc3RDYWNoZUdldCA9IF9saXN0Q2FjaGVHZXQsXG4gICAgbGlzdENhY2hlSGFzID0gX2xpc3RDYWNoZUhhcyxcbiAgICBsaXN0Q2FjaGVTZXQgPSBfbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZSQ0KGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUkNC5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZSQ0LnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUkNC5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlJDQucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZSQ0LnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbnZhciBfTGlzdENhY2hlID0gTGlzdENhY2hlJDQ7XG5cbnZhciBMaXN0Q2FjaGUkMyA9IF9MaXN0Q2FjaGU7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhciQxKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZSQzO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX3N0YWNrQ2xlYXIgPSBzdGFja0NsZWFyJDE7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxuZnVuY3Rpb24gc3RhY2tEZWxldGUkMShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfc3RhY2tEZWxldGUgPSBzdGFja0RlbGV0ZSQxO1xuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5cbmZ1bmN0aW9uIHN0YWNrR2V0JDEoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG52YXIgX3N0YWNrR2V0ID0gc3RhY2tHZXQkMTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxuZnVuY3Rpb24gc3RhY2tIYXMkMShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbnZhciBfc3RhY2tIYXMgPSBzdGFja0hhcyQxO1xuXG52YXIgcm9vdCQ2ID0gX3Jvb3Q7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhJDEgPSByb290JDZbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG52YXIgX2NvcmVKc0RhdGEgPSBjb3JlSnNEYXRhJDE7XG5cbnZhciBjb3JlSnNEYXRhID0gX2NvcmVKc0RhdGE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZCQxKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxudmFyIF9pc01hc2tlZCA9IGlzTWFza2VkJDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblxudmFyIGZ1bmNQcm90byQyID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nJDIgPSBmdW5jUHJvdG8kMi50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlJDIoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmckMi5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIF90b1NvdXJjZSA9IHRvU291cmNlJDI7XG5cbnZhciBpc0Z1bmN0aW9uID0gaXNGdW5jdGlvbl8xLFxuICAgIGlzTWFza2VkID0gX2lzTWFza2VkLFxuICAgIGlzT2JqZWN0JDUgPSBpc09iamVjdF8xLFxuICAgIHRvU291cmNlJDEgPSBfdG9Tb3VyY2U7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvJDEgPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8kOSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmckMSA9IGZ1bmNQcm90byQxLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ4ID0gb2JqZWN0UHJvdG8kOS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZyQxLmNhbGwoaGFzT3duUHJvcGVydHkkOCkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlJDEodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCQ1KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UkMSh2YWx1ZSkpO1xufVxuXG52YXIgX2Jhc2VJc05hdGl2ZSA9IGJhc2VJc05hdGl2ZSQxO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cbmZ1bmN0aW9uIGdldFZhbHVlJDEob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbnZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZSQxO1xuXG52YXIgYmFzZUlzTmF0aXZlID0gX2Jhc2VJc05hdGl2ZSxcbiAgICBnZXRWYWx1ZSA9IF9nZXRWYWx1ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlJDcob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2dldE5hdGl2ZSA9IGdldE5hdGl2ZSQ3O1xuXG52YXIgZ2V0TmF0aXZlJDYgPSBfZ2V0TmF0aXZlLFxuICAgIHJvb3QkNSA9IF9yb290O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwJDQgPSBnZXROYXRpdmUkNihyb290JDUsICdNYXAnKTtcblxudmFyIF9NYXAgPSBNYXAkNDtcblxudmFyIGdldE5hdGl2ZSQ1ID0gX2dldE5hdGl2ZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSQ0ID0gZ2V0TmF0aXZlJDUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbnZhciBfbmF0aXZlQ3JlYXRlID0gbmF0aXZlQ3JlYXRlJDQ7XG5cbnZhciBuYXRpdmVDcmVhdGUkMyA9IF9uYXRpdmVDcmVhdGU7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhciQxKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlJDMgPyBuYXRpdmVDcmVhdGUkMyhudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2hhc2hDbGVhciA9IGhhc2hDbGVhciQxO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNoRGVsZXRlJDEoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZSQxO1xuXG52YXIgbmF0aXZlQ3JlYXRlJDIgPSBfbmF0aXZlQ3JlYXRlO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQkMiA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDggPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ3ID0gb2JqZWN0UHJvdG8kOC5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQkMShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlJDIpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEJDIgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5JDcuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2hhc2hHZXQgPSBoYXNoR2V0JDE7XG5cbnZhciBuYXRpdmVDcmVhdGUkMSA9IF9uYXRpdmVDcmVhdGU7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ3ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNiA9IG9iamVjdFByb3RvJDcuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyQxKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUkMSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eSQ2LmNhbGwoZGF0YSwga2V5KTtcbn1cblxudmFyIF9oYXNoSGFzID0gaGFzaEhhcyQxO1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX25hdGl2ZUNyZWF0ZTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEJDEgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQkMShrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEJDEgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfaGFzaFNldCA9IGhhc2hTZXQkMTtcblxudmFyIGhhc2hDbGVhciA9IF9oYXNoQ2xlYXIsXG4gICAgaGFzaERlbGV0ZSA9IF9oYXNoRGVsZXRlLFxuICAgIGhhc2hHZXQgPSBfaGFzaEdldCxcbiAgICBoYXNoSGFzID0gX2hhc2hIYXMsXG4gICAgaGFzaFNldCA9IF9oYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaCQxKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaCQxLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gkMS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gkMS5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gkMS5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gkMS5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxudmFyIF9IYXNoID0gSGFzaCQxO1xuXG52YXIgSGFzaCA9IF9IYXNoLFxuICAgIExpc3RDYWNoZSQyID0gX0xpc3RDYWNoZSxcbiAgICBNYXAkMyA9IF9NYXA7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIkMSgpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCQzIHx8IExpc3RDYWNoZSQyKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxudmFyIF9tYXBDYWNoZUNsZWFyID0gbWFwQ2FjaGVDbGVhciQxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBpc0tleWFibGUkMSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG52YXIgX2lzS2V5YWJsZSA9IGlzS2V5YWJsZSQxO1xuXG52YXIgaXNLZXlhYmxlID0gX2lzS2V5YWJsZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YSQ0KG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbnZhciBfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGEkNDtcblxudmFyIGdldE1hcERhdGEkMyA9IF9nZXRNYXBEYXRhO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUkMShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEkMyh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWFwQ2FjaGVEZWxldGUgPSBtYXBDYWNoZURlbGV0ZSQxO1xuXG52YXIgZ2V0TWFwRGF0YSQyID0gX2dldE1hcERhdGE7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldCQxKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSQyKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbnZhciBfbWFwQ2FjaGVHZXQgPSBtYXBDYWNoZUdldCQxO1xuXG52YXIgZ2V0TWFwRGF0YSQxID0gX2dldE1hcERhdGE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMkMShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEkMSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG52YXIgX21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXMkMTtcblxudmFyIGdldE1hcERhdGEgPSBfZ2V0TWFwRGF0YTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldCQxKGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfbWFwQ2FjaGVTZXQgPSBtYXBDYWNoZVNldCQxO1xuXG52YXIgbWFwQ2FjaGVDbGVhciA9IF9tYXBDYWNoZUNsZWFyLFxuICAgIG1hcENhY2hlRGVsZXRlID0gX21hcENhY2hlRGVsZXRlLFxuICAgIG1hcENhY2hlR2V0ID0gX21hcENhY2hlR2V0LFxuICAgIG1hcENhY2hlSGFzID0gX21hcENhY2hlSGFzLFxuICAgIG1hcENhY2hlU2V0ID0gX21hcENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUkMyhlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZSQzLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZSQzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlJDMucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUkMy5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZSQzLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxudmFyIF9NYXBDYWNoZSA9IE1hcENhY2hlJDM7XG5cbnZhciBMaXN0Q2FjaGUkMSA9IF9MaXN0Q2FjaGUsXG4gICAgTWFwJDIgPSBfTWFwLFxuICAgIE1hcENhY2hlJDIgPSBfTWFwQ2FjaGU7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUkMSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQkMShrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUkMSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAkMiB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSQxIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlJDIocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgX3N0YWNrU2V0ID0gc3RhY2tTZXQkMTtcblxudmFyIExpc3RDYWNoZSA9IF9MaXN0Q2FjaGUsXG4gICAgc3RhY2tDbGVhciA9IF9zdGFja0NsZWFyLFxuICAgIHN0YWNrRGVsZXRlID0gX3N0YWNrRGVsZXRlLFxuICAgIHN0YWNrR2V0ID0gX3N0YWNrR2V0LFxuICAgIHN0YWNrSGFzID0gX3N0YWNrSGFzLFxuICAgIHN0YWNrU2V0ID0gX3N0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayQzKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2skMy5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2skMy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjayQzLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrJDMucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2skMy5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbnZhciBfU3RhY2sgPSBTdGFjayQzO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG5cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkJDEodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfc2V0Q2FjaGVBZGQgPSBzZXRDYWNoZUFkZCQxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0Q2FjaGVIYXMkMSh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG52YXIgX3NldENhY2hlSGFzID0gc2V0Q2FjaGVIYXMkMTtcblxudmFyIE1hcENhY2hlJDEgPSBfTWFwQ2FjaGUsXG4gICAgc2V0Q2FjaGVBZGQgPSBfc2V0Q2FjaGVBZGQsXG4gICAgc2V0Q2FjaGVIYXMgPSBfc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUkMih2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUkMTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUkMi5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUkMi5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUkMi5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbnZhciBfU2V0Q2FjaGUgPSBTZXRDYWNoZSQyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBhcnJheVNvbWUkMShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIF9hcnJheVNvbWUgPSBhcnJheVNvbWUkMTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBjYWNoZUhhcyQyKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG52YXIgX2NhY2hlSGFzID0gY2FjaGVIYXMkMjtcblxudmFyIFNldENhY2hlJDEgPSBfU2V0Q2FjaGUsXG4gICAgYXJyYXlTb21lID0gX2FycmF5U29tZSxcbiAgICBjYWNoZUhhcyQxID0gX2NhY2hlSGFzO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyQ1ID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDMgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMkMihhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyQ1LFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMykgPyBuZXcgU2V0Q2FjaGUkMSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzJDEoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9lcXVhbEFycmF5cyA9IGVxdWFsQXJyYXlzJDI7XG5cbnZhciByb290JDQgPSBfcm9vdDtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSQyID0gcm9vdCQ0LlVpbnQ4QXJyYXk7XG5cbnZhciBfVWludDhBcnJheSA9IFVpbnQ4QXJyYXkkMjtcblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5cbmZ1bmN0aW9uIG1hcFRvQXJyYXkkMShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWFwVG9BcnJheSA9IG1hcFRvQXJyYXkkMTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIHNldFRvQXJyYXkkMyhzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfc2V0VG9BcnJheSA9IHNldFRvQXJyYXkkMztcblxudmFyIFN5bWJvbCQzID0gX1N5bWJvbCxcbiAgICBVaW50OEFycmF5JDEgPSBfVWludDhBcnJheSxcbiAgICBlcSQyID0gZXFfMSxcbiAgICBlcXVhbEFycmF5cyQxID0gX2VxdWFsQXJyYXlzLFxuICAgIG1hcFRvQXJyYXkgPSBfbWFwVG9BcnJheSxcbiAgICBzZXRUb0FycmF5JDIgPSBfc2V0VG9BcnJheTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNCA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyQyID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWckMiA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnJDIgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWckMSA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnJDUgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWckMiA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyQyID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnJDUgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWckMyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyQzID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyQyID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyQzID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8kMiA9IFN5bWJvbCQzID8gU3ltYm9sJDMucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YkMSA9IHN5bWJvbFByb3RvJDIgPyBzeW1ib2xQcm90byQyLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWckMShvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnJDM6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWckMjpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5JDEob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkkMShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnJDI6XG4gICAgY2FzZSBkYXRlVGFnJDI6XG4gICAgY2FzZSBudW1iZXJUYWckMjpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxJDIoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWckMTpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZyQyOlxuICAgIGNhc2Ugc3RyaW5nVGFnJDM6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWckNTpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnJDU6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHJDQ7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSQyKTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMjtcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMkMShjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnJDM6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZiQxKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mJDEuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YkMS5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBfZXF1YWxCeVRhZyA9IGVxdWFsQnlUYWckMTtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cblxuZnVuY3Rpb24gYXJyYXlQdXNoJDMoYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxudmFyIF9hcnJheVB1c2ggPSBhcnJheVB1c2gkMztcblxudmFyIGFycmF5UHVzaCQyID0gX2FycmF5UHVzaCxcbiAgICBpc0FycmF5JGEgPSBpc0FycmF5XzE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMkMihvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkkYShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoJDIocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxudmFyIF9iYXNlR2V0QWxsS2V5cyA9IGJhc2VHZXRBbGxLZXlzJDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5cbmZ1bmN0aW9uIGFycmF5RmlsdGVyJDEoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYXJyYXlGaWx0ZXIgPSBhcnJheUZpbHRlciQxO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxuZnVuY3Rpb24gc3R1YkFycmF5JDIoKSB7XG4gIHJldHVybiBbXTtcbn1cblxudmFyIHN0dWJBcnJheV8xID0gc3R1YkFycmF5JDI7XG5cbnZhciBhcnJheUZpbHRlciA9IF9hcnJheUZpbHRlcixcbiAgICBzdHViQXJyYXkkMSA9IHN0dWJBcnJheV8xO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8kNi5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyQzID0gIW5hdGl2ZUdldFN5bWJvbHMkMSA/IHN0dWJBcnJheSQxIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMkMShvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxudmFyIF9nZXRTeW1ib2xzID0gZ2V0U3ltYm9scyQzO1xuXG52YXIgYmFzZUdldEFsbEtleXMkMSA9IF9iYXNlR2V0QWxsS2V5cyxcbiAgICBnZXRTeW1ib2xzJDIgPSBfZ2V0U3ltYm9scyxcbiAgICBrZXlzJDMgPSBrZXlzXzE7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyQyKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMkMShvYmplY3QsIGtleXMkMywgZ2V0U3ltYm9scyQyKTtcbn1cblxudmFyIF9nZXRBbGxLZXlzID0gZ2V0QWxsS2V5cyQyO1xuXG52YXIgZ2V0QWxsS2V5cyQxID0gX2dldEFsbEtleXM7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDMgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDUgPSBvYmplY3RQcm90byQ1Lmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMkMShvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyQxKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMkMShvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eSQ1LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBvYmpTdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgIHJldHVybiBvYmpTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gb2JqZWN0O1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2VxdWFsT2JqZWN0cyA9IGVxdWFsT2JqZWN0cyQxO1xuXG52YXIgZ2V0TmF0aXZlJDQgPSBfZ2V0TmF0aXZlLFxuICAgIHJvb3QkMyA9IF9yb290O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXckMSA9IGdldE5hdGl2ZSQ0KHJvb3QkMywgJ0RhdGFWaWV3Jyk7XG5cbnZhciBfRGF0YVZpZXcgPSBEYXRhVmlldyQxO1xuXG52YXIgZ2V0TmF0aXZlJDMgPSBfZ2V0TmF0aXZlLFxuICAgIHJvb3QkMiA9IF9yb290O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSQyID0gZ2V0TmF0aXZlJDMocm9vdCQyLCAnUHJvbWlzZScpO1xuXG52YXIgX1Byb21pc2UgPSBQcm9taXNlJDI7XG5cbnZhciBnZXROYXRpdmUkMiA9IF9nZXROYXRpdmUsXG4gICAgcm9vdCQxID0gX3Jvb3Q7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQkMyA9IGdldE5hdGl2ZSQyKHJvb3QkMSwgJ1NldCcpO1xuXG52YXIgX1NldCA9IFNldCQzO1xuXG52YXIgZ2V0TmF0aXZlJDEgPSBfZ2V0TmF0aXZlLFxuICAgIHJvb3QgPSBfcm9vdDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAkMiA9IGdldE5hdGl2ZSQxKHJvb3QsICdXZWFrTWFwJyk7XG5cbnZhciBfV2Vha01hcCA9IFdlYWtNYXAkMjtcblxudmFyIERhdGFWaWV3ID0gX0RhdGFWaWV3LFxuICAgIE1hcCQxID0gX01hcCxcbiAgICBQcm9taXNlJDEgPSBfUHJvbWlzZSxcbiAgICBTZXQkMiA9IF9TZXQsXG4gICAgV2Vha01hcCQxID0gX1dlYWtNYXAsXG4gICAgYmFzZUdldFRhZyQzID0gX2Jhc2VHZXRUYWcsXG4gICAgdG9Tb3VyY2UgPSBfdG9Tb3VyY2U7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWckNCA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyQzID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWckNCA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWckMSA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnJDIgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwJDEpLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSQxKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0JDIpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCQxKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyQ1ID0gYmFzZUdldFRhZyQzO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyQ1KG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZyQyKSB8fFxuICAgIChNYXAkMSAmJiBnZXRUYWckNShuZXcgTWFwJDEpICE9IG1hcFRhZyQ0KSB8fFxuICAgIChQcm9taXNlJDEgJiYgZ2V0VGFnJDUoUHJvbWlzZSQxLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0JDIgJiYgZ2V0VGFnJDUobmV3IFNldCQyKSAhPSBzZXRUYWckNCkgfHxcbiAgICAoV2Vha01hcCQxICYmIGdldFRhZyQ1KG5ldyBXZWFrTWFwJDEpICE9IHdlYWtNYXBUYWckMSkpIHtcbiAgZ2V0VGFnJDUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnJDModmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyQzID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZyQyO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWckNDtcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZyQ0O1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZyQxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG52YXIgX2dldFRhZyA9IGdldFRhZyQ1O1xuXG52YXIgU3RhY2skMiA9IF9TdGFjayxcbiAgICBlcXVhbEFycmF5cyA9IF9lcXVhbEFycmF5cyxcbiAgICBlcXVhbEJ5VGFnID0gX2VxdWFsQnlUYWcsXG4gICAgZXF1YWxPYmplY3RzID0gX2VxdWFsT2JqZWN0cyxcbiAgICBnZXRUYWckNCA9IF9nZXRUYWcsXG4gICAgaXNBcnJheSQ5ID0gaXNBcnJheV8xLFxuICAgIGlzQnVmZmVyJDEgPSBpc0J1ZmZlckV4cG9ydHMsXG4gICAgaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5XzE7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDIgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyQxID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWckMSA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnJDIgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDQgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ0ID0gb2JqZWN0UHJvdG8kNC5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAkMShvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkkOShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5JDkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyQxIDogZ2V0VGFnJDQob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWckMSA6IGdldFRhZyQ0KG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyQxID8gb2JqZWN0VGFnJDIgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnJDEgPyBvYmplY3RUYWckMiA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnJDIsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWckMixcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlciQxKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyJDEob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrJDIpO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMikpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkkNC5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5JDQuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrJDIpO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2skMik7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbnZhciBfYmFzZUlzRXF1YWxEZWVwID0gYmFzZUlzRXF1YWxEZWVwJDE7XG5cbnZhciBiYXNlSXNFcXVhbERlZXAgPSBfYmFzZUlzRXF1YWxEZWVwLFxuICAgIGlzT2JqZWN0TGlrZSQ1ID0gaXNPYmplY3RMaWtlXzE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsJDIodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSQ1KHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlJDUob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCQyLCBzdGFjayk7XG59XG5cbnZhciBfYmFzZUlzRXF1YWwgPSBiYXNlSXNFcXVhbCQyO1xuXG52YXIgU3RhY2skMSA9IF9TdGFjayxcbiAgICBiYXNlSXNFcXVhbCQxID0gX2Jhc2VJc0VxdWFsO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyQxID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gkMShvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrJDE7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsJDEoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyQxIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyQxLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgX2Jhc2VJc01hdGNoID0gYmFzZUlzTWF0Y2gkMTtcblxudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdF8xO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSQyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0JDQodmFsdWUpO1xufVxuXG52YXIgX2lzU3RyaWN0Q29tcGFyYWJsZSA9IGlzU3RyaWN0Q29tcGFyYWJsZSQyO1xuXG52YXIgaXNTdHJpY3RDb21wYXJhYmxlJDEgPSBfaXNTdHJpY3RDb21wYXJhYmxlLFxuICAgIGtleXMkMiA9IGtleXNfMTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEkMShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMkMihvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUkMSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfZ2V0TWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhJDE7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQyKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbnZhciBfbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQyO1xuXG52YXIgYmFzZUlzTWF0Y2ggPSBfYmFzZUlzTWF0Y2gsXG4gICAgZ2V0TWF0Y2hEYXRhID0gX2dldE1hdGNoRGF0YSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQxID0gX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyQxKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlJDEobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbnZhciBfYmFzZU1hdGNoZXMgPSBiYXNlTWF0Y2hlcyQxO1xuXG52YXIgYmFzZUdldFRhZyQyID0gX2Jhc2VHZXRUYWcsXG4gICAgaXNPYmplY3RMaWtlJDQgPSBpc09iamVjdExpa2VfMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyQyID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wkNCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSQ0KHZhbHVlKSAmJiBiYXNlR2V0VGFnJDIodmFsdWUpID09IHN5bWJvbFRhZyQyKTtcbn1cblxudmFyIGlzU3ltYm9sXzEgPSBpc1N5bWJvbCQ0O1xuXG52YXIgaXNBcnJheSQ4ID0gaXNBcnJheV8xLFxuICAgIGlzU3ltYm9sJDMgPSBpc1N5bWJvbF8xO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkkMyh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5JDgodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sJDModmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbnZhciBfaXNLZXkgPSBpc0tleSQzO1xuXG52YXIgTWFwQ2FjaGUgPSBfTWFwQ2FjaGU7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplJDEoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUkMS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplJDEuQ2FjaGUgPSBNYXBDYWNoZTtcblxudmFyIG1lbW9pemVfMSA9IG1lbW9pemUkMTtcblxudmFyIG1lbW9pemUgPSBtZW1vaXplXzE7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkJDEoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX21lbW9pemVDYXBwZWQgPSBtZW1vaXplQ2FwcGVkJDE7XG5cbnZhciBtZW1vaXplQ2FwcGVkID0gX21lbW9pemVDYXBwZWQ7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoJDEgPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG52YXIgX3N0cmluZ1RvUGF0aCA9IHN0cmluZ1RvUGF0aCQxO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuXG5mdW5jdGlvbiBhcnJheU1hcCQzKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9hcnJheU1hcCA9IGFycmF5TWFwJDM7XG5cbnZhciBTeW1ib2wkMiA9IF9TeW1ib2wsXG4gICAgYXJyYXlNYXAkMiA9IF9hcnJheU1hcCxcbiAgICBpc0FycmF5JDcgPSBpc0FycmF5XzEsXG4gICAgaXNTeW1ib2wkMiA9IGlzU3ltYm9sXzE7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZJDIgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8kMSA9IFN5bWJvbCQyID8gU3ltYm9sJDIucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8kMSA/IHN5bWJvbFByb3RvJDEudG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nJDEodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSQ3KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwJDIodmFsdWUsIGJhc2VUb1N0cmluZyQxKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCQyKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSQyKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZVRvU3RyaW5nID0gYmFzZVRvU3RyaW5nJDE7XG5cbnZhciBiYXNlVG9TdHJpbmcgPSBfYmFzZVRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmckMSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxudmFyIHRvU3RyaW5nXzEgPSB0b1N0cmluZyQxO1xuXG52YXIgaXNBcnJheSQ2ID0gaXNBcnJheV8xLFxuICAgIGlzS2V5JDIgPSBfaXNLZXksXG4gICAgc3RyaW5nVG9QYXRoID0gX3N0cmluZ1RvUGF0aCxcbiAgICB0b1N0cmluZyA9IHRvU3RyaW5nXzE7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCQ0KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkkNih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5JDIodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbnZhciBfY2FzdFBhdGggPSBjYXN0UGF0aCQ0O1xuXG52YXIgaXNTeW1ib2wkMSA9IGlzU3ltYm9sXzE7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZJDEgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSQ1KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wkMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSQxKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbnZhciBfdG9LZXkgPSB0b0tleSQ1O1xuXG52YXIgY2FzdFBhdGgkMyA9IF9jYXN0UGF0aCxcbiAgICB0b0tleSQ0ID0gX3RvS2V5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldCQ0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgkMyhwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkkNChwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2Jhc2VHZXQgPSBiYXNlR2V0JDQ7XG5cbnZhciBiYXNlR2V0JDMgPSBfYmFzZUdldDtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0JDEob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldCQzKG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxudmFyIGdldF8xID0gZ2V0JDE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxuZnVuY3Rpb24gYmFzZUhhc0luJDEob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxudmFyIF9iYXNlSGFzSW4gPSBiYXNlSGFzSW4kMTtcblxudmFyIGNhc3RQYXRoJDIgPSBfY2FzdFBhdGgsXG4gICAgaXNBcmd1bWVudHMkMSA9IGlzQXJndW1lbnRzXzEsXG4gICAgaXNBcnJheSQ1ID0gaXNBcnJheV8xLFxuICAgIGlzSW5kZXgkMSA9IF9pc0luZGV4LFxuICAgIGlzTGVuZ3RoID0gaXNMZW5ndGhfMSxcbiAgICB0b0tleSQzID0gX3RvS2V5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoJDEob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aCQyKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5JDMocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgkMShrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheSQ1KG9iamVjdCkgfHwgaXNBcmd1bWVudHMkMShvYmplY3QpKTtcbn1cblxudmFyIF9oYXNQYXRoID0gaGFzUGF0aCQxO1xuXG52YXIgYmFzZUhhc0luID0gX2Jhc2VIYXNJbixcbiAgICBoYXNQYXRoID0gX2hhc1BhdGg7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4kMShvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG52YXIgaGFzSW5fMSA9IGhhc0luJDE7XG5cbnZhciBiYXNlSXNFcXVhbCA9IF9iYXNlSXNFcXVhbCxcbiAgICBnZXQgPSBnZXRfMSxcbiAgICBoYXNJbiA9IGhhc0luXzEsXG4gICAgaXNLZXkkMSA9IF9pc0tleSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSBfaXNTdHJpY3RDb21wYXJhYmxlLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLFxuICAgIHRvS2V5JDIgPSBfdG9LZXk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eSQxKHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleSQxKHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkkMihwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxudmFyIF9iYXNlTWF0Y2hlc1Byb3BlcnR5ID0gYmFzZU1hdGNoZXNQcm9wZXJ0eSQxO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuXG5mdW5jdGlvbiBpZGVudGl0eSQ0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIGlkZW50aXR5XzEgPSBpZGVudGl0eSQ0O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gYmFzZVByb3BlcnR5JDIoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxudmFyIF9iYXNlUHJvcGVydHkgPSBiYXNlUHJvcGVydHkkMjtcblxudmFyIGJhc2VHZXQkMiA9IF9iYXNlR2V0O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAkMShwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldCQyKG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbnZhciBfYmFzZVByb3BlcnR5RGVlcCA9IGJhc2VQcm9wZXJ0eURlZXAkMTtcblxudmFyIGJhc2VQcm9wZXJ0eSQxID0gX2Jhc2VQcm9wZXJ0eSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gX2Jhc2VQcm9wZXJ0eURlZXAsXG4gICAgaXNLZXkgPSBfaXNLZXksXG4gICAgdG9LZXkkMSA9IF90b0tleTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eSQxKHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5JDEodG9LZXkkMShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG52YXIgcHJvcGVydHlfMSA9IHByb3BlcnR5JDE7XG5cbnZhciBiYXNlTWF0Y2hlcyA9IF9iYXNlTWF0Y2hlcyxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gX2Jhc2VNYXRjaGVzUHJvcGVydHksXG4gICAgaWRlbnRpdHkkMyA9IGlkZW50aXR5XzEsXG4gICAgaXNBcnJheSQ0ID0gaXNBcnJheV8xLFxuICAgIHByb3BlcnR5ID0gcHJvcGVydHlfMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlJDQodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5JDM7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5JDQodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxudmFyIF9iYXNlSXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUkNDtcblxudmFyIGJhc2VGaW5kS2V5ID0gX2Jhc2VGaW5kS2V5LFxuICAgIGJhc2VGb3JPd24kMiA9IF9iYXNlRm9yT3duLFxuICAgIGJhc2VJdGVyYXRlZSQzID0gX2Jhc2VJdGVyYXRlZTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IHtcbiAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIH07XG4gKlxuICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiAncGViYmxlcydcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+ICdmcmVkJ1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAnYmFybmV5J1xuICovXG5mdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGJhc2VJdGVyYXRlZSQzKHByZWRpY2F0ZSksIGJhc2VGb3JPd24kMik7XG59XG5cbnZhciBmaW5kS2V5XzEgPSBmaW5kS2V5O1xuXG52YXIgZmluZEtleSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZpbmRLZXlfMSk7XG5cbnZhciBnZXROYXRpdmUgPSBfZ2V0TmF0aXZlO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHkkMjtcblxudmFyIGRlZmluZVByb3BlcnR5JDEgPSBfZGVmaW5lUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUkMyhvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSQxKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbnZhciBfYmFzZUFzc2lnblZhbHVlID0gYmFzZUFzc2lnblZhbHVlJDM7XG5cbnZhciBiYXNlQXNzaWduVmFsdWUkMiA9IF9iYXNlQXNzaWduVmFsdWUsXG4gICAgYmFzZUZvck93biQxID0gX2Jhc2VGb3JPd24sXG4gICAgYmFzZUl0ZXJhdGVlJDIgPSBfYmFzZUl0ZXJhdGVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICogQHNlZSBfLm1hcEtleXNcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0ge1xuICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAqIH07XG4gKlxuICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUkMihpdGVyYXRlZSk7XG5cbiAgYmFzZUZvck93biQxKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgYmFzZUFzc2lnblZhbHVlJDIocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIG1hcFZhbHVlc18xID0gbWFwVmFsdWVzO1xuXG52YXIgbWFwVmFsdWVzJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobWFwVmFsdWVzXzEpO1xuXG52YXIgYnBWYXJpYWJsZXNTY3NzID0ge1wieHNcIjpcIlxcXCIzNmVtXFxcIlwiLFwic21cIjpcIlxcXCI0OGVtXFxcIlwiLFwibWRcIjpcIlxcXCI2MmVtXFxcIlwiLFwibGdcIjpcIlxcXCI3NWVtXFxcIlwiLFwieGxcIjpcIlxcXCI4OGVtXFxcIlwifTtcblxuY29uc3QgQlBfVkFSSUFCTEVTID0gbWFwVmFsdWVzJDEoYnBWYXJpYWJsZXNTY3NzLCAodmFsdWUpID0+IHZhbHVlLnJlcGxhY2VBbGwoJ1wiJywgJycpKTtcblxubGV0IGlzTW91bnRlZEdsb2JhbCA9IGZhbHNlO1xuY29uc3QgdXNlQ2xpZW50TW91bnRlZFN0YXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IFtpc01vdW50ZWQsIHNldElzTW91bnRlZF0gPSB1c2VTdGF0ZShpc01vdW50ZWRHbG9iYWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgc2V0SXNNb3VudGVkKHRydWUpO1xuICAgICAgICAgICAgaXNNb3VudGVkR2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBpc0NsaWVudCA9IHVzZU1lbW8oKCkgPT4gaXNCcm93c2VyKCksIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0NsaWVudCxcbiAgICAgICAgaXNNb3VudGVkLFxuICAgICAgICBpc01vdW50ZWRDbGllbnQ6IGlzQ2xpZW50ICYmIGlzTW91bnRlZCxcbiAgICB9O1xufTtcblxuY29uc3QgZ2V0TWF0Y2hNZWRpYSA9IChtYXRjaFN0cmluZykgPT4gaXNCcm93c2VyKCkgPyB3aW5kb3cubWF0Y2hNZWRpYShtYXRjaFN0cmluZykgOiB1bmRlZmluZWQ7XG5jb25zdCB1c2VNZWRpYVF1ZXJ5ID0gKG1hdGNoU3RyaW5nKSA9PiB7XG4gICAgY29uc3QgeyBpc01vdW50ZWRDbGllbnQgfSA9IHVzZUNsaWVudE1vdW50ZWRTdGF0ZSgpO1xuICAgIGNvbnN0IFttYXRjaGVzLCBzZXRNYXRjaGVzXSA9IHVzZVN0YXRlKGdldE1hdGNoTWVkaWEobWF0Y2hTdHJpbmcpPy5tYXRjaGVzIHx8IGZhbHNlKTtcbiAgICBjb25zdCBoYW5kbGVNZWRpYUNoYW5nZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBnZXRNYXRjaE1lZGlhKG1hdGNoU3RyaW5nKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBzZXRNYXRjaGVzKG1hdGNoLm1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgfSwgW21hdGNoU3RyaW5nXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzTW91bnRlZENsaWVudCkge1xuICAgICAgICAgICAgaGFuZGxlTWVkaWFDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH0sIFtpc01vdW50ZWRDbGllbnQsIGhhbmRsZU1lZGlhQ2hhbmdlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBnZXRNYXRjaE1lZGlhKG1hdGNoU3RyaW5nKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBtYXRjaC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVNZWRpYUNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIG1hdGNoLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZU1lZGlhQ2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbaGFuZGxlTWVkaWFDaGFuZ2UsIG1hdGNoU3RyaW5nXSk7XG4gICAgcmV0dXJuIG1hdGNoZXM7XG59O1xuY29uc3QgdXNlVGhlbWVTY3JlZW5TaXplID0gKHsgc2l6ZTogcmVxdWVzdGVkU2l6ZSwgfSA9IHt9KSA9PiB7XG4gICAgY29uc3QgeHMgPSB1c2VNZWRpYVF1ZXJ5KGAobWF4LXdpZHRoOiAke0JQX1ZBUklBQkxFUy54c30pYCk7XG4gICAgY29uc3Qgc20gPSB1c2VNZWRpYVF1ZXJ5KGAobWF4LXdpZHRoOiAke0JQX1ZBUklBQkxFUy5zbX0pYCk7XG4gICAgY29uc3QgbWQgPSB1c2VNZWRpYVF1ZXJ5KGAobWF4LXdpZHRoOiAke0JQX1ZBUklBQkxFUy5tZH0pYCk7XG4gICAgY29uc3QgbGcgPSB1c2VNZWRpYVF1ZXJ5KGAobWF4LXdpZHRoOiAke0JQX1ZBUklBQkxFUy5sZ30pYCk7XG4gICAgY29uc3QgeGwgPSB1c2VNZWRpYVF1ZXJ5KGAobWF4LXdpZHRoOiAke0JQX1ZBUklBQkxFUy54bH0pYCk7XG4gICAgY29uc3QgeHhsID0gdXNlTWVkaWFRdWVyeShgKG1pbi13aWR0aDogJHtCUF9WQVJJQUJMRVMueGx9KWApO1xuICAgIGNvbnN0IHNjcmVlblNpemVPYmplY3QgPSB7XG4gICAgICAgIHhzLFxuICAgICAgICBzbSxcbiAgICAgICAgbWQsXG4gICAgICAgIGxnLFxuICAgICAgICB4bCxcbiAgICAgICAgeHhsLFxuICAgIH07XG4gICAgY29uc3Qgc2NyZWVuU2l6ZSA9IGZpbmRLZXkkMShzY3JlZW5TaXplT2JqZWN0LCAoaXNTY3JlZW5TaXplKSA9PiAhIWlzU2NyZWVuU2l6ZSk7XG4gICAgY29uc3QgYnBWYXJpYWJsZUtleXMgPSBPYmplY3Qua2V5cyhzY3JlZW5TaXplT2JqZWN0KTtcbiAgICBjb25zdCBpbmRleE9mUmVxdWVzdGVkU2l6ZSA9IGJwVmFyaWFibGVLZXlzLmluZGV4T2YocmVxdWVzdGVkU2l6ZSB8fCAnJyk7XG4gICAgY29uc3QgaW5kZXhPZlNpemUgPSBicFZhcmlhYmxlS2V5cy5pbmRleE9mKHNjcmVlblNpemUgfHwgJycpO1xuICAgIGNvbnN0IGlzVmFsaWQgPSAhIShyZXF1ZXN0ZWRTaXplICYmXG4gICAgICAgIGluZGV4T2ZSZXF1ZXN0ZWRTaXplICYmXG4gICAgICAgIGluZGV4T2ZSZXF1ZXN0ZWRTaXplICE9PSAtMSk7XG4gICAgY29uc3QgaXNSZXF1ZXN0ZWRTaXplID0gaXNWYWxpZCAmJiBzY3JlZW5TaXplID09PSByZXF1ZXN0ZWRTaXplO1xuICAgIGNvbnN0IGlzTGFyZ2VyVGhhbiA9IGlzVmFsaWQgJiYgaW5kZXhPZlJlcXVlc3RlZFNpemUgPiBpbmRleE9mU2l6ZTtcbiAgICBjb25zdCBpc1NtYWxsZXJUaGFuID0gaXNWYWxpZCAmJiBpbmRleE9mUmVxdWVzdGVkU2l6ZSA8IGluZGV4T2ZTaXplO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpemU6IHNjcmVlblNpemUsXG4gICAgICAgIGlzUmVxdWVzdGVkU2l6ZSxcbiAgICAgICAgaXNTbWFsbGVyVGhhbixcbiAgICAgICAgaXNTbWFsbGVyVGhhbkluY2x1ZGluZzogaXNSZXF1ZXN0ZWRTaXplIHx8IGlzU21hbGxlclRoYW4sXG4gICAgICAgIGlzTGFyZ2VyVGhhbixcbiAgICAgICAgaXNMYXJnZXJUaGFuSW5jbHVkaW5nOiBpc1JlcXVlc3RlZFNpemUgfHwgaXNMYXJnZXJUaGFuLFxuICAgIH07XG59O1xuXG5jb25zdCBERUZBVUxUX0JMVVJfRlVOQyA9ICgpID0+IGZhbHNlO1xuY29uc3QgZGVmYXVsdFNob3VsZEJsdXJGdW5jdGlvbiA9ICh7IGUsIGJsdXJFbGVtZW50UmVmLCBibHVyRWxlbWVudDogYmx1ckVsZW1lbnRQYXJhbSwgfSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgY29uc3QgYmx1ckVsZW1lbnQgPSBibHVyRWxlbWVudFJlZj8uY3VycmVudCB8fCBibHVyRWxlbWVudFBhcmFtO1xuICAgIGNvbnN0IHRhcmdldENvbnRhaW5lZEluQmx1ciA9IGJsdXJFbGVtZW50Py5jb250YWlucyh0YXJnZXQpO1xuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXRDb250YWluZWRJbkJsdXIgPSBibHVyRWxlbWVudD8uY29udGFpbnMocmVsYXRlZFRhcmdldCk7XG4gICAgcmV0dXJuICF0YXJnZXRDb250YWluZWRJbkJsdXIgJiYgIXJlbGF0ZWRUYXJnZXRDb250YWluZWRJbkJsdXI7XG59O1xuY29uc3QgaGFuZGxlQmx1ciA9ICh7IGUsIGJsdXJFbGVtZW50LCBibHVyRWxlbWVudFJlZiwgb25CbHVyLCBzaG91bGRCbHVyLCBzaG91bGREaXNhYmxlQmx1ciA9IERFRkFVTFRfQkxVUl9GVU5DLCBzaG91bGRGb3JjZUJsdXIgPSBERUZBVUxUX0JMVVJfRlVOQywgcmV0dXJuQm9vbGVhbiA9IGZhbHNlLCB9KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldDtcbiAgICBjb25zdCBkZWZhdWx0U2hvdWxkQmx1ciA9IHNob3VsZEJsdXJcbiAgICAgICAgPyBzaG91bGRCbHVyKHsgZSwgdGFyZ2V0LCByZWxhdGVkVGFyZ2V0IH0pXG4gICAgICAgIDogZGVmYXVsdFNob3VsZEJsdXJGdW5jdGlvbih7IGUsIGJsdXJFbGVtZW50UmVmLCBibHVyRWxlbWVudCB9KTtcbiAgICBpZiAoKGRlZmF1bHRTaG91bGRCbHVyICYmICFzaG91bGREaXNhYmxlQmx1cj8uKHsgZSwgdGFyZ2V0LCByZWxhdGVkVGFyZ2V0IH0pKSB8fFxuICAgICAgICBzaG91bGRGb3JjZUJsdXI/Lih7IGUsIHRhcmdldCwgcmVsYXRlZFRhcmdldCB9KSkge1xuICAgICAgICBpZiAocmV0dXJuQm9vbGVhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9uQmx1cihlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IHVzZU9uQmx1ciA9ICh7IGJsdXJFbGVtZW50UmVmLCBibHVyRWxlbWVudCwgb25CbHVyLCBlbmFibGVkID0gZmFsc2UsIHNob3VsZEJsdXIsIHNob3VsZERpc2FibGVCbHVyID0gREVGQVVMVF9CTFVSX0ZVTkMsIHNob3VsZEZvcmNlQmx1ciA9IERFRkFVTFRfQkxVUl9GVU5DLCB9KSA9PiB7XG4gICAgY29uc3QgaGFuZGxlQ2xpY2tCbHVyTGlzdGVuZXIgPSB1c2VDYWxsYmFjaygoZSkgPT4gaGFuZGxlQmx1cih7XG4gICAgICAgIGUsXG4gICAgICAgIGJsdXJFbGVtZW50LFxuICAgICAgICBibHVyRWxlbWVudFJlZixcbiAgICAgICAgb25CbHVyLFxuICAgICAgICBlbmFibGVkLFxuICAgICAgICBzaG91bGRCbHVyLFxuICAgICAgICBzaG91bGREaXNhYmxlQmx1cixcbiAgICAgICAgc2hvdWxkRm9yY2VCbHVyLFxuICAgIH0pLCBbXG4gICAgICAgIGVuYWJsZWQsXG4gICAgICAgIG9uQmx1cixcbiAgICAgICAgYmx1ckVsZW1lbnQsXG4gICAgICAgIGJsdXJFbGVtZW50UmVmLFxuICAgICAgICBzaG91bGREaXNhYmxlQmx1cixcbiAgICAgICAgc2hvdWxkRm9yY2VCbHVyLFxuICAgICAgICBzaG91bGRCbHVyLFxuICAgIF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tCbHVyTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2tCbHVyTGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtlbmFibGVkLCBoYW5kbGVDbGlja0JsdXJMaXN0ZW5lcl0pO1xuICAgIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gdXNlU3RhdGVXaXRoUmVmKGluaXRpYWxWYWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoaW5pdGlhbFZhbHVlKTtcbiAgICBjb25zdCBzdGF0ZVJlZiA9IHVzZVJlZihpbml0aWFsVmFsdWUpO1xuICAgIGNvbnN0IGhhbmRsZVNldFN0YXRlID0gdXNlQ2FsbGJhY2soKHVwZGF0ZSkgPT4ge1xuICAgICAgICBzZXRTdGF0ZSgocHJldikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmF3TmV4dFZhbHVlID0gdHlwZW9mIHVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gdXBkYXRlKHByZXYpXG4gICAgICAgICAgICAgICAgOiB1cGRhdGU7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IG9wdGlvbnM/LnNldFN0YXRlVHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnNldFN0YXRlVHJhbnNmb3JtKHJhd05leHRWYWx1ZSlcbiAgICAgICAgICAgICAgICA6IHJhd05leHRWYWx1ZTtcbiAgICAgICAgICAgIHN0YXRlUmVmLmN1cnJlbnQgPSB0cmFuc2Zvcm1lZDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25DaGFuZ2UodHJhbnNmb3JtZWQsIHsgcHJldlZhbHVlOiBwcmV2IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgICAgICB9KTtcbiAgICB9LCBbb3B0aW9uc10pO1xuICAgIGNvbnN0IGhhbmRsZUdldFN0YXRlID0gdXNlQ2FsbGJhY2soKCkgPT4gc3RhdGVSZWYuY3VycmVudCwgW10pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICBzZXRTdGF0ZTogaGFuZGxlU2V0U3RhdGUsXG4gICAgICAgIGdldFN0YXRlOiBoYW5kbGVHZXRTdGF0ZSxcbiAgICB9KSwgW3N0YXRlLCBoYW5kbGVHZXRTdGF0ZSwgaGFuZGxlU2V0U3RhdGVdKTtcbn1cblxuY29uc3QgdXNlU2Nyb2xsID0gKHsgc2Nyb2xsQ29udGFpbmVyRWxlbWVudFJlZiwgc2Nyb2xsQ29udGFpbmVyRWxlbWVudDogc2Nyb2xsQ29udGFpbmVyRWxlbWVudFByb3AsIGRpc2FibGVTdGF0ZVVwZGF0ZXMsIG9uU2Nyb2xsLCB9KSA9PiB7XG4gICAgY29uc3QgeyBpc01vdW50ZWRDbGllbnQgfSA9IHVzZUNsaWVudE1vdW50ZWRTdGF0ZSgpO1xuICAgIGNvbnN0IFtzY3JvbGxUb3AsIHNldFNjcm9sbFRvcF0gPSB1c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBzY3JvbGxUb3BSZWYgPSB1c2VSZWYoMCk7XG4gICAgY29uc3QgZWxlbWVudCA9IHVzZU1lbW8oKCkgPT4gc2Nyb2xsQ29udGFpbmVyRWxlbWVudFByb3AgfHxcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyRWxlbWVudFJlZj8uY3VycmVudCB8fFxuICAgICAgICAoaXNNb3VudGVkQ2xpZW50ID8gd2luZG93IDogdW5kZWZpbmVkKSwgW3Njcm9sbENvbnRhaW5lckVsZW1lbnRQcm9wLCBzY3JvbGxDb250YWluZXJFbGVtZW50UmVmLCBpc01vdW50ZWRDbGllbnRdKTtcbiAgICBjb25zdCBoYW5kbGVTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZWxlbWVudCAmJiAnc2Nyb2xsVG9wJyBpbiBlbGVtZW50ID8gZWxlbWVudD8uc2Nyb2xsVG9wIHx8IDAgOiAwO1xuICAgICAgICBzY3JvbGxUb3BSZWYuY3VycmVudCA9IHBvc2l0aW9uO1xuICAgICAgICBpZiAob25TY3JvbGwpIHtcbiAgICAgICAgICAgIG9uU2Nyb2xsKHsgdG9wOiBwb3NpdGlvbiwgbGVmdDogMCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpc2FibGVTdGF0ZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHNldFNjcm9sbFRvcChwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2Nyb2xsVG9wKHBvc2l0aW9uKTtcbiAgICB9LCBbZWxlbWVudCwgZGlzYWJsZVN0YXRlVXBkYXRlcywgb25TY3JvbGxdKTtcbiAgICBjb25zdCBnZXRTY3JvbGxUb3AgPSB1c2VDYWxsYmFjaygoKSA9PiBzY3JvbGxUb3BSZWYuY3VycmVudCwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbZWxlbWVudCwgaGFuZGxlU2Nyb2xsLCBzY3JvbGxDb250YWluZXJFbGVtZW50UmVmXSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgc2Nyb2xsVG9wLFxuICAgICAgICBnZXRTY3JvbGxUb3AsXG4gICAgfSksIFtzY3JvbGxUb3AsIGdldFNjcm9sbFRvcF0pO1xufTtcblxuY29uc3QgVG9vbHRpcENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgdXNlVG9vbHRpcENvbnRleHQgPSAoKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoVG9vbHRpcENvbnRleHQpO1xuICAgIGlmIChjb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29sdGlwIGNvbXBvbmVudHMgbXVzdCBiZSB3cmFwcGVkIGluIDxUb29sdGlwIC8+Jyk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufTtcblxuY29uc3QgVE9PTFRJUF9ERUxBWV9ERUZBVUxUID0gNTAwO1xuY29uc3QgdXNlVG9vbHRpcCA9IChvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IGluaXRpYWxPcGVuID0gZmFsc2UsIHBsYWNlbWVudCA9ICd0b3AnLCBvcGVuOiBjb250cm9sbGVkT3Blbiwgb25PcGVuQ2hhbmdlOiBzZXRDb250cm9sbGVkT3Blbiwgb2Zmc2V0OiBvZmZzZXQkMSA9IDUsIGRlbGF5OiBkZWxheUZyb21PcHRpb25zLCBkaXNhYmxlSG92ZXIsIGRpc2FibGVGb2N1cywgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgW3VuY29udHJvbGxlZE9wZW4sIHNldFVuY29udHJvbGxlZE9wZW5dID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbE9wZW4pO1xuICAgIGNvbnN0IG9wZW4gPSBjb250cm9sbGVkT3BlbiA/PyB1bmNvbnRyb2xsZWRPcGVuO1xuICAgIGNvbnN0IHNldE9wZW4gPSBzZXRDb250cm9sbGVkT3BlbiA/PyBzZXRVbmNvbnRyb2xsZWRPcGVuO1xuICAgIGNvbnN0IHsgZGVsYXkgfSA9IHVzZURlbGF5R3JvdXBDb250ZXh0KCk7XG4gICAgY29uc3QgZGF0YSA9IHVzZUZsb2F0aW5nKHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBvcGVuLFxuICAgICAgICBvbk9wZW5DaGFuZ2U6IHNldE9wZW4sXG4gICAgICAgIHdoaWxlRWxlbWVudHNNb3VudGVkOiBhdXRvVXBkYXRlLFxuICAgICAgICBtaWRkbGV3YXJlOiBbXG4gICAgICAgICAgICBvZmZzZXQob2Zmc2V0JDEpLFxuICAgICAgICAgICAgZmxpcCh7XG4gICAgICAgICAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbjogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBvZmZzZXQkMSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2hpZnQoeyBwYWRkaW5nOiBvZmZzZXQkMSB9KSxcbiAgICAgICAgXSxcbiAgICB9KTtcbiAgICBjb25zdCB7IGNvbnRleHQgfSA9IGRhdGE7XG4gICAgY29uc3QgaG92ZXIgPSB1c2VIb3Zlcihjb250ZXh0LCB7XG4gICAgICAgIG1vdmU6IGZhbHNlLFxuICAgICAgICBlbmFibGVkOiAhZGlzYWJsZUhvdmVyLFxuICAgICAgICBkZWxheTogZGVsYXkgfHwgZGVsYXlGcm9tT3B0aW9ucyB8fCBUT09MVElQX0RFTEFZX0RFRkFVTFQsXG4gICAgfSk7XG4gICAgY29uc3QgZm9jdXMgPSB1c2VGb2N1cyhjb250ZXh0LCB7XG4gICAgICAgIGVuYWJsZWQ6ICFkaXNhYmxlRm9jdXMsXG4gICAgfSk7XG4gICAgY29uc3QgZGlzbWlzcyA9IHVzZURpc21pc3MoY29udGV4dCk7XG4gICAgY29uc3Qgcm9sZSA9IHVzZVJvbGUoY29udGV4dCwgeyByb2xlOiAndG9vbHRpcCcgfSk7XG4gICAgY29uc3QgaW50ZXJhY3Rpb25zID0gdXNlSW50ZXJhY3Rpb25zKFtob3ZlciwgZm9jdXMsIGRpc21pc3MsIHJvbGVdKTtcbiAgICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBvcGVuLFxuICAgICAgICBzZXRPcGVuLFxuICAgICAgICAuLi5pbnRlcmFjdGlvbnMsXG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgfSksIFtvcGVuLCBzZXRPcGVuLCBpbnRlcmFjdGlvbnMsIGRhdGEsIG9wdGlvbnNdKTtcbn07XG5cbmNvbnN0IFRvb2x0aXAgPSAoeyBjaGlsZHJlbiwgdG9vbHRpcFJlZiwgLi4ub3B0aW9ucyB9KSA9PiB7XG4gICAgY29uc3QgdG9vbHRpcCA9IHVzZVRvb2x0aXAob3B0aW9ucyk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZSh0b29sdGlwUmVmLCAoKSA9PiB0b29sdGlwLCBbdG9vbHRpcF0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUb29sdGlwQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdG9vbHRpcCB9LCBjaGlsZHJlbikpO1xufTtcblxudmFyIHN0eWxlc1Njc3MgPSB7XCJ0b29sdGlwVHJpZ2dlclwiOlwiVG9vbHRpcC1tb2R1bGVfdG9vbHRpcFRyaWdnZXJfX0JIbVdiXCIsXCJkaXNwbGF5QXNJbmxpbmVUZXh0XCI6XCJUb29sdGlwLW1vZHVsZV9kaXNwbGF5QXNJbmxpbmVUZXh0X196WTlXWVwiLFwidG9vbHRpcENvbnRlbnRcIjpcIlRvb2x0aXAtbW9kdWxlX3Rvb2x0aXBDb250ZW50X19aeHpnWVwiLFwic2tpbm55XCI6XCJUb29sdGlwLW1vZHVsZV9za2lubnlfX1BteFBxXCIsXCJmaXRDb250ZW50XCI6XCJUb29sdGlwLW1vZHVsZV9maXRDb250ZW50X19xYUhPYlwiLFwic3RheU9wZW5PbkhvdmVyXCI6XCJUb29sdGlwLW1vZHVsZV9zdGF5T3Blbk9uSG92ZXJfX3h2S3FDXCJ9O1xuXG5jb25zdCBUb29sdGlwVHJpZ2dlciA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoKHsgY2hpbGRyZW4sIGFzQ2hpbGQgPSBmYWxzZSwgY2xhc3NOYW1lLCBkaXNwbGF5QXNJbmxpbmVUZXh0LCAuLi5wcm9wcyB9LCBwcm9wUmVmKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVRvb2x0aXBDb250ZXh0KCk7XG4gICAgY29uc3QgY2hpbGRyZW5SZWYgPSBjaGlsZHJlbi5yZWY7XG4gICAgY29uc3QgcmVmID0gdXNlTWVyZ2VSZWZzKFtjb250ZXh0LnJlZnMuc2V0UmVmZXJlbmNlLCBwcm9wUmVmLCBjaGlsZHJlblJlZl0pO1xuICAgIGNvbnN0IHByb3BzVG9QYXNzID0gdXNlTWVtbygoKSA9PiBjb250ZXh0LmdldFJlZmVyZW5jZVByb3BzKHByb3BzKSwgW3Byb3BzLCBjb250ZXh0XSk7XG4gICAgLy8gYGFzQ2hpbGRgIGFsbG93cyB0aGUgdXNlciB0byBwYXNzIGFueSBlbGVtZW50IGFzIHRoZSBhbmNob3JcbiAgICBpZiAoYXNDaGlsZCAmJiBSZWFjdF9fZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZHJlbiwgY29udGV4dC5nZXRSZWZlcmVuY2VQcm9wcyh7XG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIC4uLmNoaWxkcmVuLnByb3BzLFxuICAgICAgICAgICAgJ2RhdGEtc3RhdGUnOiBjb250ZXh0Lm9wZW4gPyAnb3BlbicgOiAnY2xvc2VkJyxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoY2xhc3NOYW1lLCBzdHlsZXNTY3NzLnRvb2x0aXBUcmlnZ2VyLCB7XG4gICAgICAgICAgICBbc3R5bGVzU2Nzcy5kaXNwbGF5QXNJbmxpbmVUZXh0XTogZGlzcGxheUFzSW5saW5lVGV4dCxcbiAgICAgICAgfSksIFwiZGF0YS1zdGF0ZVwiOiBjb250ZXh0Lm9wZW4gPyAnb3BlbicgOiAnY2xvc2VkJywgcmVmOiByZWYsIC4uLnByb3BzVG9QYXNzIH0sIGNoaWxkcmVuKSk7XG59KTtcblRvb2x0aXBUcmlnZ2VyLmRpc3BsYXlOYW1lID0gJ1Rvb2x0b3BUcmlnZ2VyJztcblxuY29uc3QgVG9vbHRpcENvbnRlbnQgPSBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKCh7IGNsYXNzTmFtZSwgaXNTa2lubnkgPSBmYWxzZSwgZml0Q29udGVudCA9IGZhbHNlLCBzdHlsZSwgcmVuZGVySGlkZGVuQ2hpbGRyZW5XaGVuVG9vbHRpcENsb3NlZCA9IHRydWUsIGtlZXBUb29sdGlwT3Blbk9uSG92ZXIsIC4uLnByb3BzIH0sIHByb3BSZWYpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHVzZVRvb2x0aXBDb250ZXh0KCk7XG4gICAgY29uc3QgaWQgPSB1c2VJZCgpO1xuICAgIGNvbnN0IHsgaXNJbnN0YW50UGhhc2UsIGN1cnJlbnRJZCB9ID0gdXNlRGVsYXlHcm91cENvbnRleHQoKTtcbiAgICBjb25zdCByZWYgPSB1c2VNZXJnZVJlZnMoW3N0YXRlLnJlZnMuc2V0RmxvYXRpbmcsIHByb3BSZWZdKTtcbiAgICB1c2VEZWxheUdyb3VwKHN0YXRlLmNvbnRleHQsIHsgaWQgfSk7XG4gICAgY29uc3QgaW5zdGFudER1cmF0aW9uID0gMjA7XG4gICAgY29uc3QgZHVyYXRpb24gPSAxMDA7XG4gICAgY29uc3QgeyBpc01vdW50ZWQsIHN0eWxlcyB9ID0gdXNlVHJhbnNpdGlvblN0eWxlcyhzdGF0ZS5jb250ZXh0LCB7XG4gICAgICAgIGR1cmF0aW9uOiBpc0luc3RhbnRQaGFzZVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgb3BlbjogaW5zdGFudER1cmF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIGBpZGAgaXMgdGhpcyBjb21wb25lbnQncyBgaWRgXG4gICAgICAgICAgICAgICAgLy8gYGN1cnJlbnRJZGAgaXMgdGhlIGN1cnJlbnQgZ3JvdXAncyBgaWRgXG4gICAgICAgICAgICAgICAgY2xvc2U6IGN1cnJlbnRJZCA9PT0gaWQgPyBkdXJhdGlvbiA6IGluc3RhbnREdXJhdGlvbixcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZHVyYXRpb24sXG4gICAgICAgIGluaXRpYWw6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucHJvcHNGcm9tU3RhdGUgfSA9IHVzZU1lbW8oKCkgPT4gc3RhdGUuZ2V0RmxvYXRpbmdQcm9wcyhwcm9wcyksIFtwcm9wcywgc3RhdGVdKTtcbiAgICBjb25zdCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKCgpID0+IHN0YXRlLnNldE9wZW4oZmFsc2UpLCBbc3RhdGVdKTtcbiAgICBjb25zdCBzdHlsZVRvUGFzcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUuZmxvYXRpbmdTdHlsZXMsXG4gICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAuLi5zdHlsZXMsXG4gICAgICAgIGZpbHRlcjogJ2Ryb3Atc2hhZG93KDRweCA0cHggNnB4IHJnYmEoMCwgMCwgMCwgMC4xNSkpJyxcbiAgICB9KSwgW3N0YXRlLCBzdHlsZSwgc3R5bGVzXSk7XG4gICAgY29uc3QgcHJvcHNUb1Bhc3MgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIC4uLnByb3BzRnJvbVN0YXRlLFxuICAgIH0pLCBbcHJvcHNGcm9tU3RhdGVdKTtcbiAgICBpZiAoIWlzTW91bnRlZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaGlkZUNvbnRlbnQgPSByZW5kZXJIaWRkZW5DaGlsZHJlbldoZW5Ub29sdGlwQ2xvc2VkXG4gICAgICAgID8gZmFsc2VcbiAgICAgICAgOiAhaXNNb3VudGVkO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChGbG9hdGluZ1BvcnRhbCwgbnVsbCxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyhjbGFzc05hbWUsIHN0eWxlc1Njc3MudG9vbHRpcENvbnRlbnQsIHtcbiAgICAgICAgICAgICAgICBbc3R5bGVzU2Nzcy5za2lubnldOiBpc1NraW5ueSxcbiAgICAgICAgICAgICAgICBbc3R5bGVzU2Nzcy5maXRDb250ZW50XTogZml0Q29udGVudCxcbiAgICAgICAgICAgICAgICBbc3R5bGVzU2Nzcy5zdGF5T3Blbk9uSG92ZXJdOiBrZWVwVG9vbHRpcE9wZW5PbkhvdmVyLFxuICAgICAgICAgICAgfSksIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLCBvbktleURvd246IHVuZGVmaW5lZCwgcmVmOiByZWYsIHN0eWxlOiBzdHlsZVRvUGFzcywgLi4ucHJvcHNUb1Bhc3MgfSwgaGlkZUNvbnRlbnQgPyBudWxsIDogY2hpbGRyZW4pKSk7XG59KTtcblRvb2x0aXBDb250ZW50LmRpc3BsYXlOYW1lID0gJ1Rvb2x0aXBDb250ZW50JztcblxuY29uc3QgVG9vbHRpcFNpbXBsZSA9ICh7IGNoaWxkcmVuLCBjb250ZW50LCBpc1NraW5ueSwgZml0Q29udGVudCwgY2xhc3NOYW1lLCBjbGFzc05hbWVDb250ZW50LCBhc0NoaWxkLCBkaXNhYmxlID0gZmFsc2UsIGNvbnRlbnRSZWYsIHN0eWxlLCBzdHlsZUNvbnRlbnQsIHJlbmRlckhpZGRlbkNoaWxkcmVuV2hlblRvb2x0aXBDbG9zZWQsIGtlZXBUb29sdGlwT3Blbk9uSG92ZXIgPSB0cnVlLCBpc0NsaWNrVG9PcGVuLCBzdGF0ZVJlZiwgb3Blbjogb3BlblByb3AsIGNvbnRlbnRSZW5kZXJSZWxpZXNPbkJlaW5nT3BlbiwgY2xvc2VEZWxheSwgZGlzcGxheUFzSW5saW5lVGV4dCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHBvaW50ZXJMZWF2ZVRpbWVvdXRSZWYgPSB1c2VSZWYoKTtcbiAgICBjb25zdCB7IG9uT3BlbkNoYW5nZSwgZGVsYXkgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBoYW5kbGVPcGVuQ2hhbmdlID0gdXNlQ2FsbGJhY2soKG5ld09wZW4pID0+IHtcbiAgICAgICAgaWYgKGlzQ2xpY2tUb09wZW4gPyBmYWxzZSA6IG5ld09wZW4pIHtcbiAgICAgICAgICAgIHNldE9wZW4obmV3T3Blbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjb250ZW50UmVuZGVyUmVsaWVzT25CZWluZ09wZW4gfHwgIWlzQ2xpY2tUb09wZW4pICYmICFuZXdPcGVuKSB7XG4gICAgICAgICAgICBzZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250ZW50UmVuZGVyUmVsaWVzT25CZWluZ09wZW4sIGlzQ2xpY2tUb09wZW5dKTtcbiAgICBjb25zdCBoYW5kbGVQb2ludGVyRW50ZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChrZWVwVG9vbHRpcE9wZW5PbkhvdmVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocG9pbnRlckxlYXZlVGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHNldE9wZW4odHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LCBba2VlcFRvb2x0aXBPcGVuT25Ib3Zlcl0pO1xuICAgIGNvbnN0IGhhbmRsZVBvaW50ZXJMZWF2ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKGtlZXBUb29sdGlwT3Blbk9uSG92ZXIpIHtcbiAgICAgICAgICAgIHBvaW50ZXJMZWF2ZVRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgfSwgTWF0aC5tYXgoMjUwLCBjbG9zZURlbGF5IHx8IGRlbGF5IHx8IDApKTtcbiAgICAgICAgfVxuICAgIH0sIFtrZWVwVG9vbHRpcE9wZW5PbkhvdmVyLCBkZWxheSwgY2xvc2VEZWxheV0pO1xuICAgIGNvbnN0IGhhbmRsZVRyaWdnZXJQb2ludGVyRW50ZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChwb2ludGVyTGVhdmVUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBvbk9wZW5DaGFuZ2U/LihvcGVuKTtcbiAgICB9LCBbb25PcGVuQ2hhbmdlLCBvcGVuXSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShzdGF0ZVJlZiwgKCkgPT4gKHtcbiAgICAgICAgaGFuZGxlUG9pbnRlckVudGVyLFxuICAgICAgICBoYW5kbGVQb2ludGVyTGVhdmUsXG4gICAgfSksIFtoYW5kbGVQb2ludGVyRW50ZXIsIGhhbmRsZVBvaW50ZXJMZWF2ZV0pO1xuICAgIGNvbnN0IHByb3BzVG9QYXNzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgb25PcGVuQ2hhbmdlOiBoYW5kbGVPcGVuQ2hhbmdlLFxuICAgICAgICAuLi57IG9wZW46IG9wZW5Qcm9wID09PSB1bmRlZmluZWQgPyBvcGVuIDogb3BlblByb3AgfSxcbiAgICB9KSwgW3Byb3BzLCBoYW5kbGVPcGVuQ2hhbmdlLCBvcGVuLCBvcGVuUHJvcF0pO1xuICAgIHJldHVybiBkaXNhYmxlID8gKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3RfX2RlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKSkgOiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7IC4uLnByb3BzVG9QYXNzIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcFRyaWdnZXIsIHsgYXNDaGlsZDogYXNDaGlsZCwgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGRpc3BsYXlBc0lubGluZVRleHQ6IGRpc3BsYXlBc0lubGluZVRleHQsIG9uUG9pbnRlckVudGVyOiBrZWVwVG9vbHRpcE9wZW5PbkhvdmVyID8gaGFuZGxlVHJpZ2dlclBvaW50ZXJFbnRlciA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IGtlZXBUb29sdGlwT3Blbk9uSG92ZXIgPyBoYW5kbGVQb2ludGVyTGVhdmUgOiB1bmRlZmluZWQsIHN0eWxlOiBzdHlsZSB9LCBjaGlsZHJlbiksXG4gICAgICAgICEhY29udGVudCAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUb29sdGlwQ29udGVudCwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZUNvbnRlbnQsIGZpdENvbnRlbnQ6IGZpdENvbnRlbnQsIGlzU2tpbm55OiBpc1NraW5ueSwga2VlcFRvb2x0aXBPcGVuT25Ib3Zlcjoga2VlcFRvb2x0aXBPcGVuT25Ib3Zlciwgb25Qb2ludGVyRW50ZXI6IGtlZXBUb29sdGlwT3Blbk9uSG92ZXIgPyBoYW5kbGVQb2ludGVyRW50ZXIgOiB1bmRlZmluZWQsIG9uUG9pbnRlckxlYXZlOiBrZWVwVG9vbHRpcE9wZW5PbkhvdmVyID8gaGFuZGxlUG9pbnRlckxlYXZlIDogdW5kZWZpbmVkLCByZWY6IGNvbnRlbnRSZWYsIHJlbmRlckhpZGRlbkNoaWxkcmVuV2hlblRvb2x0aXBDbG9zZWQ6IHJlbmRlckhpZGRlbkNoaWxkcmVuV2hlblRvb2x0aXBDbG9zZWQsIHN0eWxlOiBzdHlsZUNvbnRlbnQgfSwgY29udGVudCkpKSk7XG59O1xuXG52YXIgc3R5bGVzJG8gPSB7XCJmbGV4XCI6XCJGbGV4LW1vZHVsZV9mbGV4X182bmVmWFwiLFwiaXNDZW50ZXJlZFhcIjpcIkZsZXgtbW9kdWxlX2lzQ2VudGVyZWRYX19JdkM5ZFwiLFwiaXNDZW50ZXJlZFlcIjpcIkZsZXgtbW9kdWxlX2lzQ2VudGVyZWRZX19ZRWVOMlwiLFwiaXNDZW50ZXJlZFwiOlwiRmxleC1tb2R1bGVfaXNDZW50ZXJlZF9fNUYwNC1cIixcImlzQ29sdW1uXCI6XCJGbGV4LW1vZHVsZV9pc0NvbHVtbl9fLUhqUjFcIn07XG5cbmNvbnN0IEZsZXggPSBmb3J3YXJkUmVmKCh7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGlzQ29sdW1uLCBpc0NlbnRlcmVkLCBpc0NlbnRlcmVkWCwgaXNDZW50ZXJlZFksIGlzRnVsbFdpZHRoLCBpc0Z1bGxIZWlnaHQsIGp1c3RpZnlDb250ZW50LCBhbGlnbkl0ZW1zLCBzdHlsZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgY2xhc3NOYW1lc0NvbWJpbmVkID0gdXNlTWVtbygoKSA9PiBjbGFzc05hbWVzKHN0eWxlcyRvLmZsZXgsIGNsYXNzTmFtZSwge1xuICAgICAgICBbc3R5bGVzJG8uaXNDZW50ZXJlZFhdOiBpc0NlbnRlcmVkWCxcbiAgICAgICAgW3N0eWxlcyRvLmlzQ2VudGVyZWRZXTogaXNDZW50ZXJlZFksXG4gICAgICAgIFtzdHlsZXMkby5pc0NlbnRlcmVkXTogaXNDZW50ZXJlZCxcbiAgICAgICAgW3N0eWxlcyRvLmlzQ29sdW1uXTogaXNDb2x1bW4sXG4gICAgICAgIFtzdHlsZXMkby5pc0Z1bGxXaWR0aF06IGlzRnVsbFdpZHRoLFxuICAgICAgICBbc3R5bGVzJG8uaXNGdWxsSGVpZ2h0XTogaXNGdWxsSGVpZ2h0LFxuICAgIH0pLCBbXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgaXNDZW50ZXJlZFgsXG4gICAgICAgIGlzQ2VudGVyZWRZLFxuICAgICAgICBpc0NlbnRlcmVkLFxuICAgICAgICBpc0NvbHVtbixcbiAgICAgICAgaXNGdWxsV2lkdGgsXG4gICAgICAgIGlzRnVsbEhlaWdodCxcbiAgICBdKTtcbiAgICBjb25zdCBzdHlsZUNvbWJpbmVkID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICAuLi4oc3R5bGUgfHwge30pLFxuICAgICAgICAnLS1qdXN0aWZ5LWNvbnRlbnQnOiBqdXN0aWZ5Q29udGVudCxcbiAgICAgICAgJy0tYWxpZ24taXRlbXMnOiBhbGlnbkl0ZW1zLFxuICAgIH0pLCBbc3R5bGUsIGFsaWduSXRlbXMsIGp1c3RpZnlDb250ZW50XSk7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgLi4ucHJvcHMsIGNsYXNzTmFtZTogY2xhc3NOYW1lc0NvbWJpbmVkLCByZWY6IHJlZiwgc3R5bGU6IHN0eWxlQ29tYmluZWQgfSwgY2hpbGRyZW4pKTtcbn0pO1xuRmxleC5kaXNwbGF5TmFtZSA9ICdGbGV4JztcblxudmFyIHN0eWxlcyRuID0ge1wieHNcIjpcIlxcXCIzNmVtXFxcIlwiLFwic21cIjpcIlxcXCI0OGVtXFxcIlwiLFwibWRcIjpcIlxcXCI2MmVtXFxcIlwiLFwibGdcIjpcIlxcXCI3NWVtXFxcIlwiLFwieGxcIjpcIlxcXCI4OGVtXFxcIlwiLFwicGFnZVBhZGRpbmdYXCI6XCJQYWdlUGFkZGluZ1gtbW9kdWxlX3BhZ2VQYWRkaW5nWF9fWk92OFZcIixcImlzRGlzYWJsZWRcIjpcIlBhZ2VQYWRkaW5nWC1tb2R1bGVfaXNEaXNhYmxlZF9fTFktSHpcIixcImlzRGlzYWJsZWRSaWdodFwiOlwiUGFnZVBhZGRpbmdYLW1vZHVsZV9pc0Rpc2FibGVkUmlnaHRfXzBDZVBwXCIsXCJpc0Rpc2FibGVkTGVmdFwiOlwiUGFnZVBhZGRpbmdYLW1vZHVsZV9pc0Rpc2FibGVkTGVmdF9fTEFJdlJcIn07XG5cbi8qKlxuICogVGhpcyBpcyBhIGNvbXBvbmVudCB0byBwcm92aWRlIHN0YW5kYXJkaXNlZCB4LWF4aXMgKGxlZnQgcmlnaHQpIHBhZGRpbmcgdG8gcGFnZSBjb21wb25lbnRzXG4gKi9cbmNvbnN0IFBhZ2VQYWRkaW5nWCA9IGZvcndhcmRSZWYoKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgZGlzYWJsZSA9IGZhbHNlLCBkaXNhYmxlTGVmdCA9IGZhbHNlLCBkaXNhYmxlUmlnaHQgPSBmYWxzZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgLi4ucHJvcHMsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkbi5wYWdlUGFkZGluZ1gsIGNsYXNzTmFtZSwge1xuICAgICAgICAgICAgW3N0eWxlcyRuLmlzRGlzYWJsZWRdOiBkaXNhYmxlLFxuICAgICAgICAgICAgW3N0eWxlcyRuLmlzRGlzYWJsZWRSaWdodF06IGRpc2FibGVSaWdodCxcbiAgICAgICAgICAgIFtzdHlsZXMkbi5pc0Rpc2FibGVkTGVmdF06IGRpc2FibGVMZWZ0LFxuICAgICAgICB9KSwgcmVmOiByZWYgfSwgY2hpbGRyZW4pKTtcbn0pO1xuUGFnZVBhZGRpbmdYLmRpc3BsYXlOYW1lID0gJ1BhZ2VQYWRkaW5nWCc7XG5cbnZhciBzdHlsZXMkbSA9IHtcInNwYWNlclwiOlwiU3BhY2VyLW1vZHVsZV9zcGFjZXJfX3RWNTg5XCIsXCJzaXplWFNcIjpcIlNwYWNlci1tb2R1bGVfc2l6ZVhTX19PWElKYVwiLFwic2l6ZVNNXCI6XCJTcGFjZXItbW9kdWxlX3NpemVTTV9fUlFRcmNcIixcInNpemVNRFwiOlwiU3BhY2VyLW1vZHVsZV9zaXplTURfX1Q2OWd2XCIsXCJzaXplTEdcIjpcIlNwYWNlci1tb2R1bGVfc2l6ZUxHX19sZmRXaFwiLFwic2l6ZVhMXCI6XCJTcGFjZXItbW9kdWxlX3NpemVYTF9fMm10djNcIixcImhlaWdodFhTXCI6XCJTcGFjZXItbW9kdWxlX2hlaWdodFhTX191eHU0cFwiLFwiaGVpZ2h0U01cIjpcIlNwYWNlci1tb2R1bGVfaGVpZ2h0U01fX1VaNS1VXCIsXCJoZWlnaHRNRFwiOlwiU3BhY2VyLW1vZHVsZV9oZWlnaHRNRF9fV090VldcIixcImhlaWdodExHXCI6XCJTcGFjZXItbW9kdWxlX2hlaWdodExHX18yMXZzUFwiLFwiaGVpZ2h0WExcIjpcIlNwYWNlci1tb2R1bGVfaGVpZ2h0WExfX1AxMEdXXCIsXCJ3aWR0aFhTXCI6XCJTcGFjZXItbW9kdWxlX3dpZHRoWFNfX3h0eXpxXCIsXCJ3aWR0aFNNXCI6XCJTcGFjZXItbW9kdWxlX3dpZHRoU01fX05GVXR5XCIsXCJ3aWR0aE1EXCI6XCJTcGFjZXItbW9kdWxlX3dpZHRoTURfXzVNa3RPXCIsXCJ3aWR0aExHXCI6XCJTcGFjZXItbW9kdWxlX3dpZHRoTEdfXzlDR2NrXCIsXCJ3aWR0aFhMXCI6XCJTcGFjZXItbW9kdWxlX3dpZHRoWExfX0JKZ0ktXCJ9O1xuXG5jb25zdCBjcmVhdGVTaXplQ2xhc3NOYW1lT2JqID0gKHR5cGUsIHNpemUpID0+IChzaXplID8geyBbc3R5bGVzJG0/LltgJHt0eXBlfSR7c2l6ZT8udG9VcHBlckNhc2UoKX1gXV06ICEhc2l6ZSB9IDoge30pO1xuY29uc3QgU3BhY2VyID0gZm9yd2FyZFJlZigoeyBzaXplLCBoZWlnaHQsIHdpZHRoLCBjbGFzc05hbWUsIHNjYWxlRmFjdG9yID0gMSwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XG4gICAgY29uc3Qgc2l6ZUNsYXNzTmFtZXMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIC4uLmNyZWF0ZVNpemVDbGFzc05hbWVPYmooJ3NpemUnLCBzaXplKSxcbiAgICAgICAgLi4uY3JlYXRlU2l6ZUNsYXNzTmFtZU9iaignaGVpZ2h0JywgaGVpZ2h0KSxcbiAgICAgICAgLi4uY3JlYXRlU2l6ZUNsYXNzTmFtZU9iaignd2lkdGgnLCB3aWR0aCksXG4gICAgfSksIFtzaXplLCBoZWlnaHQsIHdpZHRoXSk7XG4gICAgY29uc3Qgc3R5bGUgPSB1c2VNZW1vKCgpID0+ICh7ICctLXNjYWxlLWZhY3Rvcic6IHNjYWxlRmFjdG9yIH0pLCBbc2NhbGVGYWN0b3JdKTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgLi4ucHJvcHMsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkbS5zcGFjZXIsIGNsYXNzTmFtZSwgc2l6ZUNsYXNzTmFtZXMpLCByZWY6IHJlZiwgc3R5bGU6IHN0eWxlIH0pKTtcbn0pO1xuU3BhY2VyLmRpc3BsYXlOYW1lID0gJ1NwYWNlcic7XG5cbnZhciBzdHlsZXMkbCA9IHt9O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBjb21wb25lbnQgdG8gcHJvdmlkZSBzdGFuZGFyZGlzZWQgeC1heGlzIChsZWZ0IHJpZ2h0KSBwYWRkaW5nIHRvIHBhZ2UgY29tcG9uZW50c1xuICovXG5jb25zdCBQYWdlUGFkZGluZ1kgPSBmb3J3YXJkUmVmKCh7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGRpc2FibGUgPSBmYWxzZSwgZGlzYWJsZVRvcCA9IGZhbHNlLCBkaXNhYmxlQm90dG9tID0gZmFsc2UsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLnByb3BzLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGwucGFnZVBhZGRpbmdZLCBjbGFzc05hbWUpLCByZWY6IHJlZiB9LFxuICAgICAgICAhZGlzYWJsZSAmJiAhZGlzYWJsZVRvcCAmJiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNwYWNlciwgeyBoZWlnaHQ6IFwieGxcIiwgc2NhbGVGYWN0b3I6IDIgfSksXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAhZGlzYWJsZSAmJiAhZGlzYWJsZUJvdHRvbSAmJiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNwYWNlciwgeyBoZWlnaHQ6IFwieGxcIiwgc2NhbGVGYWN0b3I6IDIgfSkpKTtcbn0pO1xuUGFnZVBhZGRpbmdZLmRpc3BsYXlOYW1lID0gJ1BhZ2VQYWRkaW5nWSc7XG5cbnZhciBzdHlsZXMkayA9IHtcInRvb2x0aXBJY29uXCI6XCJUb29sdGlwSGVscEljb24tbW9kdWxlX3Rvb2x0aXBJY29uX19nRC1scFwifTtcblxuY29uc3QgVG9vbHRpcEhlbHBJY29uID0gKHsgY2xhc3NOYW1lLCBJY29uQ29tcG9uZW50ID0gUXVlc3Rpb25NYXJrQ2lyY2xlZEljb24sIC4uLnByb3BzIH0pID0+IHtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSWNvbkNvbXBvbmVudCwgeyAuLi5wcm9wcywgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNsYXNzTmFtZSwgc3R5bGVzJGsudG9vbHRpcEljb24pIH0pKTtcbn07XG5cbnZhciBzdHlsZXMkaiA9IHtcInRvb2x0aXBIZWxwXCI6XCJUb29sdGlwSGVscC1tb2R1bGVfdG9vbHRpcEhlbHBfX0tXN0xDXCJ9O1xuXG5jb25zdCBUb29sdGlwSGVscCA9ICh7IGNsYXNzTmFtZSwgY2hpbGRyZW4sIGtlZXBUb29sdGlwT3Blbk9uSG92ZXIgPSBmYWxzZSwgc2NhbGUsIHN0eWxlOiBzdHlsZVByb3AsIGRpc3BsYXlIZWxwSWNvbkFsb25nc2lkZSwgZGlzYWJsZSwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdHlsZVByb3AsXG4gICAgICAgICAgICAnLS1zY2FsZSc6IHNjYWxlIHx8IDEsXG4gICAgICAgIH07XG4gICAgfSwgW3NjYWxlLCBzdHlsZVByb3BdKTtcbiAgICByZXR1cm4gZGlzYWJsZSA/IChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbikpIDogKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcFNpbXBsZSwgeyAuLi5wcm9wcywgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNsYXNzTmFtZSwgc3R5bGVzJGoudG9vbHRpcEhlbHApLCBkaXNhYmxlOiBkaXNhYmxlLCBrZWVwVG9vbHRpcE9wZW5PbkhvdmVyOiBrZWVwVG9vbHRpcE9wZW5PbkhvdmVyLCBzdHlsZTogc3R5bGUgfSwgZGlzcGxheUhlbHBJY29uQWxvbmdzaWRlID8gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRmxleCwgbnVsbCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3BhY2VyLCB7IHdpZHRoOiBcInhzXCIgfSksXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcEhlbHBJY29uLCBudWxsKSkpIDogKGNoaWxkcmVuIHx8IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcEhlbHBJY29uLCBudWxsKSkpKTtcbn07XG5cbnZhciBzdHlsZXMkaSA9IHtcImJ1dHRvblwiOlwiQnV0dG9uLW1vZHVsZV9idXR0b25fX2JaU2hTXCIsXCJwcmltYXJ5XCI6XCJCdXR0b24tbW9kdWxlX3ByaW1hcnlfX1ZYVWh6XCIsXCJsaWdodFwiOlwiQnV0dG9uLW1vZHVsZV9saWdodF9fR3JhNE5cIixcImJsYWNrXCI6XCJCdXR0b24tbW9kdWxlX2JsYWNrX190RGJqV1wiLFwid2hpdGVcIjpcIkJ1dHRvbi1tb2R1bGVfd2hpdGVfX2lRbC1uXCIsXCJsaWdodEdyYXlcIjpcIkJ1dHRvbi1tb2R1bGVfbGlnaHRHcmF5X185cTlrQ1wiLFwic21hbGxcIjpcIkJ1dHRvbi1tb2R1bGVfc21hbGxfX0xOaXV2XCIsXCJkaXNhYmxlZFwiOlwiQnV0dG9uLW1vZHVsZV9kaXNhYmxlZF9fM1p2Q1lcIixcImRpc2FibGVQcmVzc0VmZmVjdE9uQ2xpY2tcIjpcIkJ1dHRvbi1tb2R1bGVfZGlzYWJsZVByZXNzRWZmZWN0T25DbGlja19fcE12S21cIixcImRpc2FibGVXaXRob3V0Q2hhbmdpbmdBcHBlYXJhbmNlXCI6XCJCdXR0b24tbW9kdWxlX2Rpc2FibGVXaXRob3V0Q2hhbmdpbmdBcHBlYXJhbmNlX185U3Qwb1wiLFwiZGlzYWJsZVBhZGRpbmdcIjpcIkJ1dHRvbi1tb2R1bGVfZGlzYWJsZVBhZGRpbmdfX1RuUHBCXCIsXCJ1c2VTdmdGaWxsXCI6XCJCdXR0b24tbW9kdWxlX3VzZVN2Z0ZpbGxfX0toNC1oXCIsXCJ3cmFwcGVyQnV0dG9uXCI6XCJCdXR0b24tbW9kdWxlX3dyYXBwZXJCdXR0b25fX2pDdGNTXCJ9O1xuXG5jb25zdCBCdXR0b24gPSAoeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCB0eXBlID0gJ2J1dHRvbicsIHZhcmlhbnQgPSAnYmFzZScsIGlzV3JhcHBlciA9IGZhbHNlLCBkaXNhYmxlUGFkZGluZyA9IGZhbHNlLCBzaXplVmFyaWFudCA9ICdkZWZhdWx0JywgdG9vbHRpcENvbnRlbnQsIHRvb2x0aXBQbGFjZW1lbnQsIHRvb2x0aXBEZWxheSwgZGlzYWJsZWQgPSBmYWxzZSwgZGlzYWJsZVdpdGhvdXRDaGFuZ2luZ0FwcGVhcmFuY2UgPSBmYWxzZSwgZGlzYWJsZVByZXNzRWZmZWN0T25DbGljayA9IGZhbHNlLCBlbmFibGVUb29sdGlwV2hlbkRpc2FibGVkID0gZmFsc2UsIGJ1dHRvblJlZiwgYmFja2dyb3VuZENvbG9yLCBiYWNrZ3JvdW5kQ29sb3JTaGFkZSwgYm9yZGVyQ29sb3IsIGJvcmRlckNvbG9yU2hhZGUsIHRleHRDb2xvciwgdGV4dENvbG9yU2hhZGUsIHN0eWxlOiBzdHlsZVByb3AsIG9uQ2xpY2ssIHRvb2x0aXBQcm9wcywgcGFzc0Rpc2FibGVkQXR0cmlidXRlID0gdHJ1ZSwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHRvb2x0aXBSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyBpc01vdW50ZWRDbGllbnQgfSA9IHVzZUNsaWVudE1vdW50ZWRTdGF0ZSgpO1xuICAgIGNvbnN0IHZhcmlhbnRXaXRoRGVmYXVsdCA9IGlzV3JhcHBlciA/IHZhcmlhbnQgOiB2YXJpYW50IHx8ICdiYXNlJztcbiAgICBjb25zdCBpc0JvcmRlclZhcmlhbnQgPSB2YXJpYW50V2l0aERlZmF1bHQgPT09ICdib3JkZXInO1xuICAgIGxldCBiYWNrZ3JvdW5kO1xuICAgIGxldCBjb2xvcjtcbiAgICBsZXQgYm9yZGVyO1xuICAgIGlmIChpc0JvcmRlclZhcmlhbnQgfHwgYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIGJhY2tncm91bmQgPSBpc0JvcmRlclZhcmlhbnRcbiAgICAgICAgICAgID8gJ3Vuc2V0J1xuICAgICAgICAgICAgOiBnZXRUaGVtZVZhcmlhYmxlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29sb3InLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBiYWNrZ3JvdW5kQ29sb3IgfHwgJ3ByaW1hcnknLFxuICAgICAgICAgICAgICAgIHNoYWRlOiBiYWNrZ3JvdW5kQ29sb3JTaGFkZSB8fCA3LFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc0JvcmRlclZhcmlhbnQgfHwgdGV4dENvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gZ2V0VGhlbWVWYXJpYWJsZSh7XG4gICAgICAgICAgICB0eXBlOiAnY29sb3InLFxuICAgICAgICAgICAgY29sb3I6IChpc0JvcmRlclZhcmlhbnQgPyB0ZXh0Q29sb3IgfHwgYm9yZGVyQ29sb3IgOiB0ZXh0Q29sb3IpIHx8ICdwcmltYXJ5JyxcbiAgICAgICAgICAgIHNoYWRlOiB0ZXh0Q29sb3JTaGFkZSB8fCA5LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzQm9yZGVyVmFyaWFudCB8fCBib3JkZXJDb2xvcikge1xuICAgICAgICBib3JkZXIgPVxuICAgICAgICAgICAgaXNCb3JkZXJWYXJpYW50IHx8IGJvcmRlckNvbG9yXG4gICAgICAgICAgICAgICAgPyBgMXB4IHNvbGlkICR7Z2V0VGhlbWVWYXJpYWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBib3JkZXJDb2xvciB8fCAncHJpbWFyeScsXG4gICAgICAgICAgICAgICAgICAgIHNoYWRlOiBib3JkZXJDb2xvclNoYWRlIHx8IDksXG4gICAgICAgICAgICAgICAgfSl9YFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZSA9IHVzZU1lbW8oKCkgPT4gaXNNb3VudGVkQ2xpZW50XG4gICAgICAgID8gcmVtb3ZlVW5kZWZpbmVkVmFsdWVzRnJvbU9iaih7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLFxuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICBib3JkZXIsXG4gICAgICAgICAgICAuLi5zdHlsZVByb3AsXG4gICAgICAgIH0pXG4gICAgICAgIDoge30sIFtiYWNrZ3JvdW5kLCBib3JkZXIsIGNvbG9yLCBzdHlsZVByb3AsIGlzTW91bnRlZENsaWVudF0pO1xuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgdG9vbHRpcFJlZi5jdXJyZW50Py5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgb25DbGljaz8uKGUpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2ssIGRpc2FibGVkXSk7XG4gICAgY29uc3QgYnV0dG9uQ2hpbGQgPSB1c2VNZW1vKCgpID0+IChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgLi4ucHJvcHMsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkaS5idXR0b24sIGNsYXNzTmFtZSwgc3R5bGVzJGlbc2l6ZVZhcmlhbnRdLCB7XG4gICAgICAgICAgICBbc3R5bGVzJGkudXNlU3ZnRmlsbF06ICEhYm9yZGVyLFxuICAgICAgICAgICAgW3N0eWxlcyRpLndyYXBwZXJCdXR0b25dOiBpc1dyYXBwZXIsXG4gICAgICAgICAgICBbc3R5bGVzJGkuZGlzYWJsZVBhZGRpbmddOiBkaXNhYmxlUGFkZGluZyxcbiAgICAgICAgICAgIFtzdHlsZXMkaS5iYXNlXTogdmFyaWFudFdpdGhEZWZhdWx0Py5pbmNsdWRlcygnYmFzZScpLFxuICAgICAgICAgICAgW3N0eWxlcyRpLmxpZ2h0XTogdmFyaWFudFdpdGhEZWZhdWx0Py5pbmNsdWRlcygnbGlnaHQnKSxcbiAgICAgICAgICAgIFtzdHlsZXMkaS5pbnZlcnNlXTogdmFyaWFudFdpdGhEZWZhdWx0Py5pbmNsdWRlcygnaW52ZXJzZScpLFxuICAgICAgICAgICAgW3N0eWxlcyRpLnByaW1hcnldOiB2YXJpYW50V2l0aERlZmF1bHQ/LmluY2x1ZGVzKCdwcmltYXJ5JyksXG4gICAgICAgICAgICBbc3R5bGVzJGkuZGlzYWJsZWRdOiBkaXNhYmxlZCxcbiAgICAgICAgICAgIFtzdHlsZXMkaS5kaXNhYmxlV2l0aG91dENoYW5naW5nQXBwZWFyYW5jZV06IGRpc2FibGVXaXRob3V0Q2hhbmdpbmdBcHBlYXJhbmNlLFxuICAgICAgICAgICAgW3N0eWxlcyRpLmRpc2FibGVQcmVzc0VmZmVjdE9uQ2xpY2tdOiBkaXNhYmxlUHJlc3NFZmZlY3RPbkNsaWNrLFxuICAgICAgICB9KSwgZGlzYWJsZWQ6IHBhc3NEaXNhYmxlZEF0dHJpYnV0ZSA/IGRpc2FibGVkIDogdW5kZWZpbmVkLCBvbkNsaWNrOiBoYW5kbGVDbGljaywgcmVmOiBidXR0b25SZWYsIHN0eWxlOiBzdHlsZSwgdHlwZTogdHlwZSB9LCBjaGlsZHJlbikpLCBbXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBzaXplVmFyaWFudCxcbiAgICAgICAgaXNXcmFwcGVyLFxuICAgICAgICB0eXBlLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgdmFyaWFudFdpdGhEZWZhdWx0LFxuICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgZGlzYWJsZVBhZGRpbmcsXG4gICAgICAgIGJ1dHRvblJlZixcbiAgICAgICAgZGlzYWJsZVByZXNzRWZmZWN0T25DbGljayxcbiAgICAgICAgZGlzYWJsZVdpdGhvdXRDaGFuZ2luZ0FwcGVhcmFuY2UsXG4gICAgICAgIGhhbmRsZUNsaWNrLFxuICAgICAgICBib3JkZXIsXG4gICAgICAgIHBhc3NEaXNhYmxlZEF0dHJpYnV0ZSxcbiAgICBdKTtcbiAgICByZXR1cm4gdG9vbHRpcENvbnRlbnQgJiYgKGRpc2FibGVkID8gZW5hYmxlVG9vbHRpcFdoZW5EaXNhYmxlZCA6IHRydWUpID8gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcFNpbXBsZSwgeyBhc0NoaWxkOiB0cnVlLCBjb250ZW50OiB0b29sdGlwQ29udGVudCwgZGVsYXk6IHRvb2x0aXBEZWxheSwgaXNTa2lubnk6IHRydWUsIGtlZXBUb29sdGlwT3Blbk9uSG92ZXI6IGZhbHNlLCBwbGFjZW1lbnQ6IHRvb2x0aXBQbGFjZW1lbnQsIHRvb2x0aXBSZWY6IHRvb2x0aXBSZWYsIC4uLnRvb2x0aXBQcm9wcyB9LCBidXR0b25DaGlsZCkpIDogKGJ1dHRvbkNoaWxkKTtcbn07XG5cbnZhciBzdHlsZXMkaCA9IHtcImNhcmRcIjpcIkNhcmQtbW9kdWxlX2NhcmRfX2tRVjNQXCJ9O1xuXG5jb25zdCBDYXJkID0gKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLnByb3BzLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGguY2FyZCwgY2xhc3NOYW1lKSB9LCBjaGlsZHJlbikpO1xufTtcblxudmFyIHN0eWxlcyRnID0ge1wiY2hlY2tib3hcIjpcIkNoZWNrYm94LW1vZHVsZV9jaGVja2JveF9fVENrTG9cIixcImRpc2FibGVGb2N1c091dGxpbmVcIjpcIkNoZWNrYm94LW1vZHVsZV9kaXNhYmxlRm9jdXNPdXRsaW5lX19jd3ljSFwiLFwiZGlzYWJsZWRcIjpcIkNoZWNrYm94LW1vZHVsZV9kaXNhYmxlZF9fbm5nRm9cIixcImNoZWNrYm94SW5kaWNhdG9yXCI6XCJDaGVja2JveC1tb2R1bGVfY2hlY2tib3hJbmRpY2F0b3JfX09iZjFFXCJ9O1xuXG5jb25zdCBDaGVja2JveCA9ICh7IGNoaWxkcmVuLCBjbGFzc05hbWUsIHJlbmRlckNoaWxkV2hlblVuY2hlY2tlZCA9IGZhbHNlLCBjaGVja2VkOiBjaGVja2VkUHJvcCwgZGVmYXVsdENoZWNrZWQgPSBmYWxzZSwgY2xhc3NOYW1lczogY2xhc3NOYW1lc1Byb3AsIG9uQ2xpY2ssIGRpc2FibGVGb2N1c091dGxpbmUgPSBmYWxzZSwgaXNTbWFsbCwgZGlzYWJsZWQsIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShjaGVja2VkUHJvcCB8fCBmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3Q2hlY2tlZCA9IGNoZWNrZWRQcm9wIHx8IGZhbHNlO1xuICAgICAgICBpZiAoY2hlY2tlZFByb3AgIT09IHVuZGVmaW5lZCAmJiBjaGVja2VkICE9PSBuZXdDaGVja2VkKSB7XG4gICAgICAgICAgICBzZXRDaGVja2VkKG5ld0NoZWNrZWQpO1xuICAgICAgICB9XG4gICAgfSwgW2NoZWNrZWRQcm9wLCBjaGVja2VkXSk7XG4gICAgbGV0IGNoZWNrZWRWYWx1ZSA9IGNoZWNrZWQgfHwgZmFsc2U7XG4gICAgaWYgKHJlbmRlckNoaWxkV2hlblVuY2hlY2tlZCkge1xuICAgICAgICBjaGVja2VkVmFsdWUgPSBjaGVja2VkIHx8ICdpbmRldGVybWluYXRlJztcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuVG9SZW5kZXIgPSBjaGlsZHJlbiB8fCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENoZWNrSWNvbiwgbnVsbCk7XG4gICAgaWYgKFJlYWN0X19kZWZhdWx0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMikge1xuICAgICAgICBjaGlsZHJlblRvUmVuZGVyID1cbiAgICAgICAgICAgIGNoZWNrZWRWYWx1ZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgID8gUmVhY3RfX2RlZmF1bHQuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbilbMV1cbiAgICAgICAgICAgICAgICA6IFJlYWN0X19kZWZhdWx0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pWzBdO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0Q2hlY2tlZCgocHJldlZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2soIXByZXZWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIXByZXZWYWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSwgW29uQ2xpY2tdKTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tib3hSYWRpeC5Sb290LCB7IC4uLnByb3BzLCBjaGVja2VkOiBjaGVja2VkVmFsdWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkZy5jaGVja2JveCwgY2xhc3NOYW1lLCB7XG4gICAgICAgICAgICBbY2xhc3NOYW1lc1Byb3A/LmNoZWNrZWQgfHwgJyddOiBjaGVja2VkVmFsdWUgPT09IHRydWUsXG4gICAgICAgICAgICBbY2xhc3NOYW1lc1Byb3A/LnVuY2hlY2tlZCB8fCAnJ106IGNoZWNrZWRWYWx1ZSAhPT0gdHJ1ZSxcbiAgICAgICAgICAgIFtzdHlsZXMkZy5kaXNhYmxlRm9jdXNPdXRsaW5lXTogISFkaXNhYmxlRm9jdXNPdXRsaW5lLFxuICAgICAgICAgICAgW3N0eWxlcyRnLmlzU21hbGxdOiAhIWlzU21hbGwsXG4gICAgICAgICAgICBbc3R5bGVzJGcuZGlzYWJsZWRdOiBkaXNhYmxlZCxcbiAgICAgICAgfSksIGRlZmF1bHRDaGVja2VkOiBkZWZhdWx0Q2hlY2tlZCwgZGlzYWJsZWQ6IGRpc2FibGVkLCBvbkNsaWNrOiBoYW5kbGVDbGljayB9LFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENoZWNrYm94UmFkaXguSW5kaWNhdG9yLCB7IGNsYXNzTmFtZTogc3R5bGVzJGcuY2hlY2tib3hJbmRpY2F0b3IgfSwgY2hpbGRyZW5Ub1JlbmRlcikpKTtcbn07XG5cbnZhciBiYXNlR2V0VGFnJDEgPSBfYmFzZUdldFRhZyxcbiAgICBpc0FycmF5JDMgPSBpc0FycmF5XzEsXG4gICAgaXNPYmplY3RMaWtlJDMgPSBpc09iamVjdExpa2VfMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyQyID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nJDEodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSQzKHZhbHVlKSAmJiBpc09iamVjdExpa2UkMyh2YWx1ZSkgJiYgYmFzZUdldFRhZyQxKHZhbHVlKSA9PSBzdHJpbmdUYWckMik7XG59XG5cbnZhciBpc1N0cmluZ18xID0gaXNTdHJpbmckMTtcblxudmFyIGJhc2VQcm9wZXJ0eSA9IF9iYXNlUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xudmFyIGFzY2lpU2l6ZSQxID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxudmFyIF9hc2NpaVNpemUgPSBhc2NpaVNpemUkMTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuXG52YXIgcnNBc3RyYWxSYW5nZSQxID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlJDEgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDEgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSQxID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSQxID0gcnNDb21ib01hcmtzUmFuZ2UkMSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQxICsgcnNDb21ib1N5bWJvbHNSYW5nZSQxLFxuICAgIHJzVmFyUmFuZ2UkMSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0okMSA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0okMSArIHJzQXN0cmFsUmFuZ2UkMSAgKyByc0NvbWJvUmFuZ2UkMSArIHJzVmFyUmFuZ2UkMSArICddJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZSQxKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxudmFyIF9oYXNVbmljb2RlID0gaGFzVW5pY29kZSQxO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG5cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVTaXplJDEoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICArK3Jlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX3VuaWNvZGVTaXplID0gdW5pY29kZVNpemUkMTtcblxudmFyIGFzY2lpU2l6ZSA9IF9hc2NpaVNpemUsXG4gICAgaGFzVW5pY29kZSA9IF9oYXNVbmljb2RlLFxuICAgIHVuaWNvZGVTaXplID0gX3VuaWNvZGVTaXplO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiBzdHJpbmdTaXplJDEoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xufVxuXG52YXIgX3N0cmluZ1NpemUgPSBzdHJpbmdTaXplJDE7XG5cbnZhciBiYXNlS2V5cyA9IF9iYXNlS2V5cyxcbiAgICBnZXRUYWckMyA9IF9nZXRUYWcsXG4gICAgaXNBcnJheUxpa2UkNCA9IGlzQXJyYXlMaWtlXzEsXG4gICAgaXNTdHJpbmcgPSBpc1N0cmluZ18xLFxuICAgIHN0cmluZ1NpemUgPSBfc3RyaW5nU2l6ZTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyQzID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnJDMgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAqIC8vID0+IDJcbiAqXG4gKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAqIC8vID0+IDdcbiAqL1xuZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UkNChjb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnJDMoY29sbGVjdGlvbik7XG4gIGlmICh0YWcgPT0gbWFwVGFnJDMgfHwgdGFnID09IHNldFRhZyQzKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuXG52YXIgc2l6ZV8xID0gc2l6ZTtcblxudmFyIHNpemUkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzaXplXzEpO1xuXG52YXIgc3R5bGVzJGYgPSB7XCJ0ZXh0XCI6XCJUZXh0LW1vZHVsZV90ZXh0X19ZcG43ZVwifTtcblxuY29uc3QgVGV4dCA9ICh7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGJvbGQsIGJvbGQ1MDAgPSBmYWxzZSwgYm9sZDYwMCA9IGZhbHNlLCBmb250U2l6ZSwgaXRhbGljID0gZmFsc2UsIHVuZGVybGluZSA9IGZhbHNlLCBpbmhlcml0ID0gdHJ1ZSwgdGV4dFJlZiwgdXNlSGVhZGVyRm9udCA9IGZhbHNlLCBjb2xvciwgc3R5bGU6IHN0eWxlUHJvcCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICAuLi5zdHlsZVByb3AsXG4gICAgICAgIC4uLihjb2xvciA/IHsgY29sb3IgfSA6IHt9KSxcbiAgICB9KSwgW3N0eWxlUHJvcCwgY29sb3JdKTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgLi4ucHJvcHMsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkZi50ZXh0LCBjbGFzc05hbWUsIGdlbmVyYXRlRm9udFNpemVDbGFzc05hbWUoe1xuICAgICAgICAgICAgZm9udFNpemU6IGluaGVyaXQgPyBmb250U2l6ZSA6IGZvbnRTaXplIHx8ICdtZCcsXG4gICAgICAgICAgICBib2xkLFxuICAgICAgICAgICAgYm9sZDUwMCxcbiAgICAgICAgICAgIGJvbGQ2MDAsXG4gICAgICAgICAgICBpdGFsaWMsXG4gICAgICAgICAgICB1bmRlcmxpbmUsXG4gICAgICAgICAgICBpbmhlcml0LFxuICAgICAgICAgICAgdXNlSGVhZGVyRm9udCxcbiAgICAgICAgfSkpLCByZWY6IHRleHRSZWYsIHN0eWxlOiBzdHlsZSB9LCBjaGlsZHJlbikpO1xufTtcblxudmFyIHN0eWxlcyRlID0ge1widGl0bGVcIjpcIlRpdGxlLW1vZHVsZV90aXRsZV9fR2ZsbDZcIn07XG5cbmNvbnN0IFRpdGxlID0gKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgdmFyaWFudCA9ICdoMScsIGZvbnRTaXplID0gdmFyaWFudCB8fCAnaDEnLCBib2xkLCBib2xkNTAwLCBib2xkNjAwLCBpdGFsaWMgPSBmYWxzZSwgdW5kZXJsaW5lID0gZmFsc2UsIHN0eWxlLCB1c2VIZWFkZXJGb250ID0gdHJ1ZSwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHByb3BzVG9QYXNzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkZS50aXRsZSwgY2xhc3NOYW1lLCBnZW5lcmF0ZUZvbnRTaXplQ2xhc3NOYW1lKHtcbiAgICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgICAgaXRhbGljLFxuICAgICAgICAgICAgYm9sZCxcbiAgICAgICAgICAgIGJvbGQ1MDAsXG4gICAgICAgICAgICBib2xkNjAwLFxuICAgICAgICAgICAgdW5kZXJsaW5lLFxuICAgICAgICAgICAgaGVhZGVyVmFyaWFudDogdmFyaWFudCxcbiAgICAgICAgICAgIHVzZUhlYWRlckZvbnQsXG4gICAgICAgIH0pKSxcbiAgICB9KSwgW1xuICAgICAgICBib2xkLFxuICAgICAgICBib2xkNTAwLFxuICAgICAgICBib2xkNjAwLFxuICAgICAgICB1bmRlcmxpbmUsXG4gICAgICAgIGl0YWxpYyxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIHByb3BzLFxuICAgICAgICB2YXJpYW50LFxuICAgICAgICB1c2VIZWFkZXJGb250LFxuICAgIF0pO1xuICAgIGlmICghdmFyaWFudCkge1xuICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUZXh0LCB7IC4uLnByb3BzVG9QYXNzIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09ICdoMScpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7IC4uLnByb3BzVG9QYXNzIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09ICdoMicpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCB7IC4uLnByb3BzVG9QYXNzIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09ICdoMycpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7IC4uLnByb3BzVG9QYXNzIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09ICdoNCcpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7IC4uLnByb3BzVG9QYXNzIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09ICdoNScpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoNVwiLCB7IC4uLnByb3BzVG9QYXNzIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09ICdoNicpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoNlwiLCB7IC4uLnByb3BzVG9QYXNzIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7IC4uLnByb3BzVG9QYXNzIH0sIGNoaWxkcmVuKTtcbn07XG5cbnZhciBzdHlsZXMkZCA9IHtcInRleHRJbnB1dENvbXBvbmVudFwiOlwiVGV4dElucHV0LW1vZHVsZV90ZXh0SW5wdXRDb21wb25lbnRfX25SMjBxXCIsXCJ0ZXh0SW5wdXRXcmFwcGVyXCI6XCJUZXh0SW5wdXQtbW9kdWxlX3RleHRJbnB1dFdyYXBwZXJfX05wenZUXCIsXCJ0ZXh0SW5wdXRcIjpcIlRleHRJbnB1dC1tb2R1bGVfdGV4dElucHV0X193Mk5PWlwiLFwiaGFzRXJyb3JcIjpcIlRleHRJbnB1dC1tb2R1bGVfaGFzRXJyb3JfX2NsWmU2XCIsXCJpc0ZvY3VzZWRcIjpcIlRleHRJbnB1dC1tb2R1bGVfaXNGb2N1c2VkX182YnVOS1wiLFwiaGFzSWNvbkxlZnRcIjpcIlRleHRJbnB1dC1tb2R1bGVfaGFzSWNvbkxlZnRfXzVTLWRtXCIsXCJoYXNJY29uUmlnaHRcIjpcIlRleHRJbnB1dC1tb2R1bGVfaGFzSWNvblJpZ2h0X181aFJVZ1wiLFwiaWNvbkNvbnRhaW5lclwiOlwiVGV4dElucHV0LW1vZHVsZV9pY29uQ29udGFpbmVyX19PNmEyZVwiLFwiaXNMZWZ0XCI6XCJUZXh0SW5wdXQtbW9kdWxlX2lzTGVmdF9fZFlGOUdcIixcImlzUmlnaHRcIjpcIlRleHRJbnB1dC1tb2R1bGVfaXNSaWdodF9fRnVGemJcIixcImVycm9yTWVzc2FnZVwiOlwiVGV4dElucHV0LW1vZHVsZV9lcnJvck1lc3NhZ2VfX1hDZG54XCIsXCJsYWJlbENvbnRhaW5lclwiOlwiVGV4dElucHV0LW1vZHVsZV9sYWJlbENvbnRhaW5lcl9feGpSSUZcIixcImNvbXBhY3RcIjpcIlRleHRJbnB1dC1tb2R1bGVfY29tcGFjdF9fZ29qcDJcIixcImxhYmVsXCI6XCJUZXh0SW5wdXQtbW9kdWxlX2xhYmVsX19ROXdtWVwiLFwibGFiZWxIZWxwXCI6XCJUZXh0SW5wdXQtbW9kdWxlX2xhYmVsSGVscF9fbTdpLXNcIn07XG5cbmNvbnN0IFRleHRJbnB1dCA9ICh7IGNsYXNzTmFtZSwgY2xhc3NOYW1lczogY2xhc3NOYW1lc1Byb3AsIGljb24sIGljb25SaWdodCA9IGZhbHNlLCB0eXBlID0gJ3RleHQnLCBsYWJlbCwgbmFtZSwgZXJyb3IsIHRvdWNoZWQsIG9uRm9jdXMsIG9uQmx1ciwgb25DbGljaywgaW5wdXRSZWYsIGxhYmVsSXNDb21wYWN0LCBsYWJlbEhlbHBUb29sdGlwQ29udGVudCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IFtpc0ZvY3VzZWQsIHNldElzRm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBvbkZvY3VzPy4oZSk7XG4gICAgICAgIHNldElzRm9jdXNlZCh0cnVlKTtcbiAgICB9LCBbb25Gb2N1c10pO1xuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgb25DbGljaz8uKGUpO1xuICAgICAgICBzZXRJc0ZvY3VzZWQodHJ1ZSk7XG4gICAgfSwgW29uQ2xpY2tdKTtcbiAgICBjb25zdCBoYW5kbGVCbHVyID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgb25CbHVyPy4oZSk7XG4gICAgICAgIHNldElzRm9jdXNlZChmYWxzZSk7XG4gICAgfSwgW29uQmx1cl0pO1xuICAgIGNvbnN0IGljb25Ub1JlbmRlciA9IHVzZU1lbW8oKCkgPT4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNsYXNzTmFtZXNQcm9wPy5pY29uQ29udGFpbmVyLCBzdHlsZXMkZC5pY29uQ29udGFpbmVyLCB7XG4gICAgICAgICAgICBbc3R5bGVzJGQuaXNMZWZ0XTogIWljb25SaWdodCxcbiAgICAgICAgICAgIFtzdHlsZXMkZC5pc1JpZ2h0XTogaWNvblJpZ2h0LFxuICAgICAgICB9KSB9LCBpY29uKSksIFtpY29uLCBjbGFzc05hbWVzUHJvcCwgaWNvblJpZ2h0XSk7XG4gICAgY29uc3Qgc2hvd0Vycm9yID0gISF0b3VjaGVkICYmICEhZXJyb3IgJiYgIWlzRm9jdXNlZDtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRmxleCwgeyBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyRkLnRleHRJbnB1dENvbXBvbmVudCwgY2xhc3NOYW1lKSwgaXNDb2x1bW46IHRydWUgfSxcbiAgICAgICAgISFsYWJlbCAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkZC5sYWJlbENvbnRhaW5lciwgY2xhc3NOYW1lc1Byb3A/LmxhYmVsQ29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIFtzdHlsZXMkZC5jb21wYWN0XTogbGFiZWxJc0NvbXBhY3QsXG4gICAgICAgICAgICAgICAgfSksIGh0bWxGb3I6IG5hbWUgfSxcbiAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRleHQsIHsgYm9sZDYwMDogdHJ1ZSwgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyRkLmxhYmVsLCBjbGFzc05hbWVzUHJvcD8ubGFiZWwpLCBmb250U2l6ZTogXCJzbVwiIH0sIGxhYmVsKSxcbiAgICAgICAgICAgICAgICAhIWxhYmVsSGVscFRvb2x0aXBDb250ZW50ICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRvb2x0aXBIZWxwLCB7IGNsYXNzTmFtZTogc3R5bGVzJGQubGFiZWxIZWxwLCBjb250ZW50OiBsYWJlbEhlbHBUb29sdGlwQ29udGVudCB9KSkpLFxuICAgICAgICAgICAgIWxhYmVsSXNDb21wYWN0ICYmIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3BhY2VyLCB7IGhlaWdodDogXCJ4c1wiLCBzY2FsZUZhY3RvcjogMC41IH0pKSksXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRmxleCwgeyBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGQudGV4dElucHV0V3JhcHBlciwgY2xhc3NOYW1lc1Byb3A/LmlucHV0V3JhcHBlcikgfSxcbiAgICAgICAgICAgICEhaWNvbiAmJiAhaWNvblJpZ2h0ICYmIGljb25Ub1JlbmRlcixcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IC4uLnByb3BzLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGQudGV4dElucHV0LCBjbGFzc05hbWVzUHJvcD8uaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlcyRkLmlzRm9jdXNlZF06IGlzRm9jdXNlZCxcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlcyRkLmhhc0ljb25MZWZ0XTogISFpY29uICYmICFpY29uUmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIFtzdHlsZXMkZC5oYXNJY29uUmlnaHRdOiAhIWljb25SaWdodCxcbiAgICAgICAgICAgICAgICAgICAgW3N0eWxlcyRkLmhhc0Vycm9yXTogISFzaG93RXJyb3IsXG4gICAgICAgICAgICAgICAgfSksIG9uQmx1cjogaGFuZGxlQmx1ciwgb25DbGljazogaGFuZGxlQ2xpY2ssIG9uRm9jdXM6IGhhbmRsZUZvY3VzLCBvbldoZWVsOiAoZSkgPT4gZS50YXJnZXQuYmx1cigpLCByZWY6IGlucHV0UmVmLCB0eXBlOiB0eXBlIH0pLFxuICAgICAgICAgICAgISFpY29uICYmICEhaWNvblJpZ2h0ICYmIGljb25Ub1JlbmRlciksXG4gICAgICAgICEhc2hvd0Vycm9yICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTcGFjZXIsIHsgaGVpZ2h0OiBcIm1kXCIsIHNjYWxlRmFjdG9yOiAwLjUgfSksXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRleHQsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyRkLmVycm9yTWVzc2FnZSwgY2xhc3NOYW1lc1Byb3A/LmVycm9yTWVzc2FnZSksIGZvbnRTaXplOiBcInhzXCIgfSwgZXJyb3IpKSkpKTtcbn07XG5cbnZhciBzdHlsZXMkYyA9IHtcIndyYXBwZXJcIjpcIkRyb3BEb3duV3JhcHBlci1tb2R1bGVfd3JhcHBlcl9fbVh4eUVcIixcImRyb3BEb3duQnV0dG9uV3JhcHBlclwiOlwiRHJvcERvd25XcmFwcGVyLW1vZHVsZV9kcm9wRG93bkJ1dHRvbldyYXBwZXJfX2k2SlpKXCIsXCJkcm9wRG93blwiOlwiRHJvcERvd25XcmFwcGVyLW1vZHVsZV9kcm9wRG93bl9fZklxenNcIixcImlzT3BlblwiOlwiRHJvcERvd25XcmFwcGVyLW1vZHVsZV9pc09wZW5fX2ZBNmM1XCIsXCJkcm9wRG93bk9wdGlvbnNcIjpcIkRyb3BEb3duV3JhcHBlci1tb2R1bGVfZHJvcERvd25PcHRpb25zX18tYjktN1wiLFwiZHJvcERvd25PcHRpb25cIjpcIkRyb3BEb3duV3JhcHBlci1tb2R1bGVfZHJvcERvd25PcHRpb25fX0F5YkV4XCIsXCJzZWxlY3RlZFwiOlwiRHJvcERvd25XcmFwcGVyLW1vZHVsZV9zZWxlY3RlZF9fR0dic3ZcIixcInNlYXJjaFwiOlwiRHJvcERvd25XcmFwcGVyLW1vZHVsZV9zZWFyY2hfXzNJcFZDXCIsXCJjbGVhcklucHV0QnV0dG9uXCI6XCJEcm9wRG93bldyYXBwZXItbW9kdWxlX2NsZWFySW5wdXRCdXR0b25fX3NwUlU5XCIsXCJub1Jlc3VsdHNUZXh0XCI6XCJEcm9wRG93bldyYXBwZXItbW9kdWxlX25vUmVzdWx0c1RleHRfX0NQaHZ6XCJ9O1xuXG5jb25zdCBUeXBlZEZpeGVkU2l6ZUxpc3QgPSBGaXhlZFNpemVMaXN0O1xuY29uc3QgREVGQVVMVF9WSVJUVUFMSVNBVElPTl9QUk9QUyA9IHtcbiAgICBoZWlnaHQ6IDEyMCxcbiAgICBpdGVtU2l6ZTogMzIsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBvdmVyc2NhbkNvdW50OiAxMDAsXG59O1xuY29uc3QgRHJvcERvd25XcmFwcGVyID0gKHsgYnV0dG9uSUQsIG9wdGlvbnMsIHNlbGVjdGVkSUQsIGNsYXNzTmFtZSwgY2xhc3NOYW1lczogY2xhc3NOYW1lc1Byb3AsIGNsYXNzTmFtZXNJbnB1dCwgb3B0aW9uRGF0YUF0dHJpYnV0ZSwgcmVuZGVyT3B0aW9uLCBlbmFibGVPcGVuaW5nID0gdHJ1ZSwgY2hpbGRyZW4sIG9uQ2xpY2tPcHRpb24sIGZvcmNlT3BlbiA9IGZhbHNlLCBvbkNoYW5nZU9wZW4sIHNlYXJjaEVuYWJsZWQsIHNlYXJjaFNob3dBbGxSZXN1bHRzT25FbXB0eSA9IGZhbHNlLCBzZWFyY2hQbGFjZWhvbGRlciA9ICdTZWFyY2ggZm9yIGEgdmFsdWUuLi4nLCBzZWFyY2hGaWx0ZXJGdW5jdGlvbiwgZ2V0RmlsdGVyVmFsdWVCeUlkLCBibHVyUHJvcHMsIHZpcnR1YWxpc2F0aW9uRW5hYmxlZCA9IGZhbHNlLCB2aXJ0dWFsaXNhdGlvbkxpc3RQcm9wcywgZHJvcERvd25SZWY6IGRyb3BEb3duUmVmUHJvcCwgZHJvcERvd25XcmFwcGVyUmVmLCBmb2N1c1NlYXJjaE9uT3BlbiA9IHRydWUsIH0pID0+IHtcbiAgICBjb25zdCBzZWxlY3RvckJ1dHRvblJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBkcm9wRG93blJlZkludGVybmFsID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGRyb3BEb3duUmVmID0gZHJvcERvd25SZWZQcm9wIHx8IGRyb3BEb3duUmVmSW50ZXJuYWw7XG4gICAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW2Ryb3BEb3duSXNPcGVuLCBzZXREcm9wRG93bklzT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gdXNlU3RhdGUoJycpO1xuICAgIGNvbnN0IFtkZWJvdW5jZWRJbnB1dFZhbHVlLCBzZXREZWJvdW5jZWRJbnB1dFZhbHVlXSA9IHVzZVN0YXRlKCcnKTtcbiAgICBjb25zdCBmb2N1c1NlYXJjaEJhciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaW5wdXRSZWY/LmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgfSwgW2lucHV0UmVmXSk7XG4gICAgY29uc3QgaGFuZGxlU2V0SXNPcGVuID0gdXNlQ2FsbGJhY2soKG9wZW4pID0+IHtcbiAgICAgICAgb25DaGFuZ2VPcGVuPy4ob3Blbik7XG4gICAgICAgIHNldERyb3BEb3duSXNPcGVuKG9wZW4pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChmb2N1c1NlYXJjaE9uT3BlbiAmJiAhIW9wZW4pIHtcbiAgICAgICAgICAgICAgICBmb2N1c1NlYXJjaEJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMDApO1xuICAgIH0sIFtvbkNoYW5nZU9wZW4sIGZvY3VzU2VhcmNoT25PcGVuLCBmb2N1c1NlYXJjaEJhcl0pO1xuICAgIGNvbnN0IHNldElucHV0VmFsdWVEZWJvdW5jZWQgPSB1c2VEZWJvdW5jZWRDYWxsYmFjaygodmFsdWUpID0+IHtcbiAgICAgICAgc2V0RGVib3VuY2VkSW5wdXRWYWx1ZT8uKHZhbHVlKTtcbiAgICB9LCA1MDApO1xuICAgIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gdXNlQ2FsbGJhY2soKHZhbHVlLCBmb3JjZVVwZGF0ZSkgPT4ge1xuICAgICAgICBzZXRJbnB1dFZhbHVlKHZhbHVlKTtcbiAgICAgICAgc2V0SW5wdXRWYWx1ZURlYm91bmNlZCh2YWx1ZSk7XG4gICAgICAgIGlmIChmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgc2V0SW5wdXRWYWx1ZURlYm91bmNlZC5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfSwgW3NldElucHV0VmFsdWVEZWJvdW5jZWRdKTtcbiAgICBjb25zdCBoYW5kbGVDbG9zZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaGFuZGxlU2V0SXNPcGVuKGZhbHNlKTtcbiAgICAgICAgaGFuZGxlSW5wdXRDaGFuZ2UoJycsIHRydWUpO1xuICAgIH0sIFtoYW5kbGVTZXRJc09wZW4sIGhhbmRsZUlucHV0Q2hhbmdlXSk7XG4gICAgY29uc3QgaGFuZGxlQ2xpY2tPcHRpb24gPSB1c2VDYWxsYmFjaygob3B0aW9uKSA9PiB7XG4gICAgICAgIGhhbmRsZUNsb3NlKCk7XG4gICAgICAgIG9uQ2xpY2tPcHRpb24ob3B0aW9uKTtcbiAgICB9LCBbaGFuZGxlQ2xvc2UsIG9uQ2xpY2tPcHRpb25dKTtcbiAgICBjb25zdCBmaWx0ZXJlZElkcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBub3JtYWxpc2VkRGVib3VuY2VkSW5wdXRWYWx1ZSA9IGRlYm91bmNlZElucHV0VmFsdWVcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXNlYXJjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9ybWFsaXNlZERlYm91bmNlZElucHV0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hTaG93QWxsUmVzdWx0c09uRW1wdHkgPyBvcHRpb25zIDogW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZmlsdGVyKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IG9wdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGlzZWRJZCA9IChnZXRGaWx0ZXJWYWx1ZUJ5SWRcbiAgICAgICAgICAgICAgICA/IGdldEZpbHRlclZhbHVlQnlJZCh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGRlYm91bmNlZElucHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IGlkKVxuICAgICAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChzZWFyY2hGaWx0ZXJGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWFyY2hGaWx0ZXJGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGRlYm91bmNlZElucHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tJZlRleHRUZXJtTWF0Y2hlc1NpbmdsZSh7XG4gICAgICAgICAgICAgICAgc291cmNlVmFsdWU6IG5vcm1hbGlzZWRJZCxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBub3JtYWxpc2VkRGVib3VuY2VkSW5wdXRWYWx1ZSxcbiAgICAgICAgICAgIH0pLm1hdGNoZXM7XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZGVib3VuY2VkSW5wdXRWYWx1ZSxcbiAgICAgICAgc2VhcmNoRW5hYmxlZCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgc2VhcmNoU2hvd0FsbFJlc3VsdHNPbkVtcHR5LFxuICAgICAgICBzZWFyY2hGaWx0ZXJGdW5jdGlvbixcbiAgICAgICAgZ2V0RmlsdGVyVmFsdWVCeUlkLFxuICAgIF0pO1xuICAgIGNvbnN0IGlzT3BlbiA9IGZvcmNlT3BlbiB8fCAoISFlbmFibGVPcGVuaW5nICYmICEhZHJvcERvd25Jc09wZW4pO1xuICAgIGNvbnN0IGZpbHRlcmVkSWRzU2xpY2VkID0gdXNlTWVtbygoKSA9PiAoaXNPcGVuID8gZmlsdGVyZWRJZHMgOiAoZmlsdGVyZWRJZHMgfHwgW10pLnNsaWNlKDAsIDEwKSkgfHwgW10sIFtmaWx0ZXJlZElkcywgaXNPcGVuXSk7XG4gICAgY29uc3QgeyBvbkJsdXIsIHNob3VsZERpc2FibGVCbHVyLCAuLi5vdGhlckJsdXJQcm9wcyB9ID0gYmx1clByb3BzIHx8IHt9O1xuICAgIGNvbnN0IGhhbmRsZUJsdXIgPSB1c2VDYWxsYmFjaygoLi4uYXJncykgPT4ge1xuICAgICAgICBvbkJsdXI/LiguLi5hcmdzKTtcbiAgICAgICAgaGFuZGxlQ2xvc2UoKTtcbiAgICB9LCBbb25CbHVyLCBoYW5kbGVDbG9zZV0pO1xuICAgIGNvbnN0IGhhbmRsZUNsaWNrU2VsZWN0b3IgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChkcm9wRG93bklzT3Blbikge1xuICAgICAgICAgICAgaGFuZGxlQmx1cigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlU2V0SXNPcGVuKHRydWUpO1xuICAgICAgICB9XG4gICAgfSwgW2Ryb3BEb3duSXNPcGVuLCBoYW5kbGVTZXRJc09wZW4sIGhhbmRsZUJsdXJdKTtcbiAgICBjb25zdCBoYW5kbGVTaG91bGREaXNhYmxlQmx1ciA9IHVzZUNhbGxiYWNrKChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQsIHJlbGF0ZWRUYXJnZXQgfSA9IHBhcmFtcztcbiAgICAgICAgcmV0dXJuICEhKHNlbGVjdG9yQnV0dG9uUmVmLmN1cnJlbnQ/LmNvbnRhaW5zKHRhcmdldCkgfHxcbiAgICAgICAgICAgIHNlbGVjdG9yQnV0dG9uUmVmLmN1cnJlbnQ/LmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpIHx8XG4gICAgICAgICAgICBzaG91bGREaXNhYmxlQmx1cj8uKHBhcmFtcykpO1xuICAgIH0sIFtzaG91bGREaXNhYmxlQmx1cl0pO1xuICAgIHVzZU9uQmx1cih7XG4gICAgICAgIGJsdXJFbGVtZW50UmVmOiBkcm9wRG93blJlZixcbiAgICAgICAgb25CbHVyOiBoYW5kbGVCbHVyLFxuICAgICAgICBlbmFibGVkOiAhIWlzT3BlbixcbiAgICAgICAgc2hvdWxkRGlzYWJsZUJsdXI6IGhhbmRsZVNob3VsZERpc2FibGVCbHVyLFxuICAgICAgICAuLi5vdGhlckJsdXJQcm9wcyxcbiAgICB9KTtcbiAgICBjb25zdCBsaXN0Q29tcG9uZW50UHJvcHMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIC4uLkRFRkFVTFRfVklSVFVBTElTQVRJT05fUFJPUFMsXG4gICAgICAgIC4uLnZpcnR1YWxpc2F0aW9uTGlzdFByb3BzLFxuICAgICAgICBpdGVtQ291bnQ6IHNpemUkMShmaWx0ZXJlZElkc1NsaWNlZCksXG4gICAgICAgIGl0ZW1EYXRhOiBmaWx0ZXJlZElkc1NsaWNlZCxcbiAgICB9KSwgW2ZpbHRlcmVkSWRzU2xpY2VkLCB2aXJ0dWFsaXNhdGlvbkxpc3RQcm9wc10pO1xuICAgIGNvbnN0IGxpc3RSZW5kZXJlZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAodmlydHVhbGlzYXRpb25FbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVHlwZWRGaXhlZFNpemVMaXN0LCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkYy5kcm9wRG93bk9wdGlvbnMsIGNsYXNzTmFtZXNQcm9wPy5vcHRpb25zPy4oKSksIC4uLmxpc3RDb21wb25lbnRQcm9wcyB9LCAoeyBpbmRleCwgc3R5bGUsIGRhdGEsIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb24gPSBkYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IG9wdGlvbj8uaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGMuZHJvcERvd25PcHRpb24sIGNsYXNzTmFtZXNQcm9wPy5vcHRpb24/LihvcHRpb24pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbc3R5bGVzJGMuc2VsZWN0ZWRdOiBpZCA9PT0gc2VsZWN0ZWRJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBpZCA9PT0gc2VsZWN0ZWRJRCxcbiAgICAgICAgICAgICAgICAgICAgfSksIFwiZGF0YS1lbGVtZW50LXR5cGVcIjogb3B0aW9uRGF0YUF0dHJpYnV0ZSwgZGlzYWJsZVBhZGRpbmc6IHRydWUsIGlzV3JhcHBlcjogdHJ1ZSwga2V5OiBpZCwgb25DbGljazogKCkgPT4gaGFuZGxlQ2xpY2tPcHRpb24ob3B0aW9uKSwgc3R5bGU6IHN0eWxlIH0sIHJlbmRlck9wdGlvbiA/IChyZW5kZXJPcHRpb24oe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkZWJvdW5jZWRJbnB1dFZhbHVlLFxuICAgICAgICAgICAgICAgIH0pKSA6IChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRleHQsIHsgZm9udFNpemU6IFwic21cIiB9LCBpZCkpKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZsZXgsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyRjLmRyb3BEb3duT3B0aW9ucywgY2xhc3NOYW1lc1Byb3A/Lm9wdGlvbnM/LigpKSwgaXNDb2x1bW46IHRydWUgfSwgZmlsdGVyZWRJZHNTbGljZWQubWFwKChvcHRpb24pID0+IChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGMuZHJvcERvd25PcHRpb24sIGNsYXNzTmFtZXNQcm9wPy5vcHRpb24/LihvcHRpb24pLCB7XG4gICAgICAgICAgICAgICAgW3N0eWxlcyRjLnNlbGVjdGVkXTogb3B0aW9uPy5pZCA9PT0gc2VsZWN0ZWRJRCxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogb3B0aW9uPy5pZCA9PT0gc2VsZWN0ZWRJRCxcbiAgICAgICAgICAgIH0pLCBcImRhdGEtZWxlbWVudC10eXBlXCI6IG9wdGlvbkRhdGFBdHRyaWJ1dGUsIGRpc2FibGVQYWRkaW5nOiB0cnVlLCBpc1dyYXBwZXI6IHRydWUsIGtleTogb3B0aW9uPy5pZCwgb25DbGljazogKCkgPT4gaGFuZGxlQ2xpY2tPcHRpb24ob3B0aW9uKSB9LCByZW5kZXJPcHRpb24gPyAocmVuZGVyT3B0aW9uKHtcbiAgICAgICAgICAgIGlkOiBvcHRpb24/LmlkLFxuICAgICAgICAgICAgb3B0aW9uLFxuICAgICAgICAgICAgZGVib3VuY2VkSW5wdXRWYWx1ZSxcbiAgICAgICAgfSkpIDogKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVGV4dCwgeyBmb250U2l6ZTogXCJzbVwiIH0sIG9wdGlvbj8uaWQpKSkpKSkpO1xuICAgIH0sIFtcbiAgICAgICAgY2xhc3NOYW1lc1Byb3AsXG4gICAgICAgIGZpbHRlcmVkSWRzU2xpY2VkLFxuICAgICAgICBoYW5kbGVDbGlja09wdGlvbixcbiAgICAgICAgbGlzdENvbXBvbmVudFByb3BzLFxuICAgICAgICBvcHRpb25EYXRhQXR0cmlidXRlLFxuICAgICAgICByZW5kZXJPcHRpb24sXG4gICAgICAgIHNlbGVjdGVkSUQsXG4gICAgICAgIHZpcnR1YWxpc2F0aW9uRW5hYmxlZCxcbiAgICAgICAgZGVib3VuY2VkSW5wdXRWYWx1ZSxcbiAgICBdKTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGMud3JhcHBlciwgY2xhc3NOYW1lLCB7IG9wZW46IGlzT3BlbiB9KSwgcmVmOiBkcm9wRG93bldyYXBwZXJSZWYgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChCdXR0b24sIHsgYnV0dG9uUmVmOiBzZWxlY3RvckJ1dHRvblJlZiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyRjLmRyb3BEb3duQnV0dG9uV3JhcHBlciwgY2xhc3NOYW1lc1Byb3A/LmJ1dHRvbj8uKCkpLCBkaXNhYmxlZDogIWVuYWJsZU9wZW5pbmcsIGRpc2FibGVQYWRkaW5nOiB0cnVlLCBpZDogYnV0dG9uSUQsIGlzV3JhcHBlcjogdHJ1ZSwgb25DbGljazogZW5hYmxlT3BlbmluZyA/IGhhbmRsZUNsaWNrU2VsZWN0b3IgOiB1bmRlZmluZWQgfSwgY2hpbGRyZW4pLFxuICAgICAgICAhIWVuYWJsZU9wZW5pbmcgJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRmxleCwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGMuZHJvcERvd24sIGNsYXNzTmFtZXNQcm9wPy5kcm9wRG93bj8uKCksIHtcbiAgICAgICAgICAgICAgICBbc3R5bGVzJGMuaXNPcGVuXTogaXNPcGVuLFxuICAgICAgICAgICAgICAgIG9wZW46IGlzT3BlbixcbiAgICAgICAgICAgIH0pLCBpc0NvbHVtbjogdHJ1ZSwgcmVmOiBkcm9wRG93blJlZiB9LFxuICAgICAgICAgICAgISFzZWFyY2hFbmFibGVkICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRleHRJbnB1dCwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGMuc2VhcmNoLCBjbGFzc05hbWVzUHJvcD8uc2VhcmNoPy4oKSksIGNsYXNzTmFtZXM6IGNsYXNzTmFtZXNJbnB1dCwgaWNvbjogUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChCdXR0b24sIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyRjLmNsZWFySW5wdXRCdXR0b24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZXMkYy5pc1Zpc2libGVdOiAhIWlucHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH0pLCBpc1dyYXBwZXI6IHRydWUsIG9uQ2xpY2s6ICgpID0+IGhhbmRsZUlucHV0Q2hhbmdlKCcnLCB0cnVlKSB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENyb3NzMkljb24sIG51bGwpKSwgaWNvblJpZ2h0OiB0cnVlLCBpbnB1dFJlZjogaW5wdXRSZWYsIG9uQ2hhbmdlOiAoZSkgPT4gaGFuZGxlSW5wdXRDaGFuZ2UoZS50YXJnZXQudmFsdWUpLCBwbGFjZWhvbGRlcjogc2VhcmNoUGxhY2Vob2xkZXIsIHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogaW5wdXRWYWx1ZSB9KSksXG4gICAgICAgICAgICBzaXplJDEoZmlsdGVyZWRJZHNTbGljZWQpID8gKGxpc3RSZW5kZXJlZCkgOiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUZXh0LCB7IGNsYXNzTmFtZTogc3R5bGVzJGMubm9SZXN1bHRzVGV4dCwgZm9udFNpemU6IFwieHNcIiB9LCBcIk5vIHJlc3VsdHMgZm91bmQuLi5cIikpKSkpKTtcbn07XG5cbnZhciBzdHlsZXMkYiA9IHtcImhlYWRlckJhclwiOlwiSGVhZGVyQmFyLW1vZHVsZV9oZWFkZXJCYXJfX2Faek9LXCIsXCJoZWFkZXJCYXJSZWxhdGl2ZVdyYXBwZXJcIjpcIkhlYWRlckJhci1tb2R1bGVfaGVhZGVyQmFyUmVsYXRpdmVXcmFwcGVyX19NVmtUU1wiLFwiaGVhZGVyQmFyQ29udGVudHNcIjpcIkhlYWRlckJhci1tb2R1bGVfaGVhZGVyQmFyQ29udGVudHNfX0l6dllsXCIsXCJ0aXRsZVwiOlwiSGVhZGVyQmFyLW1vZHVsZV90aXRsZV9fS0Z6R0tcIixcImhlYWRlclRpdGxlXCI6XCJIZWFkZXJCYXItbW9kdWxlX2hlYWRlclRpdGxlX180aDN3SFwiLFwiaGVhZGVyQmFySXRlbXNcIjpcIkhlYWRlckJhci1tb2R1bGVfaGVhZGVyQmFySXRlbXNfXzExTkhNXCIsXCJoZWFkZXJCYXJTdWJJdGVtc1wiOlwiSGVhZGVyQmFyLW1vZHVsZV9oZWFkZXJCYXJTdWJJdGVtc19fa2hFYk9cIixcImxpbmtcIjpcIkhlYWRlckJhci1tb2R1bGVfbGlua19fUm12VWlcIixcImRpc2FibGVkXCI6XCJIZWFkZXJCYXItbW9kdWxlX2Rpc2FibGVkX19UZWtmV1wiLFwic2VsZWN0ZWRJdGVtQm9yZGVyXCI6XCJIZWFkZXJCYXItbW9kdWxlX3NlbGVjdGVkSXRlbUJvcmRlcl9fVG5HWnFcIn07XG5cbmNvbnN0IEhlYWRlckJhckl0ZW0gPSAoeyBjbGFzc05hbWUsIGlzU2VsZWN0ZWQsIGlzRGlzYWJsZWQsIGhyZWYsIGNoaWxkLCB0ZXh0LCB9KSA9PiB7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFuY2hvciwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGIubGluaywgY2xhc3NOYW1lLCB7XG4gICAgICAgICAgICBbc3R5bGVzJGIuc2VsZWN0ZWRdOiBpc1NlbGVjdGVkLFxuICAgICAgICB9KSwgZGlzYWJsZTogaXNEaXNhYmxlZCwgaHJlZjogaHJlZiB9LCBjaGlsZCB8fCAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUZXh0LCB7IGZvbnRTaXplOiBcInhzXCIgfSwgdGV4dCksXG4gICAgICAgIGlzU2VsZWN0ZWQgJiYgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IHN0eWxlcyRiLnNlbGVjdGVkSXRlbUJvcmRlciB9KSkpKSk7XG59O1xuY29uc3QgSGVhZGVyQmFyID0gKHsgaXRlbXMsIGhlYWRlclRpdGxlQ29udGVudCwgaGVhZGVyVGl0bGVIcmVmLCByaWdodEhhbmRDb250ZW50LCBzZWxlY3RlZElkLCBkaXNhYmxlSGVhZGVyVGl0bGVMaW5rID0gZmFsc2UsIGNsYXNzTmFtZSwgY2xhc3NOYW1lczogY2xhc3NOYW1lc1Byb3AsIHVzZVBhZ2VQYWRkaW5nID0gdHJ1ZSwgfSkgPT4ge1xuICAgIGNvbnN0IFdyYXBwaW5nQ29tcG9uZW50ID0gdXNlUGFnZVBhZGRpbmcgPyBQYWdlUGFkZGluZ1ggOiBGbGV4O1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChGbGV4LCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkYi5oZWFkZXJCYXIsIGNsYXNzTmFtZSkgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChGbGV4LCB7IGFsaWduSXRlbXM6IFwiY2VudGVyXCIsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkYi5oZWFkZXJCYXJSZWxhdGl2ZVdyYXBwZXIsIGNsYXNzTmFtZXNQcm9wPy5yZWxhdGl2ZVdyYXBwZXIpIH0sXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXBwaW5nQ29tcG9uZW50LCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkYi5oZWFkZXJCYXJDb250ZW50cywgY2xhc3NOYW1lc1Byb3A/LmNvbnRlbnRzKSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRmxleCwgeyBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGIuaGVhZGVyQmFySXRlbXMsIGNsYXNzTmFtZXNQcm9wPy5pdGVtcykgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChGbGV4LCB7IGFsaWduSXRlbXM6IFwiY2VudGVyXCIsIGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkYi5oZWFkZXJCYXJTdWJJdGVtcywgY2xhc3NOYW1lc1Byb3A/LnN1Ykl0ZW1zKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChBbmNob3IsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyRiLmxpbmssIGNsYXNzTmFtZXNQcm9wPy5saW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZXMkYi5kaXNhYmxlZF06IGRpc2FibGVIZWFkZXJUaXRsZUxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGRpc2FibGU6IGRpc2FibGVIZWFkZXJUaXRsZUxpbmssIGhyZWY6IGhlYWRlclRpdGxlSHJlZiB8fCAnLycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZsZXgsIHsgYWxpZ25JdGVtczogXCJjZW50ZXJcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyRiLnRpdGxlLCBjbGFzc05hbWVzUHJvcD8udGl0bGUpIH0sIHR5cGVvZiBoZWFkZXJUaXRsZUNvbnRlbnQgPT09ICdzdHJpbmcnID8gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVGV4dCwgeyBib2xkOiB0cnVlLCBmb250U2l6ZTogXCJzbVwiIH0sIGhlYWRlclRpdGxlQ29udGVudCkpIDogKGhlYWRlclRpdGxlQ29udGVudCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLm1hcCgoeyBpZCwgaHJlZiwgdGV4dCwgY2hpbGQgfSkgPT4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSGVhZGVyQmFySXRlbSwgeyBjaGlsZDogY2hpbGQsIGNsYXNzTmFtZTogY2xhc3NOYW1lc1Byb3A/LmxpbmssIGhyZWY6IGhyZWYsIGlzRGlzYWJsZWQ6IGlkID09PSBzZWxlY3RlZElkLCBpc1NlbGVjdGVkOiBpZCA9PT0gc2VsZWN0ZWRJZCwga2V5OiBpZCwgdGV4dDogdGV4dCB9KSkpKSksXG4gICAgICAgICAgICAgICAgcmlnaHRIYW5kQ29udGVudCkpKSk7XG59O1xuXG52YXIgc3R5bGVzJGEgPSB7XCJrbm9iV3JhcHBlclwiOlwiS25vYlJvdGFyeS1tb2R1bGVfa25vYldyYXBwZXJfXzEwaWV2XCIsXCJrbm9iU2tpbldyYXBwZXJcIjpcIktub2JSb3RhcnktbW9kdWxlX2tub2JTa2luV3JhcHBlcl9fOFYyRkhcIixcImlzRGlzYWJsZWRcIjpcIktub2JSb3RhcnktbW9kdWxlX2lzRGlzYWJsZWRfXzEteU5LXCIsXCJrbm9iVmFsdWVXcmFwcGVyXCI6XCJLbm9iUm90YXJ5LW1vZHVsZV9rbm9iVmFsdWVXcmFwcGVyX19SWE5qUVwiLFwia25vYlZhbHVlXCI6XCJLbm9iUm90YXJ5LW1vZHVsZV9rbm9iVmFsdWVfX1ljNlV0XCJ9O1xuXG4vLyBLbm9icyB0YWtlbiBmcm9tIGh0dHA6Ly9yZWFjdC1yb3Rhcnkta25vYi1za2lucy1wcmV2aWV3LnN1cmdlLnNoL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5jb25zdCBLbm9iU3ZnQ2hpbGQxID0gKHsgcG9pbnRlckNvbG9yIH0pID0+IHtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3RfX2RlZmF1bHQuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibGluZWFyR3JhZGllbnRcIiwgeyBpZDogXCJmNzA2Njg3OS1mNTdiLWY3YWItMGE2Mi1iN2U3NjY1OWZjOWFcIiwgeDE6IFwiNTAlXCIsIHgyOiBcIjUwJVwiLCB5MTogXCI1MCVcIiwgeTI6IFwiMTAwJVwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMCVcIiwgc3RvcENvbG9yOiBcIiM0NDQwNDBcIiwgc3RvcE9wYWNpdHk6IFwiMC41MTA5ODI3OVwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjEwMCVcIiwgc3RvcENvbG9yOiBcIiMxMzExMTFcIiwgc3RvcE9wYWNpdHk6IFwiMC44OTMyMDA4NjFcIiB9KSksXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHsgY3g6IFwiOTguMDQwMDAwOVwiLCBjeTogXCI5OC4wNDAwMDA5XCIsIGlkOiBcIjk2OWIxZjUyLTc1OWItYzgzZS02MWVjLTM5NGNlODhhYjM0NFwiLCByOiBcIjk4LjA0MDAwMDlcIiB9KSxcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJmaWx0ZXJcIiwgeyBmaWx0ZXJVbml0czogXCJvYmplY3RCb3VuZGluZ0JveFwiLCBoZWlnaHQ6IFwiMTA2LjYlXCIsIGlkOiBcIjQ0MDBhZDBkLTRkMzYtMGJjMS0wNWIwLWJhNDZlNjEwZWM5N1wiLCB3aWR0aDogXCIxMDYuNiVcIiwgeDogXCItMy4zJVwiLCB5OiBcIi0zLjMlXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZmVNb3JwaG9sb2d5XCIsIHsgaW46IFwiU291cmNlQWxwaGFcIiwgb3BlcmF0b3I6IFwiZGlsYXRlXCIsIHJhZGl1czogXCIwLjVcIiwgcmVzdWx0OiBcInNoYWRvd1NwcmVhZE91dGVyMVwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJmZU9mZnNldFwiLCB7IGR4OiBcIjBcIiwgZHk6IFwiMFwiLCBpbjogXCJzaGFkb3dTcHJlYWRPdXRlcjFcIiwgcmVzdWx0OiBcInNoYWRvd09mZnNldE91dGVyMVwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJmZUdhdXNzaWFuQmx1clwiLCB7IGluOiBcInNoYWRvd09mZnNldE91dGVyMVwiLCByZXN1bHQ6IFwic2hhZG93Qmx1ck91dGVyMVwiLCBzdGREZXZpYXRpb246IFwiMlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJmZUNvbXBvc2l0ZVwiLCB7IGluOiBcInNoYWRvd0JsdXJPdXRlcjFcIiwgaW4yOiBcIlNvdXJjZUFscGhhXCIsIG9wZXJhdG9yOiBcIm91dFwiLCByZXN1bHQ6IFwic2hhZG93Qmx1ck91dGVyMVwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJmZUNvbG9yTWF0cml4XCIsIHsgaW46IFwic2hhZG93Qmx1ck91dGVyMVwiLCB0eXBlOiBcIm1hdHJpeFwiLCB2YWx1ZXM6IFwiMCAwIDAgMCAwICAgMCAwIDAgMCAwICAgMCAwIDAgMCAwICAwIDAgMCAwLjUgMFwiIH0pKSxcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lYXJHcmFkaWVudFwiLCB7IGlkOiBcIjY2Njg5MWQ5LTFjN2QtMzNlMC02OTk2LWFiZmE2YmM3ZTk1MFwiLCB4MTogXCI1MCVcIiwgeDI6IFwiNTAlXCIsIHkxOiBcIjAlXCIsIHkyOiBcIjEwMCVcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAlXCIsIHN0b3BDb2xvcjogXCIjRkZGRkZGXCIsIHN0b3BPcGFjaXR5OiBcIjAuNVwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjEwMCVcIiwgc3RvcENvbG9yOiBcIiMwMDAwMDBcIiwgc3RvcE9wYWNpdHk6IFwiMC41XCIgfSkpLFxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7IGN4OiBcIjk4XCIsIGN5OiBcIjk4XCIsIGlkOiBcIjJlY2I4MzBmLTg2MzctOGFhZi05MzMzLTY1ODM2MWNiOWY0OVwiLCByOiBcIjg2XCIgfSksXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZmlsdGVyXCIsIHsgZmlsdGVyVW5pdHM6IFwib2JqZWN0Qm91bmRpbmdCb3hcIiwgaGVpZ2h0OiBcIjEwOC4xJVwiLCBpZDogXCIzODgxMmNjOS02OTYxLTEwZTctNmM1Ny1kZjAwNWIyODk0NmJcIiwgd2lkdGg6IFwiMTA4LjElXCIsIHg6IFwiLTQuMSVcIiwgeTogXCItMy41JVwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImZlTW9ycGhvbG9neVwiLCB7IGluOiBcIlNvdXJjZUFscGhhXCIsIG9wZXJhdG9yOiBcImRpbGF0ZVwiLCByYWRpdXM6IFwiMC41XCIsIHJlc3VsdDogXCJzaGFkb3dTcHJlYWRPdXRlcjFcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZmVPZmZzZXRcIiwgeyBkeDogXCIwXCIsIGR5OiBcIjFcIiwgaW46IFwic2hhZG93U3ByZWFkT3V0ZXIxXCIsIHJlc3VsdDogXCJzaGFkb3dPZmZzZXRPdXRlcjFcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZmVHYXVzc2lhbkJsdXJcIiwgeyBpbjogXCJzaGFkb3dPZmZzZXRPdXRlcjFcIiwgcmVzdWx0OiBcInNoYWRvd0JsdXJPdXRlcjFcIiwgc3RkRGV2aWF0aW9uOiBcIjJcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZmVDb21wb3NpdGVcIiwgeyBpbjogXCJzaGFkb3dCbHVyT3V0ZXIxXCIsIGluMjogXCJTb3VyY2VBbHBoYVwiLCBvcGVyYXRvcjogXCJvdXRcIiwgcmVzdWx0OiBcInNoYWRvd0JsdXJPdXRlcjFcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZmVDb2xvck1hdHJpeFwiLCB7IGluOiBcInNoYWRvd0JsdXJPdXRlcjFcIiwgdHlwZTogXCJtYXRyaXhcIiwgdmFsdWVzOiBcIjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC41IDBcIiB9KSkpLFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IGZpbGw6IFwibm9uZVwiLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIGlkOiBcIlBhZ2UtMVwiLCBzdHJva2U6IFwibm9uZVwiLCBzdHJva2VXaWR0aDogXCIxXCIgfSxcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgaWQ6IFwiczEzXCIsIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoNC4wMDAwMDAsIDQuMDAwMDAwKVwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImdcIiwgeyBpZDogXCJjb250YWluZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IGlkOiBcIk92YWwtMlwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwidXNlXCIsIHsgZmlsbDogXCJibGFja1wiLCBmaWxsT3BhY2l0eTogXCIxXCIsIGZpbHRlcjogXCJ1cmwoIzQ0MDBhZDBkLTRkMzYtMGJjMS0wNWIwLWJhNDZlNjEwZWM5NylcIiwgeGxpbmtIcmVmOiBcIiM5NjliMWY1Mi03NTliLWM4M2UtNjFlYy0zOTRjZTg4YWIzNDRcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIiwgeyBmaWxsOiBcInVybCgjZjcwNjY4NzktZjU3Yi1mN2FiLTBhNjItYjdlNzY2NTlmYzlhKVwiLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIHN0cm9rZTogXCIjOTc5Nzk3XCIsIHN0cm9rZVdpZHRoOiBcIjFcIiwgeGxpbmtIcmVmOiBcIiM5NjliMWY1Mi03NTliLWM4M2UtNjFlYy0zOTRjZTg4YWIzNDRcIiB9KSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgaWQ6IFwiT3ZhbC0yXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIiwgeyBmaWxsOiBcImJsYWNrXCIsIGZpbGxPcGFjaXR5OiBcIjFcIiwgZmlsdGVyOiBcInVybCgjMzg4MTJjYzktNjk2MS0xMGU3LTZjNTctZGYwMDViMjg5NDZiKVwiLCB4bGlua0hyZWY6IFwiIzJlY2I4MzBmLTg2MzctOGFhZi05MzMzLTY1ODM2MWNiOWY0OVwiIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInVzZVwiLCB7IGZpbGw6IFwiXCIsIGZpbGxSdWxlOiBcImV2ZW5vZGRcIiwgeGxpbmtIcmVmOiBcIiMyZWNiODMwZi04NjM3LThhYWYtOTMzMy02NTgzNjFjYjlmNDlcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIiwgeyBmaWxsOiBcInVybCgjNjY2ODkxZDktMWM3ZC0zM2UwLTY5OTYtYWJmYTZiYzdlOTUwKVwiLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIHN0cm9rZTogXCIjNEE0QTRBXCIsIHN0cm9rZVdpZHRoOiBcIjFcIiwgeGxpbmtIcmVmOiBcIiMyZWNiODMwZi04NjM3LThhYWYtOTMzMy02NTgzNjFjYjlmNDlcIiB9KSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgaWQ6IFwia25vYlwiLCB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKDI3LjQzMTM3MywgMjcuNDMxMzczKVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHsgY3g6IFwiNzFcIiwgY3k6IFwiNzFcIiwgZmlsbDogXCIjMzIyRTJFXCIsIHI6IFwiNzFcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNzAuMDY4NjI3NSw0LjE3MDYzMDYxIEw4Ni41Njg2Mjc1LDY1LjI2ODk5MjkgQzgxLjM2NDI1MDEsNjYuODExMjIxIDc1Ljg2NDI1MDEsNjcuNTczNTY4NiA3MC4wNjg2Mjc1LDY3LjU1NjAzNTYgQzY0LjI3MzAwNDgsNjcuNTM4NTAyNyA1OC43NzMwMDQ4LDY2Ljc3NjE1NTEgNTMuNTY4NjI3NSw2NS4yNjg5OTI5IEw3MC4wNjg2Mjc1LDQuMTcwNjMwNjEgWlwiLCBmaWxsOiBwb2ludGVyQ29sb3IsIGlkOiBcImtub2ItcG9pbnRlclwiLCB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKDcwLjA2ODYyNywgMzUuODYzNDgxKSBzY2FsZSgxLCAtMSkgdHJhbnNsYXRlKC03MC4wNjg2MjcsIC0zNS44NjM0ODEpIFwiIH0pKSkpKSkpO1xufTtcblxudmFyIHN0eWxlcyQ5ID0ge1wic2xpZGVyTWVjaGFuaXNtV3JhcHBlclwiOlwiU2xpZGVyTWVjaGFuaXNtLW1vZHVsZV9zbGlkZXJNZWNoYW5pc21XcmFwcGVyX192azE3UFwiLFwiZGlzYWJsZWRcIjpcIlNsaWRlck1lY2hhbmlzbS1tb2R1bGVfZGlzYWJsZWRfXzVHWDNNXCIsXCJzbGlkZXJXcmFwcGVyXCI6XCJTbGlkZXJNZWNoYW5pc20tbW9kdWxlX3NsaWRlcldyYXBwZXJfX2l6VlNxXCIsXCJzbGlkZXJcIjpcIlNsaWRlck1lY2hhbmlzbS1tb2R1bGVfc2xpZGVyX19GZlJFRlwiLFwiZW5sYXJnZWRcIjpcIlNsaWRlck1lY2hhbmlzbS1tb2R1bGVfZW5sYXJnZWRfXzVwSkN6XCJ9O1xuXG52YXIgc3R5bGVzJDggPSB7XCJzbGlkZXJXcmFwcGVyXCI6XCJTbGlkZXItbW9kdWxlX3NsaWRlcldyYXBwZXJfX05welB1XCIsXCJ2ZXJ0aWNhbFwiOlwiU2xpZGVyLW1vZHVsZV92ZXJ0aWNhbF9fOFhUMnRcIixcInNsaWRlckxhYmVsXCI6XCJTbGlkZXItbW9kdWxlX3NsaWRlckxhYmVsX19hTER2eFwiLFwic2xpZGVyXCI6XCJTbGlkZXItbW9kdWxlX3NsaWRlcl9fWUdVNXJcIixcInNsaWRlclRyYWNrXCI6XCJTbGlkZXItbW9kdWxlX3NsaWRlclRyYWNrX19Dc3hvUFwiLFwic2xpZGVyVGh1bWJcIjpcIlNsaWRlci1tb2R1bGVfc2xpZGVyVGh1bWJfX2xERURFXCJ9O1xuXG5jb25zdCBSZWFjdFNsaWRlciA9IF9SZWFjdFNsaWRlcjtcbmNvbnN0IFNsaWRlciA9ICh7IGNsYXNzTmFtZSwgY2xhc3NOYW1lczogY2xhc3NOYW1lc1Byb3AsIG9yaWVudGF0aW9uLCB3cmFwcGVyUmVmLCBkaXNhYmxlZCwgaW52ZXJ0LCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgaXNWZXJ0aWNhbCA9IG9yaWVudGF0aW9uID09PSAndmVydGljYWwnO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkOC5zbGlkZXJXcmFwcGVyLCBjbGFzc05hbWVzUHJvcD8ud3JhcHBlciwgY2xhc3NOYW1lLCB7XG4gICAgICAgICAgICBbc3R5bGVzJDgudmVydGljYWxdOiBpc1ZlcnRpY2FsLFxuICAgICAgICAgICAgdmVydGljYWw6IGlzVmVydGljYWwsXG4gICAgICAgIH0pLCByZWY6IHdyYXBwZXJSZWYgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdFNsaWRlciwgeyAuLi5wcm9wcywgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyQ4LnNsaWRlciwgY2xhc3NOYW1lc1Byb3A/LnNsaWRlciwge1xuICAgICAgICAgICAgICAgIFtzdHlsZXMkOC52ZXJ0aWNhbF06IGlzVmVydGljYWwsXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IGlzVmVydGljYWwsXG4gICAgICAgICAgICB9KSwgZGlzYWJsZWQ6IGRpc2FibGVkLCBpbnZlcnQ6IGludmVydCA9PT0gdW5kZWZpbmVkID8gaXNWZXJ0aWNhbCA6IGludmVydCwgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLCBzbmFwRHJhZ0Rpc2FibGVkOiB0cnVlLCB0aHVtYkNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkOC5zbGlkZXJUaHVtYiwgY2xhc3NOYW1lc1Byb3A/LnNsaWRlclRodW1iLCB7XG4gICAgICAgICAgICAgICAgW3N0eWxlcyQ4LnZlcnRpY2FsXTogaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgIH0pLCB0cmFja0NsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkOC5zbGlkZXJUcmFjaywgY2xhc3NOYW1lc1Byb3A/LnNsaWRlclRyYWNrLCB7XG4gICAgICAgICAgICAgICAgW3N0eWxlcyQ4LnZlcnRpY2FsXTogaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgIH0pIH0pKSk7XG59O1xuXG5jb25zdCBTbGlkZXJNZWNoYW5pc20gPSAoeyBpbml0aWFsVmFsdWUgPSAwLjUsIHZhbHVlLCBtaW5WYWx1ZSA9IDAsIG1heFZhbHVlID0gMSwgZGlzYWJsZWQsIGVubGFyZ2VkLCBjbGFzc05hbWUsIHNsaWRlclByb3BzLCBvbkNoYW5nZSwgb25Qb2ludGVyRG93biwgb25Nb3VzZVVwLCBzbGlkZXJSZWYsIGNoaWxkcmVuLCB9KSA9PiB7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyQ5LnNsaWRlck1lY2hhbmlzbVdyYXBwZXIsIGNsYXNzTmFtZSwge1xuICAgICAgICAgICAgW3N0eWxlcyQ5LmRpc2FibGVkXTogZGlzYWJsZWQsXG4gICAgICAgIH0pLCBvblBvaW50ZXJEb3duOiBvblBvaW50ZXJEb3duLCBvblBvaW50ZXJVcDogb25Nb3VzZVVwIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgIWRpc2FibGVkICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyQ5LnNsaWRlcldyYXBwZXIsIHtcbiAgICAgICAgICAgICAgICBbc3R5bGVzJDkuZW5sYXJnZWRdOiBlbmxhcmdlZCxcbiAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNsaWRlciwgeyBjbGFzc05hbWU6IHN0eWxlcyQ5LnNsaWRlciwgZGlzYWJsZWQ6IGZhbHNlLCBpbml0aWFsVmFsdWU6IGluaXRpYWxWYWx1ZSwgaW52ZXJ0OiB0cnVlLCBtYXg6IG1heFZhbHVlLCBtaW46IG1pblZhbHVlLCBvbkFmdGVyQ2hhbmdlOiBvbk1vdXNlVXAsIG9uQ2hhbmdlOiBvbkNoYW5nZSwgb3JpZW50YXRpb246IFwidmVydGljYWxcIiwgc25hcERyYWdEaXNhYmxlZDogdHJ1ZSwgc3RlcDogKG1heFZhbHVlIC0gbWluVmFsdWUpIC8gMTAwLCB2YWx1ZTogdmFsdWUsIHdyYXBwZXJSZWY6IHNsaWRlclJlZiwgLi4uc2xpZGVyUHJvcHMgfSkpKSksXG4gICAgICAgIGNoaWxkcmVuKSk7XG59O1xuXG5jb25zdCB1c2VTbGlkZXJNZWNoYW5pc21TdGF0ZSA9ICh7IGluaXRpYWxWYWx1ZSA9IDAuNSwgbWluVmFsdWUgPSAwLCBtYXhWYWx1ZSA9IDEsIG9uQ2hhbmdlLCB2YWx1ZTogdmFsdWVQcm9wLCB2YWx1ZVRvUmVuZGVyLCBvblBvaW50ZXJEb3duLCB9KSA9PiB7XG4gICAgY29uc3QgW3ZhbHVlSW50ZXJuYWwsIHNldFZhbHVlSW50ZXJuYWxdID0gdXNlU3RhdGUoaW5pdGlhbFZhbHVlKTtcbiAgICBjb25zdCBbZW5sYXJnZWQsIHNldEVubGFyZ2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbaGFzU2V0Rmlyc3RWYWx1ZSwgc2V0SGFzU2V0Rmlyc3RWYWx1ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgaXNQcmVzc2luZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgc2xpZGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGxldCB2YWx1ZSA9IGlzVHJ1dGh5T3JaZXJvKHZhbHVlUHJvcCkgPyB2YWx1ZVByb3AgOiB2YWx1ZUludGVybmFsO1xuICAgIGxldCB2YWx1ZUZvcm1hdHRlZCA9IGlzVHJ1dGh5T3JaZXJvKHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogaW5pdGlhbFZhbHVlO1xuICAgIGNvbnN0IGhhbmRsZVBvaW50ZXJEb3duID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgb25Qb2ludGVyRG93bj8uKGUpO1xuICAgICAgICBpc1ByZXNzaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sIFtvblBvaW50ZXJEb3duXSk7XG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc1ByZXNzaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNldEVubGFyZ2VkKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBubyBjaGFuZ2UgaXMgbWFkZSB1bnRpbCB0aGUgc2xpZGVyIGhhcyBpbmNyZWFzZWQgaW4gc2l6ZVxuICAgICAgICBpZiAoZW5sYXJnZWQpIHtcbiAgICAgICAgICAgIGlmICghaGFzU2V0Rmlyc3RWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIERvIHRoaXMgdG8gYXZvaWQganVtcGluZyB0aGUgdmFsdWUgd2hlbiB0aGUgc2xpZGVyIGluY3JlYXNlcyBpbiBzaXplXG4gICAgICAgICAgICAgICAgc2V0SGFzU2V0Rmlyc3RWYWx1ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFZhbHVlSW50ZXJuYWwobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPy4oeyB2YWx1ZTogbmV3VmFsdWUsIG1pbjogbWluVmFsdWUsIG1heDogbWF4VmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbZW5sYXJnZWQsIGhhc1NldEZpcnN0VmFsdWUsIG9uQ2hhbmdlLCBtaW5WYWx1ZSwgbWF4VmFsdWVdKTtcbiAgICBjb25zdCBoYW5kbGVNb3VzZVVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpc1ByZXNzaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgc2V0RW5sYXJnZWQoZmFsc2UpO1xuICAgICAgICBzZXRIYXNTZXRGaXJzdFZhbHVlKGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgcmVuZGVyZWRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHZhbHVlVG9SZW5kZXIgIT09IHVuZGVmaW5lZCA/IHZhbHVlVG9SZW5kZXIgOiB2YWx1ZUZvcm1hdHRlZCksIFt2YWx1ZUZvcm1hdHRlZCwgdmFsdWVUb1JlbmRlcl0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlbmxhcmdlZCkge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTtcbiAgICAgICAgfTtcbiAgICB9LCBbZW5sYXJnZWQsIGhhbmRsZU1vdXNlVXBdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZUludGVybmFsLFxuICAgICAgICAgICAgICAgIHNldFZhbHVlSW50ZXJuYWwsXG4gICAgICAgICAgICAgICAgZW5sYXJnZWQsXG4gICAgICAgICAgICAgICAgc2V0RW5sYXJnZWQsXG4gICAgICAgICAgICAgICAgaGFzU2V0Rmlyc3RWYWx1ZSxcbiAgICAgICAgICAgICAgICBzZXRIYXNTZXRGaXJzdFZhbHVlLFxuICAgICAgICAgICAgICAgIHNsaWRlclJlZixcbiAgICAgICAgICAgICAgICBoYW5kbGVDaGFuZ2UsXG4gICAgICAgICAgICAgICAgaGFuZGxlTW91c2VVcCxcbiAgICAgICAgICAgICAgICByZW5kZXJlZFZhbHVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsaWRlck1lY2hhbmlzbVByb3BzOiB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlLFxuICAgICAgICAgICAgICAgIG1pblZhbHVlLFxuICAgICAgICAgICAgICAgIG1heFZhbHVlLFxuICAgICAgICAgICAgICAgIG9uUG9pbnRlckRvd246IGhhbmRsZVBvaW50ZXJEb3duLFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsXG4gICAgICAgICAgICAgICAgb25Nb3VzZVVwOiBoYW5kbGVNb3VzZVVwLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZW5kZXJlZFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlVG9SZW5kZXIsXG4gICAgICAgICAgICAgICAgZW5sYXJnZWQsXG4gICAgICAgICAgICAgICAgc2xpZGVyUmVmLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZUludGVybmFsLFxuICAgICAgICBzZXRWYWx1ZUludGVybmFsLFxuICAgICAgICBlbmxhcmdlZCxcbiAgICAgICAgc2V0RW5sYXJnZWQsXG4gICAgICAgIGhhc1NldEZpcnN0VmFsdWUsXG4gICAgICAgIHNldEhhc1NldEZpcnN0VmFsdWUsXG4gICAgICAgIHNsaWRlclJlZixcbiAgICAgICAgaGFuZGxlQ2hhbmdlLFxuICAgICAgICBoYW5kbGVQb2ludGVyRG93bixcbiAgICAgICAgaGFuZGxlTW91c2VVcCxcbiAgICAgICAgcmVuZGVyZWRWYWx1ZSxcbiAgICAgICAgaW5pdGlhbFZhbHVlLFxuICAgICAgICBtaW5WYWx1ZSxcbiAgICAgICAgbWF4VmFsdWUsXG4gICAgICAgIHZhbHVlVG9SZW5kZXIsXG4gICAgXSk7XG59O1xuXG5jb25zdCBMT1dFU1RfQU5HTEUgPSAtMTY1O1xuY29uc3QgR1JFQVRFU1RfQU5HTEUgPSAxNjU7XG4vKiogTk9URTogQ29uc2lkZXIgc3dpdGNoaW5nIHRvIGh0dHBzOi8vcmVhY3Qta25vYi1oZWFkbGVzcy52ZXJjZWwuYXBwLyAqL1xuY29uc3QgS25vYlJvdGFyeSA9ICh7IGluaXRpYWxWYWx1ZSA9IDAuNSwgbWluVmFsdWUgPSAwLCBtYXhWYWx1ZSA9IDEsIG9uQ2hhbmdlLCBkaXNhYmxlZCwgY2xhc3NOYW1lLCB2YWx1ZTogdmFsdWVQcm9wLCB2YWx1ZVRvUmVuZGVyLCBzbGlkZXJQcm9wcywgcG9pbnRlckNvbG9yLCByZW1vdmVEZWZhdWx0UG9pbnRlckNvbG9yLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgeyB2YWx1ZXMsIHNsaWRlck1lY2hhbmlzbVByb3BzIH0gPSB1c2VTbGlkZXJNZWNoYW5pc21TdGF0ZSh7XG4gICAgICAgIGluaXRpYWxWYWx1ZSxcbiAgICAgICAgbWluVmFsdWUsXG4gICAgICAgIG1heFZhbHVlLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlUHJvcCxcbiAgICAgICAgdmFsdWVUb1JlbmRlcixcbiAgICB9KTtcbiAgICBjb25zdCByb3RhdGlvbiA9IHVzZU1lbW8oKCkgPT4gTE9XRVNUX0FOR0xFICtcbiAgICAgICAgKHZhbHVlcy5yZW5kZXJlZFZhbHVlIC8gKG1heFZhbHVlIC0gbWluVmFsdWUpKSAqXG4gICAgICAgICAgICAoR1JFQVRFU1RfQU5HTEUgLSBMT1dFU1RfQU5HTEUpLCBbbWluVmFsdWUsIG1heFZhbHVlLCB2YWx1ZXMucmVuZGVyZWRWYWx1ZV0pO1xuICAgIGNvbnN0IHN0eWxlID0gdXNlTWVtbygoKSA9PiAoeyAnLS1yb3RhdGlvbic6IGAke3JvdGF0aW9ufWRlZ2AgfSksIFtyb3RhdGlvbl0pO1xuICAgIGNvbnN0IHNsaWRlck1lY2hhbmlzbVByb3BzQ29tYmluZWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNsaWRlck1lY2hhbmlzbVByb3BzLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJGEua25vYldyYXBwZXIsIGNsYXNzTmFtZSksXG4gICAgICAgICAgICBzbGlkZXJQcm9wcyxcbiAgICAgICAgfTtcbiAgICB9LCBbc2xpZGVyTWVjaGFuaXNtUHJvcHMsIGNsYXNzTmFtZSwgZGlzYWJsZWQsIHNsaWRlclByb3BzXSk7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNsaWRlck1lY2hhbmlzbSwgeyAuLi5zbGlkZXJNZWNoYW5pc21Qcm9wc0NvbWJpbmVkIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHN0eWxlcyRhLmtub2JWYWx1ZVdyYXBwZXIgfSxcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVGV4dCwgeyBib2xkOiB0cnVlLCBjbGFzc05hbWU6IHN0eWxlcyRhLmtub2JWYWx1ZSwgZm9udFNpemU6IFwieHNcIiB9LCB2YWx1ZXMucmVuZGVyZWRWYWx1ZSkpLFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyRhLmtub2JTa2luV3JhcHBlciwge1xuICAgICAgICAgICAgICAgIFtzdHlsZXMkYS5pc0Rpc2FibGVkXTogZGlzYWJsZWQsXG4gICAgICAgICAgICB9KSwgc3R5bGU6IHN0eWxlIH0sXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgaGVpZ2h0OiAyMDgsIHZpZXdCb3g6IFwiMCAwIDIwOCAyMDhcIiwgd2lkdGg6IDIwOCwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgeG1sbnNYbGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIC4uLnByb3BzIH0sXG4gICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChLbm9iU3ZnQ2hpbGQxLCB7IHBvaW50ZXJDb2xvcjogKHJlbW92ZURlZmF1bHRQb2ludGVyQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBvaW50ZXJDb2xvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFRoZW1lVmFyaWFibGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29sb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2dyYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkZTogJzYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB8fCB1bmRlZmluZWQgfSkpKSkpO1xufTtcblxudmFyIHN0eWxlcyQ3ID0ge1wia25vYldyYXBwZXJcIjpcIktub2JSb3RhcnlXaXRoVGlja3MtbW9kdWxlX2tub2JXcmFwcGVyX19CUTcyWVwiLFwia25vYlNraW5XcmFwcGVyXCI6XCJLbm9iUm90YXJ5V2l0aFRpY2tzLW1vZHVsZV9rbm9iU2tpbldyYXBwZXJfXzA0aGh6XCIsXCJpc0Rpc2FibGVkXCI6XCJLbm9iUm90YXJ5V2l0aFRpY2tzLW1vZHVsZV9pc0Rpc2FibGVkX19XLUx4QlwiLFwia25vYlZhbHVlV3JhcHBlclwiOlwiS25vYlJvdGFyeVdpdGhUaWNrcy1tb2R1bGVfa25vYlZhbHVlV3JhcHBlcl9fbkJ0UW5cIixcImtub2JWYWx1ZVwiOlwiS25vYlJvdGFyeVdpdGhUaWNrcy1tb2R1bGVfa25vYlZhbHVlX19qZ25XR1wifTtcblxudmFyIHN0eWxlcyQ2ID0ge1wia25vYlwiOlwiS25vYldpdGhQcm9ncmVzcy1tb2R1bGVfa25vYl9fbWRlWE5cIixcImtub2JPdXRlclwiOlwiS25vYldpdGhQcm9ncmVzcy1tb2R1bGVfa25vYk91dGVyX19jSlJBZ1wiLFwia25vYklubmVyQmFja2dyb3VuZFwiOlwiS25vYldpdGhQcm9ncmVzcy1tb2R1bGVfa25vYklubmVyQmFja2dyb3VuZF9fdmkycm5cIixcImtub2JJbm5lclwiOlwiS25vYldpdGhQcm9ncmVzcy1tb2R1bGVfa25vYklubmVyX19kY3hmWVwiLFwiZ3JpcFwiOlwiS25vYldpdGhQcm9ncmVzcy1tb2R1bGVfZ3JpcF9fSHk1bVFcIixcInRpY2tzXCI6XCJLbm9iV2l0aFByb2dyZXNzLW1vZHVsZV90aWNrc19fOVhHSTlcIixcInRpY2tcIjpcIktub2JXaXRoUHJvZ3Jlc3MtbW9kdWxlX3RpY2tfXy0tOHg2XCIsXCJhY3RpdmVcIjpcIktub2JXaXRoUHJvZ3Jlc3MtbW9kdWxlX2FjdGl2ZV9fZlF0ajNcIn07XG5cbmNvbnN0IEFDVElWRV9USUNLX09QQUNJVFlfTUlOSU1VTSA9IDAuNjY7XG5jb25zdCBjb252ZXJ0UmFuZ2UgPSAob2xkTWluLCBvbGRNYXgsIG5ld01pbiwgbmV3TWF4LCBvbGRWYWx1ZSkgPT4ge1xuICAgIHJldHVybiAoKG9sZFZhbHVlIC0gb2xkTWluKSAqIChuZXdNYXggLSBuZXdNaW4pKSAvIChvbGRNYXggLSBvbGRNaW4pICsgbmV3TWluO1xufTtcbmNvbnN0IEtub2JXaXRoUHJvZ3Jlc3MgPSAoeyBtaW4gPSAwLCBtYXggPSAxLCBudW1UaWNrcyA9IDAsIGRlZ3JlZXMgPSAyNjAsIHZhbHVlID0gbWluLCBkaXNhYmxlR3JpcCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgXG4gICAgLy8gaGVpZ2h0OiBrbm9iSGVpZ2h0LFxuICAgIHdpZHRoOiBrbm9iV2lkdGgsIHJlZjoga25vYldyYXBwZXJSZWYsIH0gPSB1c2VSZXNpemVEZXRlY3Rvcih7XG4gICAgICAgIHJlZnJlc2hNb2RlOiAndGhyb3R0bGUnLFxuICAgICAgICByZWZyZXNoUmF0ZTogMjUsXG4gICAgfSk7XG4gICAgY29uc3QgZnVsbEFuZ2xlID0gZGVncmVlcztcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gKDM2MCAtIGRlZ3JlZXMpIC8gMjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkZWdyZWVzO1xuICAgIGNvbnN0IGN1cnJlbnREZWcgPSBNYXRoLmZsb29yKGNvbnZlcnRSYW5nZShtaW4sIG1heCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHZhbHVlKSk7XG4gICAgY29uc3QgcmVuZGVyVGlja3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGxldCB0aWNrcyA9IFtdO1xuICAgICAgICBjb25zdCBpbmNyID0gZnVsbEFuZ2xlIC8gbnVtVGlja3M7XG4gICAgICAgIGNvbnN0IHNpemVDYWxjdWxhdGVkID0gKGtub2JXaWR0aCB8fCAwKSAvIDI7XG4gICAgICAgIGZvciAobGV0IGRlZyA9IHN0YXJ0QW5nbGU7IGRlZyA8PSBlbmRBbmdsZTsgZGVnICs9IGluY3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpY2sgPSB7XG4gICAgICAgICAgICAgICAgZGVnLFxuICAgICAgICAgICAgICAgIHRpY2tTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHNpemVDYWxjdWxhdGVkLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzaXplQ2FsY3VsYXRlZCAtIDEuNSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBzaXplQ2FsY3VsYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlKCR7ZGVnfWRlZylgLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICd0b3AnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGlja3MucHVzaCh0aWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfSwgW2VuZEFuZ2xlLCBmdWxsQW5nbGUsIHN0YXJ0QW5nbGUsIG51bVRpY2tzLCBrbm9iV2lkdGhdKTtcbiAgICBjb25zdCBrbm9iSW5uZXJTdHlsZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlKCR7Y3VycmVudERlZ31kZWcpYCxcbiAgICB9KSwgW2N1cnJlbnREZWddKTtcbiAgICBjb25zdCBwZXJjZW50YWdlID0gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgIGNvbnN0IGtub2JJbm5lckJhY2tncm91bmRTdHlsZSA9IHVzZU1lbW8oKCkgPT4gKHsgb3BhY2l0eTogMSAtIHBlcmNlbnRhZ2UgKiAwLjM1IH0pLCBbcGVyY2VudGFnZV0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogc3R5bGVzJDYua25vYiwgaWQ6IFwia25vYlwiLCByZWY6IGtub2JXcmFwcGVyUmVmIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHN0eWxlcyQ2LnRpY2tzIH0sIG51bVRpY2tzXG4gICAgICAgICAgICA/IHJlbmRlclRpY2tzKCkubWFwKCh0aWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlja0lzQWN0aXZlID0gdGljay5kZWcgPCBjdXJyZW50RGVnIHx8IHZhbHVlID09PSBtYXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyQ2LnRpY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZXMkNi5hY3RpdmVdOiB0aWNrSXNBY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIH0pLCBrZXk6IHRpY2suZGVnLnRvU3RyaW5nKCksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50aWNrLnRpY2tTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRpY2tJc0FjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gQUNUSVZFX1RJQ0tfT1BBQ0lUWV9NSU5JTVVNICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDEgLSBBQ1RJVkVfVElDS19PUEFDSVRZX01JTklNVU0pICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodGljay5kZWcgLSBzdGFydEFuZ2xlKSAvIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICAgICAgICAgICAgICAgICAgfSB9KSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBudWxsKSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogc3R5bGVzJDYua25vYk91dGVyIH0sXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBzdHlsZXMkNi5rbm9iSW5uZXJCYWNrZ3JvdW5kLCBzdHlsZToga25vYklubmVyQmFja2dyb3VuZFN0eWxlIH0pLFxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogc3R5bGVzJDYua25vYklubmVyLCBzdHlsZToga25vYklubmVyU3R5bGUgfSwgIWRpc2FibGVHcmlwICYmIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHN0eWxlcyQ2LmdyaXAgfSkpKSkpO1xufTtcblxuY29uc3QgS05PQl9WQUxVRV9PUEFDSVRZX01JTklNVU0gPSAwLjg1O1xuLyoqIE5PVEU6IENvbnNpZGVyIHN3aXRjaGluZyB0byBodHRwczovL3JlYWN0LWtub2ItaGVhZGxlc3MudmVyY2VsLmFwcC8gKi9cbmNvbnN0IEtub2JSb3RhcnlXaXRoVGlja3MgPSAoeyBtaW5WYWx1ZSA9IDAsIG1heFZhbHVlID0gMSwgaW5pdGlhbFZhbHVlID0gbWluVmFsdWUsIG9uQ2hhbmdlLCBkaXNhYmxlZCwgY2xhc3NOYW1lLCB2YWx1ZTogdmFsdWVQcm9wLCB2YWx1ZVRvUmVuZGVyLCBzbGlkZXJQcm9wcywga25vYlByb3BzLCBvblBvaW50ZXJEb3duLCB9KSA9PiB7XG4gICAgY29uc3QgeyB2YWx1ZXMsIHNsaWRlck1lY2hhbmlzbVByb3BzIH0gPSB1c2VTbGlkZXJNZWNoYW5pc21TdGF0ZSh7XG4gICAgICAgIGluaXRpYWxWYWx1ZSxcbiAgICAgICAgbWluVmFsdWUsXG4gICAgICAgIG1heFZhbHVlLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlUHJvcCxcbiAgICAgICAgdmFsdWVUb1JlbmRlcixcbiAgICAgICAgb25Qb2ludGVyRG93bixcbiAgICB9KTtcbiAgICBjb25zdCBwcm9ncmVzcyA9ICgodmFsdWVzLnZhbHVlIHx8IG1pblZhbHVlKSAtIG1pblZhbHVlKSAvIChtYXhWYWx1ZSAtIG1pblZhbHVlKTtcbiAgICBjb25zdCBzdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gS05PQl9WQUxVRV9PUEFDSVRZX01JTklNVU0gKyAoMSAtIEtOT0JfVkFMVUVfT1BBQ0lUWV9NSU5JTVVNKSAqIHByb2dyZXNzO1xuICAgICAgICBjb25zdCBib3JkZXJPcGFjaXR5ID0gMC4yICsgcHJvZ3Jlc3MgKiAwLjA1O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICAgIGJvcmRlcjogYDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsICR7Ym9yZGVyT3BhY2l0eX0pYCxcbiAgICAgICAgfTtcbiAgICB9LCBbcHJvZ3Jlc3NdKTtcbiAgICBjb25zdCBzbGlkZXJNZWNoYW5pc21Qcm9wc0NvbWJpbmVkID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbGlkZXJNZWNoYW5pc21Qcm9wcyxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyQ3Lmtub2JXcmFwcGVyLCBjbGFzc05hbWUpLFxuICAgICAgICAgICAgc2xpZGVyUHJvcHMsXG4gICAgICAgIH07XG4gICAgfSwgW3NsaWRlck1lY2hhbmlzbVByb3BzLCBjbGFzc05hbWUsIGRpc2FibGVkLCBzbGlkZXJQcm9wc10pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTbGlkZXJNZWNoYW5pc20sIHsgLi4uc2xpZGVyTWVjaGFuaXNtUHJvcHNDb21iaW5lZCB9LFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBzdHlsZXMkNy5rbm9iVmFsdWVXcmFwcGVyIH0sXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRleHQsIHsgYm9sZDogdHJ1ZSwgY2xhc3NOYW1lOiBzdHlsZXMkNy5rbm9iVmFsdWUsIGZvbnRTaXplOiBcInhzXCIsIHN0eWxlOiBzdHlsZSB9LCB2YWx1ZXMucmVuZGVyZWRWYWx1ZSkpLFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyQ3Lmtub2JTa2luV3JhcHBlciwge1xuICAgICAgICAgICAgICAgIFtzdHlsZXMkNy5pc0Rpc2FibGVkXTogZGlzYWJsZWQsXG4gICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChLbm9iV2l0aFByb2dyZXNzLCB7IGRlZ3JlZXM6IDI2MCwgbWF4OiBtYXhWYWx1ZSwgbWluOiBtaW5WYWx1ZSwgbnVtVGlja3M6IDIwLCB2YWx1ZTogdmFsdWVzLnZhbHVlLCAuLi5rbm9iUHJvcHMgfSkpKSk7XG59O1xuXG52YXIgc3R5bGVzJDUgPSB7XCJsaW5lXCI6XCJMaW5lLW1vZHVsZV9saW5lX19QejM4OVwiLFwiaG9yaXpvbnRhbFwiOlwiTGluZS1tb2R1bGVfaG9yaXpvbnRhbF9fOTJTbVNcIixcInZlcnRpY2FsXCI6XCJMaW5lLW1vZHVsZV92ZXJ0aWNhbF9fbGRyWGVcIn07XG5cbmNvbnN0IExpbmUgPSAoeyBvcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJywgY2xhc3NOYW1lLCBiYWNrZ3JvdW5kQ29sb3IsIH0pID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHVzZU1lbW8oKCkgPT4gKGJhY2tncm91bmRDb2xvciA/IHsgYmFja2dyb3VuZDogYmFja2dyb3VuZENvbG9yIH0gOiB7fSksIFtiYWNrZ3JvdW5kQ29sb3JdKTtcbiAgICBjb25zdCBjbGFzc05hbWVDb21iaWJlZCA9IHVzZU1lbW8oKCkgPT4gY2xhc3NOYW1lcyhzdHlsZXMkNS5saW5lLCBjbGFzc05hbWUsIHtcbiAgICAgICAgW3N0eWxlcyQ1Lmhvcml6b250YWxdOiBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnLFxuICAgICAgICBbc3R5bGVzJDUudmVydGljYWxdOiBvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyxcbiAgICB9KSwgW2NsYXNzTmFtZSwgb3JpZW50YXRpb25dKTtcbiAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZUNvbWJpYmVkLCBzdHlsZTogc3R5bGUgfSk7XG59O1xuXG52YXIgc3R5bGVzJDQgPSB7XCJsb2FkaW5nU3Bpbm5lcldyYXBwZXJcIjpcIkxvYWRpbmdTcGlubmVyLW1vZHVsZV9sb2FkaW5nU3Bpbm5lcldyYXBwZXJfX2VibHNYXCIsXCJmYWRlaW5cIjpcIkxvYWRpbmdTcGlubmVyLW1vZHVsZV9mYWRlaW5fX0E5S3RxXCIsXCJpc0Fic29sdXRlXCI6XCJMb2FkaW5nU3Bpbm5lci1tb2R1bGVfaXNBYnNvbHV0ZV9fdDNpUmJcIixcInNwYW5QYXJlbnRcIjpcIkxvYWRpbmdTcGlubmVyLW1vZHVsZV9zcGFuUGFyZW50X19OSWdJbVwiLFwibG9hZGluZ1NwaW5uZXJcIjpcIkxvYWRpbmdTcGlubmVyLW1vZHVsZV9sb2FkaW5nU3Bpbm5lcl9fSmZ3enRcIn07XG5cbmNvbnN0IExvYWRpbmdTcGlubmVyID0gKHsgc2l6ZSA9ICc2cHgnLCBjbGFzc05hbWUsIGNsYXNzTmFtZVNwaW5uZXIsIHNwYW5QYXJlbnQgPSBmYWxzZSwgaXNBYnNvbHV0ZSA9IGZhbHNlLCBoZWlnaHQgPSAnNDhweCcsIHdpZHRoID0gJzQ4cHgnLCB9KSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgICctLXNwaW5uZXItc2l6ZSc6IHNpemUsXG4gICAgICAgICctLWhlaWdodCc6IGhlaWdodCxcbiAgICAgICAgJy0td2lkdGgnOiB3aWR0aCxcbiAgICB9O1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkNC5sb2FkaW5nU3Bpbm5lcldyYXBwZXIsIGNsYXNzTmFtZSwge1xuICAgICAgICAgICAgW3N0eWxlcyQ0LnNwYW5QYXJlbnRdOiBzcGFuUGFyZW50LFxuICAgICAgICAgICAgW3N0eWxlcyQ0LmlzQWJzb2x1dGVdOiBpc0Fic29sdXRlLFxuICAgICAgICB9KSB9LFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyQ0LmxvYWRpbmdTcGlubmVyLCBjbGFzc05hbWVTcGlubmVyKSwgc3R5bGU6IHN0eWxlIH0sXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwpLFxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsKSxcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCksXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwpKSkpO1xufTtcblxuY29uc3QgdXNlRGVsYXllZE1vdW50ID0gKHsgc2hvdWxkTW91bnQgPSBmYWxzZSwgZGVsYXlUaW1lID0gMjUwIH0pID0+IHtcbiAgICBjb25zdCBbc2hvdWxkUmVuZGVyLCBzZXRTaG91bGRSZW5kZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFt0cmFuc2l0aW9uQ29tcGxldGUsIHNldFRyYW5zaXRpb25Db21wbGV0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgdGltZW91dFJlZiA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRNb3VudCAmJiAhc2hvdWxkUmVuZGVyKSB7XG4gICAgICAgICAgICBzZXRTaG91bGRSZW5kZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hvdWxkTW91bnQgJiYgc2hvdWxkUmVuZGVyICYmICF0cmFuc2l0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0VHJhbnNpdGlvbkNvbXBsZXRlKHRydWUpLCAwKTtcbiAgICAgICAgfVxuICAgIH0sIFtzaG91bGRNb3VudCwgc2hvdWxkUmVuZGVyLCB0cmFuc2l0aW9uQ29tcGxldGVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZE1vdW50KSB7XG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uQ29tcGxldGUoZmFsc2UpO1xuICAgICAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiBzZXRTaG91bGRSZW5kZXIoZmFsc2UpLCBkZWxheVRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICB9LCBbc2hvdWxkTW91bnQsIGRlbGF5VGltZSwgc2hvdWxkUmVuZGVyLCB0aW1lb3V0UmVmXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2hvdWxkUmVuZGVyLFxuICAgICAgICB0cmFuc2l0aW9uQ29tcGxldGUsXG4gICAgfTtcbn07XG5cbmNvbnN0IENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgICBvcGVuTW9kYWxaSW5kZXhlczogW10sXG4gICAgb3Blbk1vZGFsOiAoXykgPT4gXyxcbiAgICBjbG9zZU1vZGFsOiAoXykgPT4gXyxcbn0pO1xuY29uc3QgeyBQcm92aWRlciwgQ29uc3VtZXIgfSA9IENvbnRleHQ7XG5cbnZhciBTeW1ib2wkMSA9IF9TeW1ib2wsXG4gICAgaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50c18xLFxuICAgIGlzQXJyYXkkMiA9IGlzQXJyYXlfMTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCQxID8gU3ltYm9sJDEuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUkMSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSQyKHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxudmFyIF9pc0ZsYXR0ZW5hYmxlID0gaXNGbGF0dGVuYWJsZSQxO1xuXG52YXIgYXJyYXlQdXNoJDEgPSBfYXJyYXlQdXNoLFxuICAgIGlzRmxhdHRlbmFibGUgPSBfaXNGbGF0dGVuYWJsZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbiQyKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbiQyKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gkMShyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZUZsYXR0ZW4gPSBiYXNlRmxhdHRlbiQyO1xuXG52YXIgaXNBcnJheUxpa2UkMyA9IGlzQXJyYXlMaWtlXzE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2gkMShlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlJDMoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG52YXIgX2NyZWF0ZUJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2gkMTtcblxudmFyIGJhc2VGb3JPd24gPSBfYmFzZUZvck93bixcbiAgICBjcmVhdGVCYXNlRWFjaCA9IF9jcmVhdGVCYXNlRWFjaDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoJDEgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxudmFyIF9iYXNlRWFjaCA9IGJhc2VFYWNoJDE7XG5cbnZhciBiYXNlRWFjaCA9IF9iYXNlRWFjaCxcbiAgICBpc0FycmF5TGlrZSQyID0gaXNBcnJheUxpa2VfMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcCQxKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UkMihjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZU1hcCA9IGJhc2VNYXAkMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cblxuZnVuY3Rpb24gYmFzZVNvcnRCeSQxKGFycmF5LCBjb21wYXJlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfYmFzZVNvcnRCeSA9IGJhc2VTb3J0QnkkMTtcblxudmFyIGlzU3ltYm9sID0gaXNTeW1ib2xfMTtcblxuLyoqXG4gKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyQxKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBfY29tcGFyZUFzY2VuZGluZyA9IGNvbXBhcmVBc2NlbmRpbmckMTtcblxudmFyIGNvbXBhcmVBc2NlbmRpbmcgPSBfY29tcGFyZUFzY2VuZGluZztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICpcbiAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlJDEob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG52YXIgX2NvbXBhcmVNdWx0aXBsZSA9IGNvbXBhcmVNdWx0aXBsZSQxO1xuXG52YXIgYXJyYXlNYXAkMSA9IF9hcnJheU1hcCxcbiAgICBiYXNlR2V0JDEgPSBfYmFzZUdldCxcbiAgICBiYXNlSXRlcmF0ZWUkMSA9IF9iYXNlSXRlcmF0ZWUsXG4gICAgYmFzZU1hcCA9IF9iYXNlTWFwLFxuICAgIGJhc2VTb3J0QnkgPSBfYmFzZVNvcnRCeSxcbiAgICBiYXNlVW5hcnkkMiA9IF9iYXNlVW5hcnksXG4gICAgY29tcGFyZU11bHRpcGxlID0gX2NvbXBhcmVNdWx0aXBsZSxcbiAgICBpZGVudGl0eSQyID0gaWRlbnRpdHlfMSxcbiAgICBpc0FycmF5JDEgPSBpc0FycmF5XzE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5JDEoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcbiAgICBpdGVyYXRlZXMgPSBhcnJheU1hcCQxKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIGlmIChpc0FycmF5JDEoaXRlcmF0ZWUpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlR2V0JDEodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5JDJdO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gLTE7XG4gIGl0ZXJhdGVlcyA9IGFycmF5TWFwJDEoaXRlcmF0ZWVzLCBiYXNlVW5hcnkkMihiYXNlSXRlcmF0ZWUkMSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcCQxKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgfSk7XG59XG5cbnZhciBfYmFzZU9yZGVyQnkgPSBiYXNlT3JkZXJCeSQxO1xuXG4vKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5cbmZ1bmN0aW9uIGFwcGx5JDEoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG52YXIgX2FwcGx5ID0gYXBwbHkkMTtcblxudmFyIGFwcGx5ID0gX2FwcGx5O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QkMihmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbnZhciBfb3ZlclJlc3QgPSBvdmVyUmVzdCQyO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuXG5mdW5jdGlvbiBjb25zdGFudCQxKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbnZhciBjb25zdGFudF8xID0gY29uc3RhbnQkMTtcblxudmFyIGNvbnN0YW50ID0gY29uc3RhbnRfMSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IF9kZWZpbmVQcm9wZXJ0eSxcbiAgICBpZGVudGl0eSQxID0gaWRlbnRpdHlfMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nJDEgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSQxIDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG52YXIgX2Jhc2VTZXRUb1N0cmluZyA9IGJhc2VTZXRUb1N0cmluZyQxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG5cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dCQxKGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgX3Nob3J0T3V0ID0gc2hvcnRPdXQkMTtcblxudmFyIGJhc2VTZXRUb1N0cmluZyA9IF9iYXNlU2V0VG9TdHJpbmcsXG4gICAgc2hvcnRPdXQgPSBfc2hvcnRPdXQ7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyQyID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxudmFyIF9zZXRUb1N0cmluZyA9IHNldFRvU3RyaW5nJDI7XG5cbnZhciBpZGVudGl0eSA9IGlkZW50aXR5XzEsXG4gICAgb3ZlclJlc3QkMSA9IF9vdmVyUmVzdCxcbiAgICBzZXRUb1N0cmluZyQxID0gX3NldFRvU3RyaW5nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdCQxKGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyQxKG92ZXJSZXN0JDEoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxudmFyIF9iYXNlUmVzdCA9IGJhc2VSZXN0JDE7XG5cbnZhciBlcSQxID0gZXFfMSxcbiAgICBpc0FycmF5TGlrZSQxID0gaXNBcnJheUxpa2VfMSxcbiAgICBpc0luZGV4ID0gX2lzSW5kZXgsXG4gICAgaXNPYmplY3QkMyA9IGlzT2JqZWN0XzE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsJDEodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdCQzKG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlJDEob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEkMShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2lzSXRlcmF0ZWVDYWxsID0gaXNJdGVyYXRlZUNhbGwkMTtcblxudmFyIGJhc2VGbGF0dGVuJDEgPSBfYmFzZUZsYXR0ZW4sXG4gICAgYmFzZU9yZGVyQnkgPSBfYmFzZU9yZGVyQnksXG4gICAgYmFzZVJlc3QgPSBfYmFzZVJlc3QsXG4gICAgaXNJdGVyYXRlZUNhbGwgPSBfaXNJdGVyYXRlZUNhbGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICogXTtcbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAqL1xudmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbXTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gIH1cbiAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuJDEoaXRlcmF0ZWVzLCAxKSwgW10pO1xufSk7XG5cbnZhciBzb3J0QnlfMSA9IHNvcnRCeTtcblxudmFyIHNvcnRCeSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNvcnRCeV8xKTtcblxuY29uc3QgREVGQVVMVF9aX0lOREVYID0gMTAwO1xuY29uc3QgTW9kYWxQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICBjb25zdCBbb3Blbk1vZGFsWkluZGV4ZXMsIHNldE9wZW5Nb2RhbFpJbmRleGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCBvcGVuTW9kYWwgPSB1c2VDYWxsYmFjaygoeyBpZCwgekluZGV4IH0pID0+IHNldE9wZW5Nb2RhbFpJbmRleGVzKChvbGRPcGVuTW9kYWxaSW5kZXhlcykgPT4ge1xuICAgICAgICBjb25zdCBuZXdPcGVuTW9kYWxaSW5kZXhlcyA9IHNvcnRCeSQxKFtcbiAgICAgICAgICAgIC4uLm9sZE9wZW5Nb2RhbFpJbmRleGVzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sICh7IHpJbmRleDogeiA9IERFRkFVTFRfWl9JTkRFWCB9KSA9PiAteik7XG4gICAgICAgIC8qKiBFbmFibGUgYW55IGNzcyBmaWx0ZXJzIHRvIHRoZSBhcHAgY29udGVudCBoZXJlIGlmIG5lZWRlZCAqL1xuICAgICAgICByZXR1cm4gbmV3T3Blbk1vZGFsWkluZGV4ZXM7XG4gICAgfSksIFtdKTtcbiAgICBjb25zdCBjbG9zZU1vZGFsID0gdXNlQ2FsbGJhY2soKHsgaWQgfSkgPT4ge1xuICAgICAgICBzZXRPcGVuTW9kYWxaSW5kZXhlcygob2xkT3Blbk1vZGFsWkluZGV4ZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld09wZW5Nb2RhbFpJbmRleGVzID0gb2xkT3Blbk1vZGFsWkluZGV4ZXMuZmlsdGVyKCh7IGlkOiBpZEluQXJyYXkgfSkgPT4gaWRJbkFycmF5ICE9PSBpZCk7XG4gICAgICAgICAgICBpZiAoIW5ld09wZW5Nb2RhbFpJbmRleGVzLmxlbmd0aCkgO1xuICAgICAgICAgICAgcmV0dXJuIG5ld09wZW5Nb2RhbFpJbmRleGVzO1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIG9wZW5Nb2RhbCxcbiAgICAgICAgY2xvc2VNb2RhbCxcbiAgICAgICAgb3Blbk1vZGFsWkluZGV4ZXMsXG4gICAgfSksIFtvcGVuTW9kYWwsIGNsb3NlTW9kYWwsIG9wZW5Nb2RhbFpJbmRleGVzXSk7XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHsgdmFsdWU6IHZhbHVlIH0sIGNoaWxkcmVuKTtcbn07XG5cbmNvbnN0IHVzZU1vZGFsU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBzdHlsZXMkMyA9IHtcIm1vZGFsXCI6XCJzdHlsZXMtbW9kdWxlX21vZGFsX19wS21sWFwiLFwiaXNPcGVuXCI6XCJzdHlsZXMtbW9kdWxlX2lzT3Blbl9fV29uSDhcIn07XG5cbmNvbnN0IE1PREFMX0RFRkFVTFRfWl9JTkRFWCA9IDUwO1xuY29uc3QgTW9kYWwgPSAoeyBvcGVuLCBjaGlsZHJlbiwgb25DbGljaywgb25CbHVyLCBpZCwgekluZGV4ID0gTU9EQUxfREVGQVVMVF9aX0lOREVYLCBjbGFzc05hbWUsIG1vZGFsUm9vdEVsZW1lbnRJZCwgZGVsYXlUaW1lID0gMzUwLCBkaXNhYmxlQW5pbWF0aW9ucywgfSkgPT4ge1xuICAgIGNvbnN0IHsgaXNNb3VudGVkQ2xpZW50IH0gPSB1c2VDbGllbnRNb3VudGVkU3RhdGUoKTtcbiAgICBjb25zdCB7IG9wZW5Nb2RhbCwgY2xvc2VNb2RhbCwgb3Blbk1vZGFsWkluZGV4ZXMgfSA9IHVzZU1vZGFsU3RhdGUoKTtcbiAgICBjb25zdCB7IHNob3VsZFJlbmRlciwgdHJhbnNpdGlvbkNvbXBsZXRlIH0gPSB1c2VEZWxheWVkTW91bnQoe1xuICAgICAgICBzaG91bGRNb3VudDogb3BlbixcbiAgICAgICAgZGVsYXlUaW1lLFxuICAgIH0pO1xuICAgIGNvbnN0IGlzVW5kZXJBbm90aGVyTW9kYWwgPSBvcGVuTW9kYWxaSW5kZXhlc1swXT8uaWQgIT09IGlkO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBvcGVuTW9kYWwoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgIGNsb3NlTW9kYWwoe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbb3BlbiwgaWQsIHpJbmRleCwgb3Blbk1vZGFsLCBjbG9zZU1vZGFsXSk7XG4gICAgY29uc3Qgc3R5bGUgPSB1c2VNZW1vKCgpID0+ICh7IHpJbmRleCB9KSwgW3pJbmRleF0pO1xuICAgIHJldHVybiAoKGRpc2FibGVBbmltYXRpb25zID8gaXNNb3VudGVkQ2xpZW50IDogc2hvdWxkUmVuZGVyKSAmJlxuICAgICAgICBjcmVhdGVQb3J0YWwoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcyhzdHlsZXMkMy5tb2RhbCwgY2xhc3NOYW1lLCB7XG4gICAgICAgICAgICAgICAgW3N0eWxlcyQzLnVuZGVyQW5vdGhlck1vZGFsXTogaXNVbmRlckFub3RoZXJNb2RhbCxcbiAgICAgICAgICAgICAgICBbc3R5bGVzJDMuaXNPcGVuXTogZGlzYWJsZUFuaW1hdGlvbnMgPyBvcGVuIDogdHJhbnNpdGlvbkNvbXBsZXRlLFxuICAgICAgICAgICAgfSksIGlkOiBpZCwgb25CbHVyOiBvbkJsdXIsIG9uQ2xpY2s6IG9uQ2xpY2ssIG9uS2V5RG93bjogKF8pID0+IF8sIHJvbGU6IFwiYnV0dG9uXCIsIHN0eWxlOiBzdHlsZSwgdGFiSW5kZXg6IDAgfSwgY2hpbGRyZW4pLCBtb2RhbFJvb3RFbGVtZW50SWRcbiAgICAgICAgICAgID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobW9kYWxSb290RWxlbWVudElkKSB8fCBkb2N1bWVudC5ib2R5XG4gICAgICAgICAgICA6IGRvY3VtZW50LmJvZHkpKTtcbn07XG5cbnZhciBzdHlsZXMkMiA9IHtcInBpbGxcIjpcIlBpbGwtbW9kdWxlX3BpbGxfX2FmR3FEXCIsXCJiYXNlXCI6XCJQaWxsLW1vZHVsZV9iYXNlX19BdG1yVFwiLFwibGlnaHRcIjpcIlBpbGwtbW9kdWxlX2xpZ2h0X195Y1NQeFwiLFwiaW52ZXJzZVwiOlwiUGlsbC1tb2R1bGVfaW52ZXJzZV9fMVN2cmlcIixcInByaW1hcnlcIjpcIlBpbGwtbW9kdWxlX3ByaW1hcnlfXy1oLVA5XCJ9O1xuXG5jb25zdCBQaWxsID0gKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgdmFyaWFudCA9ICdiYXNlJywgLi4ucHJvcHMgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLnByb3BzLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJDIucGlsbCwgY2xhc3NOYW1lLCB7XG4gICAgICAgICAgICBbc3R5bGVzJDIuYmFzZV06IHZhcmlhbnQ/LmluY2x1ZGVzKCdiYXNlJyksXG4gICAgICAgICAgICBbc3R5bGVzJDIubGlnaHRdOiB2YXJpYW50Py5pbmNsdWRlcygnbGlnaHQnKSxcbiAgICAgICAgICAgIFtzdHlsZXMkMi5pbnZlcnNlXTogdmFyaWFudD8uaW5jbHVkZXMoJ2ludmVyc2UnKSxcbiAgICAgICAgICAgIFtzdHlsZXMkMi5wcmltYXJ5XTogdmFyaWFudD8uaW5jbHVkZXMoJ3ByaW1hcnknKSxcbiAgICAgICAgfSkgfSwgY2hpbGRyZW4pKTtcbn07XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgkMShhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxudmFyIF9iYXNlRmluZEluZGV4ID0gYmFzZUZpbmRJbmRleCQxO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxuZnVuY3Rpb24gYmFzZUlzTmFOJDEodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxudmFyIF9iYXNlSXNOYU4gPSBiYXNlSXNOYU4kMTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mJDEoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxudmFyIF9zdHJpY3RJbmRleE9mID0gc3RyaWN0SW5kZXhPZiQxO1xuXG52YXIgYmFzZUZpbmRJbmRleCA9IF9iYXNlRmluZEluZGV4LFxuICAgIGJhc2VJc05hTiA9IF9iYXNlSXNOYU4sXG4gICAgc3RyaWN0SW5kZXhPZiA9IF9zdHJpY3RJbmRleE9mO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZiQxKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbnZhciBfYmFzZUluZGV4T2YgPSBiYXNlSW5kZXhPZiQxO1xuXG52YXIgYmFzZUluZGV4T2YgPSBfYmFzZUluZGV4T2Y7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzJDEoYXJyYXksIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxudmFyIF9hcnJheUluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyQxO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoJDEoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIF9hcnJheUluY2x1ZGVzV2l0aCA9IGFycmF5SW5jbHVkZXNXaXRoJDE7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cblxuZnVuY3Rpb24gbm9vcCQxKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG52YXIgbm9vcF8xID0gbm9vcCQxO1xuXG52YXIgU2V0JDEgPSBfU2V0LFxuICAgIG5vb3AgPSBub29wXzEsXG4gICAgc2V0VG9BcnJheSQxID0gX3NldFRvQXJyYXk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAqL1xudmFyIGNyZWF0ZVNldCQxID0gIShTZXQkMSAmJiAoMSAvIHNldFRvQXJyYXkkMShuZXcgU2V0JDEoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCQxKHZhbHVlcyk7XG59O1xuXG52YXIgX2NyZWF0ZVNldCA9IGNyZWF0ZVNldCQxO1xuXG52YXIgU2V0Q2FjaGUgPSBfU2V0Q2FjaGUsXG4gICAgYXJyYXlJbmNsdWRlcyA9IF9hcnJheUluY2x1ZGVzLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gX2FycmF5SW5jbHVkZXNXaXRoLFxuICAgIGNhY2hlSGFzID0gX2NhY2hlSGFzLFxuICAgIGNyZWF0ZVNldCA9IF9jcmVhdGVTZXQsXG4gICAgc2V0VG9BcnJheSA9IF9zZXRUb0FycmF5O1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcSQxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgfVxuICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgIGlmIChzZXQpIHtcbiAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgfVxuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICB9XG4gIGVsc2Uge1xuICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZVVuaXEgPSBiYXNlVW5pcSQxO1xuXG52YXIgYmFzZUl0ZXJhdGVlID0gX2Jhc2VJdGVyYXRlZSxcbiAgICBiYXNlVW5pcSA9IF9iYXNlVW5pcTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAqIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAqICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaXFCeShbMi4xLCAxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICogLy8gPT4gWzIuMSwgMS4yXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gKi9cbmZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGJhc2VJdGVyYXRlZShpdGVyYXRlZSkpIDogW107XG59XG5cbnZhciB1bmlxQnlfMSA9IHVuaXFCeTtcblxudmFyIHVuaXFCeSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHVuaXFCeV8xKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cblxuZnVuY3Rpb24gYXJyYXlFYWNoJDEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxudmFyIF9hcnJheUVhY2ggPSBhcnJheUVhY2gkMTtcblxudmFyIGJhc2VBc3NpZ25WYWx1ZSQxID0gX2Jhc2VBc3NpZ25WYWx1ZSxcbiAgICBlcSA9IGVxXzE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQzID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkMyA9IG9iamVjdFByb3RvJDMuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZSQyKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkkMy5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUkMShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBfYXNzaWduVmFsdWUgPSBhc3NpZ25WYWx1ZSQyO1xuXG52YXIgYXNzaWduVmFsdWUkMSA9IF9hc3NpZ25WYWx1ZSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSBfYmFzZUFzc2lnblZhbHVlO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0JDUoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZSQxKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciBfY29weU9iamVjdCA9IGNvcHlPYmplY3QkNTtcblxudmFyIGNvcHlPYmplY3QkNCA9IF9jb3B5T2JqZWN0LFxuICAgIGtleXMkMSA9IGtleXNfMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24kMShvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3QkNChzb3VyY2UsIGtleXMkMShzb3VyY2UpLCBvYmplY3QpO1xufVxuXG52YXIgX2Jhc2VBc3NpZ24gPSBiYXNlQXNzaWduJDE7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbiQxKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9uYXRpdmVLZXlzSW4gPSBuYXRpdmVLZXlzSW4kMTtcblxudmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdF8xLFxuICAgIGlzUHJvdG90eXBlJDEgPSBfaXNQcm90b3R5cGUsXG4gICAgbmF0aXZlS2V5c0luID0gX25hdGl2ZUtleXNJbjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbiQxKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0JDIob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlJDEob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkkMi5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VLZXlzSW4gPSBiYXNlS2V5c0luJDE7XG5cbnZhciBhcnJheUxpa2VLZXlzID0gX2FycmF5TGlrZUtleXMsXG4gICAgYmFzZUtleXNJbiA9IF9iYXNlS2V5c0luLFxuICAgIGlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2VfMTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbiQzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxudmFyIGtleXNJbl8xID0ga2V5c0luJDM7XG5cbnZhciBjb3B5T2JqZWN0JDMgPSBfY29weU9iamVjdCxcbiAgICBrZXlzSW4kMiA9IGtleXNJbl8xO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4kMShvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3QkMyhzb3VyY2UsIGtleXNJbiQyKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbnZhciBfYmFzZUFzc2lnbkluID0gYmFzZUFzc2lnbkluJDE7XG5cbnZhciBfY2xvbmVCdWZmZXIgPSB7ZXhwb3J0czoge319O1xuXG5fY2xvbmVCdWZmZXIuZXhwb3J0cztcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0dmFyIHJvb3QgPSBfcm9vdDtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuXHR2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuXHQvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuXHR2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuXHQvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0dmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcblx0ICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG5cdCAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG5cdCAqL1xuXHRmdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuXHQgIGlmIChpc0RlZXApIHtcblx0ICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcblx0ICB9XG5cdCAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG5cdCAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuXHQgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7IFxufSAoX2Nsb25lQnVmZmVyLCBfY2xvbmVCdWZmZXIuZXhwb3J0cykpO1xuXG52YXIgX2Nsb25lQnVmZmVyRXhwb3J0cyA9IF9jbG9uZUJ1ZmZlci5leHBvcnRzO1xuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cblxuZnVuY3Rpb24gY29weUFycmF5JDEoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfY29weUFycmF5ID0gY29weUFycmF5JDE7XG5cbnZhciBjb3B5T2JqZWN0JDIgPSBfY29weU9iamVjdCxcbiAgICBnZXRTeW1ib2xzJDEgPSBfZ2V0U3ltYm9scztcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzJDEoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QkMihzb3VyY2UsIGdldFN5bWJvbHMkMShzb3VyY2UpLCBvYmplY3QpO1xufVxuXG52YXIgX2NvcHlTeW1ib2xzID0gY29weVN5bWJvbHMkMTtcblxudmFyIG92ZXJBcmcgPSBfb3ZlckFyZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlJDMgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxudmFyIF9nZXRQcm90b3R5cGUgPSBnZXRQcm90b3R5cGUkMztcblxudmFyIGFycmF5UHVzaCA9IF9hcnJheVB1c2gsXG4gICAgZ2V0UHJvdG90eXBlJDIgPSBfZ2V0UHJvdG90eXBlLFxuICAgIGdldFN5bWJvbHMgPSBfZ2V0U3ltYm9scyxcbiAgICBzdHViQXJyYXkgPSBzdHViQXJyYXlfMTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luJDIgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZSQyKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBfZ2V0U3ltYm9sc0luID0gZ2V0U3ltYm9sc0luJDI7XG5cbnZhciBjb3B5T2JqZWN0JDEgPSBfY29weU9iamVjdCxcbiAgICBnZXRTeW1ib2xzSW4kMSA9IF9nZXRTeW1ib2xzSW47XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4kMShzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdCQxKHNvdXJjZSwgZ2V0U3ltYm9sc0luJDEoc291cmNlKSwgb2JqZWN0KTtcbn1cblxudmFyIF9jb3B5U3ltYm9sc0luID0gY29weVN5bWJvbHNJbiQxO1xuXG52YXIgYmFzZUdldEFsbEtleXMgPSBfYmFzZUdldEFsbEtleXMsXG4gICAgZ2V0U3ltYm9sc0luID0gX2dldFN5bWJvbHNJbixcbiAgICBrZXlzSW4kMSA9IGtleXNJbl8xO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbiQyKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4kMSwgZ2V0U3ltYm9sc0luKTtcbn1cblxudmFyIF9nZXRBbGxLZXlzSW4gPSBnZXRBbGxLZXlzSW4kMjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXG52YXIgb2JqZWN0UHJvdG8kMSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90byQxLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheSQxKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9pbml0Q2xvbmVBcnJheSA9IGluaXRDbG9uZUFycmF5JDE7XG5cbnZhciBVaW50OEFycmF5ID0gX1VpbnQ4QXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIkMyhhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Nsb25lQXJyYXlCdWZmZXIgPSBjbG9uZUFycmF5QnVmZmVyJDM7XG5cbnZhciBjbG9uZUFycmF5QnVmZmVyJDIgPSBfY2xvbmVBcnJheUJ1ZmZlcjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyQxKGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIkMihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbnZhciBfY2xvbmVEYXRhVmlldyA9IGNsb25lRGF0YVZpZXckMTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG5cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwJDEocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfY2xvbmVSZWdFeHAgPSBjbG9uZVJlZ0V4cCQxO1xuXG52YXIgU3ltYm9sID0gX1N5bWJvbDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2wkMShzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbnZhciBfY2xvbmVTeW1ib2wgPSBjbG9uZVN5bWJvbCQxO1xuXG52YXIgY2xvbmVBcnJheUJ1ZmZlciQxID0gX2Nsb25lQXJyYXlCdWZmZXI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5JDEodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyJDEodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG52YXIgX2Nsb25lVHlwZWRBcnJheSA9IGNsb25lVHlwZWRBcnJheSQxO1xuXG52YXIgY2xvbmVBcnJheUJ1ZmZlciA9IF9jbG9uZUFycmF5QnVmZmVyLFxuICAgIGNsb25lRGF0YVZpZXcgPSBfY2xvbmVEYXRhVmlldyxcbiAgICBjbG9uZVJlZ0V4cCA9IF9jbG9uZVJlZ0V4cCxcbiAgICBjbG9uZVN5bWJvbCA9IF9jbG9uZVN5bWJvbCxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSBfY2xvbmVUeXBlZEFycmF5O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyQxID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWckMSA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWckMiA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyQxID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnJDEgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWckMiA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyQxID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnJDEgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnJDEgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnJDEgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWckMSA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWckMSA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWckMSA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnJDEgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWckMSA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyQxID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyQxID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWckMSA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnJDEgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyQxKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZyQxOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZyQxOlxuICAgIGNhc2UgZGF0ZVRhZyQxOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZyQxOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnJDE6IGNhc2UgZmxvYXQ2NFRhZyQxOlxuICAgIGNhc2UgaW50OFRhZyQxOiBjYXNlIGludDE2VGFnJDE6IGNhc2UgaW50MzJUYWckMTpcbiAgICBjYXNlIHVpbnQ4VGFnJDE6IGNhc2UgdWludDhDbGFtcGVkVGFnJDE6IGNhc2UgdWludDE2VGFnJDE6IGNhc2UgdWludDMyVGFnJDE6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnJDI6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZyQxOlxuICAgIGNhc2Ugc3RyaW5nVGFnJDE6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnJDE6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnJDI6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIHN5bWJvbFRhZyQxOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxudmFyIF9pbml0Q2xvbmVCeVRhZyA9IGluaXRDbG9uZUJ5VGFnJDE7XG5cbnZhciBpc09iamVjdCQxID0gaXNPYmplY3RfMTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUkMSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdCQxKHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbnZhciBfYmFzZUNyZWF0ZSA9IGJhc2VDcmVhdGUkMTtcblxudmFyIGJhc2VDcmVhdGUgPSBfYmFzZUNyZWF0ZSxcbiAgICBnZXRQcm90b3R5cGUkMSA9IF9nZXRQcm90b3R5cGUsXG4gICAgaXNQcm90b3R5cGUgPSBfaXNQcm90b3R5cGU7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0JDEob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUkMShvYmplY3QpKVxuICAgIDoge307XG59XG5cbnZhciBfaW5pdENsb25lT2JqZWN0ID0gaW5pdENsb25lT2JqZWN0JDE7XG5cbnZhciBnZXRUYWckMiA9IF9nZXRUYWcsXG4gICAgaXNPYmplY3RMaWtlJDIgPSBpc09iamVjdExpa2VfMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyQxID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCQxKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UkMih2YWx1ZSkgJiYgZ2V0VGFnJDIodmFsdWUpID09IG1hcFRhZyQxO1xufVxuXG52YXIgX2Jhc2VJc01hcCA9IGJhc2VJc01hcCQxO1xuXG52YXIgYmFzZUlzTWFwID0gX2Jhc2VJc01hcCxcbiAgICBiYXNlVW5hcnkkMSA9IF9iYXNlVW5hcnksXG4gICAgbm9kZVV0aWwkMSA9IF9ub2RlVXRpbEV4cG9ydHM7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwkMSAmJiBub2RlVXRpbCQxLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCQxID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5JDEobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxudmFyIGlzTWFwXzEgPSBpc01hcCQxO1xuXG52YXIgZ2V0VGFnJDEgPSBfZ2V0VGFnLFxuICAgIGlzT2JqZWN0TGlrZSQxID0gaXNPYmplY3RMaWtlXzE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWckMSA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQkMSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlJDEodmFsdWUpICYmIGdldFRhZyQxKHZhbHVlKSA9PSBzZXRUYWckMTtcbn1cblxudmFyIF9iYXNlSXNTZXQgPSBiYXNlSXNTZXQkMTtcblxudmFyIGJhc2VJc1NldCA9IF9iYXNlSXNTZXQsXG4gICAgYmFzZVVuYXJ5ID0gX2Jhc2VVbmFyeSxcbiAgICBub2RlVXRpbCA9IF9ub2RlVXRpbEV4cG9ydHM7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0JDEgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxudmFyIGlzU2V0XzEgPSBpc1NldCQxO1xuXG52YXIgU3RhY2sgPSBfU3RhY2ssXG4gICAgYXJyYXlFYWNoID0gX2FycmF5RWFjaCxcbiAgICBhc3NpZ25WYWx1ZSA9IF9hc3NpZ25WYWx1ZSxcbiAgICBiYXNlQXNzaWduID0gX2Jhc2VBc3NpZ24sXG4gICAgYmFzZUFzc2lnbkluID0gX2Jhc2VBc3NpZ25JbixcbiAgICBjbG9uZUJ1ZmZlciA9IF9jbG9uZUJ1ZmZlckV4cG9ydHMsXG4gICAgY29weUFycmF5ID0gX2NvcHlBcnJheSxcbiAgICBjb3B5U3ltYm9scyA9IF9jb3B5U3ltYm9scyxcbiAgICBjb3B5U3ltYm9sc0luID0gX2NvcHlTeW1ib2xzSW4sXG4gICAgZ2V0QWxsS2V5cyA9IF9nZXRBbGxLZXlzLFxuICAgIGdldEFsbEtleXNJbiQxID0gX2dldEFsbEtleXNJbixcbiAgICBnZXRUYWcgPSBfZ2V0VGFnLFxuICAgIGluaXRDbG9uZUFycmF5ID0gX2luaXRDbG9uZUFycmF5LFxuICAgIGluaXRDbG9uZUJ5VGFnID0gX2luaXRDbG9uZUJ5VGFnLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IF9pbml0Q2xvbmVPYmplY3QsXG4gICAgaXNBcnJheSA9IGlzQXJyYXlfMSxcbiAgICBpc0J1ZmZlciA9IGlzQnVmZmVyRXhwb3J0cyxcbiAgICBpc01hcCA9IGlzTWFwXzEsXG4gICAgaXNPYmplY3QgPSBpc09iamVjdF8xLFxuICAgIGlzU2V0ID0gaXNTZXRfMSxcbiAgICBrZXlzID0ga2V5c18xLFxuICAgIGtleXNJbiA9IGtleXNJbl8xO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyQxID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUckMSA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHJDEgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnJDEgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWckMV0gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUkMSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHJDEsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHJDEsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHJDE7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWckMSB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUkMShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZSQxKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luJDEgOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUkMShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZUNsb25lID0gYmFzZUNsb25lJDE7XG5cbi8qKlxuICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubGFzdChbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICovXG5cbmZ1bmN0aW9uIGxhc3QkMShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIGxhc3RfMSA9IGxhc3QkMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuXG5mdW5jdGlvbiBiYXNlU2xpY2UkMShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlU2xpY2UgPSBiYXNlU2xpY2UkMTtcblxudmFyIGJhc2VHZXQgPSBfYmFzZUdldCxcbiAgICBiYXNlU2xpY2UgPSBfYmFzZVNsaWNlO1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJlbnQkMShvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbn1cblxudmFyIF9wYXJlbnQgPSBwYXJlbnQkMTtcblxudmFyIGNhc3RQYXRoJDEgPSBfY2FzdFBhdGgsXG4gICAgbGFzdCA9IGxhc3RfMSxcbiAgICBwYXJlbnQgPSBfcGFyZW50LFxuICAgIHRvS2V5ID0gX3RvS2V5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbnNldCQxKG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgkMShwYXRoLCBvYmplY3QpO1xuICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xufVxuXG52YXIgX2Jhc2VVbnNldCA9IGJhc2VVbnNldCQxO1xuXG52YXIgYmFzZUdldFRhZyA9IF9iYXNlR2V0VGFnLFxuICAgIGdldFByb3RvdHlwZSA9IF9nZXRQcm90b3R5cGUsXG4gICAgaXNPYmplY3RMaWtlID0gaXNPYmplY3RMaWtlXzE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCQxKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG52YXIgaXNQbGFpbk9iamVjdF8xID0gaXNQbGFpbk9iamVjdCQxO1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3RfMTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICogb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSQxKHZhbHVlKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufVxuXG52YXIgX2N1c3RvbU9taXRDbG9uZSA9IGN1c3RvbU9taXRDbG9uZSQxO1xuXG52YXIgYmFzZUZsYXR0ZW4gPSBfYmFzZUZsYXR0ZW47XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuJDEoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbnZhciBmbGF0dGVuXzEgPSBmbGF0dGVuJDE7XG5cbnZhciBmbGF0dGVuID0gZmxhdHRlbl8xLFxuICAgIG92ZXJSZXN0ID0gX292ZXJSZXN0LFxuICAgIHNldFRvU3RyaW5nID0gX3NldFRvU3RyaW5nO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZsYXRSZXN0JDEoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxudmFyIF9mbGF0UmVzdCA9IGZsYXRSZXN0JDE7XG5cbnZhciBhcnJheU1hcCA9IF9hcnJheU1hcCxcbiAgICBiYXNlQ2xvbmUgPSBfYmFzZUNsb25lLFxuICAgIGJhc2VVbnNldCA9IF9iYXNlVW5zZXQsXG4gICAgY2FzdFBhdGggPSBfY2FzdFBhdGgsXG4gICAgY29weU9iamVjdCA9IF9jb3B5T2JqZWN0LFxuICAgIGN1c3RvbU9taXRDbG9uZSA9IF9jdXN0b21PbWl0Q2xvbmUsXG4gICAgZmxhdFJlc3QgPSBfZmxhdFJlc3QsXG4gICAgZ2V0QWxsS2V5c0luID0gX2dldEFsbEtleXNJbjtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xudmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0pO1xuICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG52YXIgb21pdF8xID0gb21pdDtcblxudmFyIG9taXQkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhvbWl0XzEpO1xuXG5jb25zdCB1c2VEeW5hbWljUmVmcyA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCBpZHMgPSAnaWRzJyBpbiBwYXJhbXNcbiAgICAgICAgPyBwYXJhbXMuaWRzXG4gICAgICAgIDogWy4uLkFycmF5KHBhcmFtcy5jb3VudCldLm1hcCgoX3YsIGkpID0+IGkudG9TdHJpbmcoKSk7XG4gICAgLy8gTWFudWFsbHkgY29uc3RydWN0IHRoZSBkeW5hbWljUmVmcyBvYmplY3Qgd2l0aCBhIHN0cmljdCB0eXBlXG4gICAgY29uc3QgZHluYW1pY1JlZnMgPSB1c2VSZWYoaWRzLnJlZHVjZSgoYWNjLCBpZCkgPT4ge1xuICAgICAgICBhY2NbaWRdID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pKTtcbiAgICAvLyBnZXRSZWYgcmV0dXJucyB0aGUgLmN1cnJlbnQgcHJvcGVydHkgb2YgdGhlIHJlZiBmb3IgdGhlIGdpdmVuIGlkXG4gICAgY29uc3QgZ2V0UmVmID0gdXNlQ2FsbGJhY2soKGlkKSA9PiBkeW5hbWljUmVmcy5jdXJyZW50W2lkXT8uY3VycmVudCA/PyBudWxsLCBbXSk7XG4gICAgLy8gc2V0UmVmIHJldHVybnMgdGhlIFJlZk9iamVjdCBpdHNlbGYgc28gaXQgY2FuIGJlIGFzc2lnbmVkIGRpcmVjdGx5XG4gICAgY29uc3Qgc2V0UmVmID0gdXNlQ2FsbGJhY2soKGlkKSA9PiBkeW5hbWljUmVmcy5jdXJyZW50W2lkXSwgW10pO1xuICAgIHJldHVybiBbZ2V0UmVmLCBzZXRSZWZdO1xufTtcblxudmFyIHN0eWxlcyQxID0ge1wiaW5kaWNhdG9yQ29udGFpbmVyXCI6XCJTZWxlY3QtbW9kdWxlX2luZGljYXRvckNvbnRhaW5lcl9fQmV4d3FcIixcImNsZWFySW5kaWNhdG9yXCI6XCJTZWxlY3QtbW9kdWxlX2NsZWFySW5kaWNhdG9yX19tQXYtOFwiLFwiaGlkZVwiOlwiU2VsZWN0LW1vZHVsZV9oaWRlX19oY3ltblwiLFwiZHJvcGRvd25JbmRpY2F0b3JcIjpcIlNlbGVjdC1tb2R1bGVfZHJvcGRvd25JbmRpY2F0b3JfX3Mwd25tXCIsXCJpc09wZW5cIjpcIlNlbGVjdC1tb2R1bGVfaXNPcGVuX183c3oybFwiLFwiaXNEaXNhYmxlZFwiOlwiU2VsZWN0LW1vZHVsZV9pc0Rpc2FibGVkX18yN2dVMVwiLFwiaW5wdXRcIjpcIlNlbGVjdC1tb2R1bGVfaW5wdXRfX2VWY3N1XCIsXCJpbnB1dFR5cGVJc1RleHRcIjpcIlNlbGVjdC1tb2R1bGVfaW5wdXRUeXBlSXNUZXh0X19MaGRwYVwiLFwibG9hZGluZ0luZGljYXRvclwiOlwiU2VsZWN0LW1vZHVsZV9sb2FkaW5nSW5kaWNhdG9yX19vQ0JkUlwiLFwibXVsdGlWYWx1ZVwiOlwiU2VsZWN0LW1vZHVsZV9tdWx0aVZhbHVlX19GdnBQblwiLFwibXVsdGlWYWx1ZVJlbW92ZVwiOlwiU2VsZWN0LW1vZHVsZV9tdWx0aVZhbHVlUmVtb3ZlX19WWXdoS1wiLFwibm9PcHRpb25zTWVzc2FnZVwiOlwiU2VsZWN0LW1vZHVsZV9ub09wdGlvbnNNZXNzYWdlX19PN2psWlwiLFwicGxhY2Vob2xkZXJcIjpcIlNlbGVjdC1tb2R1bGVfcGxhY2Vob2xkZXJfX0VRMVIyXCIsXCJ2YWx1ZUNvbnRhaW5lclwiOlwiU2VsZWN0LW1vZHVsZV92YWx1ZUNvbnRhaW5lcl9fQXVPNDlcIixcImFsbG93TXVsdGlTZWxlY3RlZE9wdGlvbnNIZWlnaHRUb0V4cGFuZFwiOlwiU2VsZWN0LW1vZHVsZV9hbGxvd011bHRpU2VsZWN0ZWRPcHRpb25zSGVpZ2h0VG9FeHBhbmRfX293dzNVXCIsXCJpc1Njcm9sbGFibGVcIjpcIlNlbGVjdC1tb2R1bGVfaXNTY3JvbGxhYmxlX19MMmxQbFwiLFwibWVudVwiOlwiU2VsZWN0LW1vZHVsZV9tZW51X18wTENTZlwiLFwibWVudUxpc3RcIjpcIlNlbGVjdC1tb2R1bGVfbWVudUxpc3RfX1hzdUpjXCIsXCJvcHRpb25cIjpcIlNlbGVjdC1tb2R1bGVfb3B0aW9uX19keDQxOVwiLFwiaXNGb2N1c2VkXCI6XCJTZWxlY3QtbW9kdWxlX2lzRm9jdXNlZF9fUlVYbnFcIixcImlzU2VsZWN0ZWRcIjpcIlNlbGVjdC1tb2R1bGVfaXNTZWxlY3RlZF9fUVhKSVlcIixcIndyYXBwZXJcIjpcIlNlbGVjdC1tb2R1bGVfd3JhcHBlcl9fdVFVTFNcIixcImlzR3JvdXBNb2RlXCI6XCJTZWxlY3QtbW9kdWxlX2lzR3JvdXBNb2RlX19oc0dXalwiLFwiZ3JvdXBzRHJvcERvd25cIjpcIlNlbGVjdC1tb2R1bGVfZ3JvdXBzRHJvcERvd25fX2VPQ21DXCIsXCJncm91cFdyYXBwZXJcIjpcIlNlbGVjdC1tb2R1bGVfZ3JvdXBXcmFwcGVyX19ialo3SlwiLFwiZ3JvdXBcIjpcIlNlbGVjdC1tb2R1bGVfZ3JvdXBfXzdVb2Z6XCIsXCJpc0VtcHR5XCI6XCJTZWxlY3QtbW9kdWxlX2lzRW1wdHlfX2Z6TUstXCIsXCJsYWJlbFwiOlwiU2VsZWN0LW1vZHVsZV9sYWJlbF9fMEl6SkJcIixcImNvbnRhaW5lckl0ZW1zR3JvdXBcIjpcIlNlbGVjdC1tb2R1bGVfY29udGFpbmVySXRlbXNHcm91cF9fUXpQUEdcIixcImNvbnRyb2xcIjpcIlNlbGVjdC1tb2R1bGVfY29udHJvbF9fMjViRjJcIixcImlzSGlkZGVuXCI6XCJTZWxlY3QtbW9kdWxlX2lzSGlkZGVuX19LRDNPalwiLFwiZ3JvdXBzRHJvcERvd25Db250ZW50c1wiOlwiU2VsZWN0LW1vZHVsZV9ncm91cHNEcm9wRG93bkNvbnRlbnRzX19heVhFTVwiLFwiaXNNdWx0aVNlbGVjdFwiOlwiU2VsZWN0LW1vZHVsZV9pc011bHRpU2VsZWN0X19pNWxVbFwiLFwiZGlzYWJsZUlucHV0SGVpZ2h0XCI6XCJTZWxlY3QtbW9kdWxlX2Rpc2FibGVJbnB1dEhlaWdodF9fcGJzLS1cIixcImNvbnRhaW5lclwiOlwiU2VsZWN0LW1vZHVsZV9jb250YWluZXJfX2toQzNZXCIsXCJoaWRlVGV4dEJsaW5rZXJcIjpcIlNlbGVjdC1tb2R1bGVfaGlkZVRleHRCbGlua2VyX182UEtYUFwiLFwib3B0aW9uVG9vbHRpcFwiOlwiU2VsZWN0LW1vZHVsZV9vcHRpb25Ub29sdGlwX19JYWZkMVwiLFwidmFsdWVDb250YWluZXJUb29sdGlwXCI6XCJTZWxlY3QtbW9kdWxlX3ZhbHVlQ29udGFpbmVyVG9vbHRpcF9fa2w1YTRcIixcImxhYmVsQ29udGFpbmVyXCI6XCJTZWxlY3QtbW9kdWxlX2xhYmVsQ29udGFpbmVyX19tdm1NUlwiLFwiY29tcGFjdFwiOlwiU2VsZWN0LW1vZHVsZV9jb21wYWN0X18xcVhkLVwiLFwibGFiZWxIZWxwXCI6XCJTZWxlY3QtbW9kdWxlX2xhYmVsSGVscF9fQk1GbzdcIixcIm9wdGlvblNwYW5cIjpcIlNlbGVjdC1tb2R1bGVfb3B0aW9uU3Bhbl9fTHIyaVhcIixcIm9wdGlvblNwYW5Db250ZW50XCI6XCJTZWxlY3QtbW9kdWxlX29wdGlvblNwYW5Db250ZW50X19TUjRkcFwiLFwiZnVsbFdpZHRoXCI6XCJTZWxlY3QtbW9kdWxlX2Z1bGxXaWR0aF9fdnhQZm1cIixcIm9wdGlvbkhlbHBUb29sdGlwXCI6XCJTZWxlY3QtbW9kdWxlX29wdGlvbkhlbHBUb29sdGlwX19nazNNRlwifTtcblxuY29uc3QgREVMQVlfRk9SX0NMT1NJTkdfRFJPUF9ET1dOID0gMjUwO1xuY29uc3QgREVGQVVMVF9GSUxURVIgPSBjcmVhdGVGaWx0ZXIoKTtcbmNvbnN0IGNyZWF0ZU9wdGlvbktleSA9ICh7IGdyb3VwSWQsIHZhbHVlLCB9KSA9PiBncm91cElkXG4gICAgPyBjcmVhdGVDdXN0b21LZXlGcm9tT2JqZWN0KHsgZ3JvdXBJZCwgdmFsdWUgfSlcbiAgICA6IGNyZWF0ZUN1c3RvbUtleUZyb21PYmplY3QoeyB2YWx1ZSB9KTtcbmNvbnN0IFZBTElEX0FDVElPTlNfRk9SX0NBTExJTkdfSU5QVVRfQ0hBTkdFID0gW1xuICAgICdpbnB1dC1jaGFuZ2UnLFxuICAgICdzZXQtdmFsdWUnLFxuXTtcbmNvbnN0IE1lbnVMaXN0R3JvdXBlZCA9ICh7IGNoaWxkcmVuLCBjbGFzc05hbWUsIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCB7IGlkLCBncm91cElkLCBvblJlbmRlcmVkSXRlbXNDaGFuZ2UsIGdyb3VwTGFiZWwsIGFsbEdyb3Vwc0VtcHR5LCBmb3JjZUVtcHR5TWVzc2FnZSwgaXNTZWFyY2hPbmx5LCBtYXhPcHRpb25zLCBjbGFzc05hbWVzOiBjbGFzc05hbWVzUHJvcCwgfSA9IHByb3BzLnNlbGVjdFByb3BzO1xuICAgIGxldCByZW5kZXIgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICA/IGNoaWxkcmVuLnNsaWNlKDAsIG1heE9wdGlvbnMpXG4gICAgICAgIDogW2NoaWxkcmVuXTtcbiAgICBpZiAoaXNTZWFyY2hPbmx5KSB7XG4gICAgICAgIHJlbmRlciA9IFtdO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXNSZW5kZXJlZCA9IChpc0FycmF5JGQocmVuZGVyKSA/IHJlbmRlciA6IFtdKS5mbGF0TWFwKChjaGlsZCkgPT4gY2hpbGQ/LnByb3BzPy5kYXRhPy52YWx1ZSB8fCBbXSk7XG4gICAgY29uc3QgY291bnQgPSB2YWx1ZXNSZW5kZXJlZC5sZW5ndGg7XG4gICAgY29uc3QgaXNFbXB0eSA9ICFjb3VudDtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBvblJlbmRlcmVkSXRlbXNDaGFuZ2U/Lih7XG4gICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXNSZW5kZXJlZC5sZW5ndGggPyB2YWx1ZXNSZW5kZXJlZCA6IG51bGwsXG4gICAgICAgICAgICBjb3VudCxcbiAgICAgICAgfSk7XG4gICAgfSwgW2NvdW50LCBncm91cElkLCBvblJlbmRlcmVkSXRlbXNDaGFuZ2UsIHZhbHVlc1JlbmRlcmVkXSk7XG4gICAgY29uc3QgcmVuZGVyTm90aGluZyA9IGFsbEdyb3Vwc0VtcHR5ID8gIWZvcmNlRW1wdHlNZXNzYWdlIDogZmFsc2U7XG4gICAgY29uc3QgcmVuZGVyRW1wdHlNZXNzYWdlID0gYWxsR3JvdXBzRW1wdHkgPyBmb3JjZUVtcHR5TWVzc2FnZSA6IGZhbHNlO1xuICAgIGlmIChyZW5kZXJOb3RoaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRmxleCwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJDEuZ3JvdXAsIGNsYXNzTmFtZXNQcm9wPy5ncm91cD8uKHt9KSwge1xuICAgICAgICAgICAgW3N0eWxlcyQxLmlzRW1wdHldOiBpc0VtcHR5LFxuICAgICAgICB9KSwgaXNDb2x1bW46IHRydWUsIGtleTogaWQgfSxcbiAgICAgICAgIXJlbmRlckVtcHR5TWVzc2FnZSAmJiAhIWdyb3VwTGFiZWwgJiYgIWlzRW1wdHkgJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVGV4dCwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJDEubGFiZWwsIGNsYXNzTmFtZXNQcm9wPy5ncm91cExhYmVsPy4oe30pKSB9LCBncm91cExhYmVsKSksXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50cy5NZW51TGlzdCwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJDEuY2xhc3NOYW1lLCBjbGFzc05hbWUsIHN0eWxlcyQxLm1lbnVMaXN0Q29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgW3N0eWxlcyQxLmZvcmNlU2Nyb2xsQmFyc106IGZhbHNlLFxuICAgICAgICAgICAgfSksIC4uLnByb3BzIH0sIHJlbmRlcikpKTtcbn07XG5jb25zdCBPcHRpb24gPSAoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgbGFiZWwsIHZhbHVlIH0gPSBwcm9wcy5kYXRhO1xuICAgIGNvbnN0IHsga2VlcE9wdGlvblRvb2x0aXBPcGVuT25Ib3ZlciA9IGZhbHNlIH0gPSBwcm9wcy5zZWxlY3RQcm9wcztcbiAgICBjb25zdCBjb250ZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ2V0T3B0aW9uVG9vbHRpcCB9ID0gcHJvcHMuc2VsZWN0UHJvcHM7XG4gICAgICAgIHJldHVybiBnZXRPcHRpb25Ub29sdGlwPy4oeyBsYWJlbCwgdmFsdWUgfSk7XG4gICAgfSwgW3Byb3BzLnNlbGVjdFByb3BzLCBsYWJlbCwgdmFsdWVdKTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcFNpbXBsZSwgeyBjbGFzc05hbWU6IHN0eWxlcyQxLm9wdGlvblRvb2x0aXAsIGNvbnRlbnQ6IGNvbnRlbnQsIGRlbGF5OiA3NTAsIGRpc2FibGU6ICFjb250ZW50LCBrZWVwVG9vbHRpcE9wZW5PbkhvdmVyOiBrZWVwT3B0aW9uVG9vbHRpcE9wZW5PbkhvdmVyIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50cy5PcHRpb24sIHsgLi4ucHJvcHMgfSxcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBzdHlsZXMkMS5vcHRpb25TcGFuLCB0aXRsZTogdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyA/IGNoaWxkcmVuIDogdW5kZWZpbmVkIH0sXG4gICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJDEub3B0aW9uU3BhbkNvbnRlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZXMkMS5mdWxsV2lkdGhdOiAhY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfSkgfSwgY2hpbGRyZW4pLFxuICAgICAgICAgICAgICAgICEhY29udGVudCAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUb29sdGlwSGVscEljb24sIHsgY2xhc3NOYW1lOiBzdHlsZXMkMS5vcHRpb25IZWxwVG9vbHRpcCB9KSkpKSkpO1xufTtcbmNvbnN0IFZhbHVlQ29udGFpbmVyID0gKHsgY2hpbGRyZW4sIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdFByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IHZhbHVlLCBpc011bHRpLCBkaXNwbGF5VG9vbHRpcEZvclNlbGVjdGVkSXRlbSwgZ2V0T3B0aW9uVG9vbHRpcCB9ID0gc2VsZWN0UHJvcHM7XG4gICAgY29uc3QgY29udGVudCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IChpc0FycmF5JGQodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKT8uWzBdO1xuICAgICAgICByZXR1cm4gIWlzTXVsdGkgJiYgISFzZWxlY3RlZCAmJiBkaXNwbGF5VG9vbHRpcEZvclNlbGVjdGVkSXRlbVxuICAgICAgICAgICAgPyBnZXRPcHRpb25Ub29sdGlwPy4oc2VsZWN0ZWQpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfSwgW2dldE9wdGlvblRvb2x0aXAsIGRpc3BsYXlUb29sdGlwRm9yU2VsZWN0ZWRJdGVtLCB2YWx1ZSwgaXNNdWx0aV0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUb29sdGlwU2ltcGxlLCB7IGNsYXNzTmFtZTogc3R5bGVzJDEudmFsdWVDb250YWluZXJUb29sdGlwLCBjb250ZW50OiBjb250ZW50LCBkaXNhYmxlOiAhY29udGVudCB9LFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuVmFsdWVDb250YWluZXIsIHsgLi4ucHJvcHMgfSwgY2hpbGRyZW4pKSk7XG59O1xuY29uc3QgRHJvcGRvd25JbmRpY2F0b3IgPSAoeyBpbm5lclByb3BzOiBpbm5lclByb3BzUHJvcCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgZ3JvdXBlZElzT3Blbiwgb25NZW51Q2xvc2UgfSA9IHByb3BzLnNlbGVjdFByb3BzO1xuICAgIGNvbnN0IGhhbmRsZVBvaW50ZXJEb3duID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAoZ3JvdXBlZElzT3Blbikge1xuICAgICAgICAgICAgb25NZW51Q2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1lbnVDbG9zZSwgZ3JvdXBlZElzT3Blbl0pO1xuICAgIGNvbnN0IGlubmVyUHJvcHMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIC4uLmlubmVyUHJvcHNQcm9wLFxuICAgICAgICBvblBvaW50ZXJEb3duOiBoYW5kbGVQb2ludGVyRG93bixcbiAgICB9KSwgW2lubmVyUHJvcHNQcm9wLCBoYW5kbGVQb2ludGVyRG93bl0pO1xuICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMuRHJvcGRvd25JbmRpY2F0b3IsIHsgaW5uZXJQcm9wczogaW5uZXJQcm9wcywgLi4ucHJvcHMgfSk7XG59O1xuY29uc3QgQ2xlYXJJbmRpY2F0b3IgPSAoeyBpbm5lclByb3BzOiBpbm5lclByb3BzUHJvcCwgY2hpbGRyZW4sIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCB7IHJlbmRlckNsZWFySW5kaWNhdG9yLCBjbGVhckluZGljYXRvclRvb2x0aXBDb250ZW50IH0gPSBwcm9wcy5zZWxlY3RQcm9wcztcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcFNpbXBsZSwgeyBjb250ZW50OiBjbGVhckluZGljYXRvclRvb2x0aXBDb250ZW50IHx8ICdDbGVhciBzZWxlY3RlZCcgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChjb21wb25lbnRzLkNsZWFySW5kaWNhdG9yLCB7IGlubmVyUHJvcHM6IGlubmVyUHJvcHNQcm9wLCAuLi5wcm9wcyB9LCByZW5kZXJDbGVhckluZGljYXRvciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGNoaWxkcmVuXG4gICAgICAgICAgICA6IHJlbmRlckNsZWFySW5kaWNhdG9yPy4oKSkpKTtcbn07XG5jb25zdCBTZWxlY3QgPSAoeyBvcHRpb25zOiBvcHRpb25zUHJvcCwgY2xhc3NOYW1lLCBwbGFjZWhvbGRlciA9ICdDaG9vc2UgYW4gb3B0aW9uLi4uJywgbm9PcHRpb25zTWVzc2FnZSA9ICgpID0+ICdObyBtYXRjaGluZyBvcHRpb25zLi4uJywgZGlzYWJsZU5vT3B0aW9uc01lc3NhZ2UgPSBmYWxzZSwgaXNMb2FkaW5nID0gZmFsc2UsIG1lbnVJc09wZW4gPSBmYWxzZSwgY2xhc3NOYW1lczogY2xhc3NOYW1lc1Byb3AsIGFsbEdyb3Vwc0VtcHR5ID0gZmFsc2UsIGlucHV0VHlwZUlzVGV4dCA9IGZhbHNlLCBvbmx5Q2FsbE9uQ2hhbmdlRm9yRWRpdHMgPSB0cnVlLCBvbklucHV0Q2hhbmdlLCBvbklucHV0Q2hhbmdlRGVib3VuY2VkLCBmb3JtYXRWYWx1ZSwgaXNEaXNhYmxlZCA9IGZhbHNlLCBpbnB1dFZhbHVlOiBpbnB1dFZhbHVlUHJvcCwgZGVib3VuY2VUaW1lID0gMzAwLCBvbktleURvd24sIGRpc2FibGVJbnRlcm5hbEZpbHRlciwgZmlsdGVyT3B0aW9uLCBpc1NlYXJjaGFibGUgPSBmYWxzZSwgaXNNdWx0aSA9IGZhbHNlLCBjbG9zZU1lbnVPblNlbGVjdCA9ICFpc011bHRpLCB2YWx1ZTogdmFsdWVQcm9wLCBvbkNoYW5nZSwgaGlkZURyb3Bkb3duSW5kaWNhdG9yOiBoaWRlRHJvcGRvd25JbmRpY2F0b3JQcm9wLCBoaWRlQ2xlYXJCdXR0b24sIHNob3dFbXB0eU1lc3NhZ2VGb3JFbXB0eUlucHV0VmFsdWUgPSBmYWxzZSwgaGlkZU1lbnVPbkVtcHR5U2VhcmNoVGVybSA9IGZhbHNlLCBsYWJlbCwgbGFiZWxIZWxwVG9vbHRpcENvbnRlbnQsIGxhYmVsSXNDb21wYWN0ID0gdHJ1ZSwgZGlzcGxheVRvb2x0aXBGb3JTZWxlY3RlZEl0ZW0gPSBmYWxzZSwga2VlcElucHV0VmFsdWVPbkJsdXIgPSBmYWxzZSwgbWF4T3B0aW9ucywgYWxsb3dNdWx0aVNlbGVjdGVkT3B0aW9uc0hlaWdodFRvRXhwYW5kLCBrZWVwTGFiZWxIZWxwVG9vbHRpcE9wZW5PbkhvdmVyLCAuLi5wcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgW2lzT3Blbiwgc2V0SXNPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbaW5wdXRWYWx1ZUludGVybmFsLCBzZXRJbnB1dFZhbHVlSW50ZXJuYWxdID0gdXNlU3RhdGUoaW5wdXRWYWx1ZVByb3ApO1xuICAgIGNvbnN0IFtyZW5kZXJlZEl0ZW1zQ291bnRCeUdyb3VwSWQsIHNldFJlbmRlcmVkSXRlbXNDb3VudEJ5R3JvdXBJZF0gPSB1c2VTdGF0ZSh7fSk7XG4gICAgY29uc3QgW3JlbmRlcmVkVmFsdWVzQnlHcm91cElkLCBzZXRSZW5kZXJlZFZhbHVlc0J5R3JvdXBJZF0gPSB1c2VTdGF0ZSh7fSk7XG4gICAgY29uc3QgW3NlbGVjdGVkLCBzZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZSgodmFsdWVQcm9wIHx8IFtdKSk7XG4gICAgLy8gVGhpcyB0cmFja3MgdGhlIGN1cnJlbnRseSBmb2N1c3NlZCBzZWxlY3QgYm94XG4gICAgLy8gVGhlcmUgYXJlIE4gR3JvdXBzICsgMSBib3hlc1xuICAgIGNvbnN0IFtncm91cFNlbGVjdEJveEZvY3VzSW5kZXgsIHNldEdyb3VwU2VsZWN0Qm94Rm9jdXNJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBjbG9zaW5nRHJvcERvd25EaXNhYmxlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgY2xvc2luZ0Ryb3BEb3duRGlzYWJsZWRUaW1lb3V0UmVmID0gdXNlUmVmKCk7XG4gICAgY29uc3QgaW5wdXRWYWx1ZSA9IChpbnB1dFZhbHVlUHJvcCA9PT0gdW5kZWZpbmVkID8gaW5wdXRWYWx1ZUludGVybmFsIDogaW5wdXRWYWx1ZVByb3ApIHx8ICcnO1xuICAgIGNvbnN0IGlucHV0VmFsdWVFbXB0eSA9ICEoaW5wdXRWYWx1ZSB8fCAnJykudHJpbSgpO1xuICAgIGNvbnN0IG9wZW4gPSBpc1NlYXJjaGFibGUgJiYgaGlkZU1lbnVPbkVtcHR5U2VhcmNoVGVybSAmJiBpbnB1dFZhbHVlRW1wdHlcbiAgICAgICAgPyBmYWxzZVxuICAgICAgICA6IG1lbnVJc09wZW4gfHwgaXNPcGVuO1xuICAgIGNvbnN0IG9wdGlvbnNBcmVHcm91cGVkID0gKG9wdGlvbnMpID0+ICdncm91cElkJyBpbiAob3B0aW9ucz8uWzBdIHx8IHt9KSAmJiAnb3B0aW9ucycgaW4gKG9wdGlvbnM/LlswXSB8fCB7fSk7XG4gICAgY29uc3QgcGFyc2VHcm91cGVkT3B0aW9ucyA9IChvcHRpb25zKSA9PiBvcHRpb25zQXJlR3JvdXBlZChvcHRpb25zKSA/IG9wdGlvbnMgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb3B0aW9uc0FyZU5vbkdyb3VwZWQgPSAob3B0aW9ucykgPT4gIW9wdGlvbnNBcmVHcm91cGVkKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlTm9uR3JvdXBlZE9wdGlvbnMgPSAob3B0aW9ucykgPT4gb3B0aW9uc0FyZU5vbkdyb3VwZWQob3B0aW9ucykgPyBvcHRpb25zIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vbkdyb3VwZWRPcHRpb25zID0gcGFyc2VOb25Hcm91cGVkT3B0aW9ucyhvcHRpb25zUHJvcCk7XG4gICAgY29uc3QgZ3JvdXBlZE9wdGlvbnMgPSBwYXJzZUdyb3VwZWRPcHRpb25zKG9wdGlvbnNQcm9wKT8ubWFwKCh7IGdyb3VwSWQsIG9wdGlvbnM6IG9wdHMsIC4uLnJlc3QgfSkgPT4gKHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgb3B0aW9uczogb3B0cy5tYXAoKG9wdCkgPT4gKHsgLi4ub3B0LCBncm91cElkIH0pKSxcbiAgICB9KSk7XG4gICAgY29uc3QgZ3JvdXBzQ291bnQgPSBncm91cGVkT3B0aW9ucz8ubGVuZ3RoIHx8IDA7XG4gICAgY29uc3QgW2dldEdyb3VwZWRTZWxlY3RSZWYsIHNldEdyb3VwZWRTZWxlY3RSZWZdID0gdXNlRHluYW1pY1JlZnMoe1xuICAgICAgICBpZHM6IFsuLi5BcnJheSgoZ3JvdXBlZE9wdGlvbnMgfHwgW10pLmxlbmd0aCArIDEpXS5tYXAoKHYsIGkpID0+IGkudG9TdHJpbmcoKSksXG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0R3JvdXBTZWxlY3RCb3hGb2N1c0luZGV4KDApO1xuICAgIH0sIFtvcGVuXSk7XG4gICAgY29uc3QgY29tYmluZWRPcHRpb25zID0gdXNlTWVtbygoKSA9PiBncm91cGVkT3B0aW9uc1xuICAgICAgICA/IGdyb3VwZWRPcHRpb25zPy5mbGF0TWFwKCh7IGdyb3VwSWQsIG9wdGlvbnM6IG9wdHMgfSkgPT4gb3B0cy5tYXAoKG9wdCkgPT4gKHtcbiAgICAgICAgICAgIC4uLm9wdCxcbiAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgIH0pKSlcbiAgICAgICAgOiBub25Hcm91cGVkT3B0aW9ucz8ubWFwKChvcHQpID0+ICh7XG4gICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICBncm91cElkOiB1bmRlZmluZWQsXG4gICAgICAgIH0pKSwgW2dyb3VwZWRPcHRpb25zLCBub25Hcm91cGVkT3B0aW9uc10pO1xuICAgIGNvbnN0IGhpZGVEcm9wZG93bkluZGljYXRvciA9IGhpZGVEcm9wZG93bkluZGljYXRvclByb3AgfHxcbiAgICAgICAgLy8gSGlkZSB0aGUgZHJvcCBkb3duIGluZGljYXRvciBpZiBtdWx0aSBzZWxlY3QgYW5kIGFsbCBlbGVtZW50cyBhcmUgc2VsZWN0ZWRcbiAgICAgICAgKCEhc2VsZWN0ZWQubGVuZ3RoICYmXG4gICAgICAgICAgICBpc011bHRpICYmXG4gICAgICAgICAgICAhZ3JvdXBlZE9wdGlvbnMgJiZcbiAgICAgICAgICAgIHNlbGVjdGVkLmxlbmd0aCA9PT0gKGNvbWJpbmVkT3B0aW9ucyB8fCBbXSkubGVuZ3RoKTtcbiAgICBjb25zdCBvcHRpb25zQnlLZXkgPSBrZXlCeVdpdGhVbmRlZmluZWQoY29tYmluZWRPcHRpb25zLCAoeyBncm91cElkLCB2YWx1ZSB9KSA9PiBjcmVhdGVPcHRpb25LZXkoeyBncm91cElkLCB2YWx1ZSB9KSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRPcHRpb25zQnlLZXkgPSBrZXlCeVdpdGhVbmRlZmluZWQoc2VsZWN0ZWQsICh7IGdyb3VwSWQsIHZhbHVlIH0pID0+IGNyZWF0ZU9wdGlvbktleSh7IGdyb3VwSWQsIHZhbHVlIH0pKTtcbiAgICBjb25zdCBzZXRJbnB1dFZhbHVlSW50ZXJuYWxEZWJvdW5jZWQgPSB1c2VEZWJvdW5jZWRDYWxsYmFjaygodmFsdWUpID0+IG9uSW5wdXRDaGFuZ2VEZWJvdW5jZWQ/Lih2YWx1ZSksIGRlYm91bmNlVGltZSk7XG4gICAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSB1c2VDYWxsYmFjaygodmFsdWUsIGFjdGlvbikgPT4ge1xuICAgICAgICAvLyBzZXRHcm91cFNlbGVjdEJveEZvY3VzSW5kZXgoMCk7XG4gICAgICAgIGlmIChvbmx5Q2FsbE9uQ2hhbmdlRm9yRWRpdHNcbiAgICAgICAgICAgID8gVkFMSURfQUNUSU9OU19GT1JfQ0FMTElOR19JTlBVVF9DSEFOR0Uuc29tZSgodikgPT4gdiA9PT0gYWN0aW9uPy5hY3Rpb24pXG4gICAgICAgICAgICA6IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFZhbHVlID0gKGZvcm1hdFZhbHVlID8gZm9ybWF0VmFsdWUodmFsdWUpIDogdmFsdWUpIHx8ICcnO1xuICAgICAgICAgICAgc2V0SW5wdXRWYWx1ZUludGVybmFsKGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgICAgICAgIHNldElucHV0VmFsdWVJbnRlcm5hbERlYm91bmNlZChmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBvbklucHV0Q2hhbmdlPy4oZm9ybWF0dGVkVmFsdWUsIGFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uSW5wdXRDaGFuZ2UsXG4gICAgICAgIG9ubHlDYWxsT25DaGFuZ2VGb3JFZGl0cyxcbiAgICAgICAgc2V0SW5wdXRWYWx1ZUludGVybmFsRGVib3VuY2VkLFxuICAgICAgICBmb3JtYXRWYWx1ZSxcbiAgICBdKTtcbiAgICAvLyBUT0RPOiBDSEVDSyBBTkQgRklYIFRISVNcbiAgICBjb25zdCBoYW5kbGVCbHVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAoaXNTZWFyY2hhYmxlICYmXG4gICAgICAgICAgICAha2VlcElucHV0VmFsdWVPbkJsdXIgJiZcbiAgICAgICAgICAgICFjbG9zaW5nRHJvcERvd25EaXNhYmxlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVJbnB1dENoYW5nZSgnJywge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdpbnB1dC1jaGFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICBwcmV2SW5wdXRWYWx1ZTogaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIERFTEFZX0ZPUl9DTE9TSU5HX0RST1BfRE9XTik7XG4gICAgICAgIH1cbiAgICB9LCBbaXNTZWFyY2hhYmxlLCBoYW5kbGVJbnB1dENoYW5nZSwgaW5wdXRWYWx1ZSwga2VlcElucHV0VmFsdWVPbkJsdXJdKTtcbiAgICBjb25zdCB1cGRhdGVTZWxlY3RlZE9wdGlvbnMgPSB1c2VDYWxsYmFjaygoeyBzZWxlY3RlZDogbmV3U2VsLCBvdmVyd3JpdGUgPSAhZ3JvdXBlZE9wdGlvbnMgfHwgKGdyb3VwZWRPcHRpb25zICYmICFpc011bHRpKSwgZ3JvdXBJZCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdTZWxJc0FycmF5ID0gaXNBcnJheSRkKG5ld1NlbCk7XG4gICAgICAgIGxldCBuZXdTZWxlY3RlZCA9IChuZXdTZWxJc0FycmF5ID8gbmV3U2VsIDogW25ld1NlbF0pIHx8IFtdO1xuICAgICAgICBpZiAoIWdyb3VwZWRPcHRpb25zICYmIGlzTXVsdGkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFdoeSBpcyB0aGlzIGNvbWluZyB0aHJvdWdoIGFzIGFuIGFycmF5IG5lc3RlZCB3aXRoaW4gYW4gYXJyYXk/XG4gICAgICAgICAgICBuZXdTZWxlY3RlZCA9IG5ld1NlbFswXSB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICBuZXdTZWxlY3RlZCA9IG5ld1NlbGVjdGVkLmZpbHRlcigoeyB2YWx1ZSB9KSA9PiAhISh2YWx1ZSB8fCAnJykudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIHNldFNlbGVjdGVkKChwcmV2U2VsZWN0ZWQpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwcmV2U2VsZWN0ZWQ7XG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3U2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChncm91cGVkT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udW5pcUJ5JDEoW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJldlNlbGVjdGVkLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5ncm91cElkID09PSBncm91cElkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihuZXdTZWxlY3RlZCB8fCBbXSksXG4gICAgICAgICAgICAgICAgICAgIF0sICh7IHZhbHVlLCBncm91cElkOiBnSWQgfSkgPT4gY3JlYXRlT3B0aW9uS2V5KHsgZ3JvdXBJZDogZ0lkLCB2YWx1ZSB9KSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnByZXZTZWxlY3RlZC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uZ3JvdXBJZCAhPT0gZ3JvdXBJZCksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udW5pcUJ5JDEoWy4uLnByZXZTZWxlY3RlZCwgLi4ubmV3U2VsZWN0ZWRdLCAoeyB2YWx1ZSwgZ3JvdXBJZDogZ0lkIH0pID0+IGNyZWF0ZU9wdGlvbktleSh7IGdyb3VwSWQ6IGdJZCwgdmFsdWUgfSkpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgY2FsbGJhY2sgZm9yIGNvbnRyb2xsZWQgbW9kZVxuICAgICAgICAgICAgb25DaGFuZ2U/LihyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfSwgW2lzTXVsdGksIGdyb3VwZWRPcHRpb25zLCBvbkNoYW5nZV0pO1xuICAgIGNvbnN0IGNsZWFyU2VsZWN0ZWRPcHRpb25zID0gdXNlQ2FsbGJhY2soKCkgPT4gdXBkYXRlU2VsZWN0ZWRPcHRpb25zKHsgc2VsZWN0ZWQ6IFtdLCBvdmVyd3JpdGU6IHRydWUgfSksIFt1cGRhdGVTZWxlY3RlZE9wdGlvbnNdKTtcbiAgICBjb25zdCBoYW5kbGVGaWx0ZXJPcHRpb24gPSB1c2VDYWxsYmFjaygob3B0aW9uLCBpbnB1dFZhbHVlRm9yRmlsdGVyKSA9PiB7XG4gICAgICAgIGlmIChpc011bHRpICYmXG4gICAgICAgICAgICAhIXNlbGVjdGVkT3B0aW9uc0J5S2V5W2NyZWF0ZU9wdGlvbktleSh7XG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogb3B0aW9uLmRhdGEuZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uLmRhdGEudmFsdWUsXG4gICAgICAgICAgICB9KV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzYWJsZUludGVybmFsRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyT3B0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyT3B0aW9uPy4ob3B0aW9uLCBpbnB1dFZhbHVlRm9yRmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gREVGQVVMVF9GSUxURVIob3B0aW9uLCBpbnB1dFZhbHVlRm9yRmlsdGVyKTtcbiAgICB9LCBbZmlsdGVyT3B0aW9uLCBkaXNhYmxlSW50ZXJuYWxGaWx0ZXIsIHNlbGVjdGVkT3B0aW9uc0J5S2V5LCBpc011bHRpXSk7XG4gICAgY29uc3QgY2xhc3NOYW1lc0ludGVybmFsID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBjbGVhckluZGljYXRvcjogKCkgPT4gY2xhc3NOYW1lcyhzdHlsZXMkMS5jbGVhckluZGljYXRvciwgeyBbc3R5bGVzJDEuaGlkZV06IGhpZGVDbGVhckJ1dHRvbiB9KSxcbiAgICAgICAgY29udGFpbmVyOiAoeyBpc0ZvY3VzZWQgfSkgPT4gY2xhc3NOYW1lcyhjbGFzc05hbWUsIHN0eWxlcyQxLmNvbnRhaW5lciwge1xuICAgICAgICAgICAgW3N0eWxlcyQxLmlzRm9jdXNlZF06IGlzRm9jdXNlZCxcbiAgICAgICAgfSksXG4gICAgICAgIGNvbnRyb2w6ICh7IGlzRm9jdXNlZCB9KSA9PiBjbGFzc05hbWVzKHN0eWxlcyQxLmNvbnRyb2wsIHtcbiAgICAgICAgICAgIFtzdHlsZXMkMS5hbGxHcm91cHNFbXB0eVRleHRCbGlua2VyXTogIWlzU2VhcmNoYWJsZSxcbiAgICAgICAgICAgIFtzdHlsZXMkMS5pc0Rpc2FibGVkXTogaXNEaXNhYmxlZCxcbiAgICAgICAgICAgIFtzdHlsZXMkMS5pbnB1dFR5cGVJc1RleHRdOiBpbnB1dFR5cGVJc1RleHQsXG4gICAgICAgICAgICBbc3R5bGVzJDEuaXNGb2N1c2VkXTogaXNTZWFyY2hhYmxlID8gaXNGb2N1c2VkIDogb3BlbiAmJiBpc0ZvY3VzZWQsXG4gICAgICAgIH0pLFxuICAgICAgICBkcm9wZG93bkluZGljYXRvcjogKCkgPT4gY2xhc3NOYW1lcyhzdHlsZXMkMS5kcm9wZG93bkluZGljYXRvciwge1xuICAgICAgICAgICAgW3N0eWxlcyQxLmlzT3Blbl06IG9wZW4sXG4gICAgICAgICAgICBbc3R5bGVzJDEuYWxsR3JvdXBzRW1wdHldOiBhbGxHcm91cHNFbXB0eSxcbiAgICAgICAgICAgIFtzdHlsZXMkMS5pc0Rpc2FibGVkXTogaXNEaXNhYmxlZCxcbiAgICAgICAgICAgIFtzdHlsZXMkMS5oaWRlXTogaGlkZURyb3Bkb3duSW5kaWNhdG9yLFxuICAgICAgICB9KSxcbiAgICAgICAgaW5wdXQ6ICgpID0+IGNsYXNzTmFtZXMoc3R5bGVzJDEuaW5wdXQsIHtcbiAgICAgICAgICAgIFtzdHlsZXMkMS5pc0Rpc2FibGVkXTogaXNEaXNhYmxlZCxcbiAgICAgICAgICAgIFtzdHlsZXMkMS5pbnB1dFR5cGVJc1RleHRdOiBpbnB1dFR5cGVJc1RleHQsXG4gICAgICAgIH0pLFxuICAgICAgICBsb2FkaW5nSW5kaWNhdG9yOiAoKSA9PiBzdHlsZXMkMS5sb2FkaW5nSW5kaWNhdG9yLFxuICAgICAgICBtZW51OiAoKSA9PiBzdHlsZXMkMS5tZW51LFxuICAgICAgICBtZW51TGlzdDogKCkgPT4gc3R5bGVzJDEubWVudUxpc3QsXG4gICAgICAgIG11bHRpVmFsdWU6ICgpID0+IHN0eWxlcyQxLm11bHRpVmFsdWUsXG4gICAgICAgIG11bHRpVmFsdWVMYWJlbDogKCkgPT4gc3R5bGVzJDEubXVsdGlWYWx1ZUxhYmVsLFxuICAgICAgICBtdWx0aVZhbHVlUmVtb3ZlOiAoKSA9PiBzdHlsZXMkMS5tdWx0aVZhbHVlUmVtb3ZlLFxuICAgICAgICBub09wdGlvbnNNZXNzYWdlOiAoKSA9PiBzdHlsZXMkMS5ub09wdGlvbnNNZXNzYWdlLFxuICAgICAgICBvcHRpb246ICh7IGRhdGEsIGlzRm9jdXNlZCwgc2VsZWN0UHJvcHMsIH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWVzKHN0eWxlcyQxLm9wdGlvbiwge1xuICAgICAgICAgICAgICAgIFtzdHlsZXMkMS5pc1NlbGVjdGVkXTogISFzZWxlY3RlZE9wdGlvbnNCeUtleVtjcmVhdGVPcHRpb25LZXkoe1xuICAgICAgICAgICAgICAgICAgICBncm91cElkOiBkYXRhLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgICAgIH0pXSxcbiAgICAgICAgICAgICAgICBbc3R5bGVzJDEuaXNGb2N1c2VkXTogc2VsZWN0UHJvcHMuaXNGb2N1c2VkICYmIGlzRm9jdXNlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwbGFjZWhvbGRlcjogKCkgPT4gY2xhc3NOYW1lcyhzdHlsZXMkMS5wbGFjZWhvbGRlciwgeyBbc3R5bGVzJDEuaXNEaXNhYmxlZF06IGlzRGlzYWJsZWQgfSksXG4gICAgICAgIHZhbHVlQ29udGFpbmVyOiAoKSA9PiBjbGFzc05hbWVzKHN0eWxlcyQxLnZhbHVlQ29udGFpbmVyLCB7XG4gICAgICAgICAgICBbc3R5bGVzJDEuaXNEaXNhYmxlZF06IGlzRGlzYWJsZWQsXG4gICAgICAgICAgICBbc3R5bGVzJDEuaXNTY3JvbGxhYmxlXTogaXNNdWx0aSxcbiAgICAgICAgICAgIFtzdHlsZXMkMS5hbGxvd011bHRpU2VsZWN0ZWRPcHRpb25zSGVpZ2h0VG9FeHBhbmRdOiBpc011bHRpICYmIGFsbG93TXVsdGlTZWxlY3RlZE9wdGlvbnNIZWlnaHRUb0V4cGFuZCxcbiAgICAgICAgfSksXG4gICAgfSksIFtcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBhbGxHcm91cHNFbXB0eSxcbiAgICAgICAgaW5wdXRUeXBlSXNUZXh0LFxuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICBvcGVuLFxuICAgICAgICBpc1NlYXJjaGFibGUsXG4gICAgICAgIGhpZGVEcm9wZG93bkluZGljYXRvcixcbiAgICAgICAgc2VsZWN0ZWRPcHRpb25zQnlLZXksXG4gICAgICAgIGlzTXVsdGksXG4gICAgICAgIGhpZGVDbGVhckJ1dHRvbixcbiAgICAgICAgYWxsb3dNdWx0aVNlbGVjdGVkT3B0aW9uc0hlaWdodFRvRXhwYW5kLFxuICAgIF0pO1xuICAgIGNvbnN0IG9uTWVudUNsb3NlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgZW5zdXJlcyB0aGF0IHdoZW4gdXNpbmcgZ3JvdXBlZCBtb2RlLFxuICAgICAgICAvLyB0aGUgY2xpY2tlZCBvcHRpb24gaXMgcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIG1lbnUgaXMgYmx1cnJlZCBhbmQgY2xvc2VkXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbG9zaW5nRHJvcERvd25EaXNhYmxlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0SXNPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgREVMQVlfRk9SX0NMT1NJTkdfRFJPUF9ET1dOKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgb25NZW51T3BlbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0SXNPcGVuKHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBjbGVhcklucHV0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldElucHV0VmFsdWVJbnRlcm5hbCgnJyk7XG4gICAgICAgIHNldElucHV0VmFsdWVJbnRlcm5hbERlYm91bmNlZCgnJyk7XG4gICAgICAgIHNldElucHV0VmFsdWVJbnRlcm5hbERlYm91bmNlZC5mbHVzaCgpO1xuICAgIH0sIFtzZXRJbnB1dFZhbHVlSW50ZXJuYWxEZWJvdW5jZWRdKTtcbiAgICBjb25zdCBnZXRDdXJyZW50Rm9jdXNlZE9wdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgZm9jdXNlZE9wdGlvbiA9IGdldEdyb3VwZWRTZWxlY3RSZWYoZ3JvdXBTZWxlY3RCb3hGb2N1c0luZGV4KT8uc3RhdGVcbiAgICAgICAgICAgID8uZm9jdXNlZE9wdGlvbjtcbiAgICAgICAgcmV0dXJuIGZvY3VzZWRPcHRpb247XG4gICAgfSwgW2dyb3VwU2VsZWN0Qm94Rm9jdXNJbmRleCwgZ2V0R3JvdXBlZFNlbGVjdFJlZl0pO1xuICAgIGNvbnN0IGdldEN1cnJlbnRGb2N1c2VkR3JvdXBJbmRleCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBncm91cElkIH0gPSBnZXRDdXJyZW50Rm9jdXNlZE9wdGlvbigpIHx8IHt9O1xuICAgICAgICBjb25zdCBmb2N1c2VkR3JvdXBJbmRleCA9IGdyb3VwZWRPcHRpb25zPy5maW5kSW5kZXgoKHsgZ3JvdXBJZDogZ0lkIH0pID0+IGdyb3VwSWQgPT09IGdJZCk7XG4gICAgICAgIHJldHVybiBmb2N1c2VkR3JvdXBJbmRleCA9PT0gdW5kZWZpbmVkID8gLTEgOiBmb2N1c2VkR3JvdXBJbmRleDtcbiAgICB9LCBbZ3JvdXBlZE9wdGlvbnMsIGdldEN1cnJlbnRGb2N1c2VkT3B0aW9uXSk7XG4gICAgY29uc3QgZ2V0Q3VycmVudEZvY3VzZWRHcm91cCA9IHVzZUNhbGxiYWNrKCgpID0+IGdyb3VwZWRPcHRpb25zPy5bZ2V0Q3VycmVudEZvY3VzZWRHcm91cEluZGV4KCldLCBbZ3JvdXBlZE9wdGlvbnMsIGdldEN1cnJlbnRGb2N1c2VkR3JvdXBJbmRleF0pO1xuICAgIGNvbnN0IGdldEN1cnJlbnRGb2N1c2VkT3B0aW9uSW5kZXggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGdldEN1cnJlbnRGb2N1c2VkT3B0aW9uKCkgfHwge307XG4gICAgICAgIGNvbnN0IGZvY3VzZWRHcm91cCA9IGdldEN1cnJlbnRGb2N1c2VkR3JvdXAoKTtcbiAgICAgICAgY29uc3QgZm9jdXNlZEluZGV4ID0gZm9jdXNlZEdyb3VwPy5vcHRpb25zLmZpbmRJbmRleCgoeyB2YWx1ZTogdiB9KSA9PiB2ID09PSB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBmb2N1c2VkSW5kZXggPT09IHVuZGVmaW5lZCA/IC0xIDogZm9jdXNlZEluZGV4O1xuICAgIH0sIFtnZXRDdXJyZW50Rm9jdXNlZE9wdGlvbiwgZ2V0Q3VycmVudEZvY3VzZWRHcm91cF0pO1xuICAgIGNvbnN0IGdldFZpc2libGVPcHRpb25zQ291bnRGb3JHcm91cEluZGV4ID0gdXNlQ2FsbGJhY2soKGdyb3VwU2VsZWN0Qm94SW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldEdyb3VwZWRTZWxlY3RSZWYoZ3JvdXBTZWxlY3RCb3hJbmRleCk/LnN0YXRlXG4gICAgICAgICAgICA/LmZvY3VzYWJsZU9wdGlvbnNXaXRoSWRzPy5sZW5ndGg7XG4gICAgfSwgW2dldEdyb3VwZWRTZWxlY3RSZWZdKTtcbiAgICBjb25zdCB0ZW1wb3JhcmlseURpc2FibGVDbG9zaW5nR3JvdXBlZFNlbGVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKGdyb3VwZWRPcHRpb25zKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2luZ0Ryb3BEb3duRGlzYWJsZWRUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgY2xvc2luZ0Ryb3BEb3duRGlzYWJsZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBjbG9zaW5nRHJvcERvd25EaXNhYmxlZFRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsb3NpbmdEcm9wRG93bkRpc2FibGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIERFTEFZX0ZPUl9DTE9TSU5HX0RST1BfRE9XTiArIDUwKTtcbiAgICAgICAgfVxuICAgIH0sIFtncm91cGVkT3B0aW9uc10pO1xuICAgIGNvbnN0IGluY3JlbWVudEdyb3VwU2VsZWN0Rm9jdXNJbmRleCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0R3JvdXBTZWxlY3RCb3hGb2N1c0luZGV4KChpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZXROZXdJbmRleCA9IChvbGRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuZXdJbmRleCA9IGdyb3Vwc0NvdW50ID8gKG9sZEluZGV4ICsgMSkgJSAoZ3JvdXBzQ291bnQgKyAxKSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTWVudUNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wb3JhcmlseURpc2FibGVDbG9zaW5nR3JvdXBlZFNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWNoZWRTZWFyY2hCb3ggPSBvbGRJbmRleCA9PT0gZ3JvdXBzQ291bnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhIYXNOb09wdGlvbnMgPSAoaXNTZWFyY2hhYmxlID8gISFpbnB1dFZhbHVlIDogZmFsc2UpICYmXG4gICAgICAgICAgICAgICAgICAgICFyZWFjaGVkU2VhcmNoQm94ICYmXG4gICAgICAgICAgICAgICAgICAgICFnZXRWaXNpYmxlT3B0aW9uc0NvdW50Rm9yR3JvdXBJbmRleChuZXdJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWFjaGVkU2VhcmNoQm94ICYmIG5ld0luZGV4SGFzTm9PcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmV3IGdyb3VwIGlzIGVtcHR5LCBzbyBpdGVyYXRlIGFnYWluXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXROZXdJbmRleChuZXdJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdJbmRleDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleCA9IGdldE5ld0luZGV4KGkpO1xuICAgICAgICAgICAgZ2V0R3JvdXBlZFNlbGVjdFJlZihuZXdJbmRleCk/LmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3SW5kZXg7XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZ3JvdXBzQ291bnQsXG4gICAgICAgIG9uTWVudUNsb3NlLFxuICAgICAgICBnZXRHcm91cGVkU2VsZWN0UmVmLFxuICAgICAgICB0ZW1wb3JhcmlseURpc2FibGVDbG9zaW5nR3JvdXBlZFNlbGVjdCxcbiAgICAgICAgZ2V0VmlzaWJsZU9wdGlvbnNDb3VudEZvckdyb3VwSW5kZXgsXG4gICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgIGlzU2VhcmNoYWJsZSxcbiAgICBdKTtcbiAgICBjb25zdCBkZWNyZW1lbnRHcm91cFNlbGVjdEZvY3VzSW5kZXggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldEdyb3VwU2VsZWN0Qm94Rm9jdXNJbmRleCgoaSkgPT4ge1xuICAgICAgICAgICAgdGVtcG9yYXJpbHlEaXNhYmxlQ2xvc2luZ0dyb3VwZWRTZWxlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGdldE5ld0luZGV4ID0gKG9sZEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0luZGV4ID0gZ3JvdXBzQ291bnQgPyAoaSAtIDEpICUgKGdyb3Vwc0NvdW50ICsgMSkgOiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWNoZWRTZWFyY2hCb3ggPSBuZXdJbmRleCA9PT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFjaGVkRW5kID0gb2xkSW5kZXggPT09IGdyb3Vwc0NvdW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4SGFzTm9PcHRpb25zID0gIXJlYWNoZWRTZWFyY2hCb3ggJiYgIWdldFZpc2libGVPcHRpb25zQ291bnRGb3JHcm91cEluZGV4KG5ld0luZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWNoZWRTZWFyY2hCb3ggJiYgIXJlYWNoZWRFbmQgJiYgbmV3SW5kZXhIYXNOb09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZXcgZ3JvdXAgaXMgZW1wdHksIHNvIGl0ZXJhdGUgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5ld0luZGV4KG5ld0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0luZGV4O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gZ2V0TmV3SW5kZXgoaSk7XG4gICAgICAgICAgICBnZXRHcm91cGVkU2VsZWN0UmVmKG5ld0luZGV4KT8uZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdJbmRleDtcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBncm91cHNDb3VudCxcbiAgICAgICAgZ2V0R3JvdXBlZFNlbGVjdFJlZixcbiAgICAgICAgZ2V0VmlzaWJsZU9wdGlvbnNDb3VudEZvckdyb3VwSW5kZXgsXG4gICAgICAgIHRlbXBvcmFyaWx5RGlzYWJsZUNsb3NpbmdHcm91cGVkU2VsZWN0LFxuICAgIF0pO1xuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgb25LZXlEb3duPy4oZXZlbnRcbiAgICAgICAgLy8gaW5wdXRWYWx1ZVxuICAgICAgICApO1xuICAgICAgICBpZiAoZXZlbnQuY29kZSA9PT0gJ1RhYicpIHtcbiAgICAgICAgICAgIGlmIChncm91cGVkT3B0aW9ucyAmJiBvcGVuKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgc2hpZnQgdGFiIChiYWNrKVxuICAgICAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTZWxlY3RCb3hGb2N1c0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk1lbnVDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50R3JvdXBTZWxlY3RGb2N1c0luZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEdyb3VwU2VsZWN0Rm9jdXNJbmRleCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5jb2RlID09PSAnQXJyb3dEb3duJykge1xuICAgICAgICAgICAgaWYgKGdyb3VwZWRPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9jdXNlZEluZGV4ID0gZ2V0Q3VycmVudEZvY3VzZWRPcHRpb25JbmRleCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZvY3VzZWRJbmRleCA9IGZvY3VzZWRJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBPcHRpb25zQ291bnQgPSBNYXRoLm1pbihnZXRWaXNpYmxlT3B0aW9uc0NvdW50Rm9yR3JvdXBJbmRleChncm91cFNlbGVjdEJveEZvY3VzSW5kZXgpID8/XG4gICAgICAgICAgICAgICAgICAgIEluZmluaXR5LCBtYXhPcHRpb25zIHx8IEluZmluaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTZWxlY3RCb3hGb2N1c0luZGV4ID09PSAwICYmICFvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3Qgb3BlbiB0aGUgZHJvcCBkb3duIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIHNldElzT3Blbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRHcm91cFNlbGVjdEZvY3VzSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlbiAmJiBuZXdGb2N1c2VkSW5kZXggPiBncm91cE9wdGlvbnNDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50R3JvdXBTZWxlY3RGb2N1c0luZGV4KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNvZGUgPT09ICdBcnJvd1VwJykge1xuICAgICAgICAgICAgaWYgKGdyb3VwZWRPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9jdXNlZEluZGV4ID0gZ2V0Q3VycmVudEZvY3VzZWRPcHRpb25JbmRleCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZvY3VzZWRJbmRleCA9IGZvY3VzZWRJbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2VsZWN0Qm94Rm9jdXNJbmRleCA9PT0gMCkgO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wZW4gJiYgbmV3Rm9jdXNlZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRHcm91cFNlbGVjdEZvY3VzSW5kZXgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY29kZSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgaWYgKGdyb3VwU2VsZWN0Qm94Rm9jdXNJbmRleCA9PT0gMCAmJiBvcGVuKSB7XG4gICAgICAgICAgICAgICAgLyoqIFByZXNzZWQgdGhlIGVudGVyIGtleSAqL1xuICAgICAgICAgICAgICAgIGNsZWFySW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIG9uTWVudUNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBwcmVzc2luZyBlbnRlciBvbiB0aGUgc2VhcmNoIGJhciBpdHNlbGZcbiAgICAgICAgICAgIGlmIChncm91cGVkT3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgIGdyb3VwU2VsZWN0Qm94Rm9jdXNJbmRleCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICFpbnB1dFZhbHVlRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEF2YWlsYWJsZUdyb3VwSWQgPSBPYmplY3Qua2V5cyhyZW5kZXJlZFZhbHVlc0J5R3JvdXBJZClbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RBdmFpbGFibGVJdGVtSWQgPSAocmVuZGVyZWRWYWx1ZXNCeUdyb3VwSWRbZmlyc3RBdmFpbGFibGVHcm91cElkXSB8fCBbXSlbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RBdmFpbGFibGVJdGVtID0gb3B0aW9uc0J5S2V5W2NyZWF0ZU9wdGlvbktleSh7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGZpcnN0QXZhaWxhYmxlR3JvdXBJZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZpcnN0QXZhaWxhYmxlSXRlbUlkLFxuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTZWxlY3RlZCA9IGZpcnN0QXZhaWxhYmxlSXRlbSA/IFtmaXJzdEF2YWlsYWJsZUl0ZW1dIDogW107XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBJZCA9IGZpcnN0QXZhaWxhYmxlR3JvdXBJZDtcbiAgICAgICAgICAgICAgICB1cGRhdGVTZWxlY3RlZE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogbmV3U2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uS2V5RG93bixcbiAgICAgICAgaW5wdXRWYWx1ZUVtcHR5LFxuICAgICAgICBncm91cGVkT3B0aW9ucyxcbiAgICAgICAgb25NZW51Q2xvc2UsXG4gICAgICAgIHJlbmRlcmVkVmFsdWVzQnlHcm91cElkLFxuICAgICAgICBvcHRpb25zQnlLZXksXG4gICAgICAgIHVwZGF0ZVNlbGVjdGVkT3B0aW9ucyxcbiAgICAgICAgZ3JvdXBTZWxlY3RCb3hGb2N1c0luZGV4LFxuICAgICAgICBvcGVuLFxuICAgICAgICBjbGVhcklucHV0VmFsdWUsXG4gICAgICAgIGRlY3JlbWVudEdyb3VwU2VsZWN0Rm9jdXNJbmRleCxcbiAgICAgICAgaW5jcmVtZW50R3JvdXBTZWxlY3RGb2N1c0luZGV4LFxuICAgICAgICBnZXRDdXJyZW50Rm9jdXNlZE9wdGlvbkluZGV4LFxuICAgICAgICBnZXRWaXNpYmxlT3B0aW9uc0NvdW50Rm9yR3JvdXBJbmRleCxcbiAgICAgICAgbWF4T3B0aW9ucyxcbiAgICBdKTtcbiAgICBjb25zdCByZW5kZXJTZWxlY3QgPSB1c2VDYWxsYmFjaygob3B0cywgeyBjbGFzc05hbWVzOiBjbiA9IHt9LCAuLi5jdXN0b21Qcm9wcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIFRPRE86IFByb3Blcmx5IHR5cGUgdGhpcyBjb21wb25lbnRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdFNlbGVjdCwgeyAuLi5wcm9wcywgY2xhc3NOYW1lczogbWVyZ2VDbGFzc05hbWVzRnVuY3Rpb25zRGVlcCh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lczE6IG1lcmdlQ2xhc3NOYW1lc0Z1bmN0aW9uc0RlZXAoe1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzMTogY2xhc3NOYW1lc1Byb3AsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMyOiBjbixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzMjogY2xhc3NOYW1lc0ludGVybmFsLFxuICAgICAgICAgICAgfSksIGZpbHRlck9wdGlvbjogZmlsdGVyT3B0aW9uIHx8IGlzTXVsdGkgfHwgZGlzYWJsZUludGVybmFsRmlsdGVyXG4gICAgICAgICAgICAgICAgPyBoYW5kbGVGaWx0ZXJPcHRpb25cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgZ3JvdXBlZElzT3Blbjogb3BlbiwgaW5wdXRWYWx1ZTogaW5wdXRWYWx1ZSwgaW5zdGFuY2VJZDogXCJzZWxlY3RcIiwgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCwgaXNMb2FkaW5nOiBpc0xvYWRpbmcsIGlzU2VhcmNoYWJsZTogaXNTZWFyY2hhYmxlLCBrZXk6IHByb3BzLmlkLCBtZW51SXNPcGVuOiBvcGVuLCBub09wdGlvbnNNZXNzYWdlOiBkaXNhYmxlTm9PcHRpb25zTWVzc2FnZSA/ICgpID0+IG51bGwgOiBub09wdGlvbnNNZXNzYWdlLCBvbktleURvd246IGhhbmRsZUtleURvd24sIG9wdGlvbnM6IG9wdHMsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgdW5zdHlsZWQ6IHRydWUsIC4uLmN1c3RvbVByb3BzIH0pKTtcbiAgICB9LCBbXG4gICAgICAgIHByb3BzLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgbm9PcHRpb25zTWVzc2FnZSxcbiAgICAgICAgZGlzYWJsZU5vT3B0aW9uc01lc3NhZ2UsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgaXNEaXNhYmxlZCxcbiAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgZmlsdGVyT3B0aW9uLFxuICAgICAgICBpc1NlYXJjaGFibGUsXG4gICAgICAgIGNsYXNzTmFtZXNJbnRlcm5hbCxcbiAgICAgICAgY2xhc3NOYW1lc1Byb3AsXG4gICAgICAgIGhhbmRsZUZpbHRlck9wdGlvbixcbiAgICAgICAgZGlzYWJsZUludGVybmFsRmlsdGVyLFxuICAgICAgICBoYW5kbGVLZXlEb3duLFxuICAgICAgICBvcGVuLFxuICAgICAgICBpc011bHRpLFxuICAgIF0pO1xuICAgIGNvbnN0IGhhbmRsZUNoYW5nZU9uU2VhcmNoQmFyRm9yR3JvdXBlZE1vZGUgPSB1c2VDYWxsYmFjaygoc2VsKSA9PiB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGVkT3B0aW9ucyh7XG4gICAgICAgICAgICBzZWxlY3RlZDogKHNlbCB8fCBbXSkubWFwKCh7IGl0ZW1WYWx1ZSwgdmFsdWUsIC4uLnMgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5zLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtVmFsdWUsXG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogb3B0aW9uc0J5S2V5W3ZhbHVlXT8uZ3JvdXBJZCxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIG92ZXJ3cml0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW29wdGlvbnNCeUtleSwgdXBkYXRlU2VsZWN0ZWRPcHRpb25zXSk7XG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlT25MaXN0ID0gdXNlQ2FsbGJhY2soKHNlbCwgeyBncm91cElkIH0pID0+IHtcbiAgICAgICAgLy8gRW5hYmxlZCB0aGlzIGNvZGUgYmxvY2sgaWYgd2Ugd2FudCB0byBrZWVwIHRoZSBtZW51IG9wZW4gb24gaXRlbSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKGdyb3VwZWRPcHRpb25zICYmICFjbG9zZU1lbnVPblNlbGVjdCkge1xuICAgICAgICAgICAgdGVtcG9yYXJpbHlEaXNhYmxlQ2xvc2luZ0dyb3VwZWRTZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNsZWFySW5wdXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsIHx8IChpc0FycmF5JGQoc2VsKSAmJiAhc2VsLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhclNlbGVjdGVkT3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1NlbGVjdGVkID0gZ3JvdXBlZE9wdGlvbnNcbiAgICAgICAgICAgID8gKGlzQXJyYXkkZChzZWwpID8gc2VsIDogW3NlbF0pLm1hcCgoaXRlbSkgPT4gKHsgLi4uaXRlbSwgZ3JvdXBJZCB9KSlcbiAgICAgICAgICAgIDogW3NlbF07XG4gICAgICAgIHJldHVybiB1cGRhdGVTZWxlY3RlZE9wdGlvbnMoe1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IG5ld1NlbGVjdGVkLFxuICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBncm91cGVkT3B0aW9ucyxcbiAgICAgICAgY2xlYXJTZWxlY3RlZE9wdGlvbnMsXG4gICAgICAgIHVwZGF0ZVNlbGVjdGVkT3B0aW9ucyxcbiAgICAgICAgY2xvc2VNZW51T25TZWxlY3QsXG4gICAgICAgIGNsZWFySW5wdXRWYWx1ZSxcbiAgICAgICAgdGVtcG9yYXJpbHlEaXNhYmxlQ2xvc2luZ0dyb3VwZWRTZWxlY3QsXG4gICAgXSk7XG4gICAgY29uc3QgaW50ZXJuYWxWYWx1ZSA9IGlzTXVsdGlcbiAgICAgICAgPyBzZWxlY3RlZC5tYXAoKHMpID0+ICh7XG4gICAgICAgICAgICAuLi5zLFxuICAgICAgICAgICAgLi4uKGdyb3VwZWRPcHRpb25zXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1WYWx1ZTogcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNyZWF0ZU9wdGlvbktleSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cElkOiBzLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KSlcbiAgICAgICAgOiBzZWxlY3RlZFswXTtcbiAgICBsZXQgZXh0ZXJuYWxWYWx1ZSA9IG51bGw7XG4gICAgaWYgKHZhbHVlUHJvcCAhPT0gbnVsbCkge1xuICAgICAgICBleHRlcm5hbFZhbHVlID0gaXNNdWx0aVxuICAgICAgICAgICAgPyAodmFsdWVQcm9wIHx8IFtdKS5tYXAoKHMpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ucyxcbiAgICAgICAgICAgICAgICAuLi4oZ3JvdXBlZE9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtVmFsdWU6IHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3JlYXRlT3B0aW9uS2V5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cElkOiBzLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgOiAodmFsdWVQcm9wIHx8IFtdKVswXTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVSYXcgPSB2YWx1ZVByb3AgPT09IHVuZGVmaW5lZCAmJiBleHRlcm5hbFZhbHVlICE9PSBudWxsXG4gICAgICAgID8gaW50ZXJuYWxWYWx1ZVxuICAgICAgICA6IGV4dGVybmFsVmFsdWU7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlUmF3ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSRkKHZhbHVlUmF3KSA/IHZhbHVlUmF3IDogW3ZhbHVlUmF3XS5mbGF0TWFwKCh2KSA9PiB2IHx8IFtdKTtcbiAgICB9LCBbdmFsdWVSYXddKTtcbiAgICBjb25zdCBjb3JlU2VsZWN0Q29tbW9uUHJvcHMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIG9uSW5wdXRDaGFuZ2U6IGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgICAgICBvbk1lbnVDbG9zZSxcbiAgICAgICAgb25NZW51T3BlbixcbiAgICAgICAgaXNNdWx0aSxcbiAgICAgICAgY2xvc2VNZW51T25TZWxlY3QsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgICAgIHRhYlNlbGVjdHNWYWx1ZTogZmFsc2UsXG4gICAgfSksIFtcbiAgICAgICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgICAgIGlzTXVsdGksXG4gICAgICAgIG9uTWVudUNsb3NlLFxuICAgICAgICBvbk1lbnVPcGVuLFxuICAgICAgICBjbG9zZU1lbnVPblNlbGVjdCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGhhbmRsZUJsdXIsXG4gICAgXSk7XG4gICAgY29uc3Qgbm9uR3JvdXBlZFNlbGVjdFByb3BzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICAuLi5jb3JlU2VsZWN0Q29tbW9uUHJvcHMsXG4gICAgICAgIG1lbnVJc09wZW46IG9wZW4sXG4gICAgICAgIC8vIFRPRE86IEZpeCB0eXBpbmdzIG9uIHRoaXMgb25DaGFuZ2VcbiAgICAgICAgb25DaGFuZ2U6ICgobmV3U2VsZWN0ZWQpID0+IGhhbmRsZUNoYW5nZU9uTGlzdChuZXdTZWxlY3RlZCwge1xuICAgICAgICAgICAgZ3JvdXBJZDogdW5kZWZpbmVkLFxuICAgICAgICB9KSksXG4gICAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgICAgIE9wdGlvbixcbiAgICAgICAgICAgIENsZWFySW5kaWNhdG9yLFxuICAgICAgICAgICAgVmFsdWVDb250YWluZXIsXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXlUb29sdGlwRm9yU2VsZWN0ZWRJdGVtLFxuICAgICAgICAvLyBpc0ZvY3VzZWQ6IHRydWUsXG4gICAgfSksIFtcbiAgICAgICAgY29yZVNlbGVjdENvbW1vblByb3BzLFxuICAgICAgICBoYW5kbGVDaGFuZ2VPbkxpc3QsXG4gICAgICAgIG9wZW4sXG4gICAgICAgIGRpc3BsYXlUb29sdGlwRm9yU2VsZWN0ZWRJdGVtLFxuICAgIF0pO1xuICAgIGNvbnN0IGdyb3VwZWRTZWxlY3RQcm9wcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgLi4uY29yZVNlbGVjdENvbW1vblByb3BzLFxuICAgICAgICByZWY6IHNldEdyb3VwZWRTZWxlY3RSZWYoMCksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjbGFzc05hbWVzOiB7XG4gICAgICAgICAgICBjb250YWluZXI6ICgpID0+IHN0eWxlcyQxLmNvbnRhaW5lclNlYXJjaEdyb3VwLFxuICAgICAgICB9LFxuICAgICAgICBtYXhPcHRpb25zOiAwLFxuICAgICAgICBpc1NlYXJjaE9ubHk6IHRydWUsXG4gICAgICAgIG1lbnVJc09wZW46IGZhbHNlLFxuICAgICAgICAvLyBUT0RPOiBGaXggdHlwaW5ncyBvbiB0aGlzIG9uQ2hhbmdlXG4gICAgICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2VPblNlYXJjaEJhckZvckdyb3VwZWRNb2RlLFxuICAgICAgICAvLyBhdXRvRm9jdXM6IGdyb3VwU2VsZWN0Qm94Rm9jdXNJbmRleCA9PT0gMCxcbiAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgRHJvcGRvd25JbmRpY2F0b3IsXG4gICAgICAgICAgICBDbGVhckluZGljYXRvcixcbiAgICAgICAgfSxcbiAgICAgICAgaXNGb2N1c2VkOiBncm91cGVkT3B0aW9ucyA/IGdyb3VwU2VsZWN0Qm94Rm9jdXNJbmRleCA9PT0gMCA6IHRydWUsXG4gICAgfSksIFtcbiAgICAgICAgY29yZVNlbGVjdENvbW1vblByb3BzLFxuICAgICAgICBncm91cFNlbGVjdEJveEZvY3VzSW5kZXgsXG4gICAgICAgIGhhbmRsZUNoYW5nZU9uU2VhcmNoQmFyRm9yR3JvdXBlZE1vZGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBzZXRHcm91cGVkU2VsZWN0UmVmLFxuICAgICAgICBncm91cGVkT3B0aW9ucyxcbiAgICBdKTtcbiAgICBjb25zdCBsYWJlbFJlbmRlcmVkID0gdXNlTWVtbygoKSA9PiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcyQxLmxhYmVsQ29udGFpbmVyLCBjbGFzc05hbWVzUHJvcD8ubGFiZWxDb250YWluZXI/Lih7fSksIHtcbiAgICAgICAgICAgICAgICBbc3R5bGVzJDEuY29tcGFjdF06IGxhYmVsSXNDb21wYWN0LFxuICAgICAgICAgICAgfSksIGh0bWxGb3I6IHByb3BzLm5hbWUgfSxcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVGV4dCwgeyBib2xkNjAwOiB0cnVlLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzJDEubGFiZWwsIGNsYXNzTmFtZXNQcm9wPy5sYWJlbD8uKHt9KSksIGZvbnRTaXplOiBcInNtXCIgfSwgbGFiZWwpLFxuICAgICAgICAgICAgISFsYWJlbEhlbHBUb29sdGlwQ29udGVudCAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUb29sdGlwSGVscCwgeyBjbGFzc05hbWU6IHN0eWxlcyQxLmxhYmVsSGVscCwgY29udGVudDogbGFiZWxIZWxwVG9vbHRpcENvbnRlbnQsIGtlZXBUb29sdGlwT3Blbk9uSG92ZXI6IGtlZXBMYWJlbEhlbHBUb29sdGlwT3Blbk9uSG92ZXIgfSkpKSxcbiAgICAgICAgIWxhYmVsSXNDb21wYWN0ICYmIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3BhY2VyLCB7IGhlaWdodDogXCJ4c1wiLCBzY2FsZUZhY3RvcjogMC41IH0pKSksIFtcbiAgICAgICAgY2xhc3NOYW1lc1Byb3AsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBsYWJlbElzQ29tcGFjdCxcbiAgICAgICAgbGFiZWxIZWxwVG9vbHRpcENvbnRlbnQsXG4gICAgICAgIHByb3BzLm5hbWUsXG4gICAgICAgIGtlZXBMYWJlbEhlbHBUb29sdGlwT3Blbk9uSG92ZXIsXG4gICAgXSk7XG4gICAgY29uc3QgY29tbW9uV3JhcHBlclN0eWxlcyA9IHVzZU1lbW8oKCkgPT4gY2xhc3NOYW1lcyhzdHlsZXMkMS53cmFwcGVyLCBjbGFzc05hbWVzUHJvcD8ud3JhcHBlcj8uKHt9KSwge1xuICAgICAgICBbc3R5bGVzJDEuaXNNdWx0aVNlbGVjdF06IGlzTXVsdGksXG4gICAgICAgIFtzdHlsZXMkMS5kaXNhYmxlSW5wdXRIZWlnaHRdOiAhaXNPcGVuICYmIGlzTXVsdGkgJiYgISFzZWxlY3RlZC5sZW5ndGgsXG4gICAgfSksIFtjbGFzc05hbWVzUHJvcCwgaXNNdWx0aSwgaXNPcGVuLCBzZWxlY3RlZF0pO1xuICAgIGlmIChncm91cGVkT3B0aW9ucykge1xuICAgICAgICBjb25zdCBhbGxHcm91cHNFbXB0eSA9IChncm91cGVkT3B0aW9ucyB8fCBbXSkucmVkdWNlKChhbGxHcm91cHNFbXB0eVZhbHVlLCB7IGdyb3VwSWQgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9ICFyZW5kZXJlZEl0ZW1zQ291bnRCeUdyb3VwSWRbZ3JvdXBJZF07XG4gICAgICAgICAgICByZXR1cm4gYWxsR3JvdXBzRW1wdHlWYWx1ZSAmJiBpc0VtcHR5O1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZsZXgsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNvbW1vbldyYXBwZXJTdHlsZXMsIHN0eWxlcyQxLmlzR3JvdXBNb2RlKSwgaXNDb2x1bW46IHRydWUgfSxcbiAgICAgICAgICAgICEhbGFiZWwgJiYgbGFiZWxSZW5kZXJlZCxcbiAgICAgICAgICAgIHJlbmRlclNlbGVjdChbXSwgZ3JvdXBlZFNlbGVjdFByb3BzKSxcbiAgICAgICAgICAgICEhb3BlbiAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChGbGV4LCB7IGNsYXNzTmFtZTogc3R5bGVzJDEuZ3JvdXBzRHJvcERvd24sIGlzQ29sdW1uOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChGbGV4LCB7IGNsYXNzTmFtZTogc3R5bGVzJDEuZ3JvdXBzRHJvcERvd25Db250ZW50cywgaXNDb2x1bW46IHRydWUgfSwgKGdyb3VwZWRPcHRpb25zIHx8IFtdKS5tYXAoKHsgZ3JvdXBJZCwgbGFiZWw6IGdyb3VwZWRPcHRpb25MYWJlbCwgb3B0aW9uczogb3B0cyB9LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0ZvY3VzZWQgPSBncm91cFNlbGVjdEJveEZvY3VzSW5kZXggPT09IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9ICFyZW5kZXJlZEl0ZW1zQ291bnRCeUdyb3VwSWRbZ3JvdXBJZF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcmNlRW1wdHlNZXNzYWdlID0gYWxsR3JvdXBzRW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5kZXggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2hvd0VtcHR5TWVzc2FnZUZvckVtcHR5SW5wdXRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAhaW5wdXRWYWx1ZUVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZsZXgsIHsgY2xhc3NOYW1lOiBzdHlsZXMkMS5ncm91cFdyYXBwZXIsIGlzQ29sdW1uOiB0cnVlLCBrZXk6IGdyb3VwSWQgfSwgcmVuZGVyU2VsZWN0KG9wdHMubWFwKChvcHQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgICAgICAgICB9KSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBncm91cElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBzZXRHcm91cGVkU2VsZWN0UmVmKGluZGV4ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZvY3VzZWQ6IGdyb3VwZWRPcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBncm91cFNlbGVjdEJveEZvY3VzSW5kZXggPT09IGluZGV4ICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cExhYmVsOiBncm91cGVkT3B0aW9uTGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxHcm91cHNFbXB0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlRW1wdHlNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogKCkgPT4gc3R5bGVzJDEuY29udGFpbmVySXRlbXNHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51TGlzdDogaXNGb2N1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKCkgPT4gc3R5bGVzJDEuaXNGb2N1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbnU6ICFmb3JjZUVtcHR5TWVzc2FnZSAmJiBpc0VtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKCkgPT4gc3R5bGVzJDEuaXNIaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbnVMaXN0OiBNZW51TGlzdEdyb3VwZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlbmRlcmVkSXRlbXNDaGFuZ2U6ICh7IGdyb3VwSWQ6IGdJZCwgdmFsdWVzLCBjb3VudCwgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRJdGVtc0NvdW50QnlHcm91cElkW2dJZF0gIT09IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlbmRlcmVkSXRlbXNDb3VudEJ5R3JvdXBJZCgob2xkKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2dJZF06IGNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlbmRlcmVkVmFsdWVzQnlHcm91cElkKChvbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2dJZF06IHZhbHVlcyB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9taXQkMShuZXdWYWx1ZXMsIFtnSWRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEZpeCB0aGUgdHlwaW5ncyBvbiB0aGlzIG9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogKG5ld1NlbGVjdGVkKSA9PiBoYW5kbGVDaGFuZ2VPbkxpc3QobmV3U2VsZWN0ZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdXRvRm9jdXM6IGlzRm9jdXNlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQmx1cjogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUucmVsYXRlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25NZW51Q2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgfSkpKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZsZXgsIHsgY2xhc3NOYW1lOiBjb21tb25XcmFwcGVyU3R5bGVzLCBpc0NvbHVtbjogdHJ1ZSB9LFxuICAgICAgICAhIWxhYmVsICYmIGxhYmVsUmVuZGVyZWQsXG4gICAgICAgIHJlbmRlclNlbGVjdChub25Hcm91cGVkT3B0aW9ucyB8fCBbXSwgbm9uR3JvdXBlZFNlbGVjdFByb3BzKSkpO1xufTtcblxudmFyIHN0eWxlcyA9IHtcInRleHRBcmVhQ29tcG9uZW50XCI6XCJUZXh0QXJlYS1tb2R1bGVfdGV4dEFyZWFDb21wb25lbnRfX3NidXZDXCIsXCJ0ZXh0QXJlYVdyYXBwZXJcIjpcIlRleHRBcmVhLW1vZHVsZV90ZXh0QXJlYVdyYXBwZXJfX0JZd2hzXCIsXCJ0ZXh0QXJlYVwiOlwiVGV4dEFyZWEtbW9kdWxlX3RleHRBcmVhX180MUk4UVwiLFwiaGFzRXJyb3JcIjpcIlRleHRBcmVhLW1vZHVsZV9oYXNFcnJvcl9fVnhKTGlcIixcImlzRm9jdXNlZFwiOlwiVGV4dEFyZWEtbW9kdWxlX2lzRm9jdXNlZF9fN1pBTGxcIixcImVycm9yTWVzc2FnZVwiOlwiVGV4dEFyZWEtbW9kdWxlX2Vycm9yTWVzc2FnZV9fYXhZRUlcIn07XG5cbmNvbnN0IFRleHRBcmVhID0gKHsgY2xhc3NOYW1lLCBjbGFzc05hbWVzOiBjbGFzc05hbWVzUHJvcCwgbGFiZWwsIG5hbWUsIGVycm9yLCB0b3VjaGVkLCBvbkZvY3VzLCBvbkJsdXIsIG9uQ2xpY2ssIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBbaXNGb2N1c2VkLCBzZXRJc0ZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGhhbmRsZUZvY3VzID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgb25Gb2N1cz8uKGUpO1xuICAgICAgICBzZXRJc0ZvY3VzZWQodHJ1ZSk7XG4gICAgfSwgW29uRm9jdXNdKTtcbiAgICBjb25zdCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIG9uQ2xpY2s/LihlKTtcbiAgICAgICAgc2V0SXNGb2N1c2VkKHRydWUpO1xuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgY29uc3QgaGFuZGxlQmx1ciA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIG9uQmx1cj8uKGUpO1xuICAgICAgICBzZXRJc0ZvY3VzZWQoZmFsc2UpO1xuICAgIH0sIFtvbkJsdXJdKTtcbiAgICBjb25zdCBzaG93RXJyb3IgPSAhIXRvdWNoZWQgJiYgISFlcnJvciAmJiAhaXNGb2N1c2VkO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChGbGV4LCB7IGFsaWduSXRlbXM6IFwiZmxleC1zdGFydFwiLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzLnRleHRBcmVhQ29tcG9uZW50LCBjbGFzc05hbWUpLCBpc0NvbHVtbjogdHJ1ZSB9LFxuICAgICAgICAhIWxhYmVsICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHsgaHRtbEZvcjogbmFtZSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVGV4dCwgeyBib2xkNTAwOiB0cnVlLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzLmxhYmVsLCBjbGFzc05hbWVzUHJvcD8ubGFiZWwpLCBmb250U2l6ZTogXCJzbVwiIH0sIGxhYmVsKSksXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNwYWNlciwgeyBoZWlnaHQ6IFwieHNcIiwgc2NhbGVGYWN0b3I6IDAuNSB9KSkpLFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZsZXgsIHsgYWxpZ25JdGVtczogXCJjZW50ZXJcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcy50ZXh0QXJlYVdyYXBwZXIsIGNsYXNzTmFtZXNQcm9wPy5pbnB1dFdyYXBwZXIpIH0sXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIiwgeyAuLi5wcm9wcywgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHN0eWxlcy50ZXh0QXJlYSwgY2xhc3NOYW1lc1Byb3A/LmlucHV0LCB7XG4gICAgICAgICAgICAgICAgICAgIFtzdHlsZXMuaXNGb2N1c2VkXTogaXNGb2N1c2VkLFxuICAgICAgICAgICAgICAgICAgICBbc3R5bGVzLmhhc0Vycm9yXTogISFzaG93RXJyb3IsXG4gICAgICAgICAgICAgICAgfSksIG9uQmx1cjogaGFuZGxlQmx1ciwgb25DbGljazogaGFuZGxlQ2xpY2ssIG9uRm9jdXM6IGhhbmRsZUZvY3VzLCBvbldoZWVsOiAoZSkgPT4gZS50YXJnZXQuYmx1cigpIH0pKSxcbiAgICAgICAgISFzaG93RXJyb3IgJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3RfX2RlZmF1bHQuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNwYWNlciwgeyBoZWlnaHQ6IFwibWRcIiwgc2NhbGVGYWN0b3I6IDAuNSB9KSxcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVGV4dCwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMoc3R5bGVzLmVycm9yTWVzc2FnZSwgY2xhc3NOYW1lc1Byb3A/LmVycm9yTWVzc2FnZSksIGZvbnRTaXplOiBcInhzXCIgfSwgZXJyb3IpKSkpKTtcbn07XG5cbnZhciBjb21tb25TdHlsZXMgPSB7XCJpY29uXCI6XCJJY29uLW1vZHVsZV9pY29uX193aUxOaVwifTtcblxuY29uc3QgZ2VuZXJhdGVTdmdQcm9wcyA9ICh7IHByb3BzLCBjbGFzc05hbWUsIGlkLCB9KSA9PiB7XG4gICAgY29uc3QgeyBjbGFzc05hbWU6IHByb3BzQ2xhc3NOYW1lIH0gPSBwcm9wcztcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKGNvbW1vblN0eWxlcy5pY29uLCBjbGFzc05hbWUsIHByb3BzQ2xhc3NOYW1lKSxcbiAgICAgICAgaWQ6IGBpY29uLSR7aWR9YCxcbiAgICAgICAgeG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgICAgIHhtbG5zWGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgICB9O1xufTtcbmNvbnN0IGdlbmVyYXRlQ29sb3JQcm9wcyA9IChjb2xvcnMgPSBbXSwgZGVmYXVsdHMgPSBbXSkgPT4gWy4uLkFycmF5KDEwKV0ubWFwKChjb2xvciwgaW5kZXgpID0+ICh7XG4gICAgJ2RhdGEtY29sb3ItaW5kZXgnOiBpbmRleC50b1N0cmluZygpLFxuICAgIGZpbGw6IGNvbG9yc1tpbmRleF0gfHwgZGVmYXVsdHNbaW5kZXhdLFxufSkpO1xuXG5leHBvcnQgeyBBbmNob3IsIEJ1dHRvbiwgQ2FyZCwgQ2hlY2tib3gsIERyb3BEb3duV3JhcHBlciwgRmxleCwgSGVhZGVyQmFyLCBIZWFkZXJCYXJJdGVtLCBLbm9iUm90YXJ5LCBLbm9iUm90YXJ5V2l0aFRpY2tzLCBMaW5lLCBMb2FkaW5nU3Bpbm5lciwgTU9EQUxfREVGQVVMVF9aX0lOREVYLCBNb2RhbCwgTW9kYWxQcm92aWRlciwgUGFnZVBhZGRpbmdYLCBQYWdlUGFkZGluZ1ksIFBpbGwsIFNlbGVjdCwgU2xpZGVyLCBTbGlkZXJNZWNoYW5pc20sIFNwYWNlciwgVGV4dCwgVGV4dEFyZWEsIFRleHRJbnB1dCwgVGl0bGUsIFRvb2x0aXAsIFRvb2x0aXBDb250ZW50LCBUb29sdGlwU2ltcGxlLCBUb29sdGlwVHJpZ2dlciwgZGVmYXVsdFNob3VsZEJsdXJGdW5jdGlvbiwgZXh0cmFjdFN0YXRpY0ltYWdlLCBnZW5lcmF0ZUNvbG9yUHJvcHMsIGdlbmVyYXRlRm9udFNpemVDbGFzc05hbWUsIGdlbmVyYXRlU3ZnUHJvcHMsIGdldFRoZW1lVmFyaWFibGUsIGhhbmRsZUJsdXIsIHVzZUNsaWVudE1vdW50ZWRTdGF0ZSwgdXNlTWVkaWFRdWVyeSwgdXNlT25CbHVyLCB1c2VTY3JvbGwsIHVzZVNsaWRlck1lY2hhbmlzbVN0YXRlLCB1c2VTdGF0ZVdpdGhSZWYsIHVzZVRoZW1lU2NyZWVuU2l6ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlRvb2x0aXBGbG9hdGluZ0RlbGF5R3JvdXAiLCJGbG9hdGluZ0RlbGF5R3JvdXAiLCJBbmNob3IiLCJCdXR0b24iLCJDYXJkIiwiQ2hlY2tib3giLCJEcm9wRG93bldyYXBwZXIiLCJGbGV4IiwiSGVhZGVyQmFyIiwiSGVhZGVyQmFySXRlbSIsIktub2JSb3RhcnkiLCJLbm9iUm90YXJ5V2l0aFRpY2tzIiwiTGluZSIsIkxvYWRpbmdTcGlubmVyIiwiTU9EQUxfREVGQVVMVF9aX0lOREVYIiwiTW9kYWwiLCJNb2RhbFByb3ZpZGVyIiwiUGFnZVBhZGRpbmdYIiwiUGFnZVBhZGRpbmdZIiwiUGlsbCIsIlNlbGVjdCIsIlNsaWRlciIsIlNsaWRlck1lY2hhbmlzbSIsIlNwYWNlciIsIlRleHQiLCJUZXh0QXJlYSIsIlRleHRJbnB1dCIsIlRpdGxlIiwiVG9vbHRpcCIsIlRvb2x0aXBDb250ZW50IiwiVG9vbHRpcFNpbXBsZSIsIlRvb2x0aXBUcmlnZ2VyIiwiZGVmYXVsdFNob3VsZEJsdXJGdW5jdGlvbiIsImV4dHJhY3RTdGF0aWNJbWFnZSIsImdlbmVyYXRlQ29sb3JQcm9wcyIsImdlbmVyYXRlRm9udFNpemVDbGFzc05hbWUiLCJnZW5lcmF0ZVN2Z1Byb3BzIiwiZ2V0VGhlbWVWYXJpYWJsZSIsImhhbmRsZUJsdXIiLCJ1c2VDbGllbnRNb3VudGVkU3RhdGUiLCJ1c2VNZWRpYVF1ZXJ5IiwidXNlT25CbHVyIiwidXNlU2Nyb2xsIiwidXNlU2xpZGVyTWVjaGFuaXNtU3RhdGUiLCJ1c2VTdGF0ZVdpdGhSZWYiLCJ1c2VUaGVtZVNjcmVlblNpemUiLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJ4IiwiX19lc01vZHVsZSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImxpbmskMSIsImV4cG9ydHMiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQkMSIsIl8iLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJvYmoiLCJkZWZhdWx0IiwicmVzb2x2ZUhyZWYiLCJxdWVyeXN0cmluZyIsImhhc1JlcXVpcmVkUXVlcnlzdHJpbmciLCJyZXF1aXJlUXVlcnlzdHJpbmciLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJhc3NpZ24iLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsImZvckVhY2giLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwic3RyaW5naWZ5VXJsUXVlcnlQYXJhbSIsInBhcmFtIiwiaXNOYU4iLCJTdHJpbmciLCJ1cmxRdWVyeSIsInJlc3VsdCIsIlVSTFNlYXJjaFBhcmFtcyIsImVudHJpZXMiLCJpdGVtIiwiYXBwZW5kIiwic2V0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNlYXJjaFBhcmFtc0xpc3QiLCJfa2V5IiwiZnJvbSIsImtleXMiLCJkZWxldGUiLCJmb3JtYXRVcmwiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiaGFzUmVxdWlyZWRfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZV9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJub2RlSW50ZXJvcCIsIldlYWtNYXAiLCJjYWNoZUJhYmVsSW50ZXJvcCIsImNhY2hlTm9kZUludGVyb3AiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkJDEiLCJjYWNoZSIsImhhcyIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlc2MiLCJoYXNSZXF1aXJlZEZvcm1hdFVybCIsInJlcXVpcmVGb3JtYXRVcmwiLCJ1cmxPYmplY3RLZXlzIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJfcXVlcnlzdHJpbmciLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJob3N0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImluZGV4T2YiLCJwb3J0Iiwic2VhcmNoIiwiZW5kc1dpdGgiLCJzbGFzaGVzIiwidGVzdCIsInVybCIsInByb2Nlc3MiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJ3YXJuIiwib21pdCQyIiwiaGFzUmVxdWlyZWRPbWl0IiwicmVxdWlyZU9taXQiLCJvbWl0Iiwib2JqZWN0Iiwib21pdHRlZCIsInV0aWxzJDEiLCJoYXNSZXF1aXJlZFV0aWxzJDEiLCJyZXF1aXJlVXRpbHMkMSIsIldFQl9WSVRBTFMiLCJleGVjT25jZSIsImlzQWJzb2x1dGVVcmwiLCJnZXRMb2NhdGlvbk9yaWdpbiIsImdldFVSTCIsImdldERpc3BsYXlOYW1lIiwiaXNSZXNTZW50Iiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwibG9hZEdldEluaXRpYWxQcm9wcyIsIlNQIiwiU1QiLCJEZWNvZGVFcnJvciIsIk5vcm1hbGl6ZUVycm9yIiwiUGFnZU5vdEZvdW5kRXJyb3IiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIiwic3RyaW5naWZ5RXJyb3IiLCJmbiIsInVzZWQiLCJhcmdzIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwic3Vic3RyaW5nIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJyZXMiLCJmaW5pc2hlZCIsImhlYWRlcnNTZW50IiwidXJsUGFydHMiLCJzcGxpdCIsInVybE5vUXVlcnkiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJfQXBwX3Byb3RvdHlwZSIsImdldEluaXRpYWxQcm9wcyIsIm1lc3NhZ2UiLCJFcnJvciIsInBhZ2VQcm9wcyIsInByb3BzIiwicGVyZm9ybWFuY2UiLCJldmVyeSIsIm1ldGhvZCIsImNvbnN0cnVjdG9yIiwicGFnZSIsImNvZGUiLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFjayIsIm5vcm1hbGl6ZVRyYWlsaW5nU2xhc2giLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiaGFzUmVxdWlyZWRSZW1vdmVUcmFpbGluZ1NsYXNoIiwicmVxdWlyZVJlbW92ZVRyYWlsaW5nU2xhc2giLCJyb3V0ZSIsInBhcnNlUGF0aCIsImhhc1JlcXVpcmVkUGFyc2VQYXRoIiwicmVxdWlyZVBhcnNlUGF0aCIsInBhdGgiLCJoYXNoSW5kZXgiLCJxdWVyeUluZGV4IiwiaGFzUXVlcnkiLCJ1bmRlZmluZWQiLCJoYXNSZXF1aXJlZE5vcm1hbGl6ZVRyYWlsaW5nU2xhc2giLCJyZXF1aXJlTm9ybWFsaXplVHJhaWxpbmdTbGFzaCIsIm1vZHVsZSIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiX3JlbW92ZXRyYWlsaW5nc2xhc2giLCJfcGFyc2VwYXRoIiwic3RhcnRzV2l0aCIsImVudiIsIl9fTkVYVF9NQU5VQUxfVFJBSUxJTkdfU0xBU0giLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJpc0xvY2FsVXJsIiwiaGFzQmFzZVBhdGgiLCJwYXRoSGFzUHJlZml4IiwiaGFzUmVxdWlyZWRQYXRoSGFzUHJlZml4IiwicmVxdWlyZVBhdGhIYXNQcmVmaXgiLCJwcmVmaXgiLCJoYXNSZXF1aXJlZEhhc0Jhc2VQYXRoIiwicmVxdWlyZUhhc0Jhc2VQYXRoIiwiX3BhdGhoYXNwcmVmaXgiLCJiYXNlUGF0aCIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJoYXNSZXF1aXJlZElzTG9jYWxVcmwiLCJyZXF1aXJlSXNMb2NhbFVybCIsImlzTG9jYWxVUkwiLCJfdXRpbHMiLCJfaGFzYmFzZXBhdGgiLCJsb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiVVJMIiwidXRpbHMiLCJzb3J0ZWRSb3V0ZXMiLCJoYXNSZXF1aXJlZFNvcnRlZFJvdXRlcyIsInJlcXVpcmVTb3J0ZWRSb3V0ZXMiLCJnZXRTb3J0ZWRSb3V0ZXMiLCJVcmxOb2RlIiwiaW5zZXJ0IiwidXJsUGF0aCIsIl9pbnNlcnQiLCJmaWx0ZXIiLCJCb29sZWFuIiwic21vb3NoIiwiX3Ntb29zaCIsImNoaWxkcmVuUGF0aHMiLCJjaGlsZHJlbiIsInNvcnQiLCJzbHVnTmFtZSIsInNwbGljZSIsInJlc3RTbHVnTmFtZSIsIm9wdGlvbmFsUmVzdFNsdWdOYW1lIiwicm91dGVzIiwibWFwIiwiYyIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwicGxhY2Vob2xkZXIiLCJyIiwidW5zaGlmdCIsInVybFBhdGhzIiwic2x1Z05hbWVzIiwiaXNDYXRjaEFsbCIsIm5leHRTZWdtZW50Iiwic2VnbWVudE5hbWUiLCJpc09wdGlvbmFsIiwiaGFuZGxlU2x1ZyIsInByZXZpb3VzU2x1ZyIsIm5leHRTbHVnIiwic2x1ZyIsIk1hcCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCIsImlzRHluYW1pYyIsImhhc1JlcXVpcmVkSXNEeW5hbWljIiwicmVxdWlyZUlzRHluYW1pYyIsImlzRHluYW1pY1JvdXRlIiwiVEVTVF9ST1VURSIsImhhc1JlcXVpcmVkVXRpbHMiLCJyZXF1aXJlVXRpbHMiLCJfc29ydGVkcm91dGVzIiwiX2lzZHluYW1pYyIsImludGVycG9sYXRlQXMiLCJyb3V0ZU1hdGNoZXIiLCJoYXNSZXF1aXJlZFJvdXRlTWF0Y2hlciIsInJlcXVpcmVSb3V0ZU1hdGNoZXIiLCJnZXRSb3V0ZU1hdGNoZXIiLCJyZSIsImdyb3VwcyIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyYW1zIiwiZyIsIm0iLCJwb3MiLCJlbnRyeSIsInJlcGVhdCIsInJvdXRlUmVnZXgiLCJpbnRlcmNlcHRpb25Sb3V0ZXMiLCJhcHBQYXRocyIsImVuc3VyZUxlYWRpbmdTbGFzaCIsImhhc1JlcXVpcmVkRW5zdXJlTGVhZGluZ1NsYXNoIiwicmVxdWlyZUVuc3VyZUxlYWRpbmdTbGFzaCIsInNlZ21lbnQiLCJoYXNSZXF1aXJlZFNlZ21lbnQiLCJyZXF1aXJlU2VnbWVudCIsImlzR3JvdXBTZWdtZW50IiwiaGFzUmVxdWlyZWRBcHBQYXRocyIsInJlcXVpcmVBcHBQYXRocyIsIm5vcm1hbGl6ZUFwcFBhdGgiLCJub3JtYWxpemVSc2NQYXRoIiwiX2Vuc3VyZWxlYWRpbmdzbGFzaCIsIl9zZWdtZW50IiwiaW5kZXgiLCJzZWdtZW50cyIsImVuYWJsZWQiLCJoYXNSZXF1aXJlZEludGVyY2VwdGlvblJvdXRlcyIsInJlcXVpcmVJbnRlcmNlcHRpb25Sb3V0ZXMiLCJJTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUyIsImlzSW50ZXJjZXB0aW9uUm91dGVBcHBQYXRoIiwiZXh0cmFjdEludGVyY2VwdGlvblJvdXRlSW5mb3JtYXRpb24iLCJfYXBwcGF0aHMiLCJmaW5kIiwiaW50ZXJjZXB0aW5nUm91dGUiLCJtYXJrZXIiLCJpbnRlcmNlcHRlZFJvdXRlIiwiY29uY2F0Iiwic3BsaXRJbnRlcmNlcHRpbmdSb3V0ZSIsImVzY2FwZVJlZ2V4cCIsImhhc1JlcXVpcmVkRXNjYXBlUmVnZXhwIiwicmVxdWlyZUVzY2FwZVJlZ2V4cCIsImVzY2FwZVN0cmluZ1JlZ2V4cCIsInJlSGFzUmVnRXhwIiwicmVSZXBsYWNlUmVnRXhwIiwic3RyIiwiaGFzUmVxdWlyZWRSb3V0ZVJlZ2V4IiwicmVxdWlyZVJvdXRlUmVnZXgiLCJnZXRSb3V0ZVJlZ2V4IiwiZ2V0TmFtZWRSb3V0ZVJlZ2V4IiwiZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXgiLCJfaW50ZXJjZXB0aW9ucm91dGVzIiwiX2VzY2FwZXJlZ2V4cCIsIk5FWFRfUVVFUllfUEFSQU1fUFJFRklYIiwiTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCIsInBhcnNlUGFyYW1ldGVyIiwib3B0aW9uYWwiLCJnZXRQYXJhbWV0cml6ZWRSb3V0ZSIsImdyb3VwSW5kZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJtYXJrZXJNYXRjaCIsInBhcmFtTWF0Y2hlcyIsIm1hdGNoIiwibm9ybWFsaXplZFJvdXRlIiwiUmVnRXhwIiwiYnVpbGRHZXRTYWZlUm91dGVLZXkiLCJpIiwicm91dGVLZXkiLCJqIiwiZnJvbUNoYXJDb2RlIiwiTWF0aCIsImZsb29yIiwiZ2V0U2FmZUtleUZyb21TZWdtZW50IiwiZ2V0U2FmZVJvdXRlS2V5Iiwicm91dGVLZXlzIiwia2V5UHJlZml4IiwiY2xlYW5lZEtleSIsImludmFsaWRLZXkiLCJwYXJzZUludCIsImdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUiLCJwcmVmaXhSb3V0ZUtleXMiLCJuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSIsImhhc0ludGVyY2VwdGlvbk1hcmtlciIsInNvbWUiLCJwcmVmaXhSb3V0ZUtleSIsIm5hbWVkUmVnZXgiLCJvcHRpb25zIiwiY2F0Y2hBbGwiLCJjYXRjaEFsbFJlZ2V4IiwiY2F0Y2hBbGxHcm91cGVkUmVnZXgiLCJoYXNSZXF1aXJlZEludGVycG9sYXRlQXMiLCJyZXF1aXJlSW50ZXJwb2xhdGVBcyIsIl9yb3V0ZW1hdGNoZXIiLCJfcm91dGVyZWdleCIsImFzUGF0aG5hbWUiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImR5bmFtaWNHcm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsInJlcGxhY2VkIiwiaGFzUmVxdWlyZWRSZXNvbHZlSHJlZiIsInJlcXVpcmVSZXNvbHZlSHJlZiIsIl9mb3JtYXR1cmwiLCJfb21pdCIsIl9ub3JtYWxpemV0cmFpbGluZ3NsYXNoIiwiX2lzbG9jYWx1cmwiLCJfdXRpbHMxIiwiX2ludGVycG9sYXRlYXMiLCJyb3V0ZXIiLCJyZXNvbHZlQXMiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJ1cmxQcm90b01hdGNoIiwidXJsQXNTdHJpbmdOb1Byb3RvIiwibm9ybWFsaXplZFVybCIsImFzUGF0aCIsImZpbmFsVXJsIiwiaW50ZXJwb2xhdGVkQXMiLCJyZXNvbHZlZEhyZWYiLCJhZGRMb2NhbGUkMSIsImFkZExvY2FsZSIsImFkZFBhdGhQcmVmaXgiLCJoYXNSZXF1aXJlZEFkZFBhdGhQcmVmaXgiLCJyZXF1aXJlQWRkUGF0aFByZWZpeCIsImhhc1JlcXVpcmVkQWRkTG9jYWxlJDEiLCJyZXF1aXJlQWRkTG9jYWxlJDEiLCJfYWRkcGF0aHByZWZpeCIsImxvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJpZ25vcmVQcmVmaXgiLCJsb3dlciIsInRvTG93ZXJDYXNlIiwiaGFzUmVxdWlyZWRBZGRMb2NhbGUiLCJyZXF1aXJlQWRkTG9jYWxlIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsInJvdXRlckNvbnRleHRfc2hhcmVkUnVudGltZSIsImhhc1JlcXVpcmVkUm91dGVyQ29udGV4dF9zaGFyZWRSdW50aW1lIiwicmVxdWlyZVJvdXRlckNvbnRleHRfc2hhcmVkUnVudGltZSIsIlJvdXRlckNvbnRleHQiLCJfcmVhY3QiLCJSZWFjdF9fZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiLCJhcHBSb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWUiLCJoYXNSZXF1aXJlZEFwcFJvdXRlckNvbnRleHRfc2hhcmVkUnVudGltZSIsInJlcXVpcmVBcHBSb3V0ZXJDb250ZXh0X3NoYXJlZFJ1bnRpbWUiLCJDYWNoZVN0YXRlcyIsIkFwcFJvdXRlckNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIlRlbXBsYXRlQ29udGV4dCIsInVzZUludGVyc2VjdGlvbiIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYXNSZXF1aXJlZFJlcXVlc3RJZGxlQ2FsbGJhY2siLCJyZXF1aXJlUmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsImJpbmQiLCJjYiIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsInNldFRpbWVvdXQiLCJkaWRUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0IiwiaGFzUmVxdWlyZWRVc2VJbnRlcnNlY3Rpb24iLCJyZXF1aXJlVXNlSW50ZXJzZWN0aW9uIiwiX3JlcXVlc3RpZGxlY2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiaWRMaXN0IiwiY3JlYXRlT2JzZXJ2ZXIiLCJtYXJnaW4iLCJyb290TWFyZ2luIiwiZXhpc3RpbmciLCJpbnN0YW5jZSIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJjYWxsYmFjayIsImlzVmlzaWJsZSIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJvYnNlcnZlIiwiZWxlbWVudCIsInVub2JzZXJ2ZSIsInNpemUiLCJkaXNjb25uZWN0IiwiZmluZEluZGV4Iiwicm9vdFJlZiIsImRpc2FibGVkIiwiaXNEaXNhYmxlZCIsInZpc2libGUiLCJzZXRWaXNpYmxlIiwidXNlU3RhdGUiLCJlbGVtZW50UmVmIiwidXNlUmVmIiwic2V0RWxlbWVudCIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsInVzZUVmZmVjdCIsInRhZ05hbWUiLCJpZGxlQ2FsbGJhY2siLCJyZXNldFZpc2libGUiLCJnZXREb21haW5Mb2NhbGUiLCJub3JtYWxpemVMb2NhbGVQYXRoJDEiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiaGFzUmVxdWlyZWROb3JtYWxpemVMb2NhbGVQYXRoJDEiLCJyZXF1aXJlTm9ybWFsaXplTG9jYWxlUGF0aCQxIiwibG9jYWxlcyIsImRldGVjdGVkTG9jYWxlIiwicGF0aG5hbWVQYXJ0cyIsImhhc1JlcXVpcmVkTm9ybWFsaXplTG9jYWxlUGF0aCIsInJlcXVpcmVOb3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0RG9tYWluTG9jYWxlJDEiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJoYXNSZXF1aXJlZERldGVjdERvbWFpbkxvY2FsZSQxIiwicmVxdWlyZURldGVjdERvbWFpbkxvY2FsZSQxIiwiZG9tYWluSXRlbXMiLCJfaXRlbV9kb21haW4iLCJfaXRlbV9sb2NhbGVzIiwiZG9tYWluSG9zdG5hbWUiLCJkb21haW4iLCJoYXNSZXF1aXJlZERldGVjdERvbWFpbkxvY2FsZSIsInJlcXVpcmVEZXRlY3REb21haW5Mb2NhbGUiLCJoYXNSZXF1aXJlZEdldERvbWFpbkxvY2FsZSIsInJlcXVpcmVHZXREb21haW5Mb2NhbGUiLCJkb21haW5Mb2NhbGVzIiwicHJvdG8iLCJodHRwIiwiZmluYWxMb2NhbGUiLCJhZGRCYXNlUGF0aCIsImhhc1JlcXVpcmVkQWRkQmFzZVBhdGgiLCJyZXF1aXJlQWRkQmFzZVBhdGgiLCJyZXF1aXJlZCIsIl9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCIsInJvdXRlclJlZHVjZXJUeXBlcyIsImhhc1JlcXVpcmVkUm91dGVyUmVkdWNlclR5cGVzIiwicmVxdWlyZVJvdXRlclJlZHVjZXJUeXBlcyIsIlByZWZldGNoS2luZCIsIkFDVElPTl9SRUZSRVNIIiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1JFU1RPUkUiLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwiQUNUSU9OX1BSRUZFVENIIiwiQUNUSU9OX0ZBU1RfUkVGUkVTSCIsIkFDVElPTl9TRVJWRVJfQUNUSU9OIiwiX2RlZmF1bHQiLCJfcmVzb2x2ZWhyZWYiLCJfYWRkbG9jYWxlIiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX3VzZWludGVyc2VjdGlvbiIsIl9nZXRkb21haW5sb2NhbGUiLCJfYWRkYmFzZXBhdGgiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwicHJlZmV0Y2hlZCIsIlNldCIsInByZWZldGNoIiwiYXMiLCJhcHBPcHRpb25zIiwiaXNBcHBSb3V0ZXIiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJwcmVmZXRjaGVkS2V5IiwiYWRkIiwicHJlZmV0Y2hQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiZXZlbnRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm5hdGl2ZUV2ZW50Iiwid2hpY2giLCJsaW5rQ2xpY2tlZCIsImUiLCJzaGFsbG93Iiwic2Nyb2xsIiwicHJlZmV0Y2hFbmFibGVkIiwibm9kZU5hbWUiLCJpc0FuY2hvck5vZGVOYW1lIiwidG9VcHBlckNhc2UiLCJwcmV2ZW50RGVmYXVsdCIsIm5hdmlnYXRlIiwicm91dGVyU2Nyb2xsIiwiZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiIsInN0YXJ0VHJhbnNpdGlvbiIsImZvcm1hdFN0cmluZ09yVXJsIiwidXJsT2JqT3JTdHJpbmciLCJMaW5rIiwiZm9yd2FyZFJlZiIsIkxpbmtDb21wb25lbnQiLCJmb3J3YXJkZWRSZWYiLCJocmVmUHJvcCIsImFzUHJvcCIsImNoaWxkcmVuUHJvcCIsInByZWZldGNoUHJvcCIsInBhc3NIcmVmIiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VFbnRlclByb3AiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoU3RhcnRQcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJyZXN0UHJvcHMiLCJjcmVhdGVFbGVtZW50IiwicGFnZXNSb3V0ZXIiLCJ1c2VDb250ZXh0IiwiYXBwUm91dGVyIiwiYXBwUHJlZmV0Y2hLaW5kIiwiQVVUTyIsIkZVTEwiLCJjcmVhdGVQcm9wRXJyb3IiLCJleHBlY3RlZCIsImFjdHVhbCIsInJlcXVpcmVkUHJvcHNHdWFyZCIsInJlcXVpcmVkUHJvcHMiLCJvcHRpb25hbFByb3BzR3VhcmQiLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsImhhc0R5bmFtaWNTZWdtZW50IiwidXNlTWVtbyIsInJlc29sdmVkQXMiLCJwcmV2aW91c0hyZWYiLCJwcmV2aW91c0FzIiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJ0eXBlIiwiY2hpbGRSZWYiLCJyZWYiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJzZXRSZWYiLCJlbCIsImtpbmQiLCJjaGlsZFByb3BzIiwiZGVmYXVsdFByZXZlbnRlZCIsInByaW9yaXR5IiwiY3VyTG9jYWxlIiwibG9jYWxlRG9tYWluIiwiaXNMb2NhbGVEb21haW4iLCJjbG9uZUVsZW1lbnQiLCJsaW5rRXhwb3J0cyIsImxpbmsiLCJzdHlsZXMkcCIsIkEiLCJvcGVuc0luTmV3VGFiIiwiY2xhc3NOYW1lIiwiY2xhc3NOYW1lQW5jaG9yIiwidXNlTmV4dEpTTGluayIsImRpc2FibGUiLCJ1c2VTcGFuSW5saW5lIiwidXNlTmV4dEpTIiwiaGFuZGxlQ2xpY2siLCJjbGFzc05hbWVzIiwiYW5jaG9yIiwiaXNTcGFuIiwicmVsIiwiYW5jaG9yV3JhcHBlciIsImltYWdlSW1wb3J0IiwiU1RPUllCT09LIiwic3JjIiwiSEVBREVSX1NJWkVTIiwiZm9udFNpemUiLCJib2xkIiwiaXRhbGljIiwiYm9sZDUwMCIsImJvbGQ2MDAiLCJ1bmRlcmxpbmUiLCJpbmhlcml0Iiwibm90Qm9sZCIsImhlYWRlclZhcmlhbnQiLCJ1c2VIZWFkZXJGb250IiwiaGVhZGVyIiwiUE9TU0lCTEVfQ09MT1JTIiwiUE9TU0lCTEVfU0hBREVTIiwiZ2V0Q3NzVmFyaWFibGVGb3JDb2xvciIsImNvbG9yIiwic2hhZGUiLCJwYXJhbXNPYmoiLCJjc3NWYXJpYWJsZUtleSIsImV4Y2x1ZGVDb2xvcnMiLCJleGNsdWRlU2hhZGVzIiwicmFuZG9tQ29sb3IiLCJnZXROUmFuZG9tRWxlbWVudHNGcm9tQXJyYXkiLCJjb2wiLCJ0b1N0cmluZyIsImlzQnJvd3NlciIsImdldENvbXB1dGVkU3R5bGUiLCJkb2N1bWVudCIsImJvZHkiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiYmFzZUZpbmRLZXkkMSIsImNvbGxlY3Rpb24iLCJwcmVkaWNhdGUiLCJlYWNoRnVuYyIsIl9iYXNlRmluZEtleSIsImNyZWF0ZUJhc2VGb3IkMSIsImZyb21SaWdodCIsIml0ZXJhdGVlIiwia2V5c0Z1bmMiLCJpdGVyYWJsZSIsIl9jcmVhdGVCYXNlRm9yIiwiY3JlYXRlQmFzZUZvciIsImJhc2VGb3IkMSIsIl9iYXNlRm9yIiwiYmFzZVRpbWVzJDEiLCJuIiwiX2Jhc2VUaW1lcyIsImZyZWVHbG9iYWwkMSIsIl9mcmVlR2xvYmFsIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCQ4IiwiRnVuY3Rpb24iLCJfcm9vdCIsInJvb3QkNyIsIlN5bWJvbCQ2IiwiU3ltYm9sIiwiX1N5bWJvbCIsIlN5bWJvbCQ1Iiwib2JqZWN0UHJvdG8kZiIsImhhc093blByb3BlcnR5JGMiLCJuYXRpdmVPYmplY3RUb1N0cmluZyQxIiwic3ltVG9TdHJpbmdUYWckMSIsInRvU3RyaW5nVGFnIiwiZ2V0UmF3VGFnJDEiLCJpc093biIsInRhZyIsInVubWFza2VkIiwiX2dldFJhd1RhZyIsIm9iamVjdFByb3RvJGUiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsIm9iamVjdFRvU3RyaW5nJDEiLCJfb2JqZWN0VG9TdHJpbmciLCJTeW1ib2wkNCIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwiYmFzZUdldFRhZyQ3IiwiX2Jhc2VHZXRUYWciLCJpc09iamVjdExpa2UkOSIsImlzT2JqZWN0TGlrZV8xIiwiYmFzZUdldFRhZyQ2IiwiaXNPYmplY3RMaWtlJDgiLCJhcmdzVGFnJDMiLCJiYXNlSXNBcmd1bWVudHMkMSIsIl9iYXNlSXNBcmd1bWVudHMiLCJiYXNlSXNBcmd1bWVudHMiLCJpc09iamVjdExpa2UkNyIsIm9iamVjdFByb3RvJGQiLCJoYXNPd25Qcm9wZXJ0eSRiIiwicHJvcGVydHlJc0VudW1lcmFibGUkMSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMkMyIsImlzQXJndW1lbnRzXzEiLCJpc0FycmF5JGMiLCJpc0FycmF5XzEiLCJpc0FycmF5JGQiLCJpc0J1ZmZlciQzIiwic3R1YkZhbHNlIiwic3R1YkZhbHNlXzEiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiaXNCdWZmZXJFeHBvcnRzIiwiTUFYX1NBRkVfSU5URUdFUiQxIiwicmVJc1VpbnQiLCJpc0luZGV4JDMiLCJfaXNJbmRleCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJpc0xlbmd0aCQzIiwiaXNMZW5ndGhfMSIsImJhc2VHZXRUYWckNSIsImlzTGVuZ3RoJDIiLCJpc09iamVjdExpa2UkNiIsImFyZ3NUYWckMiIsImFycmF5VGFnJDIiLCJib29sVGFnJDMiLCJkYXRlVGFnJDMiLCJlcnJvclRhZyQyIiwiZnVuY1RhZyQyIiwibWFwVGFnJDYiLCJudW1iZXJUYWckMyIsIm9iamVjdFRhZyQ0IiwicmVnZXhwVGFnJDMiLCJzZXRUYWckNiIsInN0cmluZ1RhZyQ0Iiwid2Vha01hcFRhZyQyIiwiYXJyYXlCdWZmZXJUYWckMyIsImRhdGFWaWV3VGFnJDQiLCJmbG9hdDMyVGFnJDIiLCJmbG9hdDY0VGFnJDIiLCJpbnQ4VGFnJDIiLCJpbnQxNlRhZyQyIiwiaW50MzJUYWckMiIsInVpbnQ4VGFnJDIiLCJ1aW50OENsYW1wZWRUYWckMiIsInVpbnQxNlRhZyQyIiwidWludDMyVGFnJDIiLCJ0eXBlZEFycmF5VGFncyIsImJhc2VJc1R5cGVkQXJyYXkkMSIsIl9iYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5JDQiLCJmdW5jIiwiX2Jhc2VVbmFyeSIsIl9ub2RlVXRpbCIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwiX25vZGVVdGlsRXhwb3J0cyIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkkMyIsIm5vZGVVdGlsJDIiLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5JDIiLCJpc1R5cGVkQXJyYXlfMSIsImJhc2VUaW1lcyIsImlzQXJndW1lbnRzJDIiLCJpc0FycmF5JGIiLCJpc0J1ZmZlciQyIiwiaXNJbmRleCQyIiwiaXNUeXBlZEFycmF5JDEiLCJvYmplY3RQcm90byRjIiwiaGFzT3duUHJvcGVydHkkYSIsImFycmF5TGlrZUtleXMkMiIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsIl9hcnJheUxpa2VLZXlzIiwib2JqZWN0UHJvdG8kYiIsImlzUHJvdG90eXBlJDMiLCJDdG9yIiwiX2lzUHJvdG90eXBlIiwib3ZlckFyZyQyIiwidHJhbnNmb3JtIiwiYXJnIiwiX292ZXJBcmciLCJvdmVyQXJnJDEiLCJuYXRpdmVLZXlzJDEiLCJfbmF0aXZlS2V5cyIsImlzUHJvdG90eXBlJDIiLCJuYXRpdmVLZXlzIiwib2JqZWN0UHJvdG8kYSIsImhhc093blByb3BlcnR5JDkiLCJiYXNlS2V5cyQyIiwiX2Jhc2VLZXlzIiwiaXNPYmplY3QkNyIsImlzT2JqZWN0XzEiLCJiYXNlR2V0VGFnJDQiLCJpc09iamVjdCQ2IiwiYXN5bmNUYWciLCJmdW5jVGFnJDEiLCJnZW5UYWckMSIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiQyIiwiaXNGdW5jdGlvbl8xIiwiaXNGdW5jdGlvbiQxIiwiaXNMZW5ndGgkMSIsImlzQXJyYXlMaWtlJDYiLCJpc0FycmF5TGlrZV8xIiwiYXJyYXlMaWtlS2V5cyQxIiwiYmFzZUtleXMkMSIsImlzQXJyYXlMaWtlJDUiLCJrZXlzJDUiLCJrZXlzXzEiLCJiYXNlRm9yIiwia2V5cyQ0IiwiYmFzZUZvck93biQzIiwiX2Jhc2VGb3JPd24iLCJsaXN0Q2FjaGVDbGVhciQxIiwiX19kYXRhX18iLCJfbGlzdENhY2hlQ2xlYXIiLCJlcSQ0Iiwib3RoZXIiLCJlcV8xIiwiZXEkMyIsImFzc29jSW5kZXhPZiQ0IiwiYXJyYXkiLCJfYXNzb2NJbmRleE9mIiwiYXNzb2NJbmRleE9mJDMiLCJhcnJheVByb3RvIiwibGlzdENhY2hlRGVsZXRlJDEiLCJkYXRhIiwibGFzdEluZGV4IiwicG9wIiwiX2xpc3RDYWNoZURlbGV0ZSIsImFzc29jSW5kZXhPZiQyIiwibGlzdENhY2hlR2V0JDEiLCJfbGlzdENhY2hlR2V0IiwiYXNzb2NJbmRleE9mJDEiLCJsaXN0Q2FjaGVIYXMkMSIsIl9saXN0Q2FjaGVIYXMiLCJhc3NvY0luZGV4T2YiLCJsaXN0Q2FjaGVTZXQkMSIsIl9saXN0Q2FjaGVTZXQiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSQ0IiwiY2xlYXIiLCJfTGlzdENhY2hlIiwiTGlzdENhY2hlJDMiLCJzdGFja0NsZWFyJDEiLCJfc3RhY2tDbGVhciIsInN0YWNrRGVsZXRlJDEiLCJfc3RhY2tEZWxldGUiLCJzdGFja0dldCQxIiwiX3N0YWNrR2V0Iiwic3RhY2tIYXMkMSIsIl9zdGFja0hhcyIsInJvb3QkNiIsImNvcmVKc0RhdGEkMSIsIl9jb3JlSnNEYXRhIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJJRV9QUk9UTyIsImlzTWFza2VkJDEiLCJfaXNNYXNrZWQiLCJmdW5jUHJvdG8kMiIsImZ1bmNUb1N0cmluZyQyIiwidG9Tb3VyY2UkMiIsIl90b1NvdXJjZSIsImlzRnVuY3Rpb24iLCJpc01hc2tlZCIsImlzT2JqZWN0JDUiLCJ0b1NvdXJjZSQxIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwiZnVuY1Byb3RvJDEiLCJvYmplY3RQcm90byQ5IiwiZnVuY1RvU3RyaW5nJDEiLCJoYXNPd25Qcm9wZXJ0eSQ4IiwicmVJc05hdGl2ZSIsImJhc2VJc05hdGl2ZSQxIiwicGF0dGVybiIsIl9iYXNlSXNOYXRpdmUiLCJnZXRWYWx1ZSQxIiwiX2dldFZhbHVlIiwiYmFzZUlzTmF0aXZlIiwiZ2V0VmFsdWUiLCJnZXROYXRpdmUkNyIsIl9nZXROYXRpdmUiLCJnZXROYXRpdmUkNiIsInJvb3QkNSIsIk1hcCQ0IiwiX01hcCIsImdldE5hdGl2ZSQ1IiwibmF0aXZlQ3JlYXRlJDQiLCJfbmF0aXZlQ3JlYXRlIiwibmF0aXZlQ3JlYXRlJDMiLCJoYXNoQ2xlYXIkMSIsIl9oYXNoQ2xlYXIiLCJoYXNoRGVsZXRlJDEiLCJfaGFzaERlbGV0ZSIsIm5hdGl2ZUNyZWF0ZSQyIiwiSEFTSF9VTkRFRklORUQkMiIsIm9iamVjdFByb3RvJDgiLCJoYXNPd25Qcm9wZXJ0eSQ3IiwiaGFzaEdldCQxIiwiX2hhc2hHZXQiLCJuYXRpdmVDcmVhdGUkMSIsIm9iamVjdFByb3RvJDciLCJoYXNPd25Qcm9wZXJ0eSQ2IiwiaGFzaEhhcyQxIiwiX2hhc2hIYXMiLCJuYXRpdmVDcmVhdGUiLCJIQVNIX1VOREVGSU5FRCQxIiwiaGFzaFNldCQxIiwiX2hhc2hTZXQiLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCQxIiwiX0hhc2giLCJIYXNoIiwiTGlzdENhY2hlJDIiLCJNYXAkMyIsIm1hcENhY2hlQ2xlYXIkMSIsIl9tYXBDYWNoZUNsZWFyIiwiaXNLZXlhYmxlJDEiLCJfaXNLZXlhYmxlIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSQ0IiwiX2dldE1hcERhdGEiLCJnZXRNYXBEYXRhJDMiLCJtYXBDYWNoZURlbGV0ZSQxIiwiX21hcENhY2hlRGVsZXRlIiwiZ2V0TWFwRGF0YSQyIiwibWFwQ2FjaGVHZXQkMSIsIl9tYXBDYWNoZUdldCIsImdldE1hcERhdGEkMSIsIm1hcENhY2hlSGFzJDEiLCJfbWFwQ2FjaGVIYXMiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVTZXQkMSIsIl9tYXBDYWNoZVNldCIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlJDMiLCJfTWFwQ2FjaGUiLCJMaXN0Q2FjaGUkMSIsIk1hcCQyIiwiTWFwQ2FjaGUkMiIsIkxBUkdFX0FSUkFZX1NJWkUkMSIsInN0YWNrU2V0JDEiLCJwYWlycyIsIl9zdGFja1NldCIsIkxpc3RDYWNoZSIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsIlN0YWNrJDMiLCJfU3RhY2siLCJIQVNIX1VOREVGSU5FRCIsInNldENhY2hlQWRkJDEiLCJfc2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyQxIiwiX3NldENhY2hlSGFzIiwiTWFwQ2FjaGUkMSIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJTZXRDYWNoZSQyIiwidmFsdWVzIiwiX1NldENhY2hlIiwiYXJyYXlTb21lJDEiLCJfYXJyYXlTb21lIiwiY2FjaGVIYXMkMiIsIl9jYWNoZUhhcyIsIlNldENhY2hlJDEiLCJhcnJheVNvbWUiLCJjYWNoZUhhcyQxIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMyIsImVxdWFsQXJyYXlzJDIiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsImVxdWFsRnVuYyIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsImFyclN0YWNrZWQiLCJvdGhTdGFja2VkIiwic2VlbiIsImFyclZhbHVlIiwib3RoVmFsdWUiLCJjb21wYXJlZCIsIm90aEluZGV4IiwiX2VxdWFsQXJyYXlzIiwicm9vdCQ0IiwiVWludDhBcnJheSQyIiwiVWludDhBcnJheSIsIl9VaW50OEFycmF5IiwibWFwVG9BcnJheSQxIiwiX21hcFRvQXJyYXkiLCJzZXRUb0FycmF5JDMiLCJfc2V0VG9BcnJheSIsIlN5bWJvbCQzIiwiVWludDhBcnJheSQxIiwiZXEkMiIsImVxdWFsQXJyYXlzJDEiLCJtYXBUb0FycmF5Iiwic2V0VG9BcnJheSQyIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUckNCIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMiIsImJvb2xUYWckMiIsImRhdGVUYWckMiIsImVycm9yVGFnJDEiLCJtYXBUYWckNSIsIm51bWJlclRhZyQyIiwicmVnZXhwVGFnJDIiLCJzZXRUYWckNSIsInN0cmluZ1RhZyQzIiwic3ltYm9sVGFnJDMiLCJhcnJheUJ1ZmZlclRhZyQyIiwiZGF0YVZpZXdUYWckMyIsInN5bWJvbFByb3RvJDIiLCJzeW1ib2xWYWx1ZU9mJDEiLCJ2YWx1ZU9mIiwiZXF1YWxCeVRhZyQxIiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJidWZmZXIiLCJjb252ZXJ0Iiwic3RhY2tlZCIsIl9lcXVhbEJ5VGFnIiwiYXJyYXlQdXNoJDMiLCJvZmZzZXQiLCJfYXJyYXlQdXNoIiwiYXJyYXlQdXNoJDIiLCJpc0FycmF5JGEiLCJiYXNlR2V0QWxsS2V5cyQyIiwic3ltYm9sc0Z1bmMiLCJfYmFzZUdldEFsbEtleXMiLCJhcnJheUZpbHRlciQxIiwicmVzSW5kZXgiLCJfYXJyYXlGaWx0ZXIiLCJzdHViQXJyYXkkMiIsInN0dWJBcnJheV8xIiwiYXJyYXlGaWx0ZXIiLCJzdHViQXJyYXkkMSIsIm9iamVjdFByb3RvJDYiLCJuYXRpdmVHZXRTeW1ib2xzJDEiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRTeW1ib2xzJDMiLCJzeW1ib2wiLCJfZ2V0U3ltYm9scyIsImJhc2VHZXRBbGxLZXlzJDEiLCJnZXRTeW1ib2xzJDIiLCJrZXlzJDMiLCJnZXRBbGxLZXlzJDIiLCJfZ2V0QWxsS2V5cyIsImdldEFsbEtleXMkMSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDMiLCJvYmplY3RQcm90byQ1IiwiaGFzT3duUHJvcGVydHkkNSIsImVxdWFsT2JqZWN0cyQxIiwib2JqUHJvcHMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsIm9ialN0YWNrZWQiLCJza2lwQ3RvciIsIm9ialZhbHVlIiwib2JqQ3RvciIsIm90aEN0b3IiLCJfZXF1YWxPYmplY3RzIiwiZ2V0TmF0aXZlJDQiLCJyb290JDMiLCJEYXRhVmlldyQxIiwiX0RhdGFWaWV3IiwiZ2V0TmF0aXZlJDMiLCJyb290JDIiLCJQcm9taXNlJDIiLCJfUHJvbWlzZSIsImdldE5hdGl2ZSQyIiwicm9vdCQxIiwiU2V0JDMiLCJfU2V0IiwiZ2V0TmF0aXZlJDEiLCJXZWFrTWFwJDIiLCJfV2Vha01hcCIsIkRhdGFWaWV3IiwiTWFwJDEiLCJQcm9taXNlJDEiLCJTZXQkMiIsIldlYWtNYXAkMSIsImJhc2VHZXRUYWckMyIsInRvU291cmNlIiwibWFwVGFnJDQiLCJvYmplY3RUYWckMyIsInByb21pc2VUYWciLCJzZXRUYWckNCIsIndlYWtNYXBUYWckMSIsImRhdGFWaWV3VGFnJDIiLCJkYXRhVmlld0N0b3JTdHJpbmciLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJnZXRUYWckNSIsIkFycmF5QnVmZmVyIiwiY3RvclN0cmluZyIsIl9nZXRUYWciLCJTdGFjayQyIiwiZXF1YWxBcnJheXMiLCJlcXVhbEJ5VGFnIiwiZXF1YWxPYmplY3RzIiwiZ2V0VGFnJDQiLCJpc0FycmF5JDkiLCJpc0J1ZmZlciQxIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUckMiIsImFyZ3NUYWckMSIsImFycmF5VGFnJDEiLCJvYmplY3RUYWckMiIsIm9iamVjdFByb3RvJDQiLCJoYXNPd25Qcm9wZXJ0eSQ0IiwiYmFzZUlzRXF1YWxEZWVwJDEiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsIl9iYXNlSXNFcXVhbERlZXAiLCJiYXNlSXNFcXVhbERlZXAiLCJpc09iamVjdExpa2UkNSIsImJhc2VJc0VxdWFsJDIiLCJfYmFzZUlzRXF1YWwiLCJTdGFjayQxIiwiYmFzZUlzRXF1YWwkMSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDEiLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEiLCJiYXNlSXNNYXRjaCQxIiwic291cmNlIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwic3JjVmFsdWUiLCJfYmFzZUlzTWF0Y2giLCJpc09iamVjdCQ0IiwiaXNTdHJpY3RDb21wYXJhYmxlJDIiLCJfaXNTdHJpY3RDb21wYXJhYmxlIiwiaXNTdHJpY3RDb21wYXJhYmxlJDEiLCJrZXlzJDIiLCJnZXRNYXRjaERhdGEkMSIsIl9nZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQyIiwiX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiYmFzZUlzTWF0Y2giLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQxIiwiYmFzZU1hdGNoZXMkMSIsIl9iYXNlTWF0Y2hlcyIsImJhc2VHZXRUYWckMiIsImlzT2JqZWN0TGlrZSQ0Iiwic3ltYm9sVGFnJDIiLCJpc1N5bWJvbCQ0IiwiaXNTeW1ib2xfMSIsImlzQXJyYXkkOCIsImlzU3ltYm9sJDMiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwiaXNLZXkkMyIsIl9pc0tleSIsIk1hcENhY2hlIiwiRlVOQ19FUlJPUl9URVhUIiwibWVtb2l6ZSQxIiwicmVzb2x2ZXIiLCJUeXBlRXJyb3IiLCJtZW1vaXplZCIsImFwcGx5IiwiQ2FjaGUiLCJtZW1vaXplXzEiLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQkMSIsIl9tZW1vaXplQ2FwcGVkIiwibWVtb2l6ZUNhcHBlZCIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJzdHJpbmdUb1BhdGgkMSIsInN0cmluZyIsImNoYXJDb2RlQXQiLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsIl9zdHJpbmdUb1BhdGgiLCJhcnJheU1hcCQzIiwiX2FycmF5TWFwIiwiU3ltYm9sJDIiLCJhcnJheU1hcCQyIiwiaXNBcnJheSQ3IiwiaXNTeW1ib2wkMiIsIklORklOSVRZJDIiLCJzeW1ib2xQcm90byQxIiwic3ltYm9sVG9TdHJpbmciLCJiYXNlVG9TdHJpbmckMSIsIl9iYXNlVG9TdHJpbmciLCJiYXNlVG9TdHJpbmciLCJ0b1N0cmluZyQxIiwidG9TdHJpbmdfMSIsImlzQXJyYXkkNiIsImlzS2V5JDIiLCJzdHJpbmdUb1BhdGgiLCJjYXN0UGF0aCQ0IiwiX2Nhc3RQYXRoIiwiaXNTeW1ib2wkMSIsIklORklOSVRZJDEiLCJ0b0tleSQ1IiwiX3RvS2V5IiwiY2FzdFBhdGgkMyIsInRvS2V5JDQiLCJiYXNlR2V0JDQiLCJfYmFzZUdldCIsImJhc2VHZXQkMyIsImdldCQxIiwiZGVmYXVsdFZhbHVlIiwiZ2V0XzEiLCJiYXNlSGFzSW4kMSIsIl9iYXNlSGFzSW4iLCJjYXN0UGF0aCQyIiwiaXNBcmd1bWVudHMkMSIsImlzQXJyYXkkNSIsImlzSW5kZXgkMSIsImlzTGVuZ3RoIiwidG9LZXkkMyIsImhhc1BhdGgkMSIsImhhc0Z1bmMiLCJfaGFzUGF0aCIsImJhc2VIYXNJbiIsImhhc1BhdGgiLCJoYXNJbiQxIiwiaGFzSW5fMSIsImJhc2VJc0VxdWFsIiwiaGFzSW4iLCJpc0tleSQxIiwiaXNTdHJpY3RDb21wYXJhYmxlIiwibWF0Y2hlc1N0cmljdENvbXBhcmFibGUiLCJ0b0tleSQyIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSQxIiwiX2Jhc2VNYXRjaGVzUHJvcGVydHkiLCJpZGVudGl0eSQ0IiwiaWRlbnRpdHlfMSIsImJhc2VQcm9wZXJ0eSQyIiwiX2Jhc2VQcm9wZXJ0eSIsImJhc2VHZXQkMiIsImJhc2VQcm9wZXJ0eURlZXAkMSIsIl9iYXNlUHJvcGVydHlEZWVwIiwiYmFzZVByb3BlcnR5JDEiLCJiYXNlUHJvcGVydHlEZWVwIiwiaXNLZXkiLCJ0b0tleSQxIiwicHJvcGVydHkkMSIsInByb3BlcnR5XzEiLCJiYXNlTWF0Y2hlcyIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJpZGVudGl0eSQzIiwiaXNBcnJheSQ0IiwicHJvcGVydHkiLCJiYXNlSXRlcmF0ZWUkNCIsIl9iYXNlSXRlcmF0ZWUiLCJiYXNlRmluZEtleSIsImJhc2VGb3JPd24kMiIsImJhc2VJdGVyYXRlZSQzIiwiZmluZEtleSIsImZpbmRLZXlfMSIsImZpbmRLZXkkMSIsImdldE5hdGl2ZSIsImRlZmluZVByb3BlcnR5JDIiLCJfZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSQxIiwiYmFzZUFzc2lnblZhbHVlJDMiLCJfYmFzZUFzc2lnblZhbHVlIiwiYmFzZUFzc2lnblZhbHVlJDIiLCJiYXNlRm9yT3duJDEiLCJiYXNlSXRlcmF0ZWUkMiIsIm1hcFZhbHVlcyIsIm1hcFZhbHVlc18xIiwibWFwVmFsdWVzJDEiLCJicFZhcmlhYmxlc1Njc3MiLCJCUF9WQVJJQUJMRVMiLCJyZXBsYWNlQWxsIiwiaXNNb3VudGVkR2xvYmFsIiwiaXNNb3VudGVkIiwic2V0SXNNb3VudGVkIiwiaXNDbGllbnQiLCJpc01vdW50ZWRDbGllbnQiLCJnZXRNYXRjaE1lZGlhIiwibWF0Y2hTdHJpbmciLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsInNldE1hdGNoZXMiLCJoYW5kbGVNZWRpYUNoYW5nZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVxdWVzdGVkU2l6ZSIsInhzIiwic20iLCJtZCIsImxnIiwieGwiLCJ4eGwiLCJzY3JlZW5TaXplT2JqZWN0Iiwic2NyZWVuU2l6ZSIsImlzU2NyZWVuU2l6ZSIsImJwVmFyaWFibGVLZXlzIiwiaW5kZXhPZlJlcXVlc3RlZFNpemUiLCJpbmRleE9mU2l6ZSIsImlzVmFsaWQiLCJpc1JlcXVlc3RlZFNpemUiLCJpc0xhcmdlclRoYW4iLCJpc1NtYWxsZXJUaGFuIiwiaXNTbWFsbGVyVGhhbkluY2x1ZGluZyIsImlzTGFyZ2VyVGhhbkluY2x1ZGluZyIsIkRFRkFVTFRfQkxVUl9GVU5DIiwiYmx1ckVsZW1lbnRSZWYiLCJibHVyRWxlbWVudCIsImJsdXJFbGVtZW50UGFyYW0iLCJyZWxhdGVkVGFyZ2V0IiwidGFyZ2V0Q29udGFpbmVkSW5CbHVyIiwiY29udGFpbnMiLCJyZWxhdGVkVGFyZ2V0Q29udGFpbmVkSW5CbHVyIiwib25CbHVyIiwic2hvdWxkQmx1ciIsInNob3VsZERpc2FibGVCbHVyIiwic2hvdWxkRm9yY2VCbHVyIiwicmV0dXJuQm9vbGVhbiIsImRlZmF1bHRTaG91bGRCbHVyIiwiaGFuZGxlQ2xpY2tCbHVyTGlzdGVuZXIiLCJpbml0aWFsVmFsdWUiLCJzdGF0ZSIsInNldFN0YXRlIiwic3RhdGVSZWYiLCJoYW5kbGVTZXRTdGF0ZSIsInVwZGF0ZSIsInJhd05leHRWYWx1ZSIsInRyYW5zZm9ybWVkIiwic2V0U3RhdGVUcmFuc2Zvcm0iLCJvbkNoYW5nZSIsInByZXZWYWx1ZSIsImhhbmRsZUdldFN0YXRlIiwiZ2V0U3RhdGUiLCJzY3JvbGxDb250YWluZXJFbGVtZW50UmVmIiwic2Nyb2xsQ29udGFpbmVyRWxlbWVudCIsInNjcm9sbENvbnRhaW5lckVsZW1lbnRQcm9wIiwiZGlzYWJsZVN0YXRlVXBkYXRlcyIsIm9uU2Nyb2xsIiwic2Nyb2xsVG9wIiwic2V0U2Nyb2xsVG9wIiwic2Nyb2xsVG9wUmVmIiwiaGFuZGxlU2Nyb2xsIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiZ2V0U2Nyb2xsVG9wIiwicGFzc2l2ZSIsIlRvb2x0aXBDb250ZXh0IiwiUmVhY3QiLCJ1c2VUb29sdGlwQ29udGV4dCIsImNvbnRleHQiLCJUT09MVElQX0RFTEFZX0RFRkFVTFQiLCJ1c2VUb29sdGlwIiwiaW5pdGlhbE9wZW4iLCJwbGFjZW1lbnQiLCJvcGVuIiwiY29udHJvbGxlZE9wZW4iLCJvbk9wZW5DaGFuZ2UiLCJzZXRDb250cm9sbGVkT3BlbiIsIm9mZnNldCQxIiwiZGVsYXkiLCJkZWxheUZyb21PcHRpb25zIiwiZGlzYWJsZUhvdmVyIiwiZGlzYWJsZUZvY3VzIiwidW5jb250cm9sbGVkT3BlbiIsInNldFVuY29udHJvbGxlZE9wZW4iLCJzZXRPcGVuIiwidXNlRGVsYXlHcm91cENvbnRleHQiLCJ1c2VGbG9hdGluZyIsIndoaWxlRWxlbWVudHNNb3VudGVkIiwiYXV0b1VwZGF0ZSIsIm1pZGRsZXdhcmUiLCJmbGlwIiwiZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiIsInBhZGRpbmciLCJzaGlmdCIsImhvdmVyIiwidXNlSG92ZXIiLCJtb3ZlIiwiZm9jdXMiLCJ1c2VGb2N1cyIsImRpc21pc3MiLCJ1c2VEaXNtaXNzIiwicm9sZSIsInVzZVJvbGUiLCJpbnRlcmFjdGlvbnMiLCJ1c2VJbnRlcmFjdGlvbnMiLCJ0b29sdGlwUmVmIiwidG9vbHRpcCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJQcm92aWRlciIsInN0eWxlc1Njc3MiLCJhc0NoaWxkIiwiZGlzcGxheUFzSW5saW5lVGV4dCIsInByb3BSZWYiLCJjaGlsZHJlblJlZiIsInVzZU1lcmdlUmVmcyIsInJlZnMiLCJzZXRSZWZlcmVuY2UiLCJwcm9wc1RvUGFzcyIsImdldFJlZmVyZW5jZVByb3BzIiwiaXNWYWxpZEVsZW1lbnQiLCJ0b29sdGlwVHJpZ2dlciIsImlzU2tpbm55IiwiZml0Q29udGVudCIsInN0eWxlIiwicmVuZGVySGlkZGVuQ2hpbGRyZW5XaGVuVG9vbHRpcENsb3NlZCIsImtlZXBUb29sdGlwT3Blbk9uSG92ZXIiLCJ1c2VJZCIsImlzSW5zdGFudFBoYXNlIiwiY3VycmVudElkIiwic2V0RmxvYXRpbmciLCJ1c2VEZWxheUdyb3VwIiwiaW5zdGFudER1cmF0aW9uIiwiZHVyYXRpb24iLCJzdHlsZXMiLCJ1c2VUcmFuc2l0aW9uU3R5bGVzIiwiY2xvc2UiLCJpbml0aWFsIiwib3BhY2l0eSIsInByb3BzRnJvbVN0YXRlIiwiZ2V0RmxvYXRpbmdQcm9wcyIsInN0eWxlVG9QYXNzIiwiZmxvYXRpbmdTdHlsZXMiLCJoaWRlQ29udGVudCIsIkZsb2F0aW5nUG9ydGFsIiwidG9vbHRpcENvbnRlbnQiLCJza2lubnkiLCJzdGF5T3Blbk9uSG92ZXIiLCJvbktleURvd24iLCJjb250ZW50IiwiY2xhc3NOYW1lQ29udGVudCIsImNvbnRlbnRSZWYiLCJzdHlsZUNvbnRlbnQiLCJpc0NsaWNrVG9PcGVuIiwib3BlblByb3AiLCJjb250ZW50UmVuZGVyUmVsaWVzT25CZWluZ09wZW4iLCJjbG9zZURlbGF5IiwicG9pbnRlckxlYXZlVGltZW91dFJlZiIsImhhbmRsZU9wZW5DaGFuZ2UiLCJuZXdPcGVuIiwiaGFuZGxlUG9pbnRlckVudGVyIiwiaGFuZGxlUG9pbnRlckxlYXZlIiwiaGFuZGxlVHJpZ2dlclBvaW50ZXJFbnRlciIsIkZyYWdtZW50Iiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsInN0eWxlcyRvIiwiaXNDb2x1bW4iLCJpc0NlbnRlcmVkIiwiaXNDZW50ZXJlZFgiLCJpc0NlbnRlcmVkWSIsImlzRnVsbFdpZHRoIiwiaXNGdWxsSGVpZ2h0IiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIiwiY2xhc3NOYW1lc0NvbWJpbmVkIiwiZmxleCIsInN0eWxlQ29tYmluZWQiLCJzdHlsZXMkbiIsImRpc2FibGVMZWZ0IiwiZGlzYWJsZVJpZ2h0IiwicGFnZVBhZGRpbmdYIiwiaXNEaXNhYmxlZFJpZ2h0IiwiaXNEaXNhYmxlZExlZnQiLCJzdHlsZXMkbSIsImNyZWF0ZVNpemVDbGFzc05hbWVPYmoiLCJoZWlnaHQiLCJ3aWR0aCIsInNjYWxlRmFjdG9yIiwic2l6ZUNsYXNzTmFtZXMiLCJzcGFjZXIiLCJzdHlsZXMkbCIsImRpc2FibGVUb3AiLCJkaXNhYmxlQm90dG9tIiwicGFnZVBhZGRpbmdZIiwic3R5bGVzJGsiLCJUb29sdGlwSGVscEljb24iLCJJY29uQ29tcG9uZW50IiwiUXVlc3Rpb25NYXJrQ2lyY2xlZEljb24iLCJ0b29sdGlwSWNvbiIsInN0eWxlcyRqIiwiVG9vbHRpcEhlbHAiLCJzY2FsZSIsInN0eWxlUHJvcCIsImRpc3BsYXlIZWxwSWNvbkFsb25nc2lkZSIsInRvb2x0aXBIZWxwIiwic3R5bGVzJGkiLCJ2YXJpYW50IiwiaXNXcmFwcGVyIiwiZGlzYWJsZVBhZGRpbmciLCJzaXplVmFyaWFudCIsInRvb2x0aXBQbGFjZW1lbnQiLCJ0b29sdGlwRGVsYXkiLCJkaXNhYmxlV2l0aG91dENoYW5naW5nQXBwZWFyYW5jZSIsImRpc2FibGVQcmVzc0VmZmVjdE9uQ2xpY2siLCJlbmFibGVUb29sdGlwV2hlbkRpc2FibGVkIiwiYnV0dG9uUmVmIiwiYmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZENvbG9yU2hhZGUiLCJib3JkZXJDb2xvciIsImJvcmRlckNvbG9yU2hhZGUiLCJ0ZXh0Q29sb3IiLCJ0ZXh0Q29sb3JTaGFkZSIsInRvb2x0aXBQcm9wcyIsInBhc3NEaXNhYmxlZEF0dHJpYnV0ZSIsInZhcmlhbnRXaXRoRGVmYXVsdCIsImlzQm9yZGVyVmFyaWFudCIsImJhY2tncm91bmQiLCJib3JkZXIiLCJyZW1vdmVVbmRlZmluZWRWYWx1ZXNGcm9tT2JqIiwiYnV0dG9uQ2hpbGQiLCJidXR0b24iLCJ1c2VTdmdGaWxsIiwid3JhcHBlckJ1dHRvbiIsImxpZ2h0IiwiaW52ZXJzZSIsInByaW1hcnkiLCJzdHlsZXMkaCIsImNhcmQiLCJzdHlsZXMkZyIsInJlbmRlckNoaWxkV2hlblVuY2hlY2tlZCIsImNoZWNrZWQiLCJjaGVja2VkUHJvcCIsImRlZmF1bHRDaGVja2VkIiwiY2xhc3NOYW1lc1Byb3AiLCJkaXNhYmxlRm9jdXNPdXRsaW5lIiwiaXNTbWFsbCIsInNldENoZWNrZWQiLCJuZXdDaGVja2VkIiwiY2hlY2tlZFZhbHVlIiwiY2hpbGRyZW5Ub1JlbmRlciIsIkNoZWNrSWNvbiIsImNvdW50IiwidG9BcnJheSIsIkNoZWNrYm94UmFkaXgiLCJSb290IiwiY2hlY2tib3giLCJ1bmNoZWNrZWQiLCJJbmRpY2F0b3IiLCJjaGVja2JveEluZGljYXRvciIsImJhc2VHZXRUYWckMSIsImlzQXJyYXkkMyIsImlzT2JqZWN0TGlrZSQzIiwic3RyaW5nVGFnJDIiLCJpc1N0cmluZyQxIiwiaXNTdHJpbmdfMSIsImJhc2VQcm9wZXJ0eSIsImFzY2lpU2l6ZSQxIiwiX2FzY2lpU2l6ZSIsInJzQXN0cmFsUmFuZ2UkMSIsInJzQ29tYm9NYXJrc1JhbmdlJDEiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UkMSIsInJzQ29tYm9SYW5nZSQxIiwicnNWYXJSYW5nZSQxIiwicnNaV0okMSIsInJlSGFzVW5pY29kZSIsImhhc1VuaWNvZGUkMSIsIl9oYXNVbmljb2RlIiwicnNBc3RyYWxSYW5nZSIsInJzQ29tYm9NYXJrc1JhbmdlIiwicmVDb21ib0hhbGZNYXJrc1JhbmdlIiwicnNDb21ib1N5bWJvbHNSYW5nZSIsInJzQ29tYm9SYW5nZSIsInJzVmFyUmFuZ2UiLCJyc0FzdHJhbCIsInJzQ29tYm8iLCJyc0ZpdHoiLCJyc01vZGlmaWVyIiwicnNOb25Bc3RyYWwiLCJyc1JlZ2lvbmFsIiwicnNTdXJyUGFpciIsInJzWldKIiwicmVPcHRNb2QiLCJyc09wdFZhciIsInJzT3B0Sm9pbiIsInJzU2VxIiwicnNTeW1ib2wiLCJyZVVuaWNvZGUiLCJ1bmljb2RlU2l6ZSQxIiwiX3VuaWNvZGVTaXplIiwiYXNjaWlTaXplIiwiaGFzVW5pY29kZSIsInVuaWNvZGVTaXplIiwic3RyaW5nU2l6ZSQxIiwiX3N0cmluZ1NpemUiLCJiYXNlS2V5cyIsImdldFRhZyQzIiwiaXNBcnJheUxpa2UkNCIsImlzU3RyaW5nIiwic3RyaW5nU2l6ZSIsIm1hcFRhZyQzIiwic2V0VGFnJDMiLCJzaXplXzEiLCJzaXplJDEiLCJzdHlsZXMkZiIsInRleHRSZWYiLCJ0ZXh0Iiwic3R5bGVzJGUiLCJ0aXRsZSIsInN0eWxlcyRkIiwiaWNvbiIsImljb25SaWdodCIsImxhYmVsIiwidG91Y2hlZCIsIm9uRm9jdXMiLCJpbnB1dFJlZiIsImxhYmVsSXNDb21wYWN0IiwibGFiZWxIZWxwVG9vbHRpcENvbnRlbnQiLCJpc0ZvY3VzZWQiLCJzZXRJc0ZvY3VzZWQiLCJoYW5kbGVGb2N1cyIsImljb25Ub1JlbmRlciIsImljb25Db250YWluZXIiLCJpc0xlZnQiLCJpc1JpZ2h0Iiwic2hvd0Vycm9yIiwidGV4dElucHV0Q29tcG9uZW50IiwibGFiZWxDb250YWluZXIiLCJjb21wYWN0IiwiaHRtbEZvciIsImxhYmVsSGVscCIsInRleHRJbnB1dFdyYXBwZXIiLCJpbnB1dFdyYXBwZXIiLCJ0ZXh0SW5wdXQiLCJpbnB1dCIsImhhc0ljb25MZWZ0IiwiaGFzSWNvblJpZ2h0IiwiaGFzRXJyb3IiLCJvbldoZWVsIiwiYmx1ciIsImVycm9yTWVzc2FnZSIsInN0eWxlcyRjIiwiVHlwZWRGaXhlZFNpemVMaXN0IiwiRml4ZWRTaXplTGlzdCIsIkRFRkFVTFRfVklSVFVBTElTQVRJT05fUFJPUFMiLCJpdGVtU2l6ZSIsIm92ZXJzY2FuQ291bnQiLCJidXR0b25JRCIsInNlbGVjdGVkSUQiLCJjbGFzc05hbWVzSW5wdXQiLCJvcHRpb25EYXRhQXR0cmlidXRlIiwicmVuZGVyT3B0aW9uIiwiZW5hYmxlT3BlbmluZyIsIm9uQ2xpY2tPcHRpb24iLCJmb3JjZU9wZW4iLCJvbkNoYW5nZU9wZW4iLCJzZWFyY2hFbmFibGVkIiwic2VhcmNoU2hvd0FsbFJlc3VsdHNPbkVtcHR5Iiwic2VhcmNoUGxhY2Vob2xkZXIiLCJzZWFyY2hGaWx0ZXJGdW5jdGlvbiIsImdldEZpbHRlclZhbHVlQnlJZCIsImJsdXJQcm9wcyIsInZpcnR1YWxpc2F0aW9uRW5hYmxlZCIsInZpcnR1YWxpc2F0aW9uTGlzdFByb3BzIiwiZHJvcERvd25SZWYiLCJkcm9wRG93blJlZlByb3AiLCJkcm9wRG93bldyYXBwZXJSZWYiLCJmb2N1c1NlYXJjaE9uT3BlbiIsInNlbGVjdG9yQnV0dG9uUmVmIiwiZHJvcERvd25SZWZJbnRlcm5hbCIsImRyb3BEb3duSXNPcGVuIiwic2V0RHJvcERvd25Jc09wZW4iLCJpbnB1dFZhbHVlIiwic2V0SW5wdXRWYWx1ZSIsImRlYm91bmNlZElucHV0VmFsdWUiLCJzZXREZWJvdW5jZWRJbnB1dFZhbHVlIiwiZm9jdXNTZWFyY2hCYXIiLCJoYW5kbGVTZXRJc09wZW4iLCJzZXRJbnB1dFZhbHVlRGVib3VuY2VkIiwidXNlRGVib3VuY2VkQ2FsbGJhY2siLCJoYW5kbGVJbnB1dENoYW5nZSIsImZvcmNlVXBkYXRlIiwiZmx1c2giLCJoYW5kbGVDbG9zZSIsImhhbmRsZUNsaWNrT3B0aW9uIiwib3B0aW9uIiwiZmlsdGVyZWRJZHMiLCJub3JtYWxpc2VkRGVib3VuY2VkSW5wdXRWYWx1ZSIsInRyaW0iLCJub3JtYWxpc2VkSWQiLCJjaGVja0lmVGV4dFRlcm1NYXRjaGVzU2luZ2xlIiwic291cmNlVmFsdWUiLCJpc09wZW4iLCJmaWx0ZXJlZElkc1NsaWNlZCIsIm90aGVyQmx1clByb3BzIiwiaGFuZGxlQ2xpY2tTZWxlY3RvciIsImhhbmRsZVNob3VsZERpc2FibGVCbHVyIiwibGlzdENvbXBvbmVudFByb3BzIiwiaXRlbUNvdW50IiwiaXRlbURhdGEiLCJsaXN0UmVuZGVyZWQiLCJkcm9wRG93bk9wdGlvbnMiLCJkcm9wRG93bk9wdGlvbiIsInNlbGVjdGVkIiwid3JhcHBlciIsImRyb3BEb3duQnV0dG9uV3JhcHBlciIsImRyb3BEb3duIiwiY2xlYXJJbnB1dEJ1dHRvbiIsIkNyb3NzMkljb24iLCJub1Jlc3VsdHNUZXh0Iiwic3R5bGVzJGIiLCJpc1NlbGVjdGVkIiwic2VsZWN0ZWRJdGVtQm9yZGVyIiwiaXRlbXMiLCJoZWFkZXJUaXRsZUNvbnRlbnQiLCJoZWFkZXJUaXRsZUhyZWYiLCJyaWdodEhhbmRDb250ZW50Iiwic2VsZWN0ZWRJZCIsImRpc2FibGVIZWFkZXJUaXRsZUxpbmsiLCJ1c2VQYWdlUGFkZGluZyIsIldyYXBwaW5nQ29tcG9uZW50IiwiaGVhZGVyQmFyIiwiaGVhZGVyQmFyUmVsYXRpdmVXcmFwcGVyIiwicmVsYXRpdmVXcmFwcGVyIiwiaGVhZGVyQmFyQ29udGVudHMiLCJjb250ZW50cyIsImhlYWRlckJhckl0ZW1zIiwiaGVhZGVyQmFyU3ViSXRlbXMiLCJzdWJJdGVtcyIsInN0eWxlcyRhIiwiS25vYlN2Z0NoaWxkMSIsInBvaW50ZXJDb2xvciIsIngxIiwieDIiLCJ5MSIsInkyIiwic3RvcENvbG9yIiwic3RvcE9wYWNpdHkiLCJjeCIsImN5IiwiZmlsdGVyVW5pdHMiLCJ5IiwiaW4iLCJvcGVyYXRvciIsInJhZGl1cyIsImR4IiwiZHkiLCJzdGREZXZpYXRpb24iLCJpbjIiLCJmaWxsIiwiZmlsbFJ1bGUiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsImZpbGxPcGFjaXR5IiwieGxpbmtIcmVmIiwiZCIsInN0eWxlcyQ5Iiwic3R5bGVzJDgiLCJSZWFjdFNsaWRlciIsIl9SZWFjdFNsaWRlciIsIm9yaWVudGF0aW9uIiwid3JhcHBlclJlZiIsImludmVydCIsImlzVmVydGljYWwiLCJzbGlkZXJXcmFwcGVyIiwidmVydGljYWwiLCJzbGlkZXIiLCJzbmFwRHJhZ0Rpc2FibGVkIiwidGh1bWJDbGFzc05hbWUiLCJzbGlkZXJUaHVtYiIsInRyYWNrQ2xhc3NOYW1lIiwic2xpZGVyVHJhY2siLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiZW5sYXJnZWQiLCJzbGlkZXJQcm9wcyIsIm9uUG9pbnRlckRvd24iLCJvbk1vdXNlVXAiLCJzbGlkZXJSZWYiLCJzbGlkZXJNZWNoYW5pc21XcmFwcGVyIiwib25Qb2ludGVyVXAiLCJtaW4iLCJvbkFmdGVyQ2hhbmdlIiwic3RlcCIsInZhbHVlUHJvcCIsInZhbHVlVG9SZW5kZXIiLCJ2YWx1ZUludGVybmFsIiwic2V0VmFsdWVJbnRlcm5hbCIsInNldEVubGFyZ2VkIiwiaGFzU2V0Rmlyc3RWYWx1ZSIsInNldEhhc1NldEZpcnN0VmFsdWUiLCJpc1ByZXNzaW5nUmVmIiwiaXNUcnV0aHlPclplcm8iLCJ2YWx1ZUZvcm1hdHRlZCIsImhhbmRsZVBvaW50ZXJEb3duIiwiaGFuZGxlQ2hhbmdlIiwibmV3VmFsdWUiLCJoYW5kbGVNb3VzZVVwIiwicmVuZGVyZWRWYWx1ZSIsInNsaWRlck1lY2hhbmlzbVByb3BzIiwiTE9XRVNUX0FOR0xFIiwiR1JFQVRFU1RfQU5HTEUiLCJyZW1vdmVEZWZhdWx0UG9pbnRlckNvbG9yIiwicm90YXRpb24iLCJzbGlkZXJNZWNoYW5pc21Qcm9wc0NvbWJpbmVkIiwia25vYldyYXBwZXIiLCJrbm9iVmFsdWVXcmFwcGVyIiwia25vYlZhbHVlIiwia25vYlNraW5XcmFwcGVyIiwidmlld0JveCIsInhtbG5zIiwieG1sbnNYbGluayIsInN0eWxlcyQ3Iiwic3R5bGVzJDYiLCJBQ1RJVkVfVElDS19PUEFDSVRZX01JTklNVU0iLCJjb252ZXJ0UmFuZ2UiLCJvbGRNaW4iLCJvbGRNYXgiLCJuZXdNaW4iLCJuZXdNYXgiLCJvbGRWYWx1ZSIsIktub2JXaXRoUHJvZ3Jlc3MiLCJudW1UaWNrcyIsImRlZ3JlZXMiLCJkaXNhYmxlR3JpcCIsImtub2JXaWR0aCIsImtub2JXcmFwcGVyUmVmIiwidXNlUmVzaXplRGV0ZWN0b3IiLCJyZWZyZXNoTW9kZSIsInJlZnJlc2hSYXRlIiwiZnVsbEFuZ2xlIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiY3VycmVudERlZyIsInJlbmRlclRpY2tzIiwidGlja3MiLCJpbmNyIiwic2l6ZUNhbGN1bGF0ZWQiLCJkZWciLCJ0aWNrIiwidGlja1N0eWxlIiwidHJhbnNmb3JtT3JpZ2luIiwia25vYklubmVyU3R5bGUiLCJwZXJjZW50YWdlIiwia25vYklubmVyQmFja2dyb3VuZFN0eWxlIiwia25vYiIsInRpY2tJc0FjdGl2ZSIsImFjdGl2ZSIsImtub2JPdXRlciIsImtub2JJbm5lckJhY2tncm91bmQiLCJrbm9iSW5uZXIiLCJncmlwIiwiS05PQl9WQUxVRV9PUEFDSVRZX01JTklNVU0iLCJrbm9iUHJvcHMiLCJwcm9ncmVzcyIsImJvcmRlck9wYWNpdHkiLCJzdHlsZXMkNSIsImNsYXNzTmFtZUNvbWJpYmVkIiwibGluZSIsImhvcml6b250YWwiLCJzdHlsZXMkNCIsImNsYXNzTmFtZVNwaW5uZXIiLCJzcGFuUGFyZW50IiwiaXNBYnNvbHV0ZSIsImxvYWRpbmdTcGlubmVyV3JhcHBlciIsImxvYWRpbmdTcGlubmVyIiwidXNlRGVsYXllZE1vdW50Iiwic2hvdWxkTW91bnQiLCJkZWxheVRpbWUiLCJzaG91bGRSZW5kZXIiLCJzZXRTaG91bGRSZW5kZXIiLCJ0cmFuc2l0aW9uQ29tcGxldGUiLCJzZXRUcmFuc2l0aW9uQ29tcGxldGUiLCJ0aW1lb3V0UmVmIiwiQ29udGV4dCIsIm9wZW5Nb2RhbFpJbmRleGVzIiwib3Blbk1vZGFsIiwiY2xvc2VNb2RhbCIsIkNvbnN1bWVyIiwiU3ltYm9sJDEiLCJpc0FyZ3VtZW50cyIsImlzQXJyYXkkMiIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJpc0ZsYXR0ZW5hYmxlJDEiLCJfaXNGbGF0dGVuYWJsZSIsImFycmF5UHVzaCQxIiwiaXNGbGF0dGVuYWJsZSIsImJhc2VGbGF0dGVuJDIiLCJkZXB0aCIsImlzU3RyaWN0IiwiX2Jhc2VGbGF0dGVuIiwiaXNBcnJheUxpa2UkMyIsImNyZWF0ZUJhc2VFYWNoJDEiLCJfY3JlYXRlQmFzZUVhY2giLCJiYXNlRm9yT3duIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRWFjaCQxIiwiX2Jhc2VFYWNoIiwiYmFzZUVhY2giLCJpc0FycmF5TGlrZSQyIiwiYmFzZU1hcCQxIiwiX2Jhc2VNYXAiLCJiYXNlU29ydEJ5JDEiLCJjb21wYXJlciIsIl9iYXNlU29ydEJ5IiwiaXNTeW1ib2wiLCJjb21wYXJlQXNjZW5kaW5nJDEiLCJ2YWxJc0RlZmluZWQiLCJ2YWxJc051bGwiLCJ2YWxJc1JlZmxleGl2ZSIsInZhbElzU3ltYm9sIiwib3RoSXNEZWZpbmVkIiwib3RoSXNOdWxsIiwib3RoSXNSZWZsZXhpdmUiLCJvdGhJc1N5bWJvbCIsIl9jb21wYXJlQXNjZW5kaW5nIiwiY29tcGFyZUFzY2VuZGluZyIsImNvbXBhcmVNdWx0aXBsZSQxIiwib3JkZXJzIiwib2JqQ3JpdGVyaWEiLCJjcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJfY29tcGFyZU11bHRpcGxlIiwiYXJyYXlNYXAkMSIsImJhc2VHZXQkMSIsImJhc2VJdGVyYXRlZSQxIiwiYmFzZU1hcCIsImJhc2VTb3J0QnkiLCJiYXNlVW5hcnkkMiIsImNvbXBhcmVNdWx0aXBsZSIsImlkZW50aXR5JDIiLCJpc0FycmF5JDEiLCJiYXNlT3JkZXJCeSQxIiwiaXRlcmF0ZWVzIiwiX2Jhc2VPcmRlckJ5IiwiYXBwbHkkMSIsInRoaXNBcmciLCJfYXBwbHkiLCJuYXRpdmVNYXgiLCJvdmVyUmVzdCQyIiwib3RoZXJBcmdzIiwiX292ZXJSZXN0IiwiY29uc3RhbnQkMSIsImNvbnN0YW50XzEiLCJjb25zdGFudCIsImlkZW50aXR5JDEiLCJiYXNlU2V0VG9TdHJpbmckMSIsIl9iYXNlU2V0VG9TdHJpbmciLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsInNob3J0T3V0JDEiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJfc2hvcnRPdXQiLCJiYXNlU2V0VG9TdHJpbmciLCJzaG9ydE91dCIsInNldFRvU3RyaW5nJDIiLCJfc2V0VG9TdHJpbmciLCJpZGVudGl0eSIsIm92ZXJSZXN0JDEiLCJzZXRUb1N0cmluZyQxIiwiYmFzZVJlc3QkMSIsIl9iYXNlUmVzdCIsImVxJDEiLCJpc0FycmF5TGlrZSQxIiwiaXNJbmRleCIsImlzT2JqZWN0JDMiLCJpc0l0ZXJhdGVlQ2FsbCQxIiwiX2lzSXRlcmF0ZWVDYWxsIiwiYmFzZUZsYXR0ZW4kMSIsImJhc2VPcmRlckJ5IiwiYmFzZVJlc3QiLCJpc0l0ZXJhdGVlQ2FsbCIsInNvcnRCeSIsInNvcnRCeV8xIiwic29ydEJ5JDEiLCJERUZBVUxUX1pfSU5ERVgiLCJzZXRPcGVuTW9kYWxaSW5kZXhlcyIsInpJbmRleCIsIm9sZE9wZW5Nb2RhbFpJbmRleGVzIiwibmV3T3Blbk1vZGFsWkluZGV4ZXMiLCJ6IiwiaWRJbkFycmF5IiwidXNlTW9kYWxTdGF0ZSIsInN0eWxlcyQzIiwibW9kYWxSb290RWxlbWVudElkIiwiZGlzYWJsZUFuaW1hdGlvbnMiLCJpc1VuZGVyQW5vdGhlck1vZGFsIiwiY3JlYXRlUG9ydGFsIiwibW9kYWwiLCJ1bmRlckFub3RoZXJNb2RhbCIsInRhYkluZGV4IiwiZ2V0RWxlbWVudEJ5SWQiLCJzdHlsZXMkMiIsInBpbGwiLCJiYXNlRmluZEluZGV4JDEiLCJmcm9tSW5kZXgiLCJfYmFzZUZpbmRJbmRleCIsImJhc2VJc05hTiQxIiwiX2Jhc2VJc05hTiIsInN0cmljdEluZGV4T2YkMSIsIl9zdHJpY3RJbmRleE9mIiwiYmFzZUZpbmRJbmRleCIsImJhc2VJc05hTiIsInN0cmljdEluZGV4T2YiLCJiYXNlSW5kZXhPZiQxIiwiX2Jhc2VJbmRleE9mIiwiYmFzZUluZGV4T2YiLCJhcnJheUluY2x1ZGVzJDEiLCJfYXJyYXlJbmNsdWRlcyIsImFycmF5SW5jbHVkZXNXaXRoJDEiLCJjb21wYXJhdG9yIiwiX2FycmF5SW5jbHVkZXNXaXRoIiwibm9vcCQxIiwibm9vcF8xIiwiU2V0JDEiLCJub29wIiwic2V0VG9BcnJheSQxIiwiSU5GSU5JVFkiLCJjcmVhdGVTZXQkMSIsIl9jcmVhdGVTZXQiLCJTZXRDYWNoZSIsImFycmF5SW5jbHVkZXMiLCJhcnJheUluY2x1ZGVzV2l0aCIsImNhY2hlSGFzIiwiY3JlYXRlU2V0Iiwic2V0VG9BcnJheSIsIkxBUkdFX0FSUkFZX1NJWkUiLCJiYXNlVW5pcSQxIiwiaXNDb21tb24iLCJvdXRlciIsImNvbXB1dGVkIiwic2VlbkluZGV4IiwiX2Jhc2VVbmlxIiwiYmFzZUl0ZXJhdGVlIiwiYmFzZVVuaXEiLCJ1bmlxQnkiLCJ1bmlxQnlfMSIsInVuaXFCeSQxIiwiYXJyYXlFYWNoJDEiLCJfYXJyYXlFYWNoIiwiYmFzZUFzc2lnblZhbHVlJDEiLCJlcSIsIm9iamVjdFByb3RvJDMiLCJoYXNPd25Qcm9wZXJ0eSQzIiwiYXNzaWduVmFsdWUkMiIsIl9hc3NpZ25WYWx1ZSIsImFzc2lnblZhbHVlJDEiLCJiYXNlQXNzaWduVmFsdWUiLCJjb3B5T2JqZWN0JDUiLCJpc05ldyIsIl9jb3B5T2JqZWN0IiwiY29weU9iamVjdCQ0Iiwia2V5cyQxIiwiYmFzZUFzc2lnbiQxIiwiX2Jhc2VBc3NpZ24iLCJuYXRpdmVLZXlzSW4kMSIsIl9uYXRpdmVLZXlzSW4iLCJpc09iamVjdCQyIiwiaXNQcm90b3R5cGUkMSIsIm5hdGl2ZUtleXNJbiIsIm9iamVjdFByb3RvJDIiLCJoYXNPd25Qcm9wZXJ0eSQyIiwiYmFzZUtleXNJbiQxIiwiaXNQcm90byIsIl9iYXNlS2V5c0luIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzSW4iLCJpc0FycmF5TGlrZSIsImtleXNJbiQzIiwia2V5c0luXzEiLCJjb3B5T2JqZWN0JDMiLCJrZXlzSW4kMiIsImJhc2VBc3NpZ25JbiQxIiwiX2Jhc2VBc3NpZ25JbiIsIl9jbG9uZUJ1ZmZlciIsImFsbG9jVW5zYWZlIiwiY2xvbmVCdWZmZXIiLCJpc0RlZXAiLCJjb3B5IiwiX2Nsb25lQnVmZmVyRXhwb3J0cyIsImNvcHlBcnJheSQxIiwiX2NvcHlBcnJheSIsImNvcHlPYmplY3QkMiIsImdldFN5bWJvbHMkMSIsImNvcHlTeW1ib2xzJDEiLCJfY29weVN5bWJvbHMiLCJvdmVyQXJnIiwiZ2V0UHJvdG90eXBlJDMiLCJnZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGUiLCJhcnJheVB1c2giLCJnZXRQcm90b3R5cGUkMiIsImdldFN5bWJvbHMiLCJzdHViQXJyYXkiLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0U3ltYm9sc0luJDIiLCJfZ2V0U3ltYm9sc0luIiwiY29weU9iamVjdCQxIiwiZ2V0U3ltYm9sc0luJDEiLCJjb3B5U3ltYm9sc0luJDEiLCJfY29weVN5bWJvbHNJbiIsImJhc2VHZXRBbGxLZXlzIiwiZ2V0U3ltYm9sc0luIiwia2V5c0luJDEiLCJnZXRBbGxLZXlzSW4kMiIsIl9nZXRBbGxLZXlzSW4iLCJvYmplY3RQcm90byQxIiwiaGFzT3duUHJvcGVydHkkMSIsImluaXRDbG9uZUFycmF5JDEiLCJfaW5pdENsb25lQXJyYXkiLCJjbG9uZUFycmF5QnVmZmVyJDMiLCJhcnJheUJ1ZmZlciIsIl9jbG9uZUFycmF5QnVmZmVyIiwiY2xvbmVBcnJheUJ1ZmZlciQyIiwiY2xvbmVEYXRhVmlldyQxIiwiZGF0YVZpZXciLCJfY2xvbmVEYXRhVmlldyIsInJlRmxhZ3MiLCJjbG9uZVJlZ0V4cCQxIiwicmVnZXhwIiwiX2Nsb25lUmVnRXhwIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xWYWx1ZU9mIiwiY2xvbmVTeW1ib2wkMSIsIl9jbG9uZVN5bWJvbCIsImNsb25lQXJyYXlCdWZmZXIkMSIsImNsb25lVHlwZWRBcnJheSQxIiwidHlwZWRBcnJheSIsIl9jbG9uZVR5cGVkQXJyYXkiLCJjbG9uZUFycmF5QnVmZmVyIiwiY2xvbmVEYXRhVmlldyIsImNsb25lUmVnRXhwIiwiY2xvbmVTeW1ib2wiLCJjbG9uZVR5cGVkQXJyYXkiLCJib29sVGFnJDEiLCJkYXRlVGFnJDEiLCJtYXBUYWckMiIsIm51bWJlclRhZyQxIiwicmVnZXhwVGFnJDEiLCJzZXRUYWckMiIsInN0cmluZ1RhZyQxIiwic3ltYm9sVGFnJDEiLCJhcnJheUJ1ZmZlclRhZyQxIiwiZGF0YVZpZXdUYWckMSIsImZsb2F0MzJUYWckMSIsImZsb2F0NjRUYWckMSIsImludDhUYWckMSIsImludDE2VGFnJDEiLCJpbnQzMlRhZyQxIiwidWludDhUYWckMSIsInVpbnQ4Q2xhbXBlZFRhZyQxIiwidWludDE2VGFnJDEiLCJ1aW50MzJUYWckMSIsImluaXRDbG9uZUJ5VGFnJDEiLCJfaW5pdENsb25lQnlUYWciLCJpc09iamVjdCQxIiwib2JqZWN0Q3JlYXRlIiwiY3JlYXRlIiwiYmFzZUNyZWF0ZSQxIiwiX2Jhc2VDcmVhdGUiLCJiYXNlQ3JlYXRlIiwiZ2V0UHJvdG90eXBlJDEiLCJpc1Byb3RvdHlwZSIsImluaXRDbG9uZU9iamVjdCQxIiwiX2luaXRDbG9uZU9iamVjdCIsImdldFRhZyQyIiwiaXNPYmplY3RMaWtlJDIiLCJtYXBUYWckMSIsImJhc2VJc01hcCQxIiwiX2Jhc2VJc01hcCIsImJhc2VJc01hcCIsImJhc2VVbmFyeSQxIiwibm9kZVV0aWwkMSIsIm5vZGVJc01hcCIsImlzTWFwIiwiaXNNYXAkMSIsImlzTWFwXzEiLCJnZXRUYWckMSIsImlzT2JqZWN0TGlrZSQxIiwic2V0VGFnJDEiLCJiYXNlSXNTZXQkMSIsIl9iYXNlSXNTZXQiLCJiYXNlSXNTZXQiLCJiYXNlVW5hcnkiLCJub2RlSXNTZXQiLCJpc1NldCIsImlzU2V0JDEiLCJpc1NldF8xIiwiU3RhY2siLCJhcnJheUVhY2giLCJhc3NpZ25WYWx1ZSIsImJhc2VBc3NpZ24iLCJiYXNlQXNzaWduSW4iLCJjb3B5QXJyYXkiLCJjb3B5U3ltYm9scyIsImNvcHlTeW1ib2xzSW4iLCJnZXRBbGxLZXlzIiwiZ2V0QWxsS2V5c0luJDEiLCJnZXRUYWciLCJpbml0Q2xvbmVBcnJheSIsImluaXRDbG9uZUJ5VGFnIiwiaW5pdENsb25lT2JqZWN0IiwiaXNPYmplY3QiLCJrZXlzSW4iLCJDTE9ORV9ERUVQX0ZMQUckMSIsIkNMT05FX0ZMQVRfRkxBRyQxIiwiQ0xPTkVfU1lNQk9MU19GTEFHJDEiLCJhcmdzVGFnIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyQxIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJjbG9uZWFibGVUYWdzIiwiYmFzZUNsb25lJDEiLCJpc0ZsYXQiLCJpc0Z1bGwiLCJpc0Z1bmMiLCJzdWJWYWx1ZSIsIl9iYXNlQ2xvbmUiLCJsYXN0JDEiLCJsYXN0XzEiLCJiYXNlU2xpY2UkMSIsImVuZCIsIl9iYXNlU2xpY2UiLCJiYXNlR2V0IiwiYmFzZVNsaWNlIiwicGFyZW50JDEiLCJfcGFyZW50IiwiY2FzdFBhdGgkMSIsImxhc3QiLCJwYXJlbnQiLCJ0b0tleSIsImJhc2VVbnNldCQxIiwiX2Jhc2VVbnNldCIsImJhc2VHZXRUYWciLCJnZXRQcm90b3R5cGUiLCJpc09iamVjdExpa2UiLCJvYmplY3RUYWciLCJmdW5jUHJvdG8iLCJvYmplY3RQcm90byIsImZ1bmNUb1N0cmluZyIsIm9iamVjdEN0b3JTdHJpbmciLCJpc1BsYWluT2JqZWN0JDEiLCJpc1BsYWluT2JqZWN0XzEiLCJpc1BsYWluT2JqZWN0IiwiY3VzdG9tT21pdENsb25lJDEiLCJfY3VzdG9tT21pdENsb25lIiwiYmFzZUZsYXR0ZW4iLCJmbGF0dGVuJDEiLCJmbGF0dGVuXzEiLCJmbGF0dGVuIiwib3ZlclJlc3QiLCJzZXRUb1N0cmluZyIsImZsYXRSZXN0JDEiLCJfZmxhdFJlc3QiLCJhcnJheU1hcCIsImJhc2VDbG9uZSIsImJhc2VVbnNldCIsImNhc3RQYXRoIiwiY29weU9iamVjdCIsImN1c3RvbU9taXRDbG9uZSIsImZsYXRSZXN0IiwiZ2V0QWxsS2V5c0luIiwiQ0xPTkVfREVFUF9GTEFHIiwiQ0xPTkVfRkxBVF9GTEFHIiwiQ0xPTkVfU1lNQk9MU19GTEFHIiwicGF0aHMiLCJvbWl0XzEiLCJvbWl0JDEiLCJ1c2VEeW5hbWljUmVmcyIsImlkcyIsIl92IiwiZHluYW1pY1JlZnMiLCJhY2MiLCJjcmVhdGVSZWYiLCJnZXRSZWYiLCJzdHlsZXMkMSIsIkRFTEFZX0ZPUl9DTE9TSU5HX0RST1BfRE9XTiIsIkRFRkFVTFRfRklMVEVSIiwiY3JlYXRlRmlsdGVyIiwiY3JlYXRlT3B0aW9uS2V5IiwiZ3JvdXBJZCIsImNyZWF0ZUN1c3RvbUtleUZyb21PYmplY3QiLCJWQUxJRF9BQ1RJT05TX0ZPUl9DQUxMSU5HX0lOUFVUX0NIQU5HRSIsIk1lbnVMaXN0R3JvdXBlZCIsIm9uUmVuZGVyZWRJdGVtc0NoYW5nZSIsImdyb3VwTGFiZWwiLCJhbGxHcm91cHNFbXB0eSIsImZvcmNlRW1wdHlNZXNzYWdlIiwiaXNTZWFyY2hPbmx5IiwibWF4T3B0aW9ucyIsInNlbGVjdFByb3BzIiwicmVuZGVyIiwidmFsdWVzUmVuZGVyZWQiLCJmbGF0TWFwIiwiaXNFbXB0eSIsInJlbmRlck5vdGhpbmciLCJyZW5kZXJFbXB0eU1lc3NhZ2UiLCJncm91cCIsImNvbXBvbmVudHMiLCJNZW51TGlzdCIsIm1lbnVMaXN0Q29tcG9uZW50IiwiZm9yY2VTY3JvbGxCYXJzIiwiT3B0aW9uIiwia2VlcE9wdGlvblRvb2x0aXBPcGVuT25Ib3ZlciIsImdldE9wdGlvblRvb2x0aXAiLCJvcHRpb25Ub29sdGlwIiwib3B0aW9uU3BhbiIsIm9wdGlvblNwYW5Db250ZW50IiwiZnVsbFdpZHRoIiwib3B0aW9uSGVscFRvb2x0aXAiLCJWYWx1ZUNvbnRhaW5lciIsImlzTXVsdGkiLCJkaXNwbGF5VG9vbHRpcEZvclNlbGVjdGVkSXRlbSIsInZhbHVlQ29udGFpbmVyVG9vbHRpcCIsIkRyb3Bkb3duSW5kaWNhdG9yIiwiaW5uZXJQcm9wcyIsImlubmVyUHJvcHNQcm9wIiwiZ3JvdXBlZElzT3BlbiIsIm9uTWVudUNsb3NlIiwiQ2xlYXJJbmRpY2F0b3IiLCJyZW5kZXJDbGVhckluZGljYXRvciIsImNsZWFySW5kaWNhdG9yVG9vbHRpcENvbnRlbnQiLCJvcHRpb25zUHJvcCIsIm5vT3B0aW9uc01lc3NhZ2UiLCJkaXNhYmxlTm9PcHRpb25zTWVzc2FnZSIsImlzTG9hZGluZyIsIm1lbnVJc09wZW4iLCJpbnB1dFR5cGVJc1RleHQiLCJvbmx5Q2FsbE9uQ2hhbmdlRm9yRWRpdHMiLCJvbklucHV0Q2hhbmdlIiwib25JbnB1dENoYW5nZURlYm91bmNlZCIsImZvcm1hdFZhbHVlIiwiaW5wdXRWYWx1ZVByb3AiLCJkZWJvdW5jZVRpbWUiLCJkaXNhYmxlSW50ZXJuYWxGaWx0ZXIiLCJmaWx0ZXJPcHRpb24iLCJpc1NlYXJjaGFibGUiLCJjbG9zZU1lbnVPblNlbGVjdCIsImhpZGVEcm9wZG93bkluZGljYXRvciIsImhpZGVEcm9wZG93bkluZGljYXRvclByb3AiLCJoaWRlQ2xlYXJCdXR0b24iLCJzaG93RW1wdHlNZXNzYWdlRm9yRW1wdHlJbnB1dFZhbHVlIiwiaGlkZU1lbnVPbkVtcHR5U2VhcmNoVGVybSIsImtlZXBJbnB1dFZhbHVlT25CbHVyIiwiYWxsb3dNdWx0aVNlbGVjdGVkT3B0aW9uc0hlaWdodFRvRXhwYW5kIiwia2VlcExhYmVsSGVscFRvb2x0aXBPcGVuT25Ib3ZlciIsInNldElzT3BlbiIsImlucHV0VmFsdWVJbnRlcm5hbCIsInNldElucHV0VmFsdWVJbnRlcm5hbCIsInJlbmRlcmVkSXRlbXNDb3VudEJ5R3JvdXBJZCIsInNldFJlbmRlcmVkSXRlbXNDb3VudEJ5R3JvdXBJZCIsInJlbmRlcmVkVmFsdWVzQnlHcm91cElkIiwic2V0UmVuZGVyZWRWYWx1ZXNCeUdyb3VwSWQiLCJzZXRTZWxlY3RlZCIsImdyb3VwU2VsZWN0Qm94Rm9jdXNJbmRleCIsInNldEdyb3VwU2VsZWN0Qm94Rm9jdXNJbmRleCIsImNsb3NpbmdEcm9wRG93bkRpc2FibGVkUmVmIiwiY2xvc2luZ0Ryb3BEb3duRGlzYWJsZWRUaW1lb3V0UmVmIiwiaW5wdXRWYWx1ZUVtcHR5Iiwib3B0aW9uc0FyZUdyb3VwZWQiLCJwYXJzZUdyb3VwZWRPcHRpb25zIiwib3B0aW9uc0FyZU5vbkdyb3VwZWQiLCJwYXJzZU5vbkdyb3VwZWRPcHRpb25zIiwibm9uR3JvdXBlZE9wdGlvbnMiLCJncm91cGVkT3B0aW9ucyIsIm9wdHMiLCJyZXN0Iiwib3B0IiwiZ3JvdXBzQ291bnQiLCJnZXRHcm91cGVkU2VsZWN0UmVmIiwic2V0R3JvdXBlZFNlbGVjdFJlZiIsInYiLCJjb21iaW5lZE9wdGlvbnMiLCJvcHRpb25zQnlLZXkiLCJrZXlCeVdpdGhVbmRlZmluZWQiLCJzZWxlY3RlZE9wdGlvbnNCeUtleSIsInNldElucHV0VmFsdWVJbnRlcm5hbERlYm91bmNlZCIsImFjdGlvbiIsImZvcm1hdHRlZFZhbHVlIiwicHJldklucHV0VmFsdWUiLCJ1cGRhdGVTZWxlY3RlZE9wdGlvbnMiLCJuZXdTZWwiLCJvdmVyd3JpdGUiLCJuZXdTZWxJc0FycmF5IiwibmV3U2VsZWN0ZWQiLCJwcmV2U2VsZWN0ZWQiLCJnSWQiLCJjbGVhclNlbGVjdGVkT3B0aW9ucyIsImhhbmRsZUZpbHRlck9wdGlvbiIsImlucHV0VmFsdWVGb3JGaWx0ZXIiLCJjbGFzc05hbWVzSW50ZXJuYWwiLCJjbGVhckluZGljYXRvciIsImhpZGUiLCJjb250YWluZXIiLCJjb250cm9sIiwiYWxsR3JvdXBzRW1wdHlUZXh0QmxpbmtlciIsImRyb3Bkb3duSW5kaWNhdG9yIiwibG9hZGluZ0luZGljYXRvciIsIm1lbnUiLCJtZW51TGlzdCIsIm11bHRpVmFsdWUiLCJtdWx0aVZhbHVlTGFiZWwiLCJtdWx0aVZhbHVlUmVtb3ZlIiwidmFsdWVDb250YWluZXIiLCJpc1Njcm9sbGFibGUiLCJvbk1lbnVPcGVuIiwiY2xlYXJJbnB1dFZhbHVlIiwiZ2V0Q3VycmVudEZvY3VzZWRPcHRpb24iLCJmb2N1c2VkT3B0aW9uIiwiZ2V0Q3VycmVudEZvY3VzZWRHcm91cEluZGV4IiwiZm9jdXNlZEdyb3VwSW5kZXgiLCJnZXRDdXJyZW50Rm9jdXNlZEdyb3VwIiwiZ2V0Q3VycmVudEZvY3VzZWRPcHRpb25JbmRleCIsImZvY3VzZWRHcm91cCIsImZvY3VzZWRJbmRleCIsImdldFZpc2libGVPcHRpb25zQ291bnRGb3JHcm91cEluZGV4IiwiZ3JvdXBTZWxlY3RCb3hJbmRleCIsImZvY3VzYWJsZU9wdGlvbnNXaXRoSWRzIiwidGVtcG9yYXJpbHlEaXNhYmxlQ2xvc2luZ0dyb3VwZWRTZWxlY3QiLCJpbmNyZW1lbnRHcm91cFNlbGVjdEZvY3VzSW5kZXgiLCJnZXROZXdJbmRleCIsIm9sZEluZGV4IiwibmV3SW5kZXgiLCJyZWFjaGVkU2VhcmNoQm94IiwibmV3SW5kZXhIYXNOb09wdGlvbnMiLCJkZWNyZW1lbnRHcm91cFNlbGVjdEZvY3VzSW5kZXgiLCJyZWFjaGVkRW5kIiwiaGFuZGxlS2V5RG93biIsIm5ld0ZvY3VzZWRJbmRleCIsImdyb3VwT3B0aW9uc0NvdW50IiwiSW5maW5pdHkiLCJmaXJzdEF2YWlsYWJsZUdyb3VwSWQiLCJmaXJzdEF2YWlsYWJsZUl0ZW1JZCIsImZpcnN0QXZhaWxhYmxlSXRlbSIsInJlbmRlclNlbGVjdCIsImNuIiwiY3VzdG9tUHJvcHMiLCJSZWFjdFNlbGVjdCIsIm1lcmdlQ2xhc3NOYW1lc0Z1bmN0aW9uc0RlZXAiLCJjbGFzc05hbWVzMSIsImNsYXNzTmFtZXMyIiwiaW5zdGFuY2VJZCIsInVuc3R5bGVkIiwiaGFuZGxlQ2hhbmdlT25TZWFyY2hCYXJGb3JHcm91cGVkTW9kZSIsInNlbCIsIml0ZW1WYWx1ZSIsInMiLCJoYW5kbGVDaGFuZ2VPbkxpc3QiLCJpbnRlcm5hbFZhbHVlIiwiZXh0ZXJuYWxWYWx1ZSIsInZhbHVlUmF3IiwiY29yZVNlbGVjdENvbW1vblByb3BzIiwidGFiU2VsZWN0c1ZhbHVlIiwibm9uR3JvdXBlZFNlbGVjdFByb3BzIiwiZ3JvdXBlZFNlbGVjdFByb3BzIiwiY29udGFpbmVyU2VhcmNoR3JvdXAiLCJsYWJlbFJlbmRlcmVkIiwiY29tbW9uV3JhcHBlclN0eWxlcyIsImlzTXVsdGlTZWxlY3QiLCJkaXNhYmxlSW5wdXRIZWlnaHQiLCJhbGxHcm91cHNFbXB0eVZhbHVlIiwiaXNHcm91cE1vZGUiLCJncm91cHNEcm9wRG93biIsImdyb3Vwc0Ryb3BEb3duQ29udGVudHMiLCJncm91cGVkT3B0aW9uTGFiZWwiLCJncm91cFdyYXBwZXIiLCJjb250YWluZXJJdGVtc0dyb3VwIiwiaXNIaWRkZW4iLCJvbGQiLCJuZXdWYWx1ZXMiLCJ0ZXh0QXJlYUNvbXBvbmVudCIsInRleHRBcmVhV3JhcHBlciIsInRleHRBcmVhIiwiY29tbW9uU3R5bGVzIiwicHJvcHNDbGFzc05hbWUiLCJjb2xvcnMiLCJkZWZhdWx0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../app-front-end-components/lib/index.esm.js\n");

/***/ }),

/***/ "./src/components/common/App/App.tsx":
/*!*******************************************!*\
  !*** ./src/components/common/App/App.tsx ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   App: () => (/* binding */ App),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fx/app-front-end-components */ \"../app-front-end-components/lib/index.esm.js\");\n/* harmony import */ var _fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"next/head\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-toastify */ \"react-toastify\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! classnames */ \"classnames\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var config_app__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! config/app */ \"./src/config/app.ts\");\n/* harmony import */ var _App_module_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./App.module.scss */ \"./src/components/common/App/App.module.scss\");\n/* harmony import */ var _App_module_scss__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_App_module_scss__WEBPACK_IMPORTED_MODULE_6__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([react_toastify__WEBPACK_IMPORTED_MODULE_3__]);\nreact_toastify__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n\n/**\n * Custom App component which wraps the whole application\n */ const App = ({ children, className })=>{\n    const { isMountedClient } = (0,_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_1__.useClientMountedState)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: classnames__WEBPACK_IMPORTED_MODULE_4___default()((_App_module_scss__WEBPACK_IMPORTED_MODULE_6___default().contentWrapper), className),\n        \"data-theme\": \"dark\",\n        id: \"app\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                    children: config_app__WEBPACK_IMPORTED_MODULE_5__.APP_CONFIG.appTitle\n                }, void 0, false, {\n                    fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/App/App.tsx\",\n                    lineNumber: 27,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/App/App.tsx\",\n                lineNumber: 26,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_1__.Flex, {\n                className: (_App_module_scss__WEBPACK_IMPORTED_MODULE_6___default().contentBelowHeader),\n                children: children\n            }, void 0, false, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/App/App.tsx\",\n                lineNumber: 29,\n                columnNumber: 7\n            }, undefined),\n            isMountedClient && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_toastify__WEBPACK_IMPORTED_MODULE_3__.ToastContainer, {\n                autoClose: 3500,\n                className: (_App_module_scss__WEBPACK_IMPORTED_MODULE_6___default().toastContainer),\n                closeButton: false,\n                closeOnClick: true,\n                draggable: false,\n                hideProgressBar: true,\n                limit: 3,\n                newestOnTop: false,\n                pauseOnFocusLoss: true,\n                pauseOnHover: true,\n                position: \"top-right\",\n                rtl: false,\n                theme: \"light\",\n                transition: react_toastify__WEBPACK_IMPORTED_MODULE_3__.Slide\n            }, void 0, false, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/App/App.tsx\",\n                lineNumber: 31,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/App/App.tsx\",\n        lineNumber: 21,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwL0FwcC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQzJFO0FBQzlDO0FBQzBCO0FBQ25CO0FBQ0k7QUFDRDtBQU92Qzs7Q0FFQyxHQUNNLE1BQU1RLE1BQW9CLENBQUMsRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUU7SUFDdkQsTUFBTSxFQUFFQyxlQUFlLEVBQUUsR0FBR1gsbUZBQXFCQTtJQUVqRCxxQkFDRSw4REFBQ1k7UUFDQ0YsV0FBV0wsaURBQVVBLENBQUNFLHdFQUFxQixFQUFFRztRQUM3Q0ksY0FBVztRQUNYQyxJQUFHOzswQkFFSCw4REFBQ2Isa0RBQUlBOzBCQUNILDRFQUFDYzs4QkFBT1Ysa0RBQVVBLENBQUNXLFFBQVE7Ozs7Ozs7Ozs7OzBCQUU3Qiw4REFBQ2hCLDhEQUFJQTtnQkFBQ1MsV0FBV0gsNEVBQXlCOzBCQUFHRTs7Ozs7O1lBQzVDRSxpQ0FDQyw4REFBQ1AsMERBQWNBO2dCQUNiZSxXQUFXO2dCQUNYVCxXQUFXSCx3RUFBcUI7Z0JBQ2hDYyxhQUFhO2dCQUNiQyxZQUFZO2dCQUNaQyxXQUFXO2dCQUNYQyxlQUFlO2dCQUNmQyxPQUFPO2dCQUNQQyxhQUFhO2dCQUNiQyxnQkFBZ0I7Z0JBQ2hCQyxZQUFZO2dCQUNaQyxVQUFTO2dCQUNUQyxLQUFLO2dCQUNMQyxPQUFNO2dCQUNOQyxZQUFZN0IsaURBQUtBOzs7Ozs7Ozs7Ozs7QUFLM0IsRUFBRTtBQUVGLGlFQUFlSyxHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9BcHAvQXBwLnRzeD84NzZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRkMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNsaWVudE1vdW50ZWRTdGF0ZSwgRmxleCB9IGZyb20gJ0BmeC9hcHAtZnJvbnQtZW5kLWNvbXBvbmVudHMnO1xuaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCB7IFNsaWRlLCBUb2FzdENvbnRhaW5lciB9IGZyb20gJ3JlYWN0LXRvYXN0aWZ5JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgQVBQX0NPTkZJRyB9IGZyb20gJ2NvbmZpZy9hcHAnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0FwcC5tb2R1bGUuc2Nzcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3ROb2RlO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ3VzdG9tIEFwcCBjb21wb25lbnQgd2hpY2ggd3JhcHMgdGhlIHdob2xlIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBBcHA6IEZDPEFwcFByb3BzPiA9ICh7IGNoaWxkcmVuLCBjbGFzc05hbWUgfSkgPT4ge1xuICBjb25zdCB7IGlzTW91bnRlZENsaWVudCB9ID0gdXNlQ2xpZW50TW91bnRlZFN0YXRlKCk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoc3R5bGVzLmNvbnRlbnRXcmFwcGVyLCBjbGFzc05hbWUpfVxuICAgICAgZGF0YS10aGVtZT1cImRhcmtcIlxuICAgICAgaWQ9XCJhcHBcIlxuICAgID5cbiAgICAgIDxIZWFkPlxuICAgICAgICA8dGl0bGU+e0FQUF9DT05GSUcuYXBwVGl0bGV9PC90aXRsZT5cbiAgICAgIDwvSGVhZD5cbiAgICAgIDxGbGV4IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRlbnRCZWxvd0hlYWRlcn0+e2NoaWxkcmVufTwvRmxleD5cbiAgICAgIHtpc01vdW50ZWRDbGllbnQgJiYgKFxuICAgICAgICA8VG9hc3RDb250YWluZXJcbiAgICAgICAgICBhdXRvQ2xvc2U9ezM1MDB9XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudG9hc3RDb250YWluZXJ9XG4gICAgICAgICAgY2xvc2VCdXR0b249e2ZhbHNlfVxuICAgICAgICAgIGNsb3NlT25DbGlja1xuICAgICAgICAgIGRyYWdnYWJsZT17ZmFsc2V9XG4gICAgICAgICAgaGlkZVByb2dyZXNzQmFyXG4gICAgICAgICAgbGltaXQ9ezN9XG4gICAgICAgICAgbmV3ZXN0T25Ub3A9e2ZhbHNlfVxuICAgICAgICAgIHBhdXNlT25Gb2N1c0xvc3NcbiAgICAgICAgICBwYXVzZU9uSG92ZXJcbiAgICAgICAgICBwb3NpdGlvbj1cInRvcC1yaWdodFwiXG4gICAgICAgICAgcnRsPXtmYWxzZX1cbiAgICAgICAgICB0aGVtZT1cImxpZ2h0XCJcbiAgICAgICAgICB0cmFuc2l0aW9uPXtTbGlkZX1cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBcHA7XG4iXSwibmFtZXMiOlsidXNlQ2xpZW50TW91bnRlZFN0YXRlIiwiRmxleCIsIkhlYWQiLCJTbGlkZSIsIlRvYXN0Q29udGFpbmVyIiwiY2xhc3NOYW1lcyIsIkFQUF9DT05GSUciLCJzdHlsZXMiLCJBcHAiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImlzTW91bnRlZENsaWVudCIsImRpdiIsImNvbnRlbnRXcmFwcGVyIiwiZGF0YS10aGVtZSIsImlkIiwidGl0bGUiLCJhcHBUaXRsZSIsImNvbnRlbnRCZWxvd0hlYWRlciIsImF1dG9DbG9zZSIsInRvYXN0Q29udGFpbmVyIiwiY2xvc2VCdXR0b24iLCJjbG9zZU9uQ2xpY2siLCJkcmFnZ2FibGUiLCJoaWRlUHJvZ3Jlc3NCYXIiLCJsaW1pdCIsIm5ld2VzdE9uVG9wIiwicGF1c2VPbkZvY3VzTG9zcyIsInBhdXNlT25Ib3ZlciIsInBvc2l0aW9uIiwicnRsIiwidGhlbWUiLCJ0cmFuc2l0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/common/App/App.tsx\n");

/***/ }),

/***/ "./src/components/common/App/index.ts":
/*!********************************************!*\
  !*** ./src/components/common/App/index.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App */ \"./src/components/common/App/App.tsx\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_App__WEBPACK_IMPORTED_MODULE_0__]);\n_App__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _App__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _App__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9BcHAvaW5kZXgudHM/NDQ1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL0FwcCc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/common/App/index.ts\n");

/***/ }),

/***/ "./src/components/common/AppWrapper/AppWrapper.tsx":
/*!*********************************************************!*\
  !*** ./src/components/common/AppWrapper/AppWrapper.tsx ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppWrapper: () => (/* binding */ AppWrapper)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/merge */ \"lodash/merge\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ \"./src/components/common/AppWrapper/context/index.ts\");\n\n\n\n\nconst DEFAULT_APP_STATE = {\n    state: {}\n};\n/**\n * This is a root level component that should wrap the Next.js App component.\n *\n * This will contain any app wide custom logic which can then be consumed in other nested\n * parts of the application. For example, it renders the application inside an `GlobalAppStateProvider`\n * for app wide config.\n */ const AppWrapper = ({ children, appState, initialAppState, onAppStateChange })=>{\n    const globalAppState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>lodash_merge__WEBPACK_IMPORTED_MODULE_2___default()(DEFAULT_APP_STATE, appState, initialAppState ? {\n            state: initialAppState\n        } : {}), [\n        appState,\n        initialAppState\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context__WEBPACK_IMPORTED_MODULE_3__.GlobalAppStateProvider, {\n        onAppStateChange: onAppStateChange,\n        value: globalAppState,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/AppWrapper/AppWrapper.tsx\",\n        lineNumber: 47,\n        columnNumber: 5\n    }, undefined);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwV3JhcHBlci9BcHBXcmFwcGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBdUM7QUFFTjtBQUVrQjtBQUduRCxNQUFNSSxvQkFBb0I7SUFDeEJDLE9BQU8sQ0FBQztBQUNWO0FBYUE7Ozs7OztDQU1DLEdBQ00sTUFBTUMsYUFBYSxDQUFtQyxFQUMzREMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLGVBQWUsRUFDZkMsZ0JBQWdCLEVBQ0E7SUFDaEIsTUFBTUMsaUJBQWlCViw4Q0FBT0EsQ0FDNUIsSUFDRUMsbURBQUtBLENBQ0hFLG1CQUNBSSxVQUNBQyxrQkFBa0I7WUFBRUosT0FBT0k7UUFBZ0IsSUFBSSxDQUFDLElBRXBEO1FBQUNEO1FBQVVDO0tBQWdCO0lBRzdCLHFCQUNFLDhEQUFDTiw0REFBc0JBO1FBQ3JCTyxrQkFBa0JBO1FBQ2xCRSxPQUFPRDtrQkFFTko7Ozs7OztBQUdQLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL0FwcFdyYXBwZXIvQXBwV3JhcHBlci50c3g/NGZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5pbXBvcnQgdHlwZSB7IE9uZU9mT3JBcnJheU9mIH0gZnJvbSAnQGZ4L2xpYi11dGlsaXR5LXR5cGVzJztcbmltcG9ydCB7IEdsb2JhbEFwcFN0YXRlUHJvdmlkZXIgfSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IHR5cGUgeyBHbG9iYWxBcHBTdGF0ZVByb3ZpZGVyVmFsdWVQcm9wIH0gZnJvbSAnLi9jb250ZXh0JztcblxuY29uc3QgREVGQVVMVF9BUFBfU1RBVEUgPSB7XG4gIHN0YXRlOiB7fSxcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwV3JhcHBlclByb3BzIHtcbiAgLyoqIENoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgYXBwICovXG4gIGNoaWxkcmVuOiBPbmVPZk9yQXJyYXlPZjxSZWFjdE5vZGUgfCBudWxsPjtcbiAgLyoqIEFuIGFwcCBjb25maWcgcHJvcCB0byBiZSBwYXNzZWQgdG8gR2xvYmFsQXBwU3RhdGVQcm92aWRlciAqL1xuICBhcHBTdGF0ZT86IEdsb2JhbEFwcFN0YXRlUHJvdmlkZXJWYWx1ZVByb3A7XG4gIC8qKiBBbiBhcHAgc3RhdGUgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byBHbG9iYWxBcHBTdGF0ZVByb3ZpZGVyICovXG4gIGluaXRpYWxBcHBTdGF0ZT86IG9iamVjdDtcbiAgLyoqIEEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBhcHAgY29uZmlnIHN0YXRlIGlzIHVwZGF0ZWQgKi9cbiAgb25BcHBTdGF0ZUNoYW5nZT86IChzdGF0ZTogb2JqZWN0KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSByb290IGxldmVsIGNvbXBvbmVudCB0aGF0IHNob3VsZCB3cmFwIHRoZSBOZXh0LmpzIEFwcCBjb21wb25lbnQuXG4gKlxuICogVGhpcyB3aWxsIGNvbnRhaW4gYW55IGFwcCB3aWRlIGN1c3RvbSBsb2dpYyB3aGljaCBjYW4gdGhlbiBiZSBjb25zdW1lZCBpbiBvdGhlciBuZXN0ZWRcbiAqIHBhcnRzIG9mIHRoZSBhcHBsaWNhdGlvbi4gRm9yIGV4YW1wbGUsIGl0IHJlbmRlcnMgdGhlIGFwcGxpY2F0aW9uIGluc2lkZSBhbiBgR2xvYmFsQXBwU3RhdGVQcm92aWRlcmBcbiAqIGZvciBhcHAgd2lkZSBjb25maWcuXG4gKi9cbmV4cG9ydCBjb25zdCBBcHBXcmFwcGVyID0gPFRHbG9iYWxTdGF0ZSA9IFJlY29yZDxhbnksIGFueT4sPih7XG4gIGNoaWxkcmVuLFxuICBhcHBTdGF0ZSxcbiAgaW5pdGlhbEFwcFN0YXRlLFxuICBvbkFwcFN0YXRlQ2hhbmdlLFxufTogQXBwV3JhcHBlclByb3BzKSA9PiB7XG4gIGNvbnN0IGdsb2JhbEFwcFN0YXRlID0gdXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgbWVyZ2UoXG4gICAgICAgIERFRkFVTFRfQVBQX1NUQVRFLFxuICAgICAgICBhcHBTdGF0ZSxcbiAgICAgICAgaW5pdGlhbEFwcFN0YXRlID8geyBzdGF0ZTogaW5pdGlhbEFwcFN0YXRlIH0gOiB7fVxuICAgICAgKSxcbiAgICBbYXBwU3RhdGUsIGluaXRpYWxBcHBTdGF0ZV1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxHbG9iYWxBcHBTdGF0ZVByb3ZpZGVyPFRHbG9iYWxTdGF0ZT5cbiAgICAgIG9uQXBwU3RhdGVDaGFuZ2U9e29uQXBwU3RhdGVDaGFuZ2V9XG4gICAgICB2YWx1ZT17Z2xvYmFsQXBwU3RhdGV9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvR2xvYmFsQXBwU3RhdGVQcm92aWRlcj5cbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VNZW1vIiwibWVyZ2UiLCJHbG9iYWxBcHBTdGF0ZVByb3ZpZGVyIiwiREVGQVVMVF9BUFBfU1RBVEUiLCJzdGF0ZSIsIkFwcFdyYXBwZXIiLCJjaGlsZHJlbiIsImFwcFN0YXRlIiwiaW5pdGlhbEFwcFN0YXRlIiwib25BcHBTdGF0ZUNoYW5nZSIsImdsb2JhbEFwcFN0YXRlIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/common/AppWrapper/AppWrapper.tsx\n");

/***/ }),

/***/ "./src/components/common/AppWrapper/context/context.ts":
/*!*************************************************************!*\
  !*** ./src/components/common/AppWrapper/context/context.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobalAppStateContext: () => (/* binding */ GlobalAppStateContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst GlobalAppStateContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwV3JhcHBlci9jb250ZXh0L2NvbnRleHQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNDO0FBb0IvQixNQUFNQyx3QkFBd0JELG9EQUFhQSxDQUNoRCxDQUFDLEdBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL0FwcFdyYXBwZXIvY29udGV4dC9jb250ZXh0LnRzPzc1MTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDb25maWcgb2JqZWN0IGZvciBjb25maWd1cmluZyBhcHBsaWNhdGlvbiB3aWRlIHNldHRpbmdzXG4gKi9cbmV4cG9ydCB0eXBlIEdsb2JhbEFwcFN0YXRlQ29udGV4dFZhbHVlPFRTdGF0ZSA9IFJlY29yZDxhbnksIGFueT4+ID0ge1xuICAvKiogVGhlIHRpdGxlIG9mIHRoZSBhcHBsaWNhdGlvbiAoYXMgaXQgd291bGQgYmUgZGlzcGxheWVkIG9uIHRoZSBicm93c2VyIHRhYikgKi9cbiAgYXBwVGl0bGU/OiBzdHJpbmc7XG4gIC8qKiBQYXNzIHRydWUgdG8gZ2xvYmFsbHkgZGlzYWJsZSByZW5kZXJpbmcgb2YgU0VPIGNvbXBvbmVudHMgKi9cbiAgZGlzYWJsZVNFTz86IGJvb2xlYW47XG4gIC8qKiBQYXNzIHRydWUgdG8gZ2xvYmFsbHkgZGlzYWJsZSBzaGFyaW5nIG1ldGEgdGFncyAqL1xuICBkaXNhYmxlU0VPU2hhcmluZ1RhZ3M/OiBib29sZWFuO1xuICAvKiogUGFzcyB0cnVlIHRvIGdsb2JhbGx5IGRpc2FibGUgaW5kZXhpbmcgKHVzaW5nIDxtZXRhIGNvbnRlbnQ9XCJub2luZGV4XCIgbmFtZT1cInJvYm90c1wiIC8+KSAqL1xuICBkaXNhYmxlU0VPSW5kZXhpbmc/OiBib29sZWFuO1xuICAvKiogQXNzb3J0ZWQgc3RhdGUgd2hpY2ggY2FuIGJlIGRlY2lkZWQgYnkgdGhlIHVzZXIgKi9cbiAgc3RhdGU6IFRTdGF0ZTtcbiAgLyoqIFNldCBzdGF0ZSBmdW5jdGlvbiBmb3IgY3VzdG9tIHN0YXRlICovXG4gIHNldFN0YXRlOiAodXBkYXRlcjogKG9sZFN0YXRlOiBUU3RhdGUpID0+IFRTdGF0ZSkgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBjb25zdCBHbG9iYWxBcHBTdGF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PEdsb2JhbEFwcFN0YXRlQ29udGV4dFZhbHVlPihcbiAge30gYXMgR2xvYmFsQXBwU3RhdGVDb250ZXh0VmFsdWVcbik7XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsIkdsb2JhbEFwcFN0YXRlQ29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/common/AppWrapper/context/context.ts\n");

/***/ }),

/***/ "./src/components/common/AppWrapper/context/index.ts":
/*!***********************************************************!*\
  !*** ./src/components/common/AppWrapper/context/index.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context */ \"./src/components/common/AppWrapper/context/context.ts\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _context__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _context__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider */ \"./src/components/common/AppWrapper/context/provider.tsx\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _provider__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _provider__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwV3JhcHBlci9jb250ZXh0L2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwQjtBQUNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9BcHBXcmFwcGVyL2NvbnRleHQvaW5kZXgudHM/ZTI1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2NvbnRleHQnO1xuZXhwb3J0ICogZnJvbSAnLi9wcm92aWRlcic7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/common/AppWrapper/context/index.ts\n");

/***/ }),

/***/ "./src/components/common/AppWrapper/context/provider.tsx":
/*!***************************************************************!*\
  !*** ./src/components/common/AppWrapper/context/provider.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobalAppStateProvider: () => (/* binding */ GlobalAppStateProvider)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\");\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ \"./src/components/common/AppWrapper/context/context.ts\");\n\n\n\n\n/**\n * Provider to pass app config to nested parts of an application\n */ const GlobalAppStateProvider = ({ children, value, onAppStateChange })=>{\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(value?.state || {});\n    const handleSetState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((newState)=>{\n        setState((prev)=>{\n            const newComputedState = typeof newState === \"function\" && lodash_isFunction__WEBPACK_IMPORTED_MODULE_2___default()(newState) ? newState(prev || {}) : {\n                ...prev,\n                ...newState\n            };\n            if (onAppStateChange) {\n                onAppStateChange(newComputedState);\n            }\n            return newComputedState;\n        });\n    }, [\n        onAppStateChange\n    ]);\n    const valueToPass = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            ...value,\n            state,\n            setState: handleSetState\n        }), [\n        value,\n        state,\n        handleSetState\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context__WEBPACK_IMPORTED_MODULE_3__.GlobalAppStateContext.Provider, {\n        value: valueToPass,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/AppWrapper/context/provider.tsx\",\n        lineNumber: 64,\n        columnNumber: 5\n    }, undefined);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwV3JhcHBlci9jb250ZXh0L3Byb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFDOEQ7QUFFbkI7QUFDTztBQWtCbEQ7O0NBRUMsR0FDTSxNQUFNTSx5QkFBeUIsQ0FBNkIsRUFDakVDLFFBQVEsRUFDUkMsS0FBSyxFQUNMQyxnQkFBZ0IsRUFDb0I7SUFDcEMsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdULCtDQUFRQSxDQUFDTSxPQUFPRSxTQUFTLENBQUM7SUFFcEQsTUFBTUUsaUJBQWlCWCxrREFBV0EsQ0FDaEMsQ0FBQ1k7UUFDQ0YsU0FBUyxDQUFDRztZQUNSLE1BQU1DLG1CQUNKLE9BQU9GLGFBQWEsY0FBY1Qsd0RBQVVBLENBQUNTLFlBQ3pDQSxTQUFTQyxRQUFRLENBQUMsS0FDbEI7Z0JBQ0UsR0FBR0EsSUFBSTtnQkFDUCxHQUFHRCxRQUFRO1lBQ2I7WUFFTixJQUFJSixrQkFBa0I7Z0JBQ3BCQSxpQkFBaUJNO1lBQ25CO1lBRUEsT0FBT0E7UUFDVDtJQUNGLEdBQ0E7UUFBQ047S0FBaUI7SUFHcEIsTUFBTU8sY0FBY2IsOENBQU9BLENBQ3pCLElBQU87WUFDTCxHQUFHSyxLQUFLO1lBQ1JFO1lBQ0FDLFVBQVVDO1FBQ1osSUFDQTtRQUFDSjtRQUFPRTtRQUFPRTtLQUFlO0lBR2hDLHFCQUNFLDhEQUFDUCwyREFBcUJBLENBQUNZLFFBQVE7UUFBQ1QsT0FBT1E7a0JBQ3BDVDs7Ozs7O0FBR1AsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BmeC9hcHAtZnJvbnQtZW5kLXdlYnNpdGUvLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwV3JhcHBlci9jb250ZXh0L3Byb3ZpZGVyLnRzeD9kMGNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgT25lT2ZPckFycmF5T2YgfSBmcm9tICdAZngvbGliLXV0aWxpdHktdHlwZXMnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnbG9kYXNoL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgR2xvYmFsQXBwU3RhdGVDb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCB0eXBlIHsgR2xvYmFsQXBwU3RhdGVDb250ZXh0VmFsdWUgfSBmcm9tICcuL2NvbnRleHQnO1xuXG4vKipcbiAqIFZhbHVlIHByb3AgZm9yIEdsb2JhbEFwcFN0YXRlUHJvdmlkZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHbG9iYWxBcHBTdGF0ZVByb3ZpZGVyVmFsdWVQcm9wPFRTdGF0ZSA9IFJlY29yZDxhbnksIGFueT4+XG4gIGV4dGVuZHMgT21pdDxHbG9iYWxBcHBTdGF0ZUNvbnRleHRWYWx1ZTxUU3RhdGU+LCAnc2V0U3RhdGUnPiB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbEFwcFN0YXRlUHJvdmlkZXJQcm9wczxUU3RhdGU+IHtcbiAgLyoqIENoaWxkIGVsZW1lbnQgcmVuZGVyZWQgaW5zaWRlIHRoZSBHbG9iYWxBcHBTdGF0ZVByb3ZpZGVyICovXG4gIGNoaWxkcmVuOiBPbmVPZk9yQXJyYXlPZjxSZWFjdE5vZGUgfCBudWxsPjtcbiAgLyoqIEFuIGFwcCBjb25maWcgb2JqZWN0ICovXG4gIHZhbHVlOiBHbG9iYWxBcHBTdGF0ZVByb3ZpZGVyVmFsdWVQcm9wPFRTdGF0ZT47XG4gIC8qKiBBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYXBwIGNvbmZpZyBzdGF0ZSBpcyB1cGRhdGVkICovXG4gIG9uQXBwU3RhdGVDaGFuZ2U/OiAoc3RhdGU6IG9iamVjdCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBQcm92aWRlciB0byBwYXNzIGFwcCBjb25maWcgdG8gbmVzdGVkIHBhcnRzIG9mIGFuIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBHbG9iYWxBcHBTdGF0ZVByb3ZpZGVyID0gPFRTdGF0ZSA9IFJlY29yZDxhbnksIGFueT4sPih7XG4gIGNoaWxkcmVuLFxuICB2YWx1ZSxcbiAgb25BcHBTdGF0ZUNoYW5nZSxcbn06IEdsb2JhbEFwcFN0YXRlUHJvdmlkZXJQcm9wczxUU3RhdGU+KSA9PiB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUodmFsdWU/LnN0YXRlIHx8IHt9KTtcblxuICBjb25zdCBoYW5kbGVTZXRTdGF0ZSA9IHVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZTogb2JqZWN0IHwgKChuZXdTdGF0ZTogb2JqZWN0KSA9PiBvYmplY3QpKSA9PiB7XG4gICAgICBzZXRTdGF0ZSgocHJldjogb2JqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0NvbXB1dGVkU3RhdGUgPVxuICAgICAgICAgIHR5cGVvZiBuZXdTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Z1bmN0aW9uKG5ld1N0YXRlKVxuICAgICAgICAgICAgPyBuZXdTdGF0ZShwcmV2IHx8IHt9KVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAob25BcHBTdGF0ZUNoYW5nZSkge1xuICAgICAgICAgIG9uQXBwU3RhdGVDaGFuZ2UobmV3Q29tcHV0ZWRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3Q29tcHV0ZWRTdGF0ZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW29uQXBwU3RhdGVDaGFuZ2VdXG4gICk7XG5cbiAgY29uc3QgdmFsdWVUb1Bhc3MgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICAuLi52YWx1ZSxcbiAgICAgIHN0YXRlLFxuICAgICAgc2V0U3RhdGU6IGhhbmRsZVNldFN0YXRlLFxuICAgIH0pLFxuICAgIFt2YWx1ZSwgc3RhdGUsIGhhbmRsZVNldFN0YXRlXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPEdsb2JhbEFwcFN0YXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWVUb1Bhc3N9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvR2xvYmFsQXBwU3RhdGVDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUNhbGxiYWNrIiwidXNlU3RhdGUiLCJ1c2VNZW1vIiwiaXNGdW5jdGlvbiIsIkdsb2JhbEFwcFN0YXRlQ29udGV4dCIsIkdsb2JhbEFwcFN0YXRlUHJvdmlkZXIiLCJjaGlsZHJlbiIsInZhbHVlIiwib25BcHBTdGF0ZUNoYW5nZSIsInN0YXRlIiwic2V0U3RhdGUiLCJoYW5kbGVTZXRTdGF0ZSIsIm5ld1N0YXRlIiwicHJldiIsIm5ld0NvbXB1dGVkU3RhdGUiLCJ2YWx1ZVRvUGFzcyIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/common/AppWrapper/context/provider.tsx\n");

/***/ }),

/***/ "./src/components/common/AppWrapper/hooks/index.ts":
/*!*********************************************************!*\
  !*** ./src/components/common/AppWrapper/hooks/index.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _useGlobalAppState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useGlobalAppState */ \"./src/components/common/AppWrapper/hooks/useGlobalAppState.ts\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _useGlobalAppState__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _useGlobalAppState__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwV3JhcHBlci9ob29rcy9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BmeC9hcHAtZnJvbnQtZW5kLXdlYnNpdGUvLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwV3JhcHBlci9ob29rcy9pbmRleC50cz8yNTQ1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vdXNlR2xvYmFsQXBwU3RhdGUnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/common/AppWrapper/hooks/index.ts\n");

/***/ }),

/***/ "./src/components/common/AppWrapper/hooks/useGlobalAppState.ts":
/*!*********************************************************************!*\
  !*** ./src/components/common/AppWrapper/hooks/useGlobalAppState.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGlobalAppState: () => (/* binding */ useGlobalAppState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../context */ \"./src/components/common/AppWrapper/context/index.ts\");\n\n\n/**\n * Hook to allow consumption of the app config from GlobalAppStateProvider\n */ const useGlobalAppState = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context__WEBPACK_IMPORTED_MODULE_1__.GlobalAppStateContext);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwV3JhcHBlci9ob29rcy91c2VHbG9iYWxBcHBTdGF0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1DO0FBRWdCO0FBRW5EOztDQUVDLEdBQ00sTUFBTUUsb0JBQW9CLElBQy9CRixpREFBVUEsQ0FBQ0MsMkRBQXFCQSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9BcHBXcmFwcGVyL2hvb2tzL3VzZUdsb2JhbEFwcFN0YXRlLnRzPzUwMWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgR2xvYmFsQXBwU3RhdGVDb250ZXh0VmFsdWUgfSBmcm9tICcuLi9jb250ZXh0JztcbmltcG9ydCB7IEdsb2JhbEFwcFN0YXRlQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuXG4vKipcbiAqIEhvb2sgdG8gYWxsb3cgY29uc3VtcHRpb24gb2YgdGhlIGFwcCBjb25maWcgZnJvbSBHbG9iYWxBcHBTdGF0ZVByb3ZpZGVyXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VHbG9iYWxBcHBTdGF0ZSA9ICgpOiBHbG9iYWxBcHBTdGF0ZUNvbnRleHRWYWx1ZSA9PlxuICB1c2VDb250ZXh0KEdsb2JhbEFwcFN0YXRlQ29udGV4dCk7XG4iXSwibmFtZXMiOlsidXNlQ29udGV4dCIsIkdsb2JhbEFwcFN0YXRlQ29udGV4dCIsInVzZUdsb2JhbEFwcFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/common/AppWrapper/hooks/useGlobalAppState.ts\n");

/***/ }),

/***/ "./src/components/common/AppWrapper/index.ts":
/*!***************************************************!*\
  !*** ./src/components/common/AppWrapper/index.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AppWrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AppWrapper */ \"./src/components/common/AppWrapper/AppWrapper.tsx\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _AppWrapper__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _AppWrapper__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context */ \"./src/components/common/AppWrapper/context/index.ts\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _context__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _context__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks */ \"./src/components/common/AppWrapper/hooks/index.ts\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _hooks__WEBPACK_IMPORTED_MODULE_2__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _hooks__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwV3JhcHBlci9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ0g7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0BmeC9hcHAtZnJvbnQtZW5kLXdlYnNpdGUvLi9zcmMvY29tcG9uZW50cy9jb21tb24vQXBwV3JhcHBlci9pbmRleC50cz8wOTk1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vQXBwV3JhcHBlcic7XG5leHBvcnQgKiBmcm9tICcuL2NvbnRleHQnO1xuZXhwb3J0ICogZnJvbSAnLi9ob29rcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/common/AppWrapper/index.ts\n");

/***/ }),

/***/ "./src/components/common/ErrorBoundary/ErrorBoundary.tsx":
/*!***************************************************************!*\
  !*** ./src/components/common/ErrorBoundary/ErrorBoundary.tsx ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorBoundaryCustom: () => (/* binding */ ErrorBoundaryCustom),\n/* harmony export */   ErrorPage: () => (/* binding */ ErrorPage),\n/* harmony export */   alertForError: () => (/* binding */ alertForError),\n/* harmony export */   logError: () => (/* binding */ logError)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_error_boundary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-error-boundary */ \"react-error-boundary\");\n/* harmony import */ var _fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fx/app-front-end-components */ \"../app-front-end-components/lib/index.esm.js\");\n/* harmony import */ var _fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Page_PageError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Page/PageError */ \"./src/components/common/Page/PageError/index.ts\");\n/* harmony import */ var _ErrorBoundary_module_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ErrorBoundary.module.scss */ \"./src/components/common/ErrorBoundary/ErrorBoundary.module.scss\");\n/* harmony import */ var _ErrorBoundary_module_scss__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_ErrorBoundary_module_scss__WEBPACK_IMPORTED_MODULE_5__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([react_error_boundary__WEBPACK_IMPORTED_MODULE_2__]);\nreact_error_boundary__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* __next_internal_client_entry_do_not_use__ alertForError,logError,ErrorPage,ErrorBoundaryCustom auto */ \n\n\n\n\n\nlet hasAlertedForError = false;\nconst alertForError = (message = \"error\")=>{\n    if (!hasAlertedForError) {\n        hasAlertedForError = true;\n        alert(message);\n        // Don't alert again for 20 seconds\n        setTimeout(()=>{\n            hasAlertedForError = false;\n        }, 20000);\n    }\n};\nconst logError = ({ error, message, info, alertForError: shouldAlertForError = true })=>{\n    console.error(error || message);\n    console.info(\"ERROR\", JSON.stringify({\n        error,\n        message,\n        info\n    }, null, 2));\n    if (shouldAlertForError) {\n        alertForError(message);\n    }\n};\nconst ErrorPage = ({ error, resetErrorBoundary, callbackOnError, resetErrorBoundaryImmediately = !!callbackOnError, disableUI = !!resetErrorBoundaryImmediately, displayErrorAsTextOnScreen, errorState })=>{\n    const { resetBoundary } = (0,react_error_boundary__WEBPACK_IMPORTED_MODULE_2__.useErrorBoundary)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (resetErrorBoundaryImmediately) {\n            resetErrorBoundary();\n            resetBoundary();\n        }\n    }, [\n        error,\n        callbackOnError,\n        resetErrorBoundary,\n        resetErrorBoundaryImmediately,\n        resetBoundary\n    ]);\n    return disableUI ? null : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_ErrorBoundary_module_scss__WEBPACK_IMPORTED_MODULE_5___default().errorPage),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Page_PageError__WEBPACK_IMPORTED_MODULE_4__.PageError, {\n            onClickButton: resetErrorBoundary,\n            children: displayErrorAsTextOnScreen ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__.Flex, {\n                className: (_ErrorBoundary_module_scss__WEBPACK_IMPORTED_MODULE_5___default().errorText),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__.Text, {\n                    children: JSON.stringify(errorState, null, 2)\n                }, void 0, false, {\n                    fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/ErrorBoundary/ErrorBoundary.tsx\",\n                    lineNumber: 103,\n                    columnNumber: 13\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/ErrorBoundary/ErrorBoundary.tsx\",\n                lineNumber: 102,\n                columnNumber: 11\n            }, undefined) : null\n        }, void 0, false, {\n            fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/ErrorBoundary/ErrorBoundary.tsx\",\n            lineNumber: 100,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/ErrorBoundary/ErrorBoundary.tsx\",\n        lineNumber: 99,\n        columnNumber: 5\n    }, undefined);\n};\nconst ErrorBoundaryCustom = ({ callbackOnError, getCurrentErrorContext, getShouldAlertForError = ()=>true, ...props })=>{\n    const [errorState, setErrorState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const FallbackComponent = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((...propsInternal)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ErrorPage, {\n            ...props,\n            ...propsInternal,\n            errorState\n        }, void 0, false, {\n            fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/ErrorBoundary/ErrorBoundary.tsx\",\n            lineNumber: 130,\n            columnNumber: 7\n        }, undefined), [\n        props,\n        errorState\n    ]);\n    const logErrorCallback = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((error, errorInfo)=>{\n        const errorLog = {\n            error,\n            message: error?.message,\n            errorInfo,\n            info: {\n                ...getCurrentErrorContext?.() || {}\n            }\n        };\n        setErrorState(errorLog);\n        logError({\n            ...errorLog,\n            alertForError: getShouldAlertForError()\n        });\n        if (callbackOnError) {\n            callbackOnError(errorLog);\n        }\n    }, [\n        callbackOnError,\n        getCurrentErrorContext,\n        getShouldAlertForError\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_error_boundary__WEBPACK_IMPORTED_MODULE_2__.ErrorBoundary, {\n        ...props,\n        FallbackComponent: FallbackComponent,\n        onError: logErrorCallback\n    }, void 0, false, {\n        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/ErrorBoundary/ErrorBoundary.tsx\",\n        lineNumber: 161,\n        columnNumber: 5\n    }, undefined);\n};\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vRXJyb3JCb3VuZGFyeS9FcnJvckJvdW5kYXJ5LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHeUQ7QUFLYztBQUNiO0FBQ1o7QUFDRztBQUVqRCxJQUFJUyxxQkFBcUI7QUFFbEIsTUFBTUMsZ0JBQWdCLENBQUNDLFVBQVUsT0FBTztJQUM3QyxJQUFJLENBQUNGLG9CQUFvQjtRQUN2QkEscUJBQXFCO1FBRXJCRyxNQUFNRDtRQUVOLG1DQUFtQztRQUNuQ0UsV0FBVztZQUNUSixxQkFBcUI7UUFDdkIsR0FBRztJQUNMO0FBQ0YsRUFBRTtBQUVLLE1BQU1LLFdBQVcsQ0FBQyxFQUN2QkMsS0FBSyxFQUNMSixPQUFPLEVBQ1BLLElBQUksRUFDSk4sZUFBZU8sc0JBQXNCLElBQUksRUFNMUM7SUFDQ0MsUUFBUUgsS0FBSyxDQUFDQSxTQUFTSjtJQUN2Qk8sUUFBUUYsSUFBSSxDQUNWLFNBQ0FHLEtBQUtDLFNBQVMsQ0FDWjtRQUNFTDtRQUNBSjtRQUNBSztJQUNGLEdBQ0EsTUFDQTtJQUlKLElBQUlDLHFCQUFxQjtRQUN2QlAsY0FBY0M7SUFDaEI7QUFDRixFQUFFO0FBaUJLLE1BQU1VLFlBQVksQ0FBQyxFQUN4Qk4sS0FBSyxFQUNMTyxrQkFBa0IsRUFDbEJDLGVBQWUsRUFDZkMsZ0NBQWdDLENBQUMsQ0FBQ0QsZUFBZSxFQUNqREUsWUFBWSxDQUFDLENBQUNELDZCQUE2QixFQUMzQ0UsMEJBQTBCLEVBQzFCQyxVQUFVLEVBQ0s7SUFDZixNQUFNLEVBQUVDLGFBQWEsRUFBRSxHQUFHeEIsc0VBQWdCQTtJQUUxQ0gsZ0RBQVNBLENBQUM7UUFDUixJQUFJdUIsK0JBQStCO1lBQ2pDRjtZQUNBTTtRQUNGO0lBQ0YsR0FBRztRQUNEYjtRQUNBUTtRQUNBRDtRQUNBRTtRQUNBSTtLQUNEO0lBRUQsT0FBT0gsWUFBWSxxQkFDakIsOERBQUNJO1FBQUlDLFdBQVd0Qiw2RUFBZ0I7a0JBQzlCLDRFQUFDRCxzREFBU0E7WUFBQ3lCLGVBQWVWO3NCQUN2QkksMkNBQ0MsOERBQUNyQiw4REFBSUE7Z0JBQUN5QixXQUFXdEIsNkVBQWdCOzBCQUMvQiw0RUFBQ0YsOERBQUlBOzhCQUFFYSxLQUFLQyxTQUFTLENBQUNPLFlBQVksTUFBTTs7Ozs7Ozs7Ozs0QkFFeEM7Ozs7Ozs7Ozs7O0FBSVosRUFBRTtBQVdLLE1BQU1PLHNCQUFvRCxDQUFDLEVBQ2hFWCxlQUFlLEVBQ2ZZLHNCQUFzQixFQUN0QkMseUJBQXlCLElBQU0sSUFBSSxFQUNuQyxHQUFHQyxPQUNKO0lBQ0MsTUFBTSxDQUFDVixZQUFZVyxjQUFjLEdBQUdwQywrQ0FBUUE7SUFFNUMsTUFBTXFDLG9CQUFvQnZDLGtEQUFXQSxDQUNuQyxDQUFDLEdBQUd3Qyw4QkFDRiw4REFBQ25CO1lBQWdCLEdBQUdnQixLQUFLO1lBQUUsR0FBR0csYUFBYTtZQUFFYjs7Ozs7dUJBRS9DO1FBQUNVO1FBQU9WO0tBQVc7SUFHckIsTUFBTWMsbUJBQW1CekMsa0RBQVdBLENBQ2xDLENBQUNlLE9BQWMyQjtRQUNiLE1BQU1DLFdBQVc7WUFDZjVCO1lBQ0FKLFNBQVNJLE9BQU9KO1lBQ2hCK0I7WUFDQTFCLE1BQU07Z0JBQ0osR0FBSW1CLDhCQUE4QixDQUFDLENBQUM7WUFDdEM7UUFDRjtRQUVBRyxjQUFjSztRQUVkN0IsU0FBUztZQUNQLEdBQUc2QixRQUFRO1lBQ1hqQyxlQUFlMEI7UUFDakI7UUFFQSxJQUFJYixpQkFBaUI7WUFDbkJBLGdCQUFnQm9CO1FBQ2xCO0lBQ0YsR0FDQTtRQUFDcEI7UUFBaUJZO1FBQXdCQztLQUF1QjtJQUduRSxxQkFDRSw4REFBQ2pDLCtEQUFhQTtRQUNYLEdBQUdrQyxLQUFLO1FBQ1RFLG1CQUFtQkE7UUFDbkJLLFNBQVNIOzs7Ozs7QUFHZixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9FcnJvckJvdW5kYXJ5L0Vycm9yQm91bmRhcnkudHN4PzM3MjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgdHlwZSB7IEVycm9ySW5mbywgRkMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHtcbiAgRXJyb3JCb3VuZGFyeVByb3BzV2l0aENvbXBvbmVudCxcbiAgRmFsbGJhY2tQcm9wcyxcbn0gZnJvbSAncmVhY3QtZXJyb3ItYm91bmRhcnknO1xuaW1wb3J0IHsgRXJyb3JCb3VuZGFyeSwgdXNlRXJyb3JCb3VuZGFyeSB9IGZyb20gJ3JlYWN0LWVycm9yLWJvdW5kYXJ5JztcbmltcG9ydCB7IEZsZXgsIFRleHQgfSBmcm9tICdAZngvYXBwLWZyb250LWVuZC1jb21wb25lbnRzJztcbmltcG9ydCB7IFBhZ2VFcnJvciB9IGZyb20gJy4uL1BhZ2UvUGFnZUVycm9yJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9FcnJvckJvdW5kYXJ5Lm1vZHVsZS5zY3NzJztcblxubGV0IGhhc0FsZXJ0ZWRGb3JFcnJvciA9IGZhbHNlO1xuXG5leHBvcnQgY29uc3QgYWxlcnRGb3JFcnJvciA9IChtZXNzYWdlID0gJ2Vycm9yJykgPT4ge1xuICBpZiAoIWhhc0FsZXJ0ZWRGb3JFcnJvcikge1xuICAgIGhhc0FsZXJ0ZWRGb3JFcnJvciA9IHRydWU7XG5cbiAgICBhbGVydChtZXNzYWdlKTtcblxuICAgIC8vIERvbid0IGFsZXJ0IGFnYWluIGZvciAyMCBzZWNvbmRzXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoYXNBbGVydGVkRm9yRXJyb3IgPSBmYWxzZTtcbiAgICB9LCAyMDAwMCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBsb2dFcnJvciA9ICh7XG4gIGVycm9yLFxuICBtZXNzYWdlLFxuICBpbmZvLFxuICBhbGVydEZvckVycm9yOiBzaG91bGRBbGVydEZvckVycm9yID0gdHJ1ZSxcbn06IHtcbiAgZXJyb3I/OiBFcnJvcjtcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgaW5mbz86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIGFsZXJ0Rm9yRXJyb3I/OiBib29sZWFuO1xufSkgPT4ge1xuICBjb25zb2xlLmVycm9yKGVycm9yIHx8IG1lc3NhZ2UpO1xuICBjb25zb2xlLmluZm8oXG4gICAgJ0VSUk9SJyxcbiAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgIHtcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGluZm8sXG4gICAgICB9LFxuICAgICAgbnVsbCxcbiAgICAgIDJcbiAgICApXG4gICk7XG5cbiAgaWYgKHNob3VsZEFsZXJ0Rm9yRXJyb3IpIHtcbiAgICBhbGVydEZvckVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG5pbnRlcmZhY2UgRXJyb3JMb2dPYmplY3Qge1xuICBlcnJvcjogRXJyb3I7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgZXJyb3JJbmZvOiBFcnJvckluZm87XG4gIGluZm86IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JQYWdlUHJvcHMgZXh0ZW5kcyBGYWxsYmFja1Byb3BzIHtcbiAgY2FsbGJhY2tPbkVycm9yPzogKHBhcmFtczogRXJyb3JMb2dPYmplY3QpID0+IHZvaWQ7XG4gIHJlc2V0RXJyb3JCb3VuZGFyeUltbWVkaWF0ZWx5PzogYm9vbGVhbjtcbiAgZGlzYWJsZVVJPzogYm9vbGVhbjtcbiAgZGlzcGxheUVycm9yQXNUZXh0T25TY3JlZW4/OiBib29sZWFuO1xuICBlcnJvclN0YXRlOiBFcnJvckxvZ09iamVjdCB8IG51bGw7XG59XG5cbmV4cG9ydCBjb25zdCBFcnJvclBhZ2UgPSAoe1xuICBlcnJvcixcbiAgcmVzZXRFcnJvckJvdW5kYXJ5LFxuICBjYWxsYmFja09uRXJyb3IsXG4gIHJlc2V0RXJyb3JCb3VuZGFyeUltbWVkaWF0ZWx5ID0gISFjYWxsYmFja09uRXJyb3IsXG4gIGRpc2FibGVVSSA9ICEhcmVzZXRFcnJvckJvdW5kYXJ5SW1tZWRpYXRlbHksXG4gIGRpc3BsYXlFcnJvckFzVGV4dE9uU2NyZWVuLFxuICBlcnJvclN0YXRlLFxufTogRXJyb3JQYWdlUHJvcHMpID0+IHtcbiAgY29uc3QgeyByZXNldEJvdW5kYXJ5IH0gPSB1c2VFcnJvckJvdW5kYXJ5KCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVzZXRFcnJvckJvdW5kYXJ5SW1tZWRpYXRlbHkpIHtcbiAgICAgIHJlc2V0RXJyb3JCb3VuZGFyeSgpO1xuICAgICAgcmVzZXRCb3VuZGFyeSgpO1xuICAgIH1cbiAgfSwgW1xuICAgIGVycm9yLFxuICAgIGNhbGxiYWNrT25FcnJvcixcbiAgICByZXNldEVycm9yQm91bmRhcnksXG4gICAgcmVzZXRFcnJvckJvdW5kYXJ5SW1tZWRpYXRlbHksXG4gICAgcmVzZXRCb3VuZGFyeSxcbiAgXSk7XG5cbiAgcmV0dXJuIGRpc2FibGVVSSA/IG51bGwgOiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5lcnJvclBhZ2V9PlxuICAgICAgPFBhZ2VFcnJvciBvbkNsaWNrQnV0dG9uPXtyZXNldEVycm9yQm91bmRhcnl9PlxuICAgICAgICB7ZGlzcGxheUVycm9yQXNUZXh0T25TY3JlZW4gPyAoXG4gICAgICAgICAgPEZsZXggY2xhc3NOYW1lPXtzdHlsZXMuZXJyb3JUZXh0fT5cbiAgICAgICAgICAgIDxUZXh0PntKU09OLnN0cmluZ2lmeShlcnJvclN0YXRlLCBudWxsLCAyKX08L1RleHQ+XG4gICAgICAgICAgPC9GbGV4PlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvUGFnZUVycm9yPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxudHlwZSBFcnJvckJvdW5kYXJ5Q3VzdG9tUHJvcHMgPSBPbWl0PFxuICBFcnJvckJvdW5kYXJ5UHJvcHNXaXRoQ29tcG9uZW50ICZcbiAgICBPbWl0PEVycm9yUGFnZVByb3BzLCAnZXJyb3InIHwgJ2Vycm9yU3RhdGUnPixcbiAgJ0ZhbGxiYWNrQ29tcG9uZW50J1xuPiAmIHtcbiAgZ2V0Q3VycmVudEVycm9yQ29udGV4dD86ICgpID0+IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIGdldFNob3VsZEFsZXJ0Rm9yRXJyb3I/OiAoKSA9PiBib29sZWFuO1xufTtcblxuZXhwb3J0IGNvbnN0IEVycm9yQm91bmRhcnlDdXN0b206IEZDPEVycm9yQm91bmRhcnlDdXN0b21Qcm9wcz4gPSAoe1xuICBjYWxsYmFja09uRXJyb3IsXG4gIGdldEN1cnJlbnRFcnJvckNvbnRleHQsXG4gIGdldFNob3VsZEFsZXJ0Rm9yRXJyb3IgPSAoKSA9PiB0cnVlLFxuICAuLi5wcm9wc1xufSkgPT4ge1xuICBjb25zdCBbZXJyb3JTdGF0ZSwgc2V0RXJyb3JTdGF0ZV0gPSB1c2VTdGF0ZTxFcnJvckxvZ09iamVjdCB8IG51bGw+KCk7XG5cbiAgY29uc3QgRmFsbGJhY2tDb21wb25lbnQgPSB1c2VDYWxsYmFjayhcbiAgICAoLi4ucHJvcHNJbnRlcm5hbDogYW55KSA9PiAoXG4gICAgICA8RXJyb3JQYWdlIHsuLi57IC4uLnByb3BzLCAuLi5wcm9wc0ludGVybmFsLCBlcnJvclN0YXRlIH19IC8+XG4gICAgKSxcbiAgICBbcHJvcHMsIGVycm9yU3RhdGVdXG4gICk7XG5cbiAgY29uc3QgbG9nRXJyb3JDYWxsYmFjayA9IHVzZUNhbGxiYWNrKFxuICAgIChlcnJvcjogRXJyb3IsIGVycm9ySW5mbzogRXJyb3JJbmZvKSA9PiB7XG4gICAgICBjb25zdCBlcnJvckxvZyA9IHtcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yPy5tZXNzYWdlLFxuICAgICAgICBlcnJvckluZm8sXG4gICAgICAgIGluZm86IHtcbiAgICAgICAgICAuLi4oZ2V0Q3VycmVudEVycm9yQ29udGV4dD8uKCkgfHwge30pLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgc2V0RXJyb3JTdGF0ZShlcnJvckxvZyk7XG5cbiAgICAgIGxvZ0Vycm9yKHtcbiAgICAgICAgLi4uZXJyb3JMb2csXG4gICAgICAgIGFsZXJ0Rm9yRXJyb3I6IGdldFNob3VsZEFsZXJ0Rm9yRXJyb3IoKSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY2FsbGJhY2tPbkVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrT25FcnJvcihlcnJvckxvZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbY2FsbGJhY2tPbkVycm9yLCBnZXRDdXJyZW50RXJyb3JDb250ZXh0LCBnZXRTaG91bGRBbGVydEZvckVycm9yXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPEVycm9yQm91bmRhcnlcbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIEZhbGxiYWNrQ29tcG9uZW50PXtGYWxsYmFja0NvbXBvbmVudH1cbiAgICAgIG9uRXJyb3I9e2xvZ0Vycm9yQ2FsbGJhY2t9XG4gICAgLz5cbiAgKTtcbn07XG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkVycm9yQm91bmRhcnkiLCJ1c2VFcnJvckJvdW5kYXJ5IiwiRmxleCIsIlRleHQiLCJQYWdlRXJyb3IiLCJzdHlsZXMiLCJoYXNBbGVydGVkRm9yRXJyb3IiLCJhbGVydEZvckVycm9yIiwibWVzc2FnZSIsImFsZXJ0Iiwic2V0VGltZW91dCIsImxvZ0Vycm9yIiwiZXJyb3IiLCJpbmZvIiwic2hvdWxkQWxlcnRGb3JFcnJvciIsImNvbnNvbGUiLCJKU09OIiwic3RyaW5naWZ5IiwiRXJyb3JQYWdlIiwicmVzZXRFcnJvckJvdW5kYXJ5IiwiY2FsbGJhY2tPbkVycm9yIiwicmVzZXRFcnJvckJvdW5kYXJ5SW1tZWRpYXRlbHkiLCJkaXNhYmxlVUkiLCJkaXNwbGF5RXJyb3JBc1RleHRPblNjcmVlbiIsImVycm9yU3RhdGUiLCJyZXNldEJvdW5kYXJ5IiwiZGl2IiwiY2xhc3NOYW1lIiwiZXJyb3JQYWdlIiwib25DbGlja0J1dHRvbiIsImVycm9yVGV4dCIsIkVycm9yQm91bmRhcnlDdXN0b20iLCJnZXRDdXJyZW50RXJyb3JDb250ZXh0IiwiZ2V0U2hvdWxkQWxlcnRGb3JFcnJvciIsInByb3BzIiwic2V0RXJyb3JTdGF0ZSIsIkZhbGxiYWNrQ29tcG9uZW50IiwicHJvcHNJbnRlcm5hbCIsImxvZ0Vycm9yQ2FsbGJhY2siLCJlcnJvckluZm8iLCJlcnJvckxvZyIsIm9uRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/common/ErrorBoundary/ErrorBoundary.tsx\n");

/***/ }),

/***/ "./src/components/common/ErrorBoundary/index.ts":
/*!******************************************************!*\
  !*** ./src/components/common/ErrorBoundary/index.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ErrorBoundary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ErrorBoundary */ \"./src/components/common/ErrorBoundary/ErrorBoundary.tsx\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_ErrorBoundary__WEBPACK_IMPORTED_MODULE_0__]);\n_ErrorBoundary__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _ErrorBoundary__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _ErrorBoundary__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vRXJyb3JCb3VuZGFyeS9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BmeC9hcHAtZnJvbnQtZW5kLXdlYnNpdGUvLi9zcmMvY29tcG9uZW50cy9jb21tb24vRXJyb3JCb3VuZGFyeS9pbmRleC50cz82NDA2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vRXJyb3JCb3VuZGFyeSc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/common/ErrorBoundary/index.ts\n");

/***/ }),

/***/ "./src/components/common/Page/PageError/PageError.tsx":
/*!************************************************************!*\
  !*** ./src/components/common/Page/PageError/PageError.tsx ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PageError: () => (/* binding */ PageError)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classnames */ \"classnames\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fx/app-front-end-components */ \"../app-front-end-components/lib/index.esm.js\");\n/* harmony import */ var _fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _PageError_module_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PageError.module.scss */ \"./src/components/common/Page/PageError/PageError.module.scss\");\n/* harmony import */ var _PageError_module_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_PageError_module_scss__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\nconst PageError = ({ className, title, titleComponent, subtitle, subtitleComponent, description, descriptionComponent, buttonText, buttonHref, buttonComponent, defaultToNotFound = false, onClickButton, children })=>{\n    const defaults = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>defaultToNotFound ? {\n            title: \"404\",\n            subtitle: \"Page does not exist...\",\n            description: \"It may have been removed or moved to a new location\",\n            buttonComponent: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__.Anchor, {\n                href: buttonHref || \"/\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__.Button, {\n                    children: buttonText || \"Go to home\"\n                }, void 0, false, {\n                    fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/Page/PageError/PageError.tsx\",\n                    lineNumber: 47,\n                    columnNumber: 17\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/Page/PageError/PageError.tsx\",\n                lineNumber: 46,\n                columnNumber: 15\n            }, undefined),\n            buttonText: \"Go to home\",\n            buttonHref: \"/\"\n        } : {\n            title: \"Error\",\n            subtitle: \"We encountered an issue...\",\n            // description: <>Please get in touch with us.</>,\n            buttonText: \"Go to home\",\n            buttonHref: \"/\"\n        }, [\n        defaultToNotFound,\n        buttonHref,\n        buttonText\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__.Flex, {\n        className: classnames__WEBPACK_IMPORTED_MODULE_2___default()((_PageError_module_scss__WEBPACK_IMPORTED_MODULE_4___default().errorWrapper), className),\n        children: [\n            titleComponent || /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__.Text, {\n                bold: true,\n                className: (_PageError_module_scss__WEBPACK_IMPORTED_MODULE_4___default().title),\n                fontSize: \"h1\",\n                children: title || defaults.title\n            }, void 0, false, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/Page/PageError/PageError.tsx\",\n                lineNumber: 65,\n                columnNumber: 9\n            }, undefined),\n            subtitleComponent || /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__.Text, {\n                bold500: true,\n                className: (_PageError_module_scss__WEBPACK_IMPORTED_MODULE_4___default().subtitle),\n                italic: true,\n                children: subtitle || defaults.subtitle\n            }, void 0, false, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/Page/PageError/PageError.tsx\",\n                lineNumber: 70,\n                columnNumber: 9\n            }, undefined),\n            descriptionComponent || /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__.Text, {\n                className: (_PageError_module_scss__WEBPACK_IMPORTED_MODULE_4___default().description),\n                fontSize: \"sm\",\n                children: description || defaults.description\n            }, void 0, false, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/Page/PageError/PageError.tsx\",\n                lineNumber: 75,\n                columnNumber: 9\n            }, undefined),\n            buttonComponent || /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__.Anchor, {\n                href: buttonHref || defaults.buttonHref,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_3__.Button, {\n                    onClick: onClickButton,\n                    children: buttonText || defaults.buttonText\n                }, void 0, false, {\n                    fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/Page/PageError/PageError.tsx\",\n                    lineNumber: 81,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/Page/PageError/PageError.tsx\",\n                lineNumber: 80,\n                columnNumber: 9\n            }, undefined),\n            children\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/components/common/Page/PageError/PageError.tsx\",\n        lineNumber: 63,\n        columnNumber: 5\n    }, undefined);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vUGFnZS9QYWdlRXJyb3IvUGFnZUVycm9yLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFDZ0M7QUFDSTtBQUNzQztBQUM3QjtBQWtCdEMsTUFBTU8sWUFBZ0MsQ0FBQyxFQUM1Q0MsU0FBUyxFQUNUQyxLQUFLLEVBQ0xDLGNBQWMsRUFDZEMsUUFBUSxFQUNSQyxpQkFBaUIsRUFDakJDLFdBQVcsRUFDWEMsb0JBQW9CLEVBQ3BCQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsZUFBZSxFQUNmQyxvQkFBb0IsS0FBSyxFQUN6QkMsYUFBYSxFQUNiQyxRQUFRLEVBQ1Q7SUFDQyxNQUFNQyxXQUFXckIsOENBQU9BLENBQ3RCLElBQ0VrQixvQkFDSTtZQUNFVCxPQUFPO1lBQ1BFLFVBQVU7WUFDVkUsYUFBYTtZQUNiSSwrQkFDRSw4REFBQ2YsZ0VBQU1BO2dCQUFDb0IsTUFBTU4sY0FBYzswQkFDMUIsNEVBQUNiLGdFQUFNQTs4QkFBRVksY0FBYzs7Ozs7Ozs7Ozs7WUFHM0JBLFlBQVk7WUFDWkMsWUFBWTtRQUNkLElBQ0E7WUFDRVAsT0FBTztZQUNQRSxVQUFVO1lBQ1Ysa0RBQWtEO1lBQ2xESSxZQUFZO1lBQ1pDLFlBQVk7UUFDZCxHQUNOO1FBQUNFO1FBQW1CRjtRQUFZRDtLQUFXO0lBRTdDLHFCQUNFLDhEQUFDWCw4REFBSUE7UUFBQ0ksV0FBV1AsaURBQVVBLENBQUNLLDRFQUFtQixFQUFFRTs7WUFDOUNFLGdDQUNDLDhEQUFDTCw4REFBSUE7Z0JBQUNtQixJQUFJO2dCQUFDaEIsV0FBV0YscUVBQVk7Z0JBQUVtQixVQUFTOzBCQUMxQ2hCLFNBQVNZLFNBQVNaLEtBQUs7Ozs7OztZQUczQkcsbUNBQ0MsOERBQUNQLDhEQUFJQTtnQkFBQ3FCLE9BQU87Z0JBQUNsQixXQUFXRix3RUFBZTtnQkFBRXFCLE1BQU07MEJBQzdDaEIsWUFBWVUsU0FBU1YsUUFBUTs7Ozs7O1lBR2pDRyxzQ0FDQyw4REFBQ1QsOERBQUlBO2dCQUFDRyxXQUFXRiwyRUFBa0I7Z0JBQUVtQixVQUFTOzBCQUMzQ1osZUFBZVEsU0FBU1IsV0FBVzs7Ozs7O1lBR3ZDSSxpQ0FDQyw4REFBQ2YsZ0VBQU1BO2dCQUFDb0IsTUFBTU4sY0FBY0ssU0FBU0wsVUFBVTswQkFDN0MsNEVBQUNiLGdFQUFNQTtvQkFBQ3lCLFNBQVNUOzhCQUNkSixjQUFjTSxTQUFTTixVQUFVOzs7Ozs7Ozs7OztZQUl2Q0s7Ozs7Ozs7QUFHUCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9QYWdlL1BhZ2VFcnJvci9QYWdlRXJyb3IudHN4P2Q3N2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGQywgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgQW5jaG9yLCBCdXR0b24sIEZsZXgsIFRleHQgfSBmcm9tICdAZngvYXBwLWZyb250LWVuZC1jb21wb25lbnRzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9QYWdlRXJyb3IubW9kdWxlLnNjc3MnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2VFcnJvclByb3BzIHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICB0aXRsZT86IFJlYWN0Tm9kZTtcbiAgdGl0bGVDb21wb25lbnQ/OiBSZWFjdE5vZGU7XG4gIHN1YnRpdGxlPzogUmVhY3ROb2RlO1xuICBzdWJ0aXRsZUNvbXBvbmVudD86IFJlYWN0Tm9kZTtcbiAgZGVzY3JpcHRpb24/OiBSZWFjdE5vZGU7XG4gIGRlc2NyaXB0aW9uQ29tcG9uZW50PzogUmVhY3ROb2RlO1xuICBidXR0b25UZXh0PzogUmVhY3ROb2RlO1xuICBidXR0b25IcmVmPzogc3RyaW5nO1xuICBidXR0b25Db21wb25lbnQ/OiBSZWFjdE5vZGU7XG4gIGRlZmF1bHRUb05vdEZvdW5kPzogYm9vbGVhbjtcbiAgb25DbGlja0J1dHRvbj86ICgpID0+IHZvaWQ7XG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgY29uc3QgUGFnZUVycm9yOiBGQzxQYWdlRXJyb3JQcm9wcz4gPSAoe1xuICBjbGFzc05hbWUsXG4gIHRpdGxlLFxuICB0aXRsZUNvbXBvbmVudCxcbiAgc3VidGl0bGUsXG4gIHN1YnRpdGxlQ29tcG9uZW50LFxuICBkZXNjcmlwdGlvbixcbiAgZGVzY3JpcHRpb25Db21wb25lbnQsXG4gIGJ1dHRvblRleHQsXG4gIGJ1dHRvbkhyZWYsXG4gIGJ1dHRvbkNvbXBvbmVudCxcbiAgZGVmYXVsdFRvTm90Rm91bmQgPSBmYWxzZSxcbiAgb25DbGlja0J1dHRvbixcbiAgY2hpbGRyZW4sXG59KSA9PiB7XG4gIGNvbnN0IGRlZmF1bHRzID0gdXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgZGVmYXVsdFRvTm90Rm91bmRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICB0aXRsZTogJzQwNCcsXG4gICAgICAgICAgICBzdWJ0aXRsZTogJ1BhZ2UgZG9lcyBub3QgZXhpc3QuLi4nLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdJdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQgb3IgbW92ZWQgdG8gYSBuZXcgbG9jYXRpb24nLFxuICAgICAgICAgICAgYnV0dG9uQ29tcG9uZW50OiAoXG4gICAgICAgICAgICAgIDxBbmNob3IgaHJlZj17YnV0dG9uSHJlZiB8fCAnLyd9PlxuICAgICAgICAgICAgICAgIDxCdXR0b24+e2J1dHRvblRleHQgfHwgJ0dvIHRvIGhvbWUnfTwvQnV0dG9uPlxuICAgICAgICAgICAgICA8L0FuY2hvcj5cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBidXR0b25UZXh0OiAnR28gdG8gaG9tZScsXG4gICAgICAgICAgICBidXR0b25IcmVmOiAnLycsXG4gICAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHRpdGxlOiAnRXJyb3InLFxuICAgICAgICAgICAgc3VidGl0bGU6ICdXZSBlbmNvdW50ZXJlZCBhbiBpc3N1ZS4uLicsXG4gICAgICAgICAgICAvLyBkZXNjcmlwdGlvbjogPD5QbGVhc2UgZ2V0IGluIHRvdWNoIHdpdGggdXMuPC8+LFxuICAgICAgICAgICAgYnV0dG9uVGV4dDogJ0dvIHRvIGhvbWUnLFxuICAgICAgICAgICAgYnV0dG9uSHJlZjogJy8nLFxuICAgICAgICAgIH0sXG4gICAgW2RlZmF1bHRUb05vdEZvdW5kLCBidXR0b25IcmVmLCBidXR0b25UZXh0XVxuICApO1xuICByZXR1cm4gKFxuICAgIDxGbGV4IGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhzdHlsZXMuZXJyb3JXcmFwcGVyLCBjbGFzc05hbWUpfT5cbiAgICAgIHt0aXRsZUNvbXBvbmVudCB8fCAoXG4gICAgICAgIDxUZXh0IGJvbGQgY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9IGZvbnRTaXplPVwiaDFcIj5cbiAgICAgICAgICB7dGl0bGUgfHwgZGVmYXVsdHMudGl0bGV9XG4gICAgICAgIDwvVGV4dD5cbiAgICAgICl9XG4gICAgICB7c3VidGl0bGVDb21wb25lbnQgfHwgKFxuICAgICAgICA8VGV4dCBib2xkNTAwIGNsYXNzTmFtZT17c3R5bGVzLnN1YnRpdGxlfSBpdGFsaWM+XG4gICAgICAgICAge3N1YnRpdGxlIHx8IGRlZmF1bHRzLnN1YnRpdGxlfVxuICAgICAgICA8L1RleHQ+XG4gICAgICApfVxuICAgICAge2Rlc2NyaXB0aW9uQ29tcG9uZW50IHx8IChcbiAgICAgICAgPFRleHQgY2xhc3NOYW1lPXtzdHlsZXMuZGVzY3JpcHRpb259IGZvbnRTaXplPVwic21cIj5cbiAgICAgICAgICB7ZGVzY3JpcHRpb24gfHwgZGVmYXVsdHMuZGVzY3JpcHRpb259XG4gICAgICAgIDwvVGV4dD5cbiAgICAgICl9XG4gICAgICB7YnV0dG9uQ29tcG9uZW50IHx8IChcbiAgICAgICAgPEFuY2hvciBocmVmPXtidXR0b25IcmVmIHx8IGRlZmF1bHRzLmJ1dHRvbkhyZWZ9PlxuICAgICAgICAgIDxCdXR0b24gb25DbGljaz17b25DbGlja0J1dHRvbn0+XG4gICAgICAgICAgICB7YnV0dG9uVGV4dCB8fCBkZWZhdWx0cy5idXR0b25UZXh0fVxuICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8L0FuY2hvcj5cbiAgICAgICl9XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9GbGV4PlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VNZW1vIiwiY2xhc3NOYW1lcyIsIkFuY2hvciIsIkJ1dHRvbiIsIkZsZXgiLCJUZXh0Iiwic3R5bGVzIiwiUGFnZUVycm9yIiwiY2xhc3NOYW1lIiwidGl0bGUiLCJ0aXRsZUNvbXBvbmVudCIsInN1YnRpdGxlIiwic3VidGl0bGVDb21wb25lbnQiLCJkZXNjcmlwdGlvbiIsImRlc2NyaXB0aW9uQ29tcG9uZW50IiwiYnV0dG9uVGV4dCIsImJ1dHRvbkhyZWYiLCJidXR0b25Db21wb25lbnQiLCJkZWZhdWx0VG9Ob3RGb3VuZCIsIm9uQ2xpY2tCdXR0b24iLCJjaGlsZHJlbiIsImRlZmF1bHRzIiwiaHJlZiIsImVycm9yV3JhcHBlciIsImJvbGQiLCJmb250U2l6ZSIsImJvbGQ1MDAiLCJpdGFsaWMiLCJvbkNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/common/Page/PageError/PageError.tsx\n");

/***/ }),

/***/ "./src/components/common/Page/PageError/index.ts":
/*!*******************************************************!*\
  !*** ./src/components/common/Page/PageError/index.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _PageError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PageError */ \"./src/components/common/Page/PageError/PageError.tsx\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _PageError__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _PageError__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb21tb24vUGFnZS9QYWdlRXJyb3IvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL1BhZ2UvUGFnZUVycm9yL2luZGV4LnRzP2I3OTEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9QYWdlRXJyb3InO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/common/Page/PageError/index.ts\n");

/***/ }),

/***/ "./src/config/app-universal.ts":
/*!*************************************!*\
  !*** ./src/config/app-universal.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APP_CONFIG_UNIVERSAL: () => (/* binding */ APP_CONFIG_UNIVERSAL)\n/* harmony export */ });\n/**\n * This is the config object for configuring application wide settings, which can also work in middleware\n */ const APP_CONFIG_UNIVERSAL = {\n    appTitleShort: \"Affector\",\n    disableSEOSharingTags: true,\n    disableSEOIndexing: true,\n    reactQueryCacheVersion: \"1.0.0\",\n    stateCacheVersion: 1\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29uZmlnL2FwcC11bml2ZXJzYWwudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztDQUVDLEdBQ00sTUFBTUEsdUJBQXVCO0lBQ2xDQyxlQUFlO0lBQ2ZDLHVCQUF1QjtJQUN2QkMsb0JBQW9CO0lBQ3BCQyx3QkFBd0I7SUFDeEJDLG1CQUFtQjtBQUNyQixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9jb25maWcvYXBwLXVuaXZlcnNhbC50cz9lZWMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBpcyB0aGUgY29uZmlnIG9iamVjdCBmb3IgY29uZmlndXJpbmcgYXBwbGljYXRpb24gd2lkZSBzZXR0aW5ncywgd2hpY2ggY2FuIGFsc28gd29yayBpbiBtaWRkbGV3YXJlXG4gKi9cbmV4cG9ydCBjb25zdCBBUFBfQ09ORklHX1VOSVZFUlNBTCA9IHtcbiAgYXBwVGl0bGVTaG9ydDogJ0FmZmVjdG9yJyxcbiAgZGlzYWJsZVNFT1NoYXJpbmdUYWdzOiB0cnVlLFxuICBkaXNhYmxlU0VPSW5kZXhpbmc6IHRydWUsXG4gIHJlYWN0UXVlcnlDYWNoZVZlcnNpb246ICcxLjAuMCcsXG4gIHN0YXRlQ2FjaGVWZXJzaW9uOiAxLFxufTtcbiJdLCJuYW1lcyI6WyJBUFBfQ09ORklHX1VOSVZFUlNBTCIsImFwcFRpdGxlU2hvcnQiLCJkaXNhYmxlU0VPU2hhcmluZ1RhZ3MiLCJkaXNhYmxlU0VPSW5kZXhpbmciLCJyZWFjdFF1ZXJ5Q2FjaGVWZXJzaW9uIiwic3RhdGVDYWNoZVZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/config/app-universal.ts\n");

/***/ }),

/***/ "./src/config/app.ts":
/*!***************************!*\
  !*** ./src/config/app.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APP_CONFIG: () => (/* binding */ APP_CONFIG)\n/* harmony export */ });\n/* harmony import */ var lodash_startCase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/startCase */ \"lodash/startCase\");\n/* harmony import */ var lodash_startCase__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_startCase__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! env */ \"./src/env.ts\");\n/* harmony import */ var _app_universal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app-universal */ \"./src/config/app-universal.ts\");\n\n\n\nconst appEnv = (0,env__WEBPACK_IMPORTED_MODULE_1__.getEnvVariable)(\"NEXT_PUBLIC_APP_ENV\");\nconst basePath = (0,env__WEBPACK_IMPORTED_MODULE_1__.getEnvVariable)(\"NEXT_PUBLIC_BASE_PATH\");\n/**\n * This is the config object for configuring application wide settings\n */ const APP_CONFIG = {\n    ..._app_universal__WEBPACK_IMPORTED_MODULE_2__.APP_CONFIG_UNIVERSAL,\n    basePath,\n    appEnv,\n    appTitle: `Affector${appEnv === \"production\" || !appEnv ? \"\" : ` - ${lodash_startCase__WEBPACK_IMPORTED_MODULE_0___default()(appEnv)}`}`\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29uZmlnL2FwcC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5QztBQUNKO0FBQ2tCO0FBRXZELE1BQU1HLFNBQVNGLG1EQUFjQSxDQUFDO0FBQzlCLE1BQU1HLFdBQVdILG1EQUFjQSxDQUFDO0FBRWhDOztDQUVDLEdBQ00sTUFBTUksYUFBYTtJQUN4QixHQUFHSCxnRUFBb0I7SUFDdkJFO0lBQ0FEO0lBQ0FHLFVBQVUsQ0FBQyxRQUFRLEVBQ2pCSCxXQUFXLGdCQUFnQixDQUFDQSxTQUFTLEtBQUssQ0FBQyxHQUFHLEVBQUVILHVEQUFTQSxDQUFDRyxRQUFRLENBQUMsQ0FDcEUsQ0FBQztBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL2NvbmZpZy9hcHAudHM/YjJhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3RhcnRDYXNlIGZyb20gJ2xvZGFzaC9zdGFydENhc2UnO1xuaW1wb3J0IHsgZ2V0RW52VmFyaWFibGUgfSBmcm9tICdlbnYnO1xuaW1wb3J0IHsgQVBQX0NPTkZJR19VTklWRVJTQUwgfSBmcm9tICcuL2FwcC11bml2ZXJzYWwnO1xuXG5jb25zdCBhcHBFbnYgPSBnZXRFbnZWYXJpYWJsZSgnTkVYVF9QVUJMSUNfQVBQX0VOVicpO1xuY29uc3QgYmFzZVBhdGggPSBnZXRFbnZWYXJpYWJsZSgnTkVYVF9QVUJMSUNfQkFTRV9QQVRIJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29uZmlnIG9iamVjdCBmb3IgY29uZmlndXJpbmcgYXBwbGljYXRpb24gd2lkZSBzZXR0aW5nc1xuICovXG5leHBvcnQgY29uc3QgQVBQX0NPTkZJRyA9IHtcbiAgLi4uQVBQX0NPTkZJR19VTklWRVJTQUwsXG4gIGJhc2VQYXRoLFxuICBhcHBFbnYsXG4gIGFwcFRpdGxlOiBgQWZmZWN0b3Ike1xuICAgIGFwcEVudiA9PT0gJ3Byb2R1Y3Rpb24nIHx8ICFhcHBFbnYgPyAnJyA6IGAgLSAke3N0YXJ0Q2FzZShhcHBFbnYpfWBcbiAgfWAsXG59O1xuIl0sIm5hbWVzIjpbInN0YXJ0Q2FzZSIsImdldEVudlZhcmlhYmxlIiwiQVBQX0NPTkZJR19VTklWRVJTQUwiLCJhcHBFbnYiLCJiYXNlUGF0aCIsIkFQUF9DT05GSUciLCJhcHBUaXRsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/config/app.ts\n");

/***/ }),

/***/ "./src/config/elements.ts":
/*!********************************!*\
  !*** ./src/config/elements.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MODAL_ROOT_ELEMENT_ID: () => (/* binding */ MODAL_ROOT_ELEMENT_ID)\n/* harmony export */ });\nconst MODAL_ROOT_ELEMENT_ID = \"modal-root\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29uZmlnL2VsZW1lbnRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSx3QkFBd0IsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL0BmeC9hcHAtZnJvbnQtZW5kLXdlYnNpdGUvLi9zcmMvY29uZmlnL2VsZW1lbnRzLnRzPzVlNDIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IE1PREFMX1JPT1RfRUxFTUVOVF9JRCA9ICdtb2RhbC1yb290JztcbiJdLCJuYW1lcyI6WyJNT0RBTF9ST09UX0VMRU1FTlRfSUQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/config/elements.ts\n");

/***/ }),

/***/ "./src/contexts/global/index.tsx":
/*!***************************************!*\
  !*** ./src/contexts/global/index.tsx ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobalStateContext: () => (/* binding */ GlobalStateContext),\n/* harmony export */   GlobalStateProvider: () => (/* binding */ GlobalStateProvider),\n/* harmony export */   useGlobalStateContext: () => (/* binding */ useGlobalStateContext)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst useContextValue = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({}), []);\n};\nconst GlobalStateContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst useGlobalStateContext = ()=>(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(GlobalStateContext);\nconst GlobalStateProvider = ({ children })=>{\n    const value = useContextValue();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(GlobalStateContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/contexts/global/index.tsx\",\n        lineNumber: 26,\n        columnNumber: 5\n    }, undefined);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29udGV4dHMvZ2xvYmFsL2luZGV4LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUMyRDtBQUUzRCxNQUFNRyxrQkFBa0I7SUFDdEIsT0FBT0QsOENBQU9BLENBQUMsSUFBTyxFQUFDLElBQUksRUFBRTtBQUMvQjtBQUlPLE1BQU1FLG1DQUFxQkosb0RBQWFBLENBQzdDLE1BQ0E7QUFFSyxNQUFNSyx3QkFBd0IsSUFBTUosaURBQVVBLENBQUNHLG9CQUFvQjtBQU1uRSxNQUFNRSxzQkFBb0QsQ0FBQyxFQUNoRUMsUUFBUSxFQUNUO0lBQ0MsTUFBTUMsUUFBUUw7SUFFZCxxQkFDRSw4REFBQ0MsbUJBQW1CSyxRQUFRO1FBQUNELE9BQU9BO2tCQUNqQ0Q7Ozs7OztBQUdQLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL2NvbnRleHRzL2dsb2JhbC9pbmRleC50c3g/NzNhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZDLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCB1c2VDb250ZXh0VmFsdWUgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+ICh7fSksIFtdKTtcbn07XG5cbmV4cG9ydCB0eXBlIEdsb2JhbFN0YXRlQ29udGV4dFZhbHVlID0gUmV0dXJuVHlwZTx0eXBlb2YgdXNlQ29udGV4dFZhbHVlPjtcblxuZXhwb3J0IGNvbnN0IEdsb2JhbFN0YXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8R2xvYmFsU3RhdGVDb250ZXh0VmFsdWUgfCBudWxsPihcbiAgbnVsbFxuKTtcblxuZXhwb3J0IGNvbnN0IHVzZUdsb2JhbFN0YXRlQ29udGV4dCA9ICgpID0+IHVzZUNvbnRleHQoR2xvYmFsU3RhdGVDb250ZXh0KTtcblxuZXhwb3J0IGludGVyZmFjZSBHbG9iYWxTdGF0ZVByb3ZpZGVyUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgY29uc3QgR2xvYmFsU3RhdGVQcm92aWRlcjogRkM8R2xvYmFsU3RhdGVQcm92aWRlclByb3BzPiA9ICh7XG4gIGNoaWxkcmVuLFxufSkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IHVzZUNvbnRleHRWYWx1ZSgpO1xuXG4gIHJldHVybiAoXG4gICAgPEdsb2JhbFN0YXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvR2xvYmFsU3RhdGVDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJ1c2VDb250ZXh0VmFsdWUiLCJHbG9iYWxTdGF0ZUNvbnRleHQiLCJ1c2VHbG9iYWxTdGF0ZUNvbnRleHQiLCJHbG9iYWxTdGF0ZVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ2YWx1ZSIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/contexts/global/index.tsx\n");

/***/ }),

/***/ "./src/env.ts":
/*!********************!*\
  !*** ./src/env.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getEnvVariable: () => (/* binding */ getEnvVariable)\n/* harmony export */ });\n/* harmony import */ var _fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fx/lib-utilities */ \"../lib-utilities/lib/index.esm.js\");\n/* harmony import */ var _fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dotenv */ \"dotenv\");\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dotenv__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst result = dotenv__WEBPACK_IMPORTED_MODULE_1___default().config();\nconst env = (0,_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0__.parseEnvVariables)({\n    ...result.error ? process.env : {\n        /**\n         * Prioritise env variables already in the process.env\n         * This is because deployment env variables (via pm2) are not set in the local dotenv above.\n         */ ...result.parsed || {},\n        ...process.env\n    },\n    /**\n   * NEXT_PUBLIC_BASE_PATH needs to be added manually to the env variables.\n   * That's because it is injected in next.config.js rather than via .env files.\n   * It must be extracted without destructuring: https://nextjs.org/docs/pages/api-reference/next-config-js/env\n   */ NEXT_PUBLIC_BASE_PATH: \"\"\n});\nconst getEnvVariable = (key, { asNumber, asCommaSeparatedList } = {})=>{\n    let value;\n    if ((0,_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0__.isBrowser)()) {\n        const variable = (0,_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0__.parseEnvVariable)(window?.__ENV?.[key]);\n        value = variable === undefined ? env[key] : variable;\n    } else {\n        value = env[key];\n    }\n    if (asCommaSeparatedList) {\n        return (value || \"\").split(\",\").map((v)=>asNumber ? Number(v.trim()) : v.trim());\n    }\n    if (asNumber) {\n        return Number(value);\n    }\n    return value;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (env);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZW52LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUkyQjtBQUNDO0FBRTVCLE1BQU1JLFNBQVNELG9EQUFhO0FBRTVCLE1BQU1HLE1BQU1MLG9FQUFpQkEsQ0FBQztJQUM1QixHQUFJRyxPQUFPRyxLQUFLLEdBQ1pDLFFBQVFGLEdBQUcsR0FDWDtRQUNFOzs7U0FHQyxHQUNELEdBQUlGLE9BQU9LLE1BQU0sSUFBSSxDQUFDLENBQUM7UUFDdkIsR0FBR0QsUUFBUUYsR0FBRztJQUNoQixDQUFDO0lBQ0w7Ozs7R0FJQyxHQUNESSx1QkFBdUJGLEVBQWlDO0FBQzFEO0FBRU8sTUFBTUcsaUJBQWlCLENBQzVCQyxLQUNBLEVBQ0VDLFFBQVEsRUFDUkMsb0JBQW9CLEVBQ21DLEdBQUcsQ0FBQyxDQUFDO0lBRTlELElBQUlDO0lBRUosSUFBSWYsNERBQVNBLElBQUk7UUFDZixNQUFNZ0IsV0FBV2QsbUVBQWdCQSxDQUM5QmUsUUFBMkRDLE9BQU8sQ0FBQ04sSUFBSTtRQUcxRUcsUUFBUUMsYUFBYUcsWUFBWWIsR0FBRyxDQUFDTSxJQUFJLEdBQUdJO0lBQzlDLE9BQU87UUFDTEQsUUFBUVQsR0FBRyxDQUFDTSxJQUFJO0lBQ2xCO0lBRUEsSUFBSUUsc0JBQXNCO1FBQ3hCLE9BQU8sQ0FBQ0MsU0FBUyxFQUFDLEVBQ2ZLLEtBQUssQ0FBQyxLQUNOQyxHQUFHLENBQUMsQ0FBQ0MsSUFBZVQsV0FBV1UsT0FBT0QsRUFBRUUsSUFBSSxNQUFNRixFQUFFRSxJQUFJO0lBQzdEO0lBRUEsSUFBSVgsVUFBVTtRQUNaLE9BQU9VLE9BQU9SO0lBQ2hCO0lBRUEsT0FBT0E7QUFDVCxFQUFFO0FBRUYsaUVBQWVULEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL2Vudi50cz83MWI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGlzQnJvd3NlcixcbiAgcGFyc2VFbnZWYXJpYWJsZXMsXG4gIHBhcnNlRW52VmFyaWFibGUsXG59IGZyb20gJ0BmeC9saWItdXRpbGl0aWVzJztcbmltcG9ydCBkb3RlbnYgZnJvbSAnZG90ZW52JztcblxuY29uc3QgcmVzdWx0ID0gZG90ZW52LmNvbmZpZygpO1xuXG5jb25zdCBlbnYgPSBwYXJzZUVudlZhcmlhYmxlcyh7XG4gIC4uLihyZXN1bHQuZXJyb3JcbiAgICA/IHByb2Nlc3MuZW52XG4gICAgOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmlvcml0aXNlIGVudiB2YXJpYWJsZXMgYWxyZWFkeSBpbiB0aGUgcHJvY2Vzcy5lbnZcbiAgICAgICAgICogVGhpcyBpcyBiZWNhdXNlIGRlcGxveW1lbnQgZW52IHZhcmlhYmxlcyAodmlhIHBtMikgYXJlIG5vdCBzZXQgaW4gdGhlIGxvY2FsIGRvdGVudiBhYm92ZS5cbiAgICAgICAgICovXG4gICAgICAgIC4uLihyZXN1bHQucGFyc2VkIHx8IHt9KSxcbiAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICB9KSxcbiAgLyoqXG4gICAqIE5FWFRfUFVCTElDX0JBU0VfUEFUSCBuZWVkcyB0byBiZSBhZGRlZCBtYW51YWxseSB0byB0aGUgZW52IHZhcmlhYmxlcy5cbiAgICogVGhhdCdzIGJlY2F1c2UgaXQgaXMgaW5qZWN0ZWQgaW4gbmV4dC5jb25maWcuanMgcmF0aGVyIHRoYW4gdmlhIC5lbnYgZmlsZXMuXG4gICAqIEl0IG11c3QgYmUgZXh0cmFjdGVkIHdpdGhvdXQgZGVzdHJ1Y3R1cmluZzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvcGFnZXMvYXBpLXJlZmVyZW5jZS9uZXh0LWNvbmZpZy1qcy9lbnZcbiAgICovXG4gIE5FWFRfUFVCTElDX0JBU0VfUEFUSDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFTRV9QQVRILFxufSk7XG5cbmV4cG9ydCBjb25zdCBnZXRFbnZWYXJpYWJsZSA9IChcbiAga2V5OiBzdHJpbmcsXG4gIHtcbiAgICBhc051bWJlcixcbiAgICBhc0NvbW1hU2VwYXJhdGVkTGlzdCxcbiAgfTogeyBhc051bWJlcj86IGJvb2xlYW47IGFzQ29tbWFTZXBhcmF0ZWRMaXN0PzogYm9vbGVhbiB9ID0ge31cbikgPT4ge1xuICBsZXQgdmFsdWU7XG5cbiAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgY29uc3QgdmFyaWFibGUgPSBwYXJzZUVudlZhcmlhYmxlKFxuICAgICAgKHdpbmRvdyBhcyB0eXBlb2Ygd2luZG93ICYgeyBfX0VOVjogUmVjb3JkPHN0cmluZywgYW55PiB9KT8uX19FTlY/LltrZXldXG4gICAgKTtcblxuICAgIHZhbHVlID0gdmFyaWFibGUgPT09IHVuZGVmaW5lZCA/IGVudltrZXldIDogdmFyaWFibGU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBlbnZba2V5XTtcbiAgfVxuXG4gIGlmIChhc0NvbW1hU2VwYXJhdGVkTGlzdCkge1xuICAgIHJldHVybiAodmFsdWUgfHwgJycpXG4gICAgICAuc3BsaXQoJywnKVxuICAgICAgLm1hcCgodjogc3RyaW5nKSA9PiAoYXNOdW1iZXIgPyBOdW1iZXIodi50cmltKCkpIDogdi50cmltKCkpKTtcbiAgfVxuXG4gIGlmIChhc051bWJlcikge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZW52O1xuIl0sIm5hbWVzIjpbImlzQnJvd3NlciIsInBhcnNlRW52VmFyaWFibGVzIiwicGFyc2VFbnZWYXJpYWJsZSIsImRvdGVudiIsInJlc3VsdCIsImNvbmZpZyIsImVudiIsImVycm9yIiwicHJvY2VzcyIsInBhcnNlZCIsIk5FWFRfUFVCTElDX0JBU0VfUEFUSCIsImdldEVudlZhcmlhYmxlIiwia2V5IiwiYXNOdW1iZXIiLCJhc0NvbW1hU2VwYXJhdGVkTGlzdCIsInZhbHVlIiwidmFyaWFibGUiLCJ3aW5kb3ciLCJfX0VOViIsInVuZGVmaW5lZCIsInNwbGl0IiwibWFwIiwidiIsIk51bWJlciIsInRyaW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/env.ts\n");

/***/ }),

/***/ "./src/pages/_app.tsx":
/*!****************************!*\
  !*** ./src/pages/_app.tsx ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fx_app_front_end_components_lib_index_esm_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fx/app-front-end-components/lib/index.esm.css */ \"../app-front-end-components/lib/index.esm.css\");\n/* harmony import */ var _fx_app_front_end_components_lib_index_esm_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fx_app_front_end_components_lib_index_esm_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fx_app_front_end_components_lib_sass_root_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fx/app-front-end-components/lib/sass/root.scss */ \"../app-front-end-components/lib/sass/root.scss\");\n/* harmony import */ var _fx_app_front_end_components_lib_sass_root_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_fx_app_front_end_components_lib_sass_root_scss__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var styles_sass_root_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styles/sass/root.scss */ \"./src/styles/sass/root.scss\");\n/* harmony import */ var styles_sass_root_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(styles_sass_root_scss__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_toastify_dist_ReactToastify_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-toastify/dist/ReactToastify.css */ \"./node_modules/react-toastify/dist/ReactToastify.css\");\n/* harmony import */ var react_toastify_dist_ReactToastify_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_toastify_dist_ReactToastify_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _styles_global_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/global.css */ \"./src/styles/global.css\");\n/* harmony import */ var _styles_global_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_global_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var components_common_App__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! components/common/App */ \"./src/components/common/App/index.ts\");\n/* harmony import */ var config_app__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! config/app */ \"./src/config/app.ts\");\n/* harmony import */ var state_components_StoreProvider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! state/components/StoreProvider */ \"./src/state/components/StoreProvider/index.ts\");\n/* harmony import */ var _fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @fx/app-front-end-components */ \"../app-front-end-components/lib/index.esm.js\");\n/* harmony import */ var _fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var state_store__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! state/store */ \"./src/state/store/index.ts\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/head */ \"next/head\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var contexts_global__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! contexts/global */ \"./src/contexts/global/index.tsx\");\n/* harmony import */ var config_elements__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! config/elements */ \"./src/config/elements.ts\");\n/* harmony import */ var components_common_AppWrapper__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! components/common/AppWrapper */ \"./src/components/common/AppWrapper/index.ts\");\n/* harmony import */ var components_common_ErrorBoundary__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! components/common/ErrorBoundary */ \"./src/components/common/ErrorBoundary/index.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([components_common_App__WEBPACK_IMPORTED_MODULE_7__, state_components_StoreProvider__WEBPACK_IMPORTED_MODULE_9__, components_common_ErrorBoundary__WEBPACK_IMPORTED_MODULE_16__]);\n([components_common_App__WEBPACK_IMPORTED_MODULE_7__, state_components_StoreProvider__WEBPACK_IMPORTED_MODULE_9__, components_common_ErrorBoundary__WEBPACK_IMPORTED_MODULE_16__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/** Import component library styles */ \n\n\n/** Import global styles */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n// const { basePath } = APP_CONFIG;\nconst resetErrorBoundary = ()=>{\n    (0,state_store__WEBPACK_IMPORTED_MODULE_11__.resetAllStateSlices)();\n// window.location.href = window.location.origin + basePath;\n};\n/**\n * Custom App component which wraps the whole application\n */ const App = (props)=>{\n    const { Component, pageProps } = props;\n    const ComponentToRender = Component;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_12___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        content: \"width=device-width, initial-scale=1, user-scalable=no\",\n                        name: \"viewport\"\n                    }, void 0, false, {\n                        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                        lineNumber: 40,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        content: \"#141517\",\n                        name: \"theme-color\"\n                    }, void 0, false, {\n                        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                        lineNumber: 44,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        href: \"/favicon.ico\",\n                        rel: \"icon\"\n                    }, void 0, false, {\n                        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                        lineNumber: 45,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        href: \"/media/icons/apple-touch-icon.png\",\n                        rel: \"apple-touch-icon\",\n                        sizes: \"180x180\"\n                    }, void 0, false, {\n                        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                        lineNumber: 46,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        href: \"/media/icons/favicon-32x32.png\",\n                        rel: \"icon\",\n                        sizes: \"32x32\",\n                        type: \"image/png\"\n                    }, void 0, false, {\n                        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                        lineNumber: 51,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        href: \"/media/icons/favicon-16x16.png\",\n                        rel: \"icon\",\n                        sizes: \"16x16\",\n                        type: \"image/png\"\n                    }, void 0, false, {\n                        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                        lineNumber: 57,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                lineNumber: 39,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_common_ErrorBoundary__WEBPACK_IMPORTED_MODULE_16__.ErrorBoundaryCustom, {\n                disableUI: true,\n                resetErrorBoundary: resetErrorBoundary,\n                resetErrorBoundaryImmediately: true,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_common_AppWrapper__WEBPACK_IMPORTED_MODULE_15__.AppWrapper, {\n                    appState: (0,react__WEBPACK_IMPORTED_MODULE_6__.useMemo)(()=>({\n                            appTitle: config_app__WEBPACK_IMPORTED_MODULE_8__.APP_CONFIG.appTitle,\n                            state: {}\n                        }), []),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(state_components_StoreProvider__WEBPACK_IMPORTED_MODULE_9__.StoreProvider, {\n                        ...pageProps.initialZustandState,\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(contexts_global__WEBPACK_IMPORTED_MODULE_13__.GlobalStateProvider, {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fx_app_front_end_components__WEBPACK_IMPORTED_MODULE_10__.ModalProvider, {\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(components_common_App__WEBPACK_IMPORTED_MODULE_7__.App, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ComponentToRender, {\n                                            ...pageProps\n                                        }, void 0, false, {\n                                            fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                                            lineNumber: 83,\n                                            columnNumber: 19\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            id: config_elements__WEBPACK_IMPORTED_MODULE_14__.MODAL_ROOT_ELEMENT_ID\n                                        }, void 0, false, {\n                                            fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                                            lineNumber: 84,\n                                            columnNumber: 19\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                                    lineNumber: 82,\n                                    columnNumber: 17\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                                lineNumber: 81,\n                                columnNumber: 15\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                            lineNumber: 80,\n                            columnNumber: 13\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                        lineNumber: 79,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                    lineNumber: 70,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_app.tsx\",\n                lineNumber: 65,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvX2FwcC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0NBQW9DO0FBQ29CO0FBQ0M7QUFDekQseUJBQXlCLEdBQ007QUFDZ0I7QUFDakI7QUFFRTtBQUN3QjtBQUNoQjtBQUN1QjtBQUNGO0FBQ1g7QUFDckI7QUFDeUI7QUFDRTtBQUNFO0FBQ1k7QUFFdEUsbUNBQW1DO0FBRW5DLE1BQU1ZLHFCQUFxQjtJQUN6Qk4saUVBQW1CQTtBQUVuQiw0REFBNEQ7QUFDOUQ7QUFFQTs7Q0FFQyxHQUNELE1BQU1MLE1BQU0sQ0FBQ1k7SUFDWCxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFLEdBQUdGO0lBRWpDLE1BQU1HLG9CQUFvQkY7SUFFMUIscUJBQ0U7OzBCQUNFLDhEQUFDUCxtREFBSUE7O2tDQUNILDhEQUFDVTt3QkFDQ0MsU0FBUTt3QkFDUkMsTUFBSzs7Ozs7O2tDQUVQLDhEQUFDRjt3QkFBS0MsU0FBUTt3QkFBVUMsTUFBSzs7Ozs7O2tDQUM3Qiw4REFBQ0M7d0JBQUtDLE1BQUs7d0JBQWVDLEtBQUk7Ozs7OztrQ0FDOUIsOERBQUNGO3dCQUNDQyxNQUFLO3dCQUNMQyxLQUFJO3dCQUNKQyxPQUFNOzs7Ozs7a0NBRVIsOERBQUNIO3dCQUNDQyxNQUFLO3dCQUNMQyxLQUFJO3dCQUNKQyxPQUFNO3dCQUNOQyxNQUFLOzs7Ozs7a0NBRVAsOERBQUNKO3dCQUNDQyxNQUFLO3dCQUNMQyxLQUFJO3dCQUNKQyxPQUFNO3dCQUNOQyxNQUFLOzs7Ozs7Ozs7Ozs7MEJBSVQsOERBQUNiLGlGQUFtQkE7Z0JBQ2xCYyxTQUFTO2dCQUNUYixvQkFBb0JBO2dCQUNwQmMsNkJBQTZCOzBCQUU3Qiw0RUFBQ2hCLHFFQUFVQTtvQkFDVGlCLFVBQVUzQiw4Q0FBT0EsQ0FDZixJQUFPOzRCQUNMNEIsVUFBVXpCLGtEQUFVQSxDQUFDeUIsUUFBUTs0QkFDN0JDLE9BQU8sQ0FBQzt3QkFDVixJQUNBLEVBQUU7OEJBR0osNEVBQUN6Qix5RUFBYUE7d0JBQUUsR0FBR1csVUFBVWUsbUJBQW1CO2tDQUM5Qyw0RUFBQ3RCLGlFQUFtQkE7c0NBQ2xCLDRFQUFDSCx3RUFBYUE7MENBQ1osNEVBQUNILHNEQUFRQTs7c0RBQ1AsOERBQUNjOzRDQUFtQixHQUFHRCxTQUFTOzs7Ozs7c0RBQ2hDLDhEQUFDZ0I7NENBQUlDLElBQUl2QixtRUFBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTaEQ7QUFFQSxpRUFBZVIsR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BmeC9hcHAtZnJvbnQtZW5kLXdlYnNpdGUvLi9zcmMvcGFnZXMvX2FwcC50c3g/ZjlkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogSW1wb3J0IGNvbXBvbmVudCBsaWJyYXJ5IHN0eWxlcyAqL1xuaW1wb3J0ICdAZngvYXBwLWZyb250LWVuZC1jb21wb25lbnRzL2xpYi9pbmRleC5lc20uY3NzJztcbmltcG9ydCAnQGZ4L2FwcC1mcm9udC1lbmQtY29tcG9uZW50cy9saWIvc2Fzcy9yb290LnNjc3MnO1xuLyoqIEltcG9ydCBnbG9iYWwgc3R5bGVzICovXG5pbXBvcnQgJ3N0eWxlcy9zYXNzL3Jvb3Quc2Nzcyc7XG5pbXBvcnQgJ3JlYWN0LXRvYXN0aWZ5L2Rpc3QvUmVhY3RUb2FzdGlmeS5jc3MnO1xuaW1wb3J0ICcuLi9zdHlsZXMvZ2xvYmFsLmNzcyc7XG5pbXBvcnQgdHlwZSB7IEFwcFByb3BzIH0gZnJvbSAnbmV4dC9hcHAnO1xuaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFwcCBhcyBBcHBJbm5lciB9IGZyb20gJ2NvbXBvbmVudHMvY29tbW9uL0FwcCc7XG5pbXBvcnQgeyBBUFBfQ09ORklHIH0gZnJvbSAnY29uZmlnL2FwcCc7XG5pbXBvcnQgeyBTdG9yZVByb3ZpZGVyIH0gZnJvbSAnc3RhdGUvY29tcG9uZW50cy9TdG9yZVByb3ZpZGVyJztcbmltcG9ydCB7IE1vZGFsUHJvdmlkZXIgfSBmcm9tICdAZngvYXBwLWZyb250LWVuZC1jb21wb25lbnRzJztcbmltcG9ydCB7IHJlc2V0QWxsU3RhdGVTbGljZXMgfSBmcm9tICdzdGF0ZS9zdG9yZSc7XG5pbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnO1xuaW1wb3J0IHsgR2xvYmFsU3RhdGVQcm92aWRlciB9IGZyb20gJ2NvbnRleHRzL2dsb2JhbCc7XG5pbXBvcnQgeyBNT0RBTF9ST09UX0VMRU1FTlRfSUQgfSBmcm9tICdjb25maWcvZWxlbWVudHMnO1xuaW1wb3J0IHsgQXBwV3JhcHBlciB9IGZyb20gJ2NvbXBvbmVudHMvY29tbW9uL0FwcFdyYXBwZXInO1xuaW1wb3J0IHsgRXJyb3JCb3VuZGFyeUN1c3RvbSB9IGZyb20gJ2NvbXBvbmVudHMvY29tbW9uL0Vycm9yQm91bmRhcnknO1xuXG4vLyBjb25zdCB7IGJhc2VQYXRoIH0gPSBBUFBfQ09ORklHO1xuXG5jb25zdCByZXNldEVycm9yQm91bmRhcnkgPSAoKSA9PiB7XG4gIHJlc2V0QWxsU3RhdGVTbGljZXMoKTtcblxuICAvLyB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyBiYXNlUGF0aDtcbn07XG5cbi8qKlxuICogQ3VzdG9tIEFwcCBjb21wb25lbnQgd2hpY2ggd3JhcHMgdGhlIHdob2xlIGFwcGxpY2F0aW9uXG4gKi9cbmNvbnN0IEFwcCA9IChwcm9wczogQXBwUHJvcHMpID0+IHtcbiAgY29uc3QgeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9ID0gcHJvcHM7XG5cbiAgY29uc3QgQ29tcG9uZW50VG9SZW5kZXIgPSBDb21wb25lbnQgYXMgYW55O1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxIZWFkPlxuICAgICAgICA8bWV0YVxuICAgICAgICAgIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ub1wiXG4gICAgICAgICAgbmFtZT1cInZpZXdwb3J0XCJcbiAgICAgICAgLz5cbiAgICAgICAgPG1ldGEgY29udGVudD1cIiMxNDE1MTdcIiBuYW1lPVwidGhlbWUtY29sb3JcIiAvPlxuICAgICAgICA8bGluayBocmVmPVwiL2Zhdmljb24uaWNvXCIgcmVsPVwiaWNvblwiIC8+XG4gICAgICAgIDxsaW5rXG4gICAgICAgICAgaHJlZj1cIi9tZWRpYS9pY29ucy9hcHBsZS10b3VjaC1pY29uLnBuZ1wiXG4gICAgICAgICAgcmVsPVwiYXBwbGUtdG91Y2gtaWNvblwiXG4gICAgICAgICAgc2l6ZXM9XCIxODB4MTgwXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGxpbmtcbiAgICAgICAgICBocmVmPVwiL21lZGlhL2ljb25zL2Zhdmljb24tMzJ4MzIucG5nXCJcbiAgICAgICAgICByZWw9XCJpY29uXCJcbiAgICAgICAgICBzaXplcz1cIjMyeDMyXCJcbiAgICAgICAgICB0eXBlPVwiaW1hZ2UvcG5nXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGxpbmtcbiAgICAgICAgICBocmVmPVwiL21lZGlhL2ljb25zL2Zhdmljb24tMTZ4MTYucG5nXCJcbiAgICAgICAgICByZWw9XCJpY29uXCJcbiAgICAgICAgICBzaXplcz1cIjE2eDE2XCJcbiAgICAgICAgICB0eXBlPVwiaW1hZ2UvcG5nXCJcbiAgICAgICAgLz5cbiAgICAgICAgey8qIDxsaW5rIGhyZWY9XCIvc2l0ZS53ZWJtYW5pZmVzdFwiIHJlbD1cIm1hbmlmZXN0XCIgLz4gKi99XG4gICAgICA8L0hlYWQ+XG4gICAgICA8RXJyb3JCb3VuZGFyeUN1c3RvbVxuICAgICAgICBkaXNhYmxlVUlcbiAgICAgICAgcmVzZXRFcnJvckJvdW5kYXJ5PXtyZXNldEVycm9yQm91bmRhcnl9XG4gICAgICAgIHJlc2V0RXJyb3JCb3VuZGFyeUltbWVkaWF0ZWx5XG4gICAgICA+XG4gICAgICAgIDxBcHBXcmFwcGVyXG4gICAgICAgICAgYXBwU3RhdGU9e3VzZU1lbW8oXG4gICAgICAgICAgICAoKSA9PiAoe1xuICAgICAgICAgICAgICBhcHBUaXRsZTogQVBQX0NPTkZJRy5hcHBUaXRsZSxcbiAgICAgICAgICAgICAgc3RhdGU6IHt9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBbXVxuICAgICAgICAgICl9XG4gICAgICAgID5cbiAgICAgICAgICA8U3RvcmVQcm92aWRlciB7Li4ucGFnZVByb3BzLmluaXRpYWxadXN0YW5kU3RhdGV9PlxuICAgICAgICAgICAgPEdsb2JhbFN0YXRlUHJvdmlkZXI+XG4gICAgICAgICAgICAgIDxNb2RhbFByb3ZpZGVyPlxuICAgICAgICAgICAgICAgIDxBcHBJbm5lcj5cbiAgICAgICAgICAgICAgICAgIDxDb21wb25lbnRUb1JlbmRlciB7Li4ucGFnZVByb3BzfSAvPlxuICAgICAgICAgICAgICAgICAgPGRpdiBpZD17TU9EQUxfUk9PVF9FTEVNRU5UX0lEfSAvPlxuICAgICAgICAgICAgICAgIDwvQXBwSW5uZXI+XG4gICAgICAgICAgICAgIDwvTW9kYWxQcm92aWRlcj5cbiAgICAgICAgICAgIDwvR2xvYmFsU3RhdGVQcm92aWRlcj5cbiAgICAgICAgICA8L1N0b3JlUHJvdmlkZXI+XG4gICAgICAgIDwvQXBwV3JhcHBlcj5cbiAgICAgIDwvRXJyb3JCb3VuZGFyeUN1c3RvbT5cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFwcDtcbiJdLCJuYW1lcyI6WyJ1c2VNZW1vIiwiQXBwIiwiQXBwSW5uZXIiLCJBUFBfQ09ORklHIiwiU3RvcmVQcm92aWRlciIsIk1vZGFsUHJvdmlkZXIiLCJyZXNldEFsbFN0YXRlU2xpY2VzIiwiSGVhZCIsIkdsb2JhbFN0YXRlUHJvdmlkZXIiLCJNT0RBTF9ST09UX0VMRU1FTlRfSUQiLCJBcHBXcmFwcGVyIiwiRXJyb3JCb3VuZGFyeUN1c3RvbSIsInJlc2V0RXJyb3JCb3VuZGFyeSIsInByb3BzIiwiQ29tcG9uZW50IiwicGFnZVByb3BzIiwiQ29tcG9uZW50VG9SZW5kZXIiLCJtZXRhIiwiY29udGVudCIsIm5hbWUiLCJsaW5rIiwiaHJlZiIsInJlbCIsInNpemVzIiwidHlwZSIsImRpc2FibGVVSSIsInJlc2V0RXJyb3JCb3VuZGFyeUltbWVkaWF0ZWx5IiwiYXBwU3RhdGUiLCJhcHBUaXRsZSIsInN0YXRlIiwiaW5pdGlhbFp1c3RhbmRTdGF0ZSIsImRpdiIsImlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/_app.tsx\n");

/***/ }),

/***/ "./src/state/components/StoreProvider/StoreProvider.tsx":
/*!**************************************************************!*\
  !*** ./src/state/components/StoreProvider/StoreProvider.tsx ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StoreProvider: () => (/* binding */ StoreProvider),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/traditional */ \"zustand/traditional\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zustand/shallow */ \"zustand/shallow\");\n/* harmony import */ var state_store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! state/store */ \"./src/state/store/index.ts\");\n/* harmony import */ var _store_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../store/store */ \"./src/state/store/store.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([zustand_traditional__WEBPACK_IMPORTED_MODULE_2__, zustand_shallow__WEBPACK_IMPORTED_MODULE_3__, _store_store__WEBPACK_IMPORTED_MODULE_5__]);\n([zustand_traditional__WEBPACK_IMPORTED_MODULE_2__, zustand_shallow__WEBPACK_IMPORTED_MODULE_3__, _store_store__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/* eslint-disable import/no-mutable-exports */ \n\n\n\n\n\nconst ZustandContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst useStore = (selector, equalityFn)=>{\n    const storeFromProvider = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ZustandContext);\n    if (!storeFromProvider) throw new Error(\"Store is missing the provider\");\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_2__.useStoreWithEqualityFn)(storeFromProvider, selector, equalityFn || zustand_shallow__WEBPACK_IMPORTED_MODULE_3__.shallow);\n};\nconst StoreProvider = ({ children, ...props })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    if (!storeRef.current) {\n        const store = (0,_store_store__WEBPACK_IMPORTED_MODULE_5__.initializeStore)(props);\n        (0,state_store__WEBPACK_IMPORTED_MODULE_4__.setStore)(store);\n        storeRef.current = (0,state_store__WEBPACK_IMPORTED_MODULE_4__.getStore)();\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ZustandContext.Provider, {\n        value: storeRef.current,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/state/components/StoreProvider/StoreProvider.tsx\",\n        lineNumber: 38,\n        columnNumber: 5\n    }, undefined);\n};\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RhdGUvY29tcG9uZW50cy9TdG9yZVByb3ZpZGVyL1N0b3JlUHJvdmlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw0Q0FBNEM7QUFNN0I7QUFDaUU7QUFDdEM7QUFFTztBQUVHO0FBRXBELE1BQU1TLCtCQUFpQlIsb0RBQWFBLENBQW1CO0FBRWhELE1BQU1TLFdBQVcsQ0FDdEJDLFVBQ0FDO0lBRUEsTUFBTUMsb0JBQW9CWCxpREFBVUEsQ0FBQ087SUFFckMsSUFBSSxDQUFDSSxtQkFBbUIsTUFBTSxJQUFJQyxNQUFNO0lBRXhDLE9BQU9WLDJFQUFlQSxDQUFDUyxtQkFBbUJGLFVBQVVDLGNBQWNQLG9EQUFPQTtBQUMzRSxFQUFFO0FBRUssTUFBTVUsZ0JBQWdCLENBQUMsRUFBRUMsUUFBUSxFQUFFLEdBQUdDLE9BQTBCO0lBQ3JFLE1BQU1DLFdBQVdsQiw2Q0FBTUE7SUFFdkIsSUFBSSxDQUFDa0IsU0FBU0MsT0FBTyxFQUFFO1FBQ3JCLE1BQU1DLFFBQVFaLDZEQUFlQSxDQUFDUztRQUM5QlYscURBQVFBLENBQUNhO1FBQ1RGLFNBQVNDLE9BQU8sR0FBR2IscURBQVFBO0lBQzdCO0lBRUEscUJBQ0UsOERBQUNHLGVBQWVZLFFBQVE7UUFBQ0MsT0FBT0osU0FBU0MsT0FBTztrQkFDN0NIOzs7Ozs7QUFHUCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9zdGF0ZS9jb21wb25lbnRzL1N0b3JlUHJvdmlkZXIvU3RvcmVQcm92aWRlci50c3g/YzA3MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tbXV0YWJsZS1leHBvcnRzICovXG5pbXBvcnQge1xuICB0eXBlIFByb3BzV2l0aENoaWxkcmVuLFxuICB1c2VSZWYsXG4gIGNyZWF0ZUNvbnRleHQsXG4gIHVzZUNvbnRleHQsXG59IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4gYXMgdXNlWnVzdGFuZFN0b3JlIH0gZnJvbSAnenVzdGFuZC90cmFkaXRpb25hbCc7XG5pbXBvcnQgeyBzaGFsbG93IH0gZnJvbSAnenVzdGFuZC9zaGFsbG93JztcbmltcG9ydCB0eXBlIHsgU3RvcmVJbnRlcmZhY2UgfSBmcm9tICdzdGF0ZS90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdG9yZSwgc2V0U3RvcmUgfSBmcm9tICdzdGF0ZS9zdG9yZSc7XG5pbXBvcnQgdHlwZSB7IFN0b3JlVHlwZSB9IGZyb20gJy4uLy4uL3N0b3JlL3N0b3JlJztcbmltcG9ydCB7IGluaXRpYWxpemVTdG9yZSB9IGZyb20gJy4uLy4uL3N0b3JlL3N0b3JlJztcblxuY29uc3QgWnVzdGFuZENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFN0b3JlVHlwZSB8IG51bGw+KG51bGwpO1xuXG5leHBvcnQgY29uc3QgdXNlU3RvcmUgPSA8VCw+KFxuICBzZWxlY3RvcjogKHN0YXRlOiBTdG9yZUludGVyZmFjZSkgPT4gVCxcbiAgZXF1YWxpdHlGbj86IHR5cGVvZiBzaGFsbG93XG4pID0+IHtcbiAgY29uc3Qgc3RvcmVGcm9tUHJvdmlkZXIgPSB1c2VDb250ZXh0KFp1c3RhbmRDb250ZXh0KTtcblxuICBpZiAoIXN0b3JlRnJvbVByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ1N0b3JlIGlzIG1pc3NpbmcgdGhlIHByb3ZpZGVyJyk7XG5cbiAgcmV0dXJuIHVzZVp1c3RhbmRTdG9yZShzdG9yZUZyb21Qcm92aWRlciwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4gfHwgc2hhbGxvdyk7XG59O1xuXG5leHBvcnQgY29uc3QgU3RvcmVQcm92aWRlciA9ICh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9OiBQcm9wc1dpdGhDaGlsZHJlbikgPT4ge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVJlZjxTdG9yZVR5cGU+KCk7XG5cbiAgaWYgKCFzdG9yZVJlZi5jdXJyZW50KSB7XG4gICAgY29uc3Qgc3RvcmUgPSBpbml0aWFsaXplU3RvcmUocHJvcHMpO1xuICAgIHNldFN0b3JlKHN0b3JlKTtcbiAgICBzdG9yZVJlZi5jdXJyZW50ID0gZ2V0U3RvcmUoKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFp1c3RhbmRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtzdG9yZVJlZi5jdXJyZW50fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1p1c3RhbmRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4iLCJ1c2VadXN0YW5kU3RvcmUiLCJzaGFsbG93IiwiZ2V0U3RvcmUiLCJzZXRTdG9yZSIsImluaXRpYWxpemVTdG9yZSIsIlp1c3RhbmRDb250ZXh0IiwidXNlU3RvcmUiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJzdG9yZUZyb21Qcm92aWRlciIsIkVycm9yIiwiU3RvcmVQcm92aWRlciIsImNoaWxkcmVuIiwicHJvcHMiLCJzdG9yZVJlZiIsImN1cnJlbnQiLCJzdG9yZSIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/state/components/StoreProvider/StoreProvider.tsx\n");

/***/ }),

/***/ "./src/state/components/StoreProvider/index.ts":
/*!*****************************************************!*\
  !*** ./src/state/components/StoreProvider/index.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _StoreProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StoreProvider */ \"./src/state/components/StoreProvider/StoreProvider.tsx\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_StoreProvider__WEBPACK_IMPORTED_MODULE_0__]);\n_StoreProvider__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _StoreProvider__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _StoreProvider__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RhdGUvY29tcG9uZW50cy9TdG9yZVByb3ZpZGVyL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9zdGF0ZS9jb21wb25lbnRzL1N0b3JlUHJvdmlkZXIvaW5kZXgudHM/YWM5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL1N0b3JlUHJvdmlkZXInO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/state/components/StoreProvider/index.ts\n");

/***/ }),

/***/ "./src/state/store/app/index.ts":
/*!**************************************!*\
  !*** ./src/state/store/app/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAppSlice: () => (/* binding */ createAppSlice),\n/* harmony export */   createStoreAction: () => (/* binding */ createStoreAction)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ \"./src/state/store/index.ts\");\n/* eslint-disable no-param-reassign */ \nconst createStoreAction = (type, payload)=>({\n        type: `ACTION_${type}`,\n        payload\n    });\nconst initialState = {\n    _hasHydrated: false\n};\nconst createAppSlice = (set)=>{\n    (0,___WEBPACK_IMPORTED_MODULE_0__.addResetSliceFunction)(()=>set((state)=>{\n            state.app = {\n                ...state.app,\n                ...initialState\n            };\n        }));\n    return {\n        app: {\n            ...initialState,\n            actions: {\n                setHasHydrated: (payload)=>{\n                    const { hasHydrated = false } = payload;\n                    set((state)=>{\n                        state.app._hasHydrated = hasHydrated;\n                    }, false, createStoreAction(`SET_HAS_HYDRATED:${hasHydrated}`, payload));\n                }\n            }\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RhdGUvc3RvcmUvYXBwL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG9DQUFvQyxHQUdPO0FBRXBDLE1BQU1DLG9CQUFvQixDQUMvQkMsTUFDQUMsVUFDSTtRQUNKRCxNQUFNLENBQUMsT0FBTyxFQUFFQSxLQUFLLENBQUM7UUFDdEJDO0lBQ0YsR0FBRztBQUVILE1BQU1DLGVBQWU7SUFDbkJDLGNBQWM7QUFDaEI7QUFFTyxNQUFNQyxpQkFLVCxDQUFDQztJQUNIUCx3REFBcUJBLENBQUMsSUFDcEJPLElBQUksQ0FBQ0M7WUFDSEEsTUFBTUMsR0FBRyxHQUFHO2dCQUNWLEdBQUdELE1BQU1DLEdBQUc7Z0JBQ1osR0FBR0wsWUFBWTtZQUNqQjtRQUNGO0lBR0YsT0FBTztRQUNMSyxLQUFLO1lBQ0gsR0FBR0wsWUFBWTtZQUNmTSxTQUFTO2dCQUNQQyxnQkFBZ0IsQ0FBQ1I7b0JBQ2YsTUFBTSxFQUFFUyxjQUFjLEtBQUssRUFBRSxHQUFHVDtvQkFFaENJLElBQ0UsQ0FBQ0M7d0JBQ0NBLE1BQU1DLEdBQUcsQ0FBQ0osWUFBWSxHQUFHTztvQkFDM0IsR0FDQSxPQUNBWCxrQkFBa0IsQ0FBQyxpQkFBaUIsRUFBRVcsWUFBWSxDQUFDLEVBQUVUO2dCQUV6RDtZQUNGO1FBQ0Y7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL3N0YXRlL3N0b3JlL2FwcC9pbmRleC50cz9jMzM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5pbXBvcnQgdHlwZSB7IFN0YXRlQ3JlYXRvciB9IGZyb20gJ3p1c3RhbmQnO1xuaW1wb3J0IHR5cGUgeyBNdXRhdG9ycywgQXBwU2xpY2UsIFN0b3JlSW50ZXJmYWNlIH0gZnJvbSAnc3RhdGUvdHlwZXMnO1xuaW1wb3J0IHsgYWRkUmVzZXRTbGljZUZ1bmN0aW9uIH0gZnJvbSAnLi4nO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3RvcmVBY3Rpb24gPSAoXG4gIHR5cGU6IHN0cmluZyxcbiAgcGF5bG9hZDogUmVjb3JkPHN0cmluZywgYW55PiB8IHN0cmluZ1xuKSA9PiAoe1xuICB0eXBlOiBgQUNUSU9OXyR7dHlwZX1gLFxuICBwYXlsb2FkLFxufSk7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgX2hhc0h5ZHJhdGVkOiBmYWxzZSxcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVBcHBTbGljZTogU3RhdGVDcmVhdG9yPFxuICBTdG9yZUludGVyZmFjZSxcbiAgTXV0YXRvcnMsXG4gIFtdLFxuICBBcHBTbGljZVxuPiA9IChzZXQpID0+IHtcbiAgYWRkUmVzZXRTbGljZUZ1bmN0aW9uKCgpID0+XG4gICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUuYXBwID0ge1xuICAgICAgICAuLi5zdGF0ZS5hcHAsXG4gICAgICAgIC4uLmluaXRpYWxTdGF0ZSxcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIGFwcDoge1xuICAgICAgLi4uaW5pdGlhbFN0YXRlLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBzZXRIYXNIeWRyYXRlZDogKHBheWxvYWQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGhhc0h5ZHJhdGVkID0gZmFsc2UgfSA9IHBheWxvYWQ7XG5cbiAgICAgICAgICBzZXQoXG4gICAgICAgICAgICAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgc3RhdGUuYXBwLl9oYXNIeWRyYXRlZCA9IGhhc0h5ZHJhdGVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgY3JlYXRlU3RvcmVBY3Rpb24oYFNFVF9IQVNfSFlEUkFURUQ6JHtoYXNIeWRyYXRlZH1gLCBwYXlsb2FkKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIH07XG59O1xuIl0sIm5hbWVzIjpbImFkZFJlc2V0U2xpY2VGdW5jdGlvbiIsImNyZWF0ZVN0b3JlQWN0aW9uIiwidHlwZSIsInBheWxvYWQiLCJpbml0aWFsU3RhdGUiLCJfaGFzSHlkcmF0ZWQiLCJjcmVhdGVBcHBTbGljZSIsInNldCIsInN0YXRlIiwiYXBwIiwiYWN0aW9ucyIsInNldEhhc0h5ZHJhdGVkIiwiaGFzSHlkcmF0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/state/store/app/index.ts\n");

/***/ }),

/***/ "./src/state/store/index.ts":
/*!**********************************!*\
  !*** ./src/state/store/index.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addResetSliceFunction: () => (/* binding */ addResetSliceFunction),\n/* harmony export */   getStore: () => (/* binding */ getStore),\n/* harmony export */   resetAllStateSlices: () => (/* binding */ resetAllStateSlices),\n/* harmony export */   resetSliceFunctions: () => (/* binding */ resetSliceFunctions),\n/* harmony export */   setStore: () => (/* binding */ setStore)\n/* harmony export */ });\nlet store;\nconst resetSliceFunctions = [];\nconst addResetSliceFunction = (fn)=>{\n    resetSliceFunctions.push(fn);\n};\nconst resetAllStateSlices = ()=>{\n    resetSliceFunctions.forEach((resetFn)=>{\n        resetFn();\n    });\n};\nconst setStore = (s)=>{\n    store = s;\n};\nconst getStore = ()=>store;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RhdGUvc3RvcmUvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFQSxJQUFJQTtBQUVHLE1BQU1DLHNCQUFzQyxFQUFFLENBQUM7QUFFL0MsTUFBTUMsd0JBQXdCLENBQUNDO0lBQ3BDRixvQkFBb0JHLElBQUksQ0FBQ0Q7QUFDM0IsRUFBRTtBQUVLLE1BQU1FLHNCQUFzQjtJQUNqQ0osb0JBQW9CSyxPQUFPLENBQUMsQ0FBQ0M7UUFDM0JBO0lBQ0Y7QUFDRixFQUFFO0FBRUssTUFBTUMsV0FBVyxDQUFDQztJQUN2QlQsUUFBUVM7QUFDVixFQUFFO0FBRUssTUFBTUMsV0FBVyxJQUN0QlYsTUFBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL3N0YXRlL3N0b3JlL2luZGV4LnRzPzA0YTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBpbml0aWFsaXplU3RvcmUgfSBmcm9tICcuL3N0b3JlJztcblxubGV0IHN0b3JlOiBSZXR1cm5UeXBlPHR5cGVvZiBpbml0aWFsaXplU3RvcmU+IHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgY29uc3QgcmVzZXRTbGljZUZ1bmN0aW9uczogKCgpID0+IHZvaWQpW10gPSBbXTtcblxuZXhwb3J0IGNvbnN0IGFkZFJlc2V0U2xpY2VGdW5jdGlvbiA9IChmbjogKCkgPT4gdm9pZCkgPT4ge1xuICByZXNldFNsaWNlRnVuY3Rpb25zLnB1c2goZm4pO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlc2V0QWxsU3RhdGVTbGljZXMgPSAoKSA9PiB7XG4gIHJlc2V0U2xpY2VGdW5jdGlvbnMuZm9yRWFjaCgocmVzZXRGbikgPT4ge1xuICAgIHJlc2V0Rm4oKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0U3RvcmUgPSAoczogUmV0dXJuVHlwZTx0eXBlb2YgaW5pdGlhbGl6ZVN0b3JlPikgPT4ge1xuICBzdG9yZSA9IHM7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U3RvcmUgPSAoKTogUmV0dXJuVHlwZTx0eXBlb2YgaW5pdGlhbGl6ZVN0b3JlPiA9PlxuICBzdG9yZSBhcyBSZXR1cm5UeXBlPHR5cGVvZiBpbml0aWFsaXplU3RvcmU+O1xuIl0sIm5hbWVzIjpbInN0b3JlIiwicmVzZXRTbGljZUZ1bmN0aW9ucyIsImFkZFJlc2V0U2xpY2VGdW5jdGlvbiIsImZuIiwicHVzaCIsInJlc2V0QWxsU3RhdGVTbGljZXMiLCJmb3JFYWNoIiwicmVzZXRGbiIsInNldFN0b3JlIiwicyIsImdldFN0b3JlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/state/store/index.ts\n");

/***/ }),

/***/ "./src/state/store/settings/index.ts":
/*!*******************************************!*\
  !*** ./src/state/store/settings/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSettingsSlice: () => (/* binding */ createSettingsSlice)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ \"./src/state/store/index.ts\");\n/* eslint-disable no-param-reassign */ \nconst initialState = {};\nconst createSettingsSlice = (set)=>{\n    (0,___WEBPACK_IMPORTED_MODULE_0__.addResetSliceFunction)(()=>set((state)=>{\n            state.settings = {\n                ...state.settings,\n                ...initialState\n            };\n        }));\n    return {\n        settings: {\n            ...initialState,\n            actions: {}\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RhdGUvc3RvcmUvc2V0dGluZ3MvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxvQ0FBb0MsR0FHTztBQUUzQyxNQUFNQyxlQUFlLENBQUM7QUFFZixNQUFNQyxzQkFLVCxDQUFDQztJQUNISCx3REFBcUJBLENBQUMsSUFDcEJHLElBQUksQ0FBQ0M7WUFDSEEsTUFBTUMsUUFBUSxHQUFHO2dCQUNmLEdBQUdELE1BQU1DLFFBQVE7Z0JBQ2pCLEdBQUdKLFlBQVk7WUFDakI7UUFDRjtJQUdGLE9BQU87UUFDTEksVUFBVTtZQUNSLEdBQUdKLFlBQVk7WUFDZkssU0FBUyxDQUFDO1FBQ1o7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL3N0YXRlL3N0b3JlL3NldHRpbmdzL2luZGV4LnRzPzZhNDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmltcG9ydCB0eXBlIHsgU3RhdGVDcmVhdG9yIH0gZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgdHlwZSB7IE11dGF0b3JzLCBTZXR0aW5nc1NsaWNlLCBTdG9yZUludGVyZmFjZSB9IGZyb20gJ3N0YXRlL3R5cGVzJztcbmltcG9ydCB7IGFkZFJlc2V0U2xpY2VGdW5jdGlvbiB9IGZyb20gJy4uJztcblxuY29uc3QgaW5pdGlhbFN0YXRlID0ge307XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXR0aW5nc1NsaWNlOiBTdGF0ZUNyZWF0b3I8XG4gIFN0b3JlSW50ZXJmYWNlLFxuICBNdXRhdG9ycyxcbiAgW10sXG4gIFNldHRpbmdzU2xpY2Vcbj4gPSAoc2V0KSA9PiB7XG4gIGFkZFJlc2V0U2xpY2VGdW5jdGlvbigoKSA9PlxuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLnNldHRpbmdzID0ge1xuICAgICAgICAuLi5zdGF0ZS5zZXR0aW5ncyxcbiAgICAgICAgLi4uaW5pdGlhbFN0YXRlLFxuICAgICAgfTtcbiAgICB9KVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgc2V0dGluZ3M6IHtcbiAgICAgIC4uLmluaXRpYWxTdGF0ZSxcbiAgICAgIGFjdGlvbnM6IHt9LFxuICAgIH0sXG4gIH07XG59O1xuIl0sIm5hbWVzIjpbImFkZFJlc2V0U2xpY2VGdW5jdGlvbiIsImluaXRpYWxTdGF0ZSIsImNyZWF0ZVNldHRpbmdzU2xpY2UiLCJzZXQiLCJzdGF0ZSIsInNldHRpbmdzIiwiYWN0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/state/store/settings/index.ts\n");

/***/ }),

/***/ "./src/state/store/store.ts":
/*!**********************************!*\
  !*** ./src/state/store/store.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeStore: () => (/* binding */ initializeStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"zustand\");\n/* harmony import */ var zustand_mutative__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand-mutative */ \"zustand-mutative\");\n/* harmony import */ var zustand_mutative__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zustand_mutative__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"zustand/middleware\");\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/mapValues */ \"lodash/mapValues\");\n/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_mapValues__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _fx_lib_utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fx/lib-utilities */ \"../lib-utilities/lib/index.esm.js\");\n/* harmony import */ var _fx_lib_utilities__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var config_app__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! config/app */ \"./src/config/app.ts\");\n/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/omit */ \"lodash/omit\");\n/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_omit__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./app */ \"./src/state/store/app/index.ts\");\n/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./settings */ \"./src/state/store/settings/index.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([zustand__WEBPACK_IMPORTED_MODULE_0__, zustand_middleware__WEBPACK_IMPORTED_MODULE_2__]);\n([zustand__WEBPACK_IMPORTED_MODULE_0__, zustand_middleware__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\nconst { appEnv } = config_app__WEBPACK_IMPORTED_MODULE_5__.APP_CONFIG;\nconst initializeStore = (preloadedState = {})=>{\n    return (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.persist)((0,zustand_mutative__WEBPACK_IMPORTED_MODULE_1__.mutative)((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.devtools)((...a)=>(0,_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_4__.mergeObject)(preloadedState, {\n            ...(0,_app__WEBPACK_IMPORTED_MODULE_7__.createAppSlice)(...a),\n            ...(0,_settings__WEBPACK_IMPORTED_MODULE_8__.createSettingsSlice)(...a)\n        }), {\n        enabled: appEnv !== \"production\"\n    })), {\n        name: `STATE_${appEnv?.toUpperCase()}`,\n        partialize: (state)=>({\n                settings: lodash_omit__WEBPACK_IMPORTED_MODULE_6___default()(state.settings, [\n                    \"actions\"\n                ])\n            }),\n        onRehydrateStorage: (state)=>{\n            return (_state_on_done, error)=>{\n                if (error) {\n                /** handle error here */ } else {\n                /** handle success here */ }\n                state.app.actions.setHasHydrated({\n                    hasHydrated: true\n                });\n            };\n        },\n        version: Number(config_app__WEBPACK_IMPORTED_MODULE_5__.APP_CONFIG.stateCacheVersion),\n        skipHydration: !(0,_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_4__.isBrowser)(),\n        merge: (persistedState, currentState)=>lodash_mapValues__WEBPACK_IMPORTED_MODULE_3___default()(currentState, (value, key)=>({\n                    ...value,\n                    ...(persistedState || {})[key]\n                }))\n    }));\n};\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RhdGUvc3RvcmUvc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUM7QUFDVztBQUNXO0FBQ2Q7QUFDa0I7QUFFbkI7QUFDVDtBQUVRO0FBQ1U7QUFFakQsTUFBTSxFQUFFVyxNQUFNLEVBQUUsR0FBR0osa0RBQVVBO0FBSXRCLE1BQU1LLGtCQUFrQixDQUM3QkMsaUJBQWdELENBQUMsQ0FBQztJQUVsRCxPQUFPYiwrQ0FBTUEsR0FDWEcsMkRBQU9BLENBQ0xGLDBEQUFRQSxDQUNOQyw0REFBUUEsQ0FDTixDQUFDLEdBQUdZLElBQ0ZSLDhEQUFXQSxDQUFDTyxnQkFBZ0I7WUFDMUIsR0FBR0osb0RBQWNBLElBQUlLLEVBQUU7WUFDdkIsR0FBR0osOERBQW1CQSxJQUFJSSxFQUFFO1FBQzlCLElBQ0Y7UUFDRUMsU0FBU0osV0FBVztJQUN0QixLQUdKO1FBQ0VLLE1BQU0sQ0FBQyxNQUFNLEVBQUVMLFFBQVFNLGNBQWMsQ0FBQztRQUN0Q0MsWUFBWSxDQUFDQyxRQUFXO2dCQUN0QkMsVUFBVVosa0RBQUlBLENBQUNXLE1BQU1DLFFBQVEsRUFBRTtvQkFBQztpQkFBVTtZQUM1QztRQUNBQyxvQkFBb0IsQ0FBQ0Y7WUFDbkIsT0FBTyxDQUFDRyxnQkFBZ0JDO2dCQUN0QixJQUFJQSxPQUFPO2dCQUNULHNCQUFzQixHQUN4QixPQUFPO2dCQUNMLHdCQUF3QixHQUMxQjtnQkFFQUosTUFBTUssR0FBRyxDQUFDQyxPQUFPLENBQUNDLGNBQWMsQ0FBQztvQkFBRUMsYUFBYTtnQkFBSztZQUN2RDtRQUNGO1FBQ0FDLFNBQVNDLE9BQU90QixrREFBVUEsQ0FBQ3VCLGlCQUFpQjtRQUM1Q0MsZUFBZSxDQUFDMUIsNERBQVNBO1FBQ3pCMkIsT0FBTyxDQUFDQyxnQkFBZ0JDLGVBQ3RCOUIsdURBQVNBLENBQUM4QixjQUFjLENBQUNDLE9BQU9DLE1BQVM7b0JBQ3ZDLEdBQUdELEtBQUs7b0JBQ1IsR0FBRyxDQUFFRixrQkFBa0IsQ0FBQyxFQUEwQixDQUFDRyxJQUFJO2dCQUN6RDtJQUNKO0FBR04sRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BmeC9hcHAtZnJvbnQtZW5kLXdlYnNpdGUvLi9zcmMvc3RhdGUvc3RvcmUvc3RvcmUudHM/MTY2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCB7IG11dGF0aXZlIH0gZnJvbSAnenVzdGFuZC1tdXRhdGl2ZSc7XG5pbXBvcnQgeyBkZXZ0b29scywgcGVyc2lzdCB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XG5pbXBvcnQgbWFwVmFsdWVzIGZyb20gJ2xvZGFzaC9tYXBWYWx1ZXMnO1xuaW1wb3J0IHsgaXNCcm93c2VyLCBtZXJnZU9iamVjdCB9IGZyb20gJ0BmeC9saWItdXRpbGl0aWVzJztcbmltcG9ydCB0eXBlIHsgUGFydGlhbE5lc3RlZCB9IGZyb20gJ0BmeC9saWItdXRpbGl0eS10eXBlcyc7XG5pbXBvcnQgeyBBUFBfQ09ORklHIH0gZnJvbSAnY29uZmlnL2FwcCc7XG5pbXBvcnQgb21pdCBmcm9tICdsb2Rhc2gvb21pdCc7XG5pbXBvcnQgdHlwZSB7IFN0b3JlSW50ZXJmYWNlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlQXBwU2xpY2UgfSBmcm9tICcuL2FwcCc7XG5pbXBvcnQgeyBjcmVhdGVTZXR0aW5nc1NsaWNlIH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5cbmNvbnN0IHsgYXBwRW52IH0gPSBBUFBfQ09ORklHO1xuXG5leHBvcnQgdHlwZSBTdG9yZVR5cGUgPSBSZXR1cm5UeXBlPHR5cGVvZiBpbml0aWFsaXplU3RvcmU+O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVN0b3JlID0gKFxuICBwcmVsb2FkZWRTdGF0ZTogUGFydGlhbE5lc3RlZDxTdG9yZUludGVyZmFjZT4gPSB7fVxuKSA9PiB7XG4gIHJldHVybiBjcmVhdGU8U3RvcmVJbnRlcmZhY2U+KCkoXG4gICAgcGVyc2lzdChcbiAgICAgIG11dGF0aXZlKFxuICAgICAgICBkZXZ0b29scyhcbiAgICAgICAgICAoLi4uYSkgPT5cbiAgICAgICAgICAgIG1lcmdlT2JqZWN0KHByZWxvYWRlZFN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmNyZWF0ZUFwcFNsaWNlKC4uLmEpLFxuICAgICAgICAgICAgICAuLi5jcmVhdGVTZXR0aW5nc1NsaWNlKC4uLmEpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW5hYmxlZDogYXBwRW52ICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApLFxuICAgICAge1xuICAgICAgICBuYW1lOiBgU1RBVEVfJHthcHBFbnY/LnRvVXBwZXJDYXNlKCl9YCxcbiAgICAgICAgcGFydGlhbGl6ZTogKHN0YXRlKSA9PiAoe1xuICAgICAgICAgIHNldHRpbmdzOiBvbWl0KHN0YXRlLnNldHRpbmdzLCBbJ2FjdGlvbnMnXSksXG4gICAgICAgIH0pLFxuICAgICAgICBvblJlaHlkcmF0ZVN0b3JhZ2U6IChzdGF0ZSkgPT4ge1xuICAgICAgICAgIHJldHVybiAoX3N0YXRlX29uX2RvbmUsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLyoqIGhhbmRsZSBlcnJvciBoZXJlICovXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvKiogaGFuZGxlIHN1Y2Nlc3MgaGVyZSAqL1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5hcHAuYWN0aW9ucy5zZXRIYXNIeWRyYXRlZCh7IGhhc0h5ZHJhdGVkOiB0cnVlIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHZlcnNpb246IE51bWJlcihBUFBfQ09ORklHLnN0YXRlQ2FjaGVWZXJzaW9uKSxcbiAgICAgICAgc2tpcEh5ZHJhdGlvbjogIWlzQnJvd3NlcigpLFxuICAgICAgICBtZXJnZTogKHBlcnNpc3RlZFN0YXRlLCBjdXJyZW50U3RhdGUpID0+XG4gICAgICAgICAgbWFwVmFsdWVzKGN1cnJlbnRTdGF0ZSwgKHZhbHVlLCBrZXkpID0+ICh7XG4gICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgIC4uLigocGVyc2lzdGVkU3RhdGUgfHwge30pIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pW2tleV0sXG4gICAgICAgICAgfSkpLFxuICAgICAgfVxuICAgIClcbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiY3JlYXRlIiwibXV0YXRpdmUiLCJkZXZ0b29scyIsInBlcnNpc3QiLCJtYXBWYWx1ZXMiLCJpc0Jyb3dzZXIiLCJtZXJnZU9iamVjdCIsIkFQUF9DT05GSUciLCJvbWl0IiwiY3JlYXRlQXBwU2xpY2UiLCJjcmVhdGVTZXR0aW5nc1NsaWNlIiwiYXBwRW52IiwiaW5pdGlhbGl6ZVN0b3JlIiwicHJlbG9hZGVkU3RhdGUiLCJhIiwiZW5hYmxlZCIsIm5hbWUiLCJ0b1VwcGVyQ2FzZSIsInBhcnRpYWxpemUiLCJzdGF0ZSIsInNldHRpbmdzIiwib25SZWh5ZHJhdGVTdG9yYWdlIiwiX3N0YXRlX29uX2RvbmUiLCJlcnJvciIsImFwcCIsImFjdGlvbnMiLCJzZXRIYXNIeWRyYXRlZCIsImhhc0h5ZHJhdGVkIiwidmVyc2lvbiIsIk51bWJlciIsInN0YXRlQ2FjaGVWZXJzaW9uIiwic2tpcEh5ZHJhdGlvbiIsIm1lcmdlIiwicGVyc2lzdGVkU3RhdGUiLCJjdXJyZW50U3RhdGUiLCJ2YWx1ZSIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/state/store/store.ts\n");

/***/ }),

/***/ "../lib-utilities/lib/index.esm.js":
/*!*****************************************!*\
  !*** ../lib-utilities/lib/index.esm.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    CACHE_TIME_1_HOUR: function() {\n        return CACHE_TIME_1_HOUR;\n    },\n    CACHE_TIME_30_MINUTES: function() {\n        return CACHE_TIME_30_MINUTES;\n    },\n    CACHE_TIME_48_HOURS: function() {\n        return CACHE_TIME_48_HOURS;\n    },\n    CACHE_TIME_72_HOURS: function() {\n        return CACHE_TIME_72_HOURS;\n    },\n    RGBAToHexA: function() {\n        return RGBAToHexA;\n    },\n    antilog: function() {\n        return antilog;\n    },\n    arrayWithoutElements: function() {\n        return arrayWithoutElements;\n    },\n    assertTruthyOrZero: function() {\n        return assertTruthyOrZero;\n    },\n    capitaliseFirstLetter: function() {\n        return capitaliseFirstLetter;\n    },\n    checkIfTextTermMatchesArray: function() {\n        return checkIfTextTermMatchesArray;\n    },\n    checkIfTextTermMatchesSingle: function() {\n        return checkIfTextTermMatchesSingle;\n    },\n    clampValue: function() {\n        return clampValue;\n    },\n    cleanString: function() {\n        return cleanString;\n    },\n    conditionalOrIfTruthyOrZero: function() {\n        return conditionalOrIfTruthyOrZero;\n    },\n    createCustomFileNameKeyFromObject: function() {\n        return createCustomFileNameKeyFromObject;\n    },\n    createCustomKey: function() {\n        return createCustomKey;\n    },\n    createCustomKeyFromObject: function() {\n        return createCustomKeyFromObject;\n    },\n    createCustomKeyFromSrcTgt: function() {\n        return createCustomKeyFromSrcTgt;\n    },\n    createTimeMsInDays: function() {\n        return createTimeMsInDays;\n    },\n    createTimeMsInHours: function() {\n        return createTimeMsInHours;\n    },\n    createTimeMsInMinutes: function() {\n        return createTimeMsInMinutes;\n    },\n    downloadCSV: function() {\n        return downloadCSV;\n    },\n    downloadFromObjectURL: function() {\n        return downloadFromObjectURL;\n    },\n    downloadJSON: function() {\n        return downloadJSON;\n    },\n    evaluateOneOrZeroBooleanIfNotEmptyString: function() {\n        return evaluateOneOrZeroBooleanIfNotEmptyString;\n    },\n    evaluateOneOrZeroBooleanIfNotUndefined: function() {\n        return evaluateOneOrZeroBooleanIfNotUndefined;\n    },\n    evaluateTruthyIfNotUndefined: function() {\n        return evaluateTruthyIfNotUndefined;\n    },\n    generateCSV: function() {\n        return generateCSV;\n    },\n    generateQueryString: function() {\n        return generateQueryString;\n    },\n    getNRandomElementsFromArray: function() {\n        return getNRandomElementsFromArray;\n    },\n    getNextJSQueryParam: function() {\n        return getNextJSQueryParam;\n    },\n    getRandomElementFromArray: function() {\n        return getRandomElementFromArray;\n    },\n    getRandomElementsFromArray: function() {\n        return getRandomElementsFromArray;\n    },\n    getRandomInteger: function() {\n        return getRandomInteger;\n    },\n    getRandomNumber: function() {\n        return getRandomNumber;\n    },\n    getReactQueryStatus: function() {\n        return getReactQueryStatus;\n    },\n    isBrowser: function() {\n        return isBrowser;\n    },\n    isEmail: function() {\n        return isEmail;\n    },\n    isEqualIgnoringOrder: function() {\n        return isEqualIgnoringOrder;\n    },\n    isTruthyOrZero: function() {\n        return isTruthyOrZero;\n    },\n    keyByWithUndefined: function() {\n        return keyByWithUndefined;\n    },\n    log: function() {\n        return log;\n    },\n    mergeClassNamesDeep: function() {\n        return mergeClassNamesDeep;\n    },\n    mergeClassNamesFunctionsDeep: function() {\n        return mergeClassNamesFunctionsDeep;\n    },\n    mergeObject: function() {\n        return mergeObject;\n    },\n    mergeObjectReplacingArrays: function() {\n        return mergeObjectReplacingArrays;\n    },\n    normaliseString: function() {\n        return normaliseString;\n    },\n    openUrlInNewTab: function() {\n        return openUrlInNewTab;\n    },\n    parseEnvVariable: function() {\n        return parseEnvVariable;\n    },\n    parseEnvVariables: function() {\n        return parseEnvVariables;\n    },\n    removeUndefinedAndEmptyStringValuesFromObj: function() {\n        return removeUndefinedAndEmptyStringValuesFromObj;\n    },\n    removeUndefinedAndNullValuesFromObj: function() {\n        return removeUndefinedAndNullValuesFromObj;\n    },\n    removeUndefinedValuesFromObj: function() {\n        return removeUndefinedValuesFromObj;\n    },\n    roundNumber: function() {\n        return roundNumber;\n    },\n    sanitiseTextTerm: function() {\n        return sanitiseTextTerm;\n    },\n    sleep: function() {\n        return sleep;\n    },\n    stringsEqualInsensitive: function() {\n        return stringsEqualInsensitive;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"../../node_modules/@swc/helpers/cjs/_interop_require_default.cjs\");\nconst _classnames = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! classnames */ \"classnames\"));\nconst _fuzzysort = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! fuzzysort */ \"fuzzysort\"));\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */ function arrayReduce$2(array, iteratee, accumulator, initAccum) {\n    var index = -1, length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n        accumulator = array[++index];\n    }\n    while(++index < length){\n        accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n}\nvar _arrayReduce = arrayReduce$2;\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */ function createBaseFor$1(fromRight) {\n    return function(object, iteratee, keysFunc) {\n        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;\n        while(length--){\n            var key = props[fromRight ? length : ++index];\n            if (iteratee(iterable[key], key, iterable) === false) {\n                break;\n            }\n        }\n        return object;\n    };\n}\nvar _createBaseFor = createBaseFor$1;\nvar createBaseFor = _createBaseFor;\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */ var baseFor$2 = createBaseFor();\nvar _baseFor = baseFor$2;\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */ function baseTimes$1(n, iteratee) {\n    var index = -1, result = Array(n);\n    while(++index < n){\n        result[index] = iteratee(index);\n    }\n    return result;\n}\nvar _baseTimes = baseTimes$1;\n/** Detect free variable `global` from Node.js. */ var freeGlobal$1 = typeof commonjsGlobal == \"object\" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\nvar _freeGlobal = freeGlobal$1;\nvar freeGlobal = _freeGlobal;\n/** Detect free variable `self`. */ var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n/** Used as a reference to the global object. */ var root$8 = freeGlobal || freeSelf || Function(\"return this\")();\nvar _root = root$8;\nvar root$7 = _root;\n/** Built-in value references. */ var Symbol$6 = root$7.Symbol;\nvar _Symbol = Symbol$6;\nvar Symbol$5 = _Symbol;\n/** Used for built-in method references. */ var objectProto$e = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$b = objectProto$e.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var nativeObjectToString$1 = objectProto$e.toString;\n/** Built-in value references. */ var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : undefined;\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */ function getRawTag$1(value) {\n    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];\n    try {\n        value[symToStringTag$1] = undefined;\n        var unmasked = true;\n    } catch (e) {}\n    var result = nativeObjectToString$1.call(value);\n    if (unmasked) {\n        if (isOwn) {\n            value[symToStringTag$1] = tag;\n        } else {\n            delete value[symToStringTag$1];\n        }\n    }\n    return result;\n}\nvar _getRawTag = getRawTag$1;\n/** Used for built-in method references. */ var objectProto$d = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var nativeObjectToString = objectProto$d.toString;\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */ function objectToString$1(value) {\n    return nativeObjectToString.call(value);\n}\nvar _objectToString = objectToString$1;\nvar Symbol$4 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;\n/** `Object#toString` result references. */ var nullTag = \"[object Null]\", undefinedTag = \"[object Undefined]\";\n/** Built-in value references. */ var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : undefined;\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */ function baseGetTag$6(value) {\n    if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n    }\n    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\nvar _baseGetTag = baseGetTag$6;\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ function isObjectLike$7(value) {\n    return value != null && typeof value == \"object\";\n}\nvar isObjectLike_1 = isObjectLike$7;\nvar baseGetTag$5 = _baseGetTag, isObjectLike$6 = isObjectLike_1;\n/** `Object#toString` result references. */ var argsTag$2 = \"[object Arguments]\";\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */ function baseIsArguments$1(value) {\n    return isObjectLike$6(value) && baseGetTag$5(value) == argsTag$2;\n}\nvar _baseIsArguments = baseIsArguments$1;\nvar baseIsArguments = _baseIsArguments, isObjectLike$5 = isObjectLike_1;\n/** Used for built-in method references. */ var objectProto$c = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$a = objectProto$c.hasOwnProperty;\n/** Built-in value references. */ var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */ var isArguments$4 = baseIsArguments(function() {\n    return arguments;\n}()) ? baseIsArguments : function(value) {\n    return isObjectLike$5(value) && hasOwnProperty$a.call(value, \"callee\") && !propertyIsEnumerable$1.call(value, \"callee\");\n};\nvar isArguments_1 = isArguments$4;\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */ var isArray$e = Array.isArray;\nvar isArray_1 = isArray$e;\nvar isArray$f = /*@__PURE__*/ getDefaultExportFromCjs(isArray_1);\nvar isBuffer$4 = {\n    exports: {}\n};\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */ function stubFalse() {\n    return false;\n}\nvar stubFalse_1 = stubFalse;\nisBuffer$4.exports;\n(function(module, exports1) {\n    var root = _root, stubFalse = stubFalse_1;\n    /** Detect free variable `exports`. */ var freeExports = exports1 && !exports1.nodeType && exports1;\n    /** Detect free variable `module`. */ var freeModule = freeExports && \"object\" == \"object\" && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined;\n    /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n    /**\n\t * Checks if `value` is a buffer.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.3.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n\t * @example\n\t *\n\t * _.isBuffer(new Buffer(2));\n\t * // => true\n\t *\n\t * _.isBuffer(new Uint8Array(2));\n\t * // => false\n\t */ var isBuffer = nativeIsBuffer || stubFalse;\n    module.exports = isBuffer;\n})(isBuffer$4, isBuffer$4.exports);\nvar isBufferExports = isBuffer$4.exports;\n/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER$1 = 9007199254740991;\n/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\\d*)$/;\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */ function isIndex$3(value, length) {\n    var type = typeof value;\n    length = length == null ? MAX_SAFE_INTEGER$1 : length;\n    return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n}\nvar _isIndex = isIndex$3;\n/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */ function isLength$3(value) {\n    return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\nvar isLength_1 = isLength$3;\nvar baseGetTag$4 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$4 = isObjectLike_1;\n/** `Object#toString` result references. */ var argsTag$1 = \"[object Arguments]\", arrayTag$1 = \"[object Array]\", boolTag$1 = \"[object Boolean]\", dateTag$1 = \"[object Date]\", errorTag$1 = \"[object Error]\", funcTag$1 = \"[object Function]\", mapTag$2 = \"[object Map]\", numberTag$1 = \"[object Number]\", objectTag$3 = \"[object Object]\", regexpTag$1 = \"[object RegExp]\", setTag$2 = \"[object Set]\", stringTag$1 = \"[object String]\", weakMapTag$1 = \"[object WeakMap]\";\nvar arrayBufferTag$1 = \"[object ArrayBuffer]\", dataViewTag$2 = \"[object DataView]\", float32Tag = \"[object Float32Array]\", float64Tag = \"[object Float64Array]\", int8Tag = \"[object Int8Array]\", int16Tag = \"[object Int16Array]\", int32Tag = \"[object Int32Array]\", uint8Tag = \"[object Uint8Array]\", uint8ClampedTag = \"[object Uint8ClampedArray]\", uint16Tag = \"[object Uint16Array]\", uint32Tag = \"[object Uint32Array]\";\n/** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */ function baseIsTypedArray$1(value) {\n    return isObjectLike$4(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$4(value)];\n}\nvar _baseIsTypedArray = baseIsTypedArray$1;\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */ function baseUnary$2(func) {\n    return function(value) {\n        return func(value);\n    };\n}\nvar _baseUnary = baseUnary$2;\nvar _nodeUtil = {\n    exports: {}\n};\n_nodeUtil.exports;\n(function(module, exports1) {\n    var freeGlobal = _freeGlobal;\n    /** Detect free variable `exports`. */ var freeExports = exports1 && !exports1.nodeType && exports1;\n    /** Detect free variable `module`. */ var freeModule = freeExports && \"object\" == \"object\" && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;\n    /** Used to access faster Node.js helpers. */ var nodeUtil = function() {\n        try {\n            // Use `util.types` for Node.js 10+.\n            var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n            if (types) {\n                return types;\n            }\n            // Legacy `process.binding('util')` for Node.js < 10.\n            return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n        } catch (e) {}\n    }();\n    module.exports = nodeUtil;\n})(_nodeUtil, _nodeUtil.exports);\nvar _nodeUtilExports = _nodeUtil.exports;\nvar baseIsTypedArray = _baseIsTypedArray, baseUnary$1 = _baseUnary, nodeUtil = _nodeUtilExports;\n/* Node.js helper references. */ var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */ var isTypedArray$3 = nodeIsTypedArray ? baseUnary$1(nodeIsTypedArray) : baseIsTypedArray;\nvar isTypedArray_1 = isTypedArray$3;\nvar baseTimes = _baseTimes, isArguments$3 = isArguments_1, isArray$d = isArray_1, isBuffer$3 = isBufferExports, isIndex$2 = _isIndex, isTypedArray$2 = isTypedArray_1;\n/** Used for built-in method references. */ var objectProto$b = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$9 = objectProto$b.hasOwnProperty;\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */ function arrayLikeKeys$2(value, inherited) {\n    var isArr = isArray$d(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$3(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;\n    for(var key in value){\n        if ((inherited || hasOwnProperty$9.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n        (key == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n        isBuff && (key == \"offset\" || key == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n        isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n        isIndex$2(key, length)))) {\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _arrayLikeKeys = arrayLikeKeys$2;\n/** Used for built-in method references. */ var objectProto$a = Object.prototype;\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */ function isPrototype$3(value) {\n    var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$a;\n    return value === proto;\n}\nvar _isPrototype = isPrototype$3;\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */ function overArg$2(func, transform) {\n    return function(arg) {\n        return func(transform(arg));\n    };\n}\nvar _overArg = overArg$2;\nvar overArg$1 = _overArg;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeKeys$1 = overArg$1(Object.keys, Object);\nvar _nativeKeys = nativeKeys$1;\nvar isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;\n/** Used for built-in method references. */ var objectProto$9 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$8 = objectProto$9.hasOwnProperty;\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function baseKeys$1(object) {\n    if (!isPrototype$2(object)) {\n        return nativeKeys(object);\n    }\n    var result = [];\n    for(var key in Object(object)){\n        if (hasOwnProperty$8.call(object, key) && key != \"constructor\") {\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _baseKeys = baseKeys$1;\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ function isObject$8(value) {\n    var type = typeof value;\n    return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_1 = isObject$8;\nvar isObject$9 = /*@__PURE__*/ getDefaultExportFromCjs(isObject_1);\nvar baseGetTag$3 = _baseGetTag, isObject$7 = isObject_1;\n/** `Object#toString` result references. */ var asyncTag = \"[object AsyncFunction]\", funcTag = \"[object Function]\", genTag = \"[object GeneratorFunction]\", proxyTag = \"[object Proxy]\";\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */ function isFunction$3(value) {\n    if (!isObject$7(value)) {\n        return false;\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = baseGetTag$3(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\nvar isFunction_1 = isFunction$3;\nvar isFunction$2 = isFunction_1, isLength$1 = isLength_1;\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */ function isArrayLike$6(value) {\n    return value != null && isLength$1(value.length) && !isFunction$2(value);\n}\nvar isArrayLike_1 = isArrayLike$6;\nvar arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$5 = isArrayLike_1;\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */ function keys$3(object) {\n    return isArrayLike$5(object) ? arrayLikeKeys$1(object) : baseKeys(object);\n}\nvar keys_1 = keys$3;\nvar baseFor$1 = _baseFor, keys$2 = keys_1;\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */ function baseForOwn$3(object, iteratee) {\n    return object && baseFor$1(object, iteratee, keys$2);\n}\nvar _baseForOwn = baseForOwn$3;\nvar isArrayLike$4 = isArrayLike_1;\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */ function createBaseEach$1(eachFunc, fromRight) {\n    return function(collection, iteratee) {\n        if (collection == null) {\n            return collection;\n        }\n        if (!isArrayLike$4(collection)) {\n            return eachFunc(collection, iteratee);\n        }\n        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);\n        while(fromRight ? index-- : ++index < length){\n            if (iteratee(iterable[index], index, iterable) === false) {\n                break;\n            }\n        }\n        return collection;\n    };\n}\nvar _createBaseEach = createBaseEach$1;\nvar baseForOwn$2 = _baseForOwn, createBaseEach = _createBaseEach;\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */ var baseEach$3 = createBaseEach(baseForOwn$2);\nvar _baseEach = baseEach$3;\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */ function listCacheClear$1() {\n    this.__data__ = [];\n    this.size = 0;\n}\nvar _listCacheClear = listCacheClear$1;\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */ function eq$5(value, other) {\n    return value === other || value !== value && other !== other;\n}\nvar eq_1 = eq$5;\nvar eq$4 = eq_1;\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */ function assocIndexOf$4(array, key) {\n    var length = array.length;\n    while(length--){\n        if (eq$4(array[length][0], key)) {\n            return length;\n        }\n    }\n    return -1;\n}\nvar _assocIndexOf = assocIndexOf$4;\nvar assocIndexOf$3 = _assocIndexOf;\n/** Used for built-in method references. */ var arrayProto = Array.prototype;\n/** Built-in value references. */ var splice = arrayProto.splice;\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function listCacheDelete$1(key) {\n    var data = this.__data__, index = assocIndexOf$3(data, key);\n    if (index < 0) {\n        return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n        data.pop();\n    } else {\n        splice.call(data, index, 1);\n    }\n    --this.size;\n    return true;\n}\nvar _listCacheDelete = listCacheDelete$1;\nvar assocIndexOf$2 = _assocIndexOf;\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function listCacheGet$1(key) {\n    var data = this.__data__, index = assocIndexOf$2(data, key);\n    return index < 0 ? undefined : data[index][1];\n}\nvar _listCacheGet = listCacheGet$1;\nvar assocIndexOf$1 = _assocIndexOf;\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function listCacheHas$1(key) {\n    return assocIndexOf$1(this.__data__, key) > -1;\n}\nvar _listCacheHas = listCacheHas$1;\nvar assocIndexOf = _assocIndexOf;\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */ function listCacheSet$1(key, value) {\n    var data = this.__data__, index = assocIndexOf(data, key);\n    if (index < 0) {\n        ++this.size;\n        data.push([\n            key,\n            value\n        ]);\n    } else {\n        data[index][1] = value;\n    }\n    return this;\n}\nvar _listCacheSet = listCacheSet$1;\nvar listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function ListCache$4(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while(++index < length){\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `ListCache`.\nListCache$4.prototype.clear = listCacheClear;\nListCache$4.prototype[\"delete\"] = listCacheDelete;\nListCache$4.prototype.get = listCacheGet;\nListCache$4.prototype.has = listCacheHas;\nListCache$4.prototype.set = listCacheSet;\nvar _ListCache = ListCache$4;\nvar ListCache$3 = _ListCache;\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */ function stackClear$1() {\n    this.__data__ = new ListCache$3;\n    this.size = 0;\n}\nvar _stackClear = stackClear$1;\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function stackDelete$1(key) {\n    var data = this.__data__, result = data[\"delete\"](key);\n    this.size = data.size;\n    return result;\n}\nvar _stackDelete = stackDelete$1;\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function stackGet$1(key) {\n    return this.__data__.get(key);\n}\nvar _stackGet = stackGet$1;\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function stackHas$1(key) {\n    return this.__data__.has(key);\n}\nvar _stackHas = stackHas$1;\nvar root$6 = _root;\n/** Used to detect overreaching core-js shims. */ var coreJsData$1 = root$6[\"__core-js_shared__\"];\nvar _coreJsData = coreJsData$1;\nvar coreJsData = _coreJsData;\n/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n    return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */ function isMasked$1(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n}\nvar _isMasked = isMasked$1;\n/** Used for built-in method references. */ var funcProto$2 = Function.prototype;\n/** Used to resolve the decompiled source of functions. */ var funcToString$2 = funcProto$2.toString;\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */ function toSource$2(func) {\n    if (func != null) {\n        try {\n            return funcToString$2.call(func);\n        } catch (e) {}\n        try {\n            return func + \"\";\n        } catch (e) {}\n    }\n    return \"\";\n}\nvar _toSource = toSource$2;\nvar isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$6 = isObject_1, toSource$1 = _toSource;\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */ var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n/** Used for built-in method references. */ var funcProto$1 = Function.prototype, objectProto$8 = Object.prototype;\n/** Used to resolve the decompiled source of functions. */ var funcToString$1 = funcProto$1.toString;\n/** Used to check objects for own properties. */ var hasOwnProperty$7 = objectProto$8.hasOwnProperty;\n/** Used to detect if a method is native. */ var reIsNative = RegExp(\"^\" + funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */ function baseIsNative$1(value) {\n    if (!isObject$6(value) || isMasked(value)) {\n        return false;\n    }\n    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource$1(value));\n}\nvar _baseIsNative = baseIsNative$1;\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */ function getValue$1(object, key) {\n    return object == null ? undefined : object[key];\n}\nvar _getValue = getValue$1;\nvar baseIsNative = _baseIsNative, getValue = _getValue;\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */ function getNative$7(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n}\nvar _getNative = getNative$7;\nvar getNative$6 = _getNative, root$5 = _root;\n/* Built-in method references that are verified to be native. */ var Map$3 = getNative$6(root$5, \"Map\");\nvar _Map = Map$3;\nvar getNative$5 = _getNative;\n/* Built-in method references that are verified to be native. */ var nativeCreate$4 = getNative$5(Object, \"create\");\nvar _nativeCreate = nativeCreate$4;\nvar nativeCreate$3 = _nativeCreate;\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */ function hashClear$1() {\n    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};\n    this.size = 0;\n}\nvar _hashClear = hashClear$1;\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function hashDelete$1(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n}\nvar _hashDelete = hashDelete$1;\nvar nativeCreate$2 = _nativeCreate;\n/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED$2 = \"__lodash_hash_undefined__\";\n/** Used for built-in method references. */ var objectProto$7 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$6 = objectProto$7.hasOwnProperty;\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function hashGet$1(key) {\n    var data = this.__data__;\n    if (nativeCreate$2) {\n        var result = data[key];\n        return result === HASH_UNDEFINED$2 ? undefined : result;\n    }\n    return hasOwnProperty$6.call(data, key) ? data[key] : undefined;\n}\nvar _hashGet = hashGet$1;\nvar nativeCreate$1 = _nativeCreate;\n/** Used for built-in method references. */ var objectProto$6 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$5 = objectProto$6.hasOwnProperty;\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function hashHas$1(key) {\n    var data = this.__data__;\n    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$5.call(data, key);\n}\nvar _hashHas = hashHas$1;\nvar nativeCreate = _nativeCreate;\n/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */ function hashSet$1(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;\n    return this;\n}\nvar _hashSet = hashSet$1;\nvar hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function Hash$1(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while(++index < length){\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `Hash`.\nHash$1.prototype.clear = hashClear;\nHash$1.prototype[\"delete\"] = hashDelete;\nHash$1.prototype.get = hashGet;\nHash$1.prototype.has = hashHas;\nHash$1.prototype.set = hashSet;\nvar _Hash = Hash$1;\nvar Hash = _Hash, ListCache$2 = _ListCache, Map$2 = _Map;\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */ function mapCacheClear$1() {\n    this.size = 0;\n    this.__data__ = {\n        \"hash\": new Hash,\n        \"map\": new (Map$2 || ListCache$2),\n        \"string\": new Hash\n    };\n}\nvar _mapCacheClear = mapCacheClear$1;\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */ function isKeyable$1(value) {\n    var type = typeof value;\n    return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar _isKeyable = isKeyable$1;\nvar isKeyable = _isKeyable;\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */ function getMapData$4(map, key) {\n    var data = map.__data__;\n    return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar _getMapData = getMapData$4;\nvar getMapData$3 = _getMapData;\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function mapCacheDelete$1(key) {\n    var result = getMapData$3(this, key)[\"delete\"](key);\n    this.size -= result ? 1 : 0;\n    return result;\n}\nvar _mapCacheDelete = mapCacheDelete$1;\nvar getMapData$2 = _getMapData;\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function mapCacheGet$1(key) {\n    return getMapData$2(this, key).get(key);\n}\nvar _mapCacheGet = mapCacheGet$1;\nvar getMapData$1 = _getMapData;\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function mapCacheHas$1(key) {\n    return getMapData$1(this, key).has(key);\n}\nvar _mapCacheHas = mapCacheHas$1;\nvar getMapData = _getMapData;\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */ function mapCacheSet$1(key, value) {\n    var data = getMapData(this, key), size = data.size;\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n}\nvar _mapCacheSet = mapCacheSet$1;\nvar mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function MapCache$3(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while(++index < length){\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `MapCache`.\nMapCache$3.prototype.clear = mapCacheClear;\nMapCache$3.prototype[\"delete\"] = mapCacheDelete;\nMapCache$3.prototype.get = mapCacheGet;\nMapCache$3.prototype.has = mapCacheHas;\nMapCache$3.prototype.set = mapCacheSet;\nvar _MapCache = MapCache$3;\nvar ListCache$1 = _ListCache, Map$1 = _Map, MapCache$2 = _MapCache;\n/** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */ function stackSet$1(key, value) {\n    var data = this.__data__;\n    if (data instanceof ListCache$1) {\n        var pairs = data.__data__;\n        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n            pairs.push([\n                key,\n                value\n            ]);\n            this.size = ++data.size;\n            return this;\n        }\n        data = this.__data__ = new MapCache$2(pairs);\n    }\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n}\nvar _stackSet = stackSet$1;\nvar ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function Stack$3(entries) {\n    var data = this.__data__ = new ListCache(entries);\n    this.size = data.size;\n}\n// Add methods to `Stack`.\nStack$3.prototype.clear = stackClear;\nStack$3.prototype[\"delete\"] = stackDelete;\nStack$3.prototype.get = stackGet;\nStack$3.prototype.has = stackHas;\nStack$3.prototype.set = stackSet;\nvar _Stack = Stack$3;\n/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */ function setCacheAdd$1(value) {\n    this.__data__.set(value, HASH_UNDEFINED);\n    return this;\n}\nvar _setCacheAdd = setCacheAdd$1;\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */ function setCacheHas$1(value) {\n    return this.__data__.has(value);\n}\nvar _setCacheHas = setCacheHas$1;\nvar MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */ function SetCache$1(values) {\n    var index = -1, length = values == null ? 0 : values.length;\n    this.__data__ = new MapCache$1;\n    while(++index < length){\n        this.add(values[index]);\n    }\n}\n// Add methods to `SetCache`.\nSetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;\nSetCache$1.prototype.has = setCacheHas;\nvar _SetCache = SetCache$1;\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */ function arraySome$1(array, predicate) {\n    var index = -1, length = array == null ? 0 : array.length;\n    while(++index < length){\n        if (predicate(array[index], index, array)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar _arraySome = arraySome$1;\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function cacheHas$1(cache, key) {\n    return cache.has(key);\n}\nvar _cacheHas = cacheHas$1;\nvar SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */ function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n    }\n    // Check that cyclic values are equal.\n    var arrStacked = stack.get(array);\n    var othStacked = stack.get(other);\n    if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n    }\n    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache : undefined;\n    stack.set(array, other);\n    stack.set(other, array);\n    // Ignore non-index properties.\n    while(++index < arrLength){\n        var arrValue = array[index], othValue = other[index];\n        if (customizer) {\n            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n            if (compared) {\n                continue;\n            }\n            result = false;\n            break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n            if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                    return seen.push(othIndex);\n                }\n            })) {\n                result = false;\n                break;\n            }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n            result = false;\n            break;\n        }\n    }\n    stack[\"delete\"](array);\n    stack[\"delete\"](other);\n    return result;\n}\nvar _equalArrays = equalArrays$2;\nvar root$4 = _root;\n/** Built-in value references. */ var Uint8Array$3 = root$4.Uint8Array;\nvar _Uint8Array = Uint8Array$3;\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */ function mapToArray$1(map) {\n    var index = -1, result = Array(map.size);\n    map.forEach(function(value, key) {\n        result[++index] = [\n            key,\n            value\n        ];\n    });\n    return result;\n}\nvar _mapToArray = mapToArray$1;\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */ function setToArray$1(set) {\n    var index = -1, result = Array(set.size);\n    set.forEach(function(value) {\n        result[++index] = value;\n    });\n    return result;\n}\nvar _setToArray = setToArray$1;\nvar Symbol$3 = _Symbol, Uint8Array$2 = _Uint8Array, eq$3 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;\n/** `Object#toString` result references. */ var boolTag = \"[object Boolean]\", dateTag = \"[object Date]\", errorTag = \"[object Error]\", mapTag$1 = \"[object Map]\", numberTag = \"[object Number]\", regexpTag = \"[object RegExp]\", setTag$1 = \"[object Set]\", stringTag = \"[object String]\", symbolTag$1 = \"[object Symbol]\";\nvar arrayBufferTag = \"[object ArrayBuffer]\", dataViewTag$1 = \"[object DataView]\";\n/** Used to convert symbols to primitives and strings. */ var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : undefined, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */ function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch(tag){\n        case dataViewTag$1:\n            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n                return false;\n            }\n            object = object.buffer;\n            other = other.buffer;\n        case arrayBufferTag:\n            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {\n                return false;\n            }\n            return true;\n        case boolTag:\n        case dateTag:\n        case numberTag:\n            // Coerce booleans to `1` or `0` and dates to milliseconds.\n            // Invalid dates are coerced to `NaN`.\n            return eq$3(+object, +other);\n        case errorTag:\n            return object.name == other.name && object.message == other.message;\n        case regexpTag:\n        case stringTag:\n            // Coerce regexes to strings and treat strings, primitives and objects,\n            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n            // for more details.\n            return object == other + \"\";\n        case mapTag$1:\n            var convert = mapToArray;\n        case setTag$1:\n            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;\n            convert || (convert = setToArray);\n            if (object.size != other.size && !isPartial) {\n                return false;\n            }\n            // Assume cyclic values are equal.\n            var stacked = stack.get(object);\n            if (stacked) {\n                return stacked == other;\n            }\n            bitmask |= COMPARE_UNORDERED_FLAG$2;\n            // Recursively compare objects (susceptible to call stack limits).\n            stack.set(object, other);\n            var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n            stack[\"delete\"](object);\n            return result;\n        case symbolTag$1:\n            if (symbolValueOf) {\n                return symbolValueOf.call(object) == symbolValueOf.call(other);\n            }\n    }\n    return false;\n}\nvar _equalByTag = equalByTag$1;\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */ function arrayPush$2(array, values) {\n    var index = -1, length = values.length, offset = array.length;\n    while(++index < length){\n        array[offset + index] = values[index];\n    }\n    return array;\n}\nvar _arrayPush = arrayPush$2;\nvar arrayPush$1 = _arrayPush, isArray$c = isArray_1;\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */ function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray$c(object) ? result : arrayPush$1(result, symbolsFunc(object));\n}\nvar _baseGetAllKeys = baseGetAllKeys$1;\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */ function arrayFilter$1(array, predicate) {\n    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n    while(++index < length){\n        var value = array[index];\n        if (predicate(value, index, array)) {\n            result[resIndex++] = value;\n        }\n    }\n    return result;\n}\nvar _arrayFilter = arrayFilter$1;\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */ function stubArray$1() {\n    return [];\n}\nvar stubArray_1 = stubArray$1;\nvar arrayFilter = _arrayFilter, stubArray = stubArray_1;\n/** Used for built-in method references. */ var objectProto$5 = Object.prototype;\n/** Built-in value references. */ var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols;\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */ var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {\n    if (object == null) {\n        return [];\n    }\n    object = Object(object);\n    return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n    });\n};\nvar _getSymbols = getSymbols$1;\nvar baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$1 = keys_1;\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */ function getAllKeys$1(object) {\n    return baseGetAllKeys(object, keys$1, getSymbols);\n}\nvar _getAllKeys = getAllKeys$1;\nvar getAllKeys = _getAllKeys;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$3 = 1;\n/** Used for built-in method references. */ var objectProto$4 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$4 = objectProto$4.hasOwnProperty;\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */ function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;\n    if (objLength != othLength && !isPartial) {\n        return false;\n    }\n    var index = objLength;\n    while(index--){\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {\n            return false;\n        }\n    }\n    // Check that cyclic values are equal.\n    var objStacked = stack.get(object);\n    var othStacked = stack.get(other);\n    if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n    }\n    var result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n    var skipCtor = isPartial;\n    while(++index < objLength){\n        key = objProps[index];\n        var objValue = object[key], othValue = other[key];\n        if (customizer) {\n            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n            result = false;\n            break;\n        }\n        skipCtor || (skipCtor = key == \"constructor\");\n    }\n    if (result && !skipCtor) {\n        var objCtor = object.constructor, othCtor = other.constructor;\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n            result = false;\n        }\n    }\n    stack[\"delete\"](object);\n    stack[\"delete\"](other);\n    return result;\n}\nvar _equalObjects = equalObjects$1;\nvar getNative$4 = _getNative, root$3 = _root;\n/* Built-in method references that are verified to be native. */ var DataView$1 = getNative$4(root$3, \"DataView\");\nvar _DataView = DataView$1;\nvar getNative$3 = _getNative, root$2 = _root;\n/* Built-in method references that are verified to be native. */ var Promise$2 = getNative$3(root$2, \"Promise\");\nvar _Promise = Promise$2;\nvar getNative$2 = _getNative, root$1 = _root;\n/* Built-in method references that are verified to be native. */ var Set$2 = getNative$2(root$1, \"Set\");\nvar _Set = Set$2;\nvar getNative$1 = _getNative, root = _root;\n/* Built-in method references that are verified to be native. */ var WeakMap$1 = getNative$1(root, \"WeakMap\");\nvar _WeakMap = WeakMap$1;\nvar DataView = _DataView, Map = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap = _WeakMap, baseGetTag$2 = _baseGetTag, toSource = _toSource;\n/** `Object#toString` result references. */ var mapTag = \"[object Map]\", objectTag$2 = \"[object Object]\", promiseTag = \"[object Promise]\", setTag = \"[object Set]\", weakMapTag = \"[object WeakMap]\";\nvar dataViewTag = \"[object DataView]\";\n/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap);\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */ var getTag$2 = baseGetTag$2;\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif (DataView && getTag$2(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag$2(new Map) != mapTag || Promise$1 && getTag$2(Promise$1.resolve()) != promiseTag || Set$1 && getTag$2(new Set$1) != setTag || WeakMap && getTag$2(new WeakMap) != weakMapTag) {\n    getTag$2 = function(value) {\n        var result = baseGetTag$2(value), Ctor = result == objectTag$2 ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : \"\";\n        if (ctorString) {\n            switch(ctorString){\n                case dataViewCtorString:\n                    return dataViewTag;\n                case mapCtorString:\n                    return mapTag;\n                case promiseCtorString:\n                    return promiseTag;\n                case setCtorString:\n                    return setTag;\n                case weakMapCtorString:\n                    return weakMapTag;\n            }\n        }\n        return result;\n    };\n}\nvar _getTag = getTag$2;\nvar Stack$2 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$1 = _getTag, isArray$b = isArray_1, isBuffer$2 = isBufferExports, isTypedArray$1 = isTypedArray_1;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$2 = 1;\n/** `Object#toString` result references. */ var argsTag = \"[object Arguments]\", arrayTag = \"[object Array]\", objectTag$1 = \"[object Object]\";\n/** Used for built-in method references. */ var objectProto$3 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */ function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray$b(object), othIsArr = isArray$b(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);\n    objTag = objTag == argsTag ? objectTag$1 : objTag;\n    othTag = othTag == argsTag ? objectTag$1 : othTag;\n    var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;\n    if (isSameTag && isBuffer$2(object)) {\n        if (!isBuffer$2(other)) {\n            return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n    }\n    if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack$2);\n        return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n    }\n    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n        var objIsWrapped = objIsObj && hasOwnProperty$3.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, \"__wrapped__\");\n        if (objIsWrapped || othIsWrapped) {\n            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n            stack || (stack = new Stack$2);\n            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n    }\n    if (!isSameTag) {\n        return false;\n    }\n    stack || (stack = new Stack$2);\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\nvar _baseIsEqualDeep = baseIsEqualDeep$1;\nvar baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$3 = isObjectLike_1;\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */ function baseIsEqual$3(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n        return true;\n    }\n    if (value == null || other == null || !isObjectLike$3(value) && !isObjectLike$3(other)) {\n        return value !== value && other !== other;\n    }\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);\n}\nvar _baseIsEqual = baseIsEqual$3;\nvar Stack$1 = _Stack, baseIsEqual$2 = _baseIsEqual;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */ function baseIsMatch$1(object, source, matchData, customizer) {\n    var index = matchData.length, length = index, noCustomizer = !customizer;\n    if (object == null) {\n        return !length;\n    }\n    object = Object(object);\n    while(index--){\n        var data = matchData[index];\n        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n            return false;\n        }\n    }\n    while(++index < length){\n        data = matchData[index];\n        var key = data[0], objValue = object[key], srcValue = data[1];\n        if (noCustomizer && data[2]) {\n            if (objValue === undefined && !(key in object)) {\n                return false;\n            }\n        } else {\n            var stack = new Stack$1;\n            if (customizer) {\n                var result = customizer(objValue, srcValue, key, object, source, stack);\n            }\n            if (!(result === undefined ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nvar _baseIsMatch = baseIsMatch$1;\nvar isObject$5 = isObject_1;\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */ function isStrictComparable$2(value) {\n    return value === value && !isObject$5(value);\n}\nvar _isStrictComparable = isStrictComparable$2;\nvar isStrictComparable$1 = _isStrictComparable, keys = keys_1;\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */ function getMatchData$1(object) {\n    var result = keys(object), length = result.length;\n    while(length--){\n        var key = result[length], value = object[key];\n        result[length] = [\n            key,\n            value,\n            isStrictComparable$1(value)\n        ];\n    }\n    return result;\n}\nvar _getMatchData = getMatchData$1;\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */ function matchesStrictComparable$2(key, srcValue) {\n    return function(object) {\n        if (object == null) {\n            return false;\n        }\n        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n    };\n}\nvar _matchesStrictComparable = matchesStrictComparable$2;\nvar baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */ function baseMatches$1(source) {\n    var matchData = getMatchData(source);\n    if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);\n    }\n    return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n    };\n}\nvar _baseMatches = baseMatches$1;\nvar baseGetTag$1 = _baseGetTag, isObjectLike$2 = isObjectLike_1;\n/** `Object#toString` result references. */ var symbolTag = \"[object Symbol]\";\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */ function isSymbol$5(value) {\n    return typeof value == \"symbol\" || isObjectLike$2(value) && baseGetTag$1(value) == symbolTag;\n}\nvar isSymbol_1 = isSymbol$5;\nvar isArray$a = isArray_1, isSymbol$4 = isSymbol_1;\n/** Used to match property names within property paths. */ var reIsDeepProp$1 = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp$1 = /^\\w*$/;\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */ function isKey$4(value, object) {\n    if (isArray$a(value)) {\n        return false;\n    }\n    var type = typeof value;\n    if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol$4(value)) {\n        return true;\n    }\n    return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);\n}\nvar _isKey = isKey$4;\nvar MapCache = _MapCache;\n/** Error message constants. */ var FUNC_ERROR_TEXT = \"Expected a function\";\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */ function memoize$1(func, resolver) {\n    if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function() {\n        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n    };\n    memoized.cache = new (memoize$1.Cache || MapCache);\n    return memoized;\n}\n// Expose `MapCache`.\nmemoize$1.Cache = MapCache;\nvar memoize_1 = memoize$1;\nvar memoize = memoize_1;\n/** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */ function memoizeCapped$1(func) {\n    var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n            cache.clear();\n        }\n        return key;\n    });\n    var cache = result.cache;\n    return result;\n}\nvar _memoizeCapped = memoizeCapped$1;\nvar memoizeCapped = _memoizeCapped;\n/** Used to match property names within property paths. */ var rePropName$1 = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n/** Used to match backslashes in property paths. */ var reEscapeChar$1 = /\\\\(\\\\)?/g;\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */ var stringToPath$2 = memoizeCapped(function(string) {\n    var result = [];\n    if (string.charCodeAt(0) === 46 /* . */ ) {\n        result.push(\"\");\n    }\n    string.replace(rePropName$1, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar$1, \"$1\") : number || match);\n    });\n    return result;\n});\nvar _stringToPath = stringToPath$2;\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */ function arrayMap$2(array, iteratee) {\n    var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n    while(++index < length){\n        result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n}\nvar _arrayMap = arrayMap$2;\nvar Symbol$2 = _Symbol, arrayMap$1 = _arrayMap, isArray$9 = isArray_1, isSymbol$3 = isSymbol_1;\n/** Used as references for various `Number` constants. */ var INFINITY$2 = 1 / 0;\n/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */ function baseToString$1(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == \"string\") {\n        return value;\n    }\n    if (isArray$9(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap$1(value, baseToString$1) + \"\";\n    }\n    if (isSymbol$3(value)) {\n        return symbolToString ? symbolToString.call(value) : \"\";\n    }\n    var result = value + \"\";\n    return result == \"0\" && 1 / value == -INFINITY$2 ? \"-0\" : result;\n}\nvar _baseToString = baseToString$1;\nvar baseToString = _baseToString;\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */ function toString$5(value) {\n    return value == null ? \"\" : baseToString(value);\n}\nvar toString_1 = toString$5;\nvar isArray$8 = isArray_1, isKey$3 = _isKey, stringToPath$1 = _stringToPath, toString$4 = toString_1;\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */ function castPath$3(value, object) {\n    if (isArray$8(value)) {\n        return value;\n    }\n    return isKey$3(value, object) ? [\n        value\n    ] : stringToPath$1(toString$4(value));\n}\nvar _castPath = castPath$3;\nvar isSymbol$2 = isSymbol_1;\n/** Used as references for various `Number` constants. */ var INFINITY$1 = 1 / 0;\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */ function toKey$5(value) {\n    if (typeof value == \"string\" || isSymbol$2(value)) {\n        return value;\n    }\n    var result = value + \"\";\n    return result == \"0\" && 1 / value == -INFINITY$1 ? \"-0\" : result;\n}\nvar _toKey = toKey$5;\nvar castPath$2 = _castPath, toKey$4 = _toKey;\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */ function baseGet$3(object, path) {\n    path = castPath$2(path, object);\n    var index = 0, length = path.length;\n    while(object != null && index < length){\n        object = object[toKey$4(path[index++])];\n    }\n    return index && index == length ? object : undefined;\n}\nvar _baseGet = baseGet$3;\nvar baseGet$2 = _baseGet;\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */ function get$2(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet$2(object, path);\n    return result === undefined ? defaultValue : result;\n}\nvar get_1 = get$2;\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */ function baseHasIn$1(object, key) {\n    return object != null && key in Object(object);\n}\nvar _baseHasIn = baseHasIn$1;\nvar castPath$1 = _castPath, isArguments$2 = isArguments_1, isArray$7 = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$3 = _toKey;\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */ function hasPath$1(object, path, hasFunc) {\n    path = castPath$1(path, object);\n    var index = -1, length = path.length, result = false;\n    while(++index < length){\n        var key = toKey$3(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n            break;\n        }\n        object = object[key];\n    }\n    if (result || ++index != length) {\n        return result;\n    }\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex$1(key, length) && (isArray$7(object) || isArguments$2(object));\n}\nvar _hasPath = hasPath$1;\nvar baseHasIn = _baseHasIn, hasPath = _hasPath;\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */ function hasIn$1(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n}\nvar hasIn_1 = hasIn$1;\nvar baseIsEqual$1 = _baseIsEqual, get$1 = get_1, hasIn = hasIn_1, isKey$2 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$2 = _toKey;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */ function baseMatchesProperty$1(path, srcValue) {\n    if (isKey$2(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey$2(path), srcValue);\n    }\n    return function(object) {\n        var objValue = get$1(object, path);\n        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n    };\n}\nvar _baseMatchesProperty = baseMatchesProperty$1;\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */ function identity$4(value) {\n    return value;\n}\nvar identity_1 = identity$4;\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */ function baseProperty$1(key) {\n    return function(object) {\n        return object == null ? undefined : object[key];\n    };\n}\nvar _baseProperty = baseProperty$1;\nvar baseGet$1 = _baseGet;\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */ function basePropertyDeep$1(path) {\n    return function(object) {\n        return baseGet$1(object, path);\n    };\n}\nvar _basePropertyDeep = basePropertyDeep$1;\nvar baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey$1 = _isKey, toKey$1 = _toKey;\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */ function property$1(path) {\n    return isKey$1(path) ? baseProperty(toKey$1(path)) : basePropertyDeep(path);\n}\nvar property_1 = property$1;\nvar baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$3 = identity_1, isArray$6 = isArray_1, property = property_1;\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */ function baseIteratee$5(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == \"function\") {\n        return value;\n    }\n    if (value == null) {\n        return identity$3;\n    }\n    if (typeof value == \"object\") {\n        return isArray$6(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n    }\n    return property(value);\n}\nvar _baseIteratee = baseIteratee$5;\n/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */ function baseReduce$1(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n}\nvar _baseReduce = baseReduce$1;\nvar arrayReduce$1 = _arrayReduce, baseEach$2 = _baseEach, baseIteratee$4 = _baseIteratee, baseReduce = _baseReduce, isArray$5 = isArray_1;\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */ function reduce(collection, iteratee, accumulator) {\n    var func = isArray$5(collection) ? arrayReduce$1 : baseReduce, initAccum = arguments.length < 3;\n    return func(collection, baseIteratee$4(iteratee), accumulator, initAccum, baseEach$2);\n}\nvar reduce_1 = reduce;\nvar reduce$1 = /*@__PURE__*/ getDefaultExportFromCjs(reduce_1);\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self :  false ? 0 : {};\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar inited = false;\nfunction init() {\n    inited = true;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for(var i = 0, len = code.length; i < len; ++i){\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n    }\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n}\nfunction toByteArray(b64) {\n    if (!inited) {\n        init();\n    }\n    var i, j, l, tmp, placeHolders, arr;\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    placeHolders = b64[len - 2] === \"=\" ? 2 : b64[len - 1] === \"=\" ? 1 : 0;\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(len * 3 / 4 - placeHolders);\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? len - 4 : len;\n    var L = 0;\n    for(i = 0, j = 0; i < l; i += 4, j += 3){\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[L++] = tmp >> 16 & 0xFF;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    if (placeHolders === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[L++] = tmp & 0xFF;\n    } else if (placeHolders === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\nfunction encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n    if (!inited) {\n        init();\n    }\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    var output = \"\";\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        output += lookup[tmp >> 2];\n        output += lookup[tmp << 4 & 0x3F];\n        output += \"==\";\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        output += lookup[tmp >> 10];\n        output += lookup[tmp >> 4 & 0x3F];\n        output += lookup[tmp << 2 & 0x3F];\n        output += \"=\";\n    }\n    parts.push(output);\n    return parts.join(\"\");\n}\nfunction read(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    if (e === 0) {\n        e = 1 - eBias;\n    } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n}\nfunction write(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) {\n            value += rt / c;\n        } else {\n            value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}\n    buffer[offset + i - d] |= s * 128;\n}\nvar toString$3 = {}.toString;\nvar isArray$4 = Array.isArray || function(arr) {\n    return toString$3.call(arr) == \"[object Array]\";\n};\nvar INSPECT_MAX_BYTES = 50;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */ Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;\n/*\n * Export kMaxLength after typed array support is determined.\n */ kMaxLength();\nfunction kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\nfunction createBuffer(that, length) {\n    if (kMaxLength() < length) {\n        throw new RangeError(\"Invalid typed array length\");\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length);\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n            that = new Buffer(length);\n        }\n        that.length = length;\n    }\n    return that;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length);\n    }\n    // Common case.\n    if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n            throw new Error(\"If encoding is specified then the first argument must be a string\");\n        }\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, encodingOrOffset, length);\n}\nBuffer.poolSize = 8192; // not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function(arr) {\n    arr.__proto__ = Buffer.prototype;\n    return arr;\n};\nfunction from(that, value, encodingOrOffset, length) {\n    if (typeof value === \"number\") {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === \"string\") {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ Buffer.from = function(value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length);\n};\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    if (typeof Symbol !== \"undefined\" && Symbol.species && Buffer[Symbol.species] === Buffer) ;\n}\nfunction assertSize(size) {\n    if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be a number');\n    } else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n    }\n}\nfunction alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ Buffer.alloc = function(size, fill, encoding) {\n    return alloc(null, size, fill, encoding);\n};\nfunction allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for(var i = 0; i < size; ++i){\n            that[i] = 0;\n        }\n    }\n    return that;\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ Buffer.allocUnsafe = function(size) {\n    return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ Buffer.allocUnsafeSlow = function(size) {\n    return allocUnsafe(null, size);\n};\nfunction fromString(that, string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual);\n    }\n    return that;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for(var i = 0; i < length; i += 1){\n        that[i] = array[i] & 255;\n    }\n    return that;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\");\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\");\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    } else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}\nfunction fromObject(that, obj) {\n    if (internalIsBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        that = createBuffer(that, len);\n        if (that.length === 0) {\n            return that;\n        }\n        obj.copy(that, 0, 0, len);\n        return that;\n    }\n    if (obj) {\n        if (typeof ArrayBuffer !== \"undefined\" && obj.buffer instanceof ArrayBuffer || \"length\" in obj) {\n            if (typeof obj.length !== \"number\" || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === \"Buffer\" && isArray$4(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n}\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + kMaxLength().toString(16) + \" bytes\");\n    }\n    return length | 0;\n}\nBuffer.isBuffer = isBuffer$1;\nfunction internalIsBuffer(b) {\n    return !!(b != null && b._isBuffer);\n}\nBuffer.compare = function compare(a, b) {\n    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n        throw new TypeError(\"Arguments must be Buffers\");\n    }\n    if (a === b) return 0;\n    var x = a.length;\n    var y = b.length;\n    for(var i = 0, len = Math.min(x, y); i < len; ++i){\n        if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return true;\n        default:\n            return false;\n    }\n};\nBuffer.concat = function concat(list, length) {\n    if (!isArray$4(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return Buffer.alloc(0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i){\n            length += list[i].length;\n        }\n    }\n    var buffer = Buffer.allocUnsafe(length);\n    var pos = 0;\n    for(i = 0; i < list.length; ++i){\n        var buf = list[i];\n        if (!internalIsBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction byteLength(string, encoding) {\n    if (internalIsBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n        string = \"\" + string;\n    }\n    var len = string.length;\n    if (len === 0) return 0;\n    // Use a for loop to avoid recursion\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n                return len;\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined:\n                return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return len * 2;\n            case \"hex\":\n                return len >>> 1;\n            case \"base64\":\n                return base64ToBytes(string).length;\n            default:\n                if (loweredCase) return utf8ToBytes(string).length // assume utf8\n                ;\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\nBuffer.byteLength = byteLength;\nfunction slowToString(encoding, start, end) {\n    var loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while(true){\n        switch(encoding){\n            case \"hex\":\n                return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Slice(this, start, end);\n            case \"ascii\":\n                return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Slice(this, start, end);\n            case \"base64\":\n                return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return utf16leSlice(this, start, end);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (encoding + \"\").toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\nfunction swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\nBuffer.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n    for(var i = 0; i < len; i += 2){\n        swap(this, i, i + 1);\n    }\n    return this;\n};\nBuffer.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n    for(var i = 0; i < len; i += 4){\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n    }\n    return this;\n};\nBuffer.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n    for(var i = 0; i < len; i += 8){\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n    }\n    return this;\n};\nBuffer.prototype.toString = function toString() {\n    var length = this.length | 0;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n};\nBuffer.prototype.equals = function equals(b) {\n    if (!internalIsBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return Buffer.compare(this, b) === 0;\n};\nBuffer.prototype.inspect = function inspect() {\n    var str = \"\";\n    var max = INSPECT_MAX_BYTES;\n    if (this.length > 0) {\n        str = this.toString(\"hex\", 0, max).match(/.{2}/g).join(\" \");\n        if (this.length > max) str += \" ... \";\n    }\n    return \"<Buffer \" + str + \">\";\n};\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (!internalIsBuffer(target)) {\n        throw new TypeError(\"Argument must be a Buffer\");\n    }\n    if (start === undefined) {\n        start = 0;\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0;\n    }\n    if (thisStart === undefined) {\n        thisStart = 0;\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n    }\n    if (thisStart >= thisEnd && start >= end) {\n        return 0;\n    }\n    if (thisStart >= thisEnd) {\n        return -1;\n    }\n    if (start >= end) {\n        return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n    for(var i = 0; i < len; ++i){\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n    } else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n    }\n    byteOffset = +byteOffset; // Coerce to Number.\n    if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (internalIsBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 0xFF; // Search for a byte value [0-255]\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++){\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            var found = true;\n            for(var j = 0; j < valLength; j++){\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    // must be an even number of digits\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError(\"Invalid hex string\");\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for(var i = 0; i < length; ++i){\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\nfunction latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length);\n}\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n            if (encoding === undefined) encoding = \"utf8\";\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n    } else {\n        throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n    if (!encoding) encoding = \"utf8\";\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"hex\":\n                return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Write(this, string, offset, length);\n            case \"ascii\":\n                return asciiWrite(this, string, offset, length);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Write(this, string, offset, length);\n            case \"base64\":\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return ucs2Write(this, string, offset, length);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n};\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return fromByteArray(buf);\n    } else {\n        return fromByteArray(buf.slice(start, end));\n    }\n}\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while(i < end){\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte;\n                    }\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n        ;\n    }\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = \"\";\n    var i = 0;\n    while(i < len){\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}\nfunction asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n    return ret;\n}\nfunction latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}\nfunction hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for(var i = start; i < end; ++i){\n        out += toHex(buf[i]);\n    }\n    return out;\n}\nfunction utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for(var i = 0; i < bytes.length; i += 2){\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) {\n        end = len;\n    }\n    if (end < start) end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        newBuf.__proto__ = Buffer.prototype;\n    } else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for(var i = 0; i < sliceLen; ++i){\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n}\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length);\n    }\n    var val = this[offset + --byteLength];\n    var mul = 1;\n    while(byteLength > 0 && (mul *= 0x100)){\n        val += this[offset + --byteLength] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    return this[offset];\n};\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var i = byteLength;\n    var mul = 1;\n    var val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100)){\n        val += this[offset + --i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, true, 23, 4);\n};\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, false, 23, 4);\n};\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, true, 52, 8);\n};\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, false, 52, 8);\n};\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n}\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i){\n        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n    }\n}\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffffffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i){\n        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n    }\n}\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0) value = 0xffffffff + value + 1;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n}\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4);\n    }\n    write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n};\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8);\n    }\n    write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n    }\n    if (start < 0 || start >= this.length) throw new RangeError(\"sourceStart out of bounds\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for(i = len - 1; i >= 0; --i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for(i = 0; i < len; ++i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n        if (encoding !== undefined && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    var i;\n    if (typeof val === \"number\") {\n        for(i = start; i < end; ++i){\n            this[i] = val;\n        }\n    } else {\n        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n        var len = bytes.length;\n        for(i = 0; i < end - start; ++i){\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\n// HELPER FUNCTIONS\n// ================\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\nfunction base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return \"\";\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0){\n        str = str + \"=\";\n    }\n    return str;\n}\nfunction stringtrim(str) {\n    if (str.trim) return str.trim();\n    return str.replace(/^\\s+|\\s+$/g, \"\");\n}\nfunction toHex(n) {\n    if (n < 16) return \"0\" + n.toString(16);\n    return n.toString(16);\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for(var i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}\nfunction asciiToBytes(str) {\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n    return byteArray;\n}\nfunction utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction base64ToBytes(str) {\n    return toByteArray(base64clean(str));\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for(var i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction isnan(val) {\n    return val !== val // eslint-disable-line no-self-compare\n    ;\n}\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer$1(obj) {\n    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));\n}\nfunction isFastBuffer(obj) {\n    return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n}\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer(obj) {\n    return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isFastBuffer(obj.slice(0, 0));\n}\n// Lodash implementation of `get`\nconst charCodeOfDot = \".\".charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(// Match anything that isn't a dot or bracket.\n\"[^.[\\\\]]+\" + \"|\" + // Or match property names within brackets.\n\"\\\\[(?:\" + // Match a non-string expression.\n\"([^\\\"'][^[]*)\" + \"|\" + // Or match strings (supports escaping characters).\n\"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" + \")\\\\]\" + \"|\" + // Or match \"\" as the space between consecutive dots or empty brackets.\n\"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\", \"g\");\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\nconst getTag = function(value) {\n    return Object.prototype.toString.call(value);\n};\nconst isSymbol$1 = function(value) {\n    const type = typeof value;\n    return type === \"symbol\" || type === \"object\" && value && getTag(value) === \"[object Symbol]\";\n};\nconst isKey = function(value, object) {\n    if (Array.isArray(value)) {\n        return false;\n    }\n    const type = typeof value;\n    if (type === \"number\" || type === \"symbol\" || type === \"boolean\" || !value || isSymbol$1(value)) {\n        return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n};\nconst stringToPath = function(string) {\n    const result = [];\n    if (string.charCodeAt(0) === charCodeOfDot) {\n        result.push(\"\");\n    }\n    string.replace(rePropName, function(match, expression, quote, subString) {\n        let key = match;\n        if (quote) {\n            key = subString.replace(reEscapeChar, \"$1\");\n        } else if (expression) {\n            key = expression.trim();\n        }\n        result.push(key);\n    });\n    return result;\n};\nconst castPath = function(value, object) {\n    if (Array.isArray(value)) {\n        return value;\n    } else {\n        return isKey(value, object) ? [\n            value\n        ] : stringToPath(value);\n    }\n};\nconst toKey = function(value) {\n    if (typeof value === \"string\" || isSymbol$1(value)) return value;\n    const result = `${value}`;\n    // eslint-disable-next-line\n    return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n};\nconst get = function(object, path) {\n    path = castPath(path, object);\n    let index = 0;\n    const length = path.length;\n    while(object != null && index < length){\n        object = object[toKey(path[index++])];\n    }\n    return index && index === length ? object : undefined;\n};\nconst is_object = function(obj) {\n    return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n};\nconst normalize_columns = function(columns) {\n    if (columns === undefined || columns === null) {\n        return [\n            undefined,\n            undefined\n        ];\n    }\n    if (typeof columns !== \"object\") {\n        return [\n            Error('Invalid option \"columns\": expect an array or an object')\n        ];\n    }\n    if (!Array.isArray(columns)) {\n        const newcolumns = [];\n        for(const k in columns){\n            newcolumns.push({\n                key: k,\n                header: columns[k]\n            });\n        }\n        columns = newcolumns;\n    } else {\n        const newcolumns = [];\n        for (const column of columns){\n            if (typeof column === \"string\") {\n                newcolumns.push({\n                    key: column,\n                    header: column\n                });\n            } else if (typeof column === \"object\" && column !== null && !Array.isArray(column)) {\n                if (!column.key) {\n                    return [\n                        Error('Invalid column definition: property \"key\" is required')\n                    ];\n                }\n                if (column.header === undefined) {\n                    column.header = column.key;\n                }\n                newcolumns.push(column);\n            } else {\n                return [\n                    Error(\"Invalid column definition: expect a string or an object\")\n                ];\n            }\n        }\n        columns = newcolumns;\n    }\n    return [\n        undefined,\n        columns\n    ];\n};\nclass CsvError extends Error {\n    constructor(code, message, ...contexts){\n        if (Array.isArray(message)) message = message.join(\" \");\n        super(message);\n        if (Error.captureStackTrace !== undefined) {\n            Error.captureStackTrace(this, CsvError);\n        }\n        this.code = code;\n        for (const context of contexts){\n            for(const key in context){\n                const value = context[key];\n                this[key] = isBuffer$1(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n            }\n        }\n    }\n}\nconst underscore = function(str) {\n    return str.replace(/([A-Z])/g, function(_, match) {\n        return \"_\" + match.toLowerCase();\n    });\n};\nconst normalize_options = function(opts) {\n    const options = {};\n    // Merge with user options\n    for(const opt in opts){\n        options[underscore(opt)] = opts[opt];\n    }\n    // Normalize option `bom`\n    if (options.bom === undefined || options.bom === null || options.bom === false) {\n        options.bom = false;\n    } else if (options.bom !== true) {\n        return [\n            new CsvError(\"CSV_OPTION_BOOLEAN_INVALID_TYPE\", [\n                \"option `bom` is optional and must be a boolean value,\",\n                `got ${JSON.stringify(options.bom)}`\n            ])\n        ];\n    }\n    // Normalize option `delimiter`\n    if (options.delimiter === undefined || options.delimiter === null) {\n        options.delimiter = \",\";\n    } else if (isBuffer$1(options.delimiter)) {\n        options.delimiter = options.delimiter.toString();\n    } else if (typeof options.delimiter !== \"string\") {\n        return [\n            new CsvError(\"CSV_OPTION_DELIMITER_INVALID_TYPE\", [\n                \"option `delimiter` must be a buffer or a string,\",\n                `got ${JSON.stringify(options.delimiter)}`\n            ])\n        ];\n    }\n    // Normalize option `quote`\n    if (options.quote === undefined || options.quote === null) {\n        options.quote = '\"';\n    } else if (options.quote === true) {\n        options.quote = '\"';\n    } else if (options.quote === false) {\n        options.quote = \"\";\n    } else if (isBuffer$1(options.quote)) {\n        options.quote = options.quote.toString();\n    } else if (typeof options.quote !== \"string\") {\n        return [\n            new CsvError(\"CSV_OPTION_QUOTE_INVALID_TYPE\", [\n                \"option `quote` must be a boolean, a buffer or a string,\",\n                `got ${JSON.stringify(options.quote)}`\n            ])\n        ];\n    }\n    // Normalize option `quoted`\n    if (options.quoted === undefined || options.quoted === null) {\n        options.quoted = false;\n    }\n    // Normalize option `escape_formulas`\n    if (options.escape_formulas === undefined || options.escape_formulas === null) {\n        options.escape_formulas = false;\n    } else if (typeof options.escape_formulas !== \"boolean\") {\n        return [\n            new CsvError(\"CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE\", [\n                \"option `escape_formulas` must be a boolean,\",\n                `got ${JSON.stringify(options.escape_formulas)}`\n            ])\n        ];\n    }\n    // Normalize option `quoted_empty`\n    if (options.quoted_empty === undefined || options.quoted_empty === null) {\n        options.quoted_empty = undefined;\n    }\n    // Normalize option `quoted_match`\n    if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {\n        options.quoted_match = null;\n    } else if (!Array.isArray(options.quoted_match)) {\n        options.quoted_match = [\n            options.quoted_match\n        ];\n    }\n    if (options.quoted_match) {\n        for (const quoted_match of options.quoted_match){\n            const isString = typeof quoted_match === \"string\";\n            const isRegExp = quoted_match instanceof RegExp;\n            if (!isString && !isRegExp) {\n                return [\n                    Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)\n                ];\n            }\n        }\n    }\n    // Normalize option `quoted_string`\n    if (options.quoted_string === undefined || options.quoted_string === null) {\n        options.quoted_string = false;\n    }\n    // Normalize option `eof`\n    if (options.eof === undefined || options.eof === null) {\n        options.eof = true;\n    }\n    // Normalize option `escape`\n    if (options.escape === undefined || options.escape === null) {\n        options.escape = '\"';\n    } else if (isBuffer$1(options.escape)) {\n        options.escape = options.escape.toString();\n    } else if (typeof options.escape !== \"string\") {\n        return [\n            Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)\n        ];\n    }\n    if (options.escape.length > 1) {\n        return [\n            Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)\n        ];\n    }\n    // Normalize option `header`\n    if (options.header === undefined || options.header === null) {\n        options.header = false;\n    }\n    // Normalize option `columns`\n    const [errColumns, columns] = normalize_columns(options.columns);\n    if (errColumns !== undefined) return [\n        errColumns\n    ];\n    options.columns = columns;\n    // Normalize option `quoted`\n    if (options.quoted === undefined || options.quoted === null) {\n        options.quoted = false;\n    }\n    // Normalize option `cast`\n    if (options.cast === undefined || options.cast === null) {\n        options.cast = {};\n    }\n    // Normalize option cast.bigint\n    if (options.cast.bigint === undefined || options.cast.bigint === null) {\n        // Cast boolean to string by default\n        options.cast.bigint = (value)=>\"\" + value;\n    }\n    // Normalize option cast.boolean\n    if (options.cast.boolean === undefined || options.cast.boolean === null) {\n        // Cast boolean to string by default\n        options.cast.boolean = (value)=>value ? \"1\" : \"\";\n    }\n    // Normalize option cast.date\n    if (options.cast.date === undefined || options.cast.date === null) {\n        // Cast date to timestamp string by default\n        options.cast.date = (value)=>\"\" + value.getTime();\n    }\n    // Normalize option cast.number\n    if (options.cast.number === undefined || options.cast.number === null) {\n        // Cast number to string using native casting by default\n        options.cast.number = (value)=>\"\" + value;\n    }\n    // Normalize option cast.object\n    if (options.cast.object === undefined || options.cast.object === null) {\n        // Stringify object as JSON by default\n        options.cast.object = (value)=>JSON.stringify(value);\n    }\n    // Normalize option cast.string\n    if (options.cast.string === undefined || options.cast.string === null) {\n        // Leave string untouched\n        options.cast.string = function(value) {\n            return value;\n        };\n    }\n    // Normalize option `on_record`\n    if (options.on_record !== undefined && typeof options.on_record !== \"function\") {\n        return [\n            Error(`Invalid Option: \"on_record\" must be a function.`)\n        ];\n    }\n    // Normalize option `record_delimiter`\n    if (options.record_delimiter === undefined || options.record_delimiter === null) {\n        options.record_delimiter = \"\\n\";\n    } else if (isBuffer$1(options.record_delimiter)) {\n        options.record_delimiter = options.record_delimiter.toString();\n    } else if (typeof options.record_delimiter !== \"string\") {\n        return [\n            Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)\n        ];\n    }\n    switch(options.record_delimiter){\n        case \"unix\":\n            options.record_delimiter = \"\\n\";\n            break;\n        case \"mac\":\n            options.record_delimiter = \"\\r\";\n            break;\n        case \"windows\":\n            options.record_delimiter = \"\\r\\n\";\n            break;\n        case \"ascii\":\n            options.record_delimiter = \"\\x1e\";\n            break;\n        case \"unicode\":\n            options.record_delimiter = \"\\u2028\";\n            break;\n    }\n    return [\n        undefined,\n        options\n    ];\n};\nconst bom_utf8 = Buffer.from([\n    239,\n    187,\n    191\n]);\nconst stringifier = function(options, state, info) {\n    return {\n        options: options,\n        state: state,\n        info: info,\n        __transform: function(chunk, push) {\n            // Chunk validation\n            if (!Array.isArray(chunk) && typeof chunk !== \"object\") {\n                return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);\n            }\n            // Detect columns from the first record\n            if (this.info.records === 0) {\n                if (Array.isArray(chunk)) {\n                    if (this.options.header === true && this.options.columns === undefined) {\n                        return Error(\"Undiscoverable Columns: header option requires column option or object records\");\n                    }\n                } else if (this.options.columns === undefined) {\n                    const [err, columns] = normalize_columns(Object.keys(chunk));\n                    if (err) return;\n                    this.options.columns = columns;\n                }\n            }\n            // Emit the header\n            if (this.info.records === 0) {\n                this.bom(push);\n                const err = this.headers(push);\n                if (err) return err;\n            }\n            // Emit and stringify the record if an object or an array\n            try {\n                // this.emit('record', chunk, this.info.records);\n                if (this.options.on_record) {\n                    this.options.on_record(chunk, this.info.records);\n                }\n            } catch (err) {\n                return err;\n            }\n            // Convert the record into a string\n            let err, chunk_string;\n            if (this.options.eof) {\n                [err, chunk_string] = this.stringify(chunk);\n                if (err) return err;\n                if (chunk_string === undefined) {\n                    return;\n                } else {\n                    chunk_string = chunk_string + this.options.record_delimiter;\n                }\n            } else {\n                [err, chunk_string] = this.stringify(chunk);\n                if (err) return err;\n                if (chunk_string === undefined) {\n                    return;\n                } else {\n                    if (this.options.header || this.info.records) {\n                        chunk_string = this.options.record_delimiter + chunk_string;\n                    }\n                }\n            }\n            // Emit the csv\n            this.info.records++;\n            push(chunk_string);\n        },\n        stringify: function(chunk, chunkIsHeader = false) {\n            if (typeof chunk !== \"object\") {\n                return [\n                    undefined,\n                    chunk\n                ];\n            }\n            const { columns } = this.options;\n            const record = [];\n            // Record is an array\n            if (Array.isArray(chunk)) {\n                // We are getting an array but the user has specified output columns. In\n                // this case, we respect the columns indexes\n                if (columns) {\n                    chunk.splice(columns.length);\n                }\n                // Cast record elements\n                for(let i = 0; i < chunk.length; i++){\n                    const field = chunk[i];\n                    const [err, value] = this.__cast(field, {\n                        index: i,\n                        column: i,\n                        records: this.info.records,\n                        header: chunkIsHeader\n                    });\n                    if (err) return [\n                        err\n                    ];\n                    record[i] = [\n                        value,\n                        field\n                    ];\n                }\n            // Record is a literal object\n            // `columns` is always defined: it is either provided or discovered.\n            } else {\n                for(let i = 0; i < columns.length; i++){\n                    const field = get(chunk, columns[i].key);\n                    const [err, value] = this.__cast(field, {\n                        index: i,\n                        column: columns[i].key,\n                        records: this.info.records,\n                        header: chunkIsHeader\n                    });\n                    if (err) return [\n                        err\n                    ];\n                    record[i] = [\n                        value,\n                        field\n                    ];\n                }\n            }\n            let csvrecord = \"\";\n            for(let i = 0; i < record.length; i++){\n                let options, err;\n                let [value, field] = record[i];\n                if (typeof value === \"string\") {\n                    options = this.options;\n                } else if (is_object(value)) {\n                    options = value;\n                    value = options.value;\n                    delete options.value;\n                    if (typeof value !== \"string\" && value !== undefined && value !== null) {\n                        if (err) return [\n                            Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)\n                        ];\n                    }\n                    options = {\n                        ...this.options,\n                        ...options\n                    };\n                    [err, options] = normalize_options(options);\n                    if (err !== undefined) {\n                        return [\n                            err\n                        ];\n                    }\n                } else if (value === undefined || value === null) {\n                    options = this.options;\n                } else {\n                    return [\n                        Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)\n                    ];\n                }\n                const { delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter, escape_formulas } = options;\n                if (\"\" === value && \"\" === field) {\n                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{\n                        if (typeof quoted_match === \"string\") {\n                            return value.indexOf(quoted_match) !== -1;\n                        } else {\n                            return quoted_match.test(value);\n                        }\n                    });\n                    quotedMatch = quotedMatch && quotedMatch.length > 0;\n                    const shouldQuote = quotedMatch || true === quoted_empty || true === quoted_string && false !== quoted_empty;\n                    if (shouldQuote === true) {\n                        value = quote + value + quote;\n                    }\n                    csvrecord += value;\n                } else if (value) {\n                    if (typeof value !== \"string\") {\n                        return [\n                            Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)\n                        ];\n                    }\n                    const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;\n                    const containsQuote = quote !== \"\" && value.indexOf(quote) >= 0;\n                    const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n                    const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n                    const quotedString = quoted_string && typeof field === \"string\";\n                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{\n                        if (typeof quoted_match === \"string\") {\n                            return value.indexOf(quoted_match) !== -1;\n                        } else {\n                            return quoted_match.test(value);\n                        }\n                    });\n                    quotedMatch = quotedMatch && quotedMatch.length > 0;\n                    // See https://github.com/adaltas/node-csv/pull/387\n                    // More about CSV injection or formula injection, when websites embed\n                    // untrusted input inside CSV files:\n                    // https://owasp.org/www-community/attacks/CSV_Injection\n                    // http://georgemauer.net/2017/10/07/csv-injection.html\n                    // Apple Numbers unicode normalization is empirical from testing\n                    if (escape_formulas) {\n                        switch(value[0]){\n                            case \"=\":\n                            case \"+\":\n                            case \"-\":\n                            case \"@\":\n                            case \"\t\":\n                            case \"\\r\":\n                            case \"＝\":\n                            case \"＋\":\n                            case \"－\":\n                            case \"＠\":\n                                value = `'${value}`;\n                                break;\n                        }\n                    }\n                    const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;\n                    if (shouldQuote === true && containsEscape === true) {\n                        const regexp = escape === \"\\\\\" ? new RegExp(escape + escape, \"g\") : new RegExp(escape, \"g\");\n                        value = value.replace(regexp, escape + escape);\n                    }\n                    if (containsQuote === true) {\n                        const regexp = new RegExp(quote, \"g\");\n                        value = value.replace(regexp, escape + quote);\n                    }\n                    if (shouldQuote === true) {\n                        value = quote + value + quote;\n                    }\n                    csvrecord += value;\n                } else if (quoted_empty === true || field === \"\" && quoted_string === true && quoted_empty !== false) {\n                    csvrecord += quote + quote;\n                }\n                if (i !== record.length - 1) {\n                    csvrecord += delimiter;\n                }\n            }\n            return [\n                undefined,\n                csvrecord\n            ];\n        },\n        bom: function(push) {\n            if (this.options.bom !== true) {\n                return;\n            }\n            push(bom_utf8);\n        },\n        headers: function(push) {\n            if (this.options.header === false) {\n                return;\n            }\n            if (this.options.columns === undefined) {\n                return;\n            }\n            let err;\n            let headers = this.options.columns.map((column)=>column.header);\n            if (this.options.eof) {\n                [err, headers] = this.stringify(headers, true);\n                headers += this.options.record_delimiter;\n            } else {\n                [err, headers] = this.stringify(headers);\n            }\n            if (err) return err;\n            push(headers);\n        },\n        __cast: function(value, context) {\n            const type = typeof value;\n            try {\n                if (type === \"string\") {\n                    // Fine for 99% of the cases\n                    return [\n                        undefined,\n                        this.options.cast.string(value, context)\n                    ];\n                } else if (type === \"bigint\") {\n                    return [\n                        undefined,\n                        this.options.cast.bigint(value, context)\n                    ];\n                } else if (type === \"number\") {\n                    return [\n                        undefined,\n                        this.options.cast.number(value, context)\n                    ];\n                } else if (type === \"boolean\") {\n                    return [\n                        undefined,\n                        this.options.cast.boolean(value, context)\n                    ];\n                } else if (value instanceof Date) {\n                    return [\n                        undefined,\n                        this.options.cast.date(value, context)\n                    ];\n                } else if (type === \"object\" && value !== null) {\n                    return [\n                        undefined,\n                        this.options.cast.object(value, context)\n                    ];\n                } else {\n                    return [\n                        undefined,\n                        value,\n                        value\n                    ];\n                }\n            } catch (err) {\n                return [\n                    err\n                ];\n            }\n        }\n    };\n};\nconst stringify = function(records, opts = {}) {\n    const data = [];\n    const [err, options] = normalize_options(opts);\n    if (err !== undefined) throw err;\n    const state = {\n        stop: false\n    };\n    // Information\n    const info = {\n        records: 0\n    };\n    const api = stringifier(options, state, info);\n    for (const record of records){\n        const err = api.__transform(record, function(record) {\n            data.push(record);\n        });\n        if (err !== undefined) throw err;\n    }\n    if (data.length === 0) {\n        api.bom((d)=>{\n            data.push(d);\n        });\n        const err = api.headers((headers)=>{\n            data.push(headers);\n        });\n        if (err !== undefined) throw err;\n    }\n    return data.join(\"\");\n};\nvar getNative = _getNative;\nvar defineProperty$2 = function() {\n    try {\n        var func = getNative(Object, \"defineProperty\");\n        func({}, \"\", {});\n        return func;\n    } catch (e) {}\n}();\nvar _defineProperty = defineProperty$2;\nvar defineProperty$1 = _defineProperty;\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function baseAssignValue$6(object, key, value) {\n    if (key == \"__proto__\" && defineProperty$1) {\n        defineProperty$1(object, key, {\n            \"configurable\": true,\n            \"enumerable\": true,\n            \"value\": value,\n            \"writable\": true\n        });\n    } else {\n        object[key] = value;\n    }\n}\nvar _baseAssignValue = baseAssignValue$6;\nvar baseAssignValue$5 = _baseAssignValue, baseForOwn$1 = _baseForOwn, baseIteratee$3 = _baseIteratee;\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */ function mapValues(object, iteratee) {\n    var result = {};\n    iteratee = baseIteratee$3(iteratee);\n    baseForOwn$1(object, function(value, key, object) {\n        baseAssignValue$5(result, key, iteratee(value, key, object));\n    });\n    return result;\n}\nvar mapValues_1 = mapValues;\nvar mapValues$1 = /*@__PURE__*/ getDefaultExportFromCjs(mapValues_1);\nvar baseAssignValue$4 = _baseAssignValue, eq$2 = eq_1;\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function assignMergeValue$2(object, key, value) {\n    if (value !== undefined && !eq$2(object[key], value) || value === undefined && !(key in object)) {\n        baseAssignValue$4(object, key, value);\n    }\n}\nvar _assignMergeValue = assignMergeValue$2;\nvar _cloneBuffer = {\n    exports: {}\n};\n_cloneBuffer.exports;\n(function(module, exports1) {\n    var root = _root;\n    /** Detect free variable `exports`. */ var freeExports = exports1 && !exports1.nodeType && exports1;\n    /** Detect free variable `module`. */ var freeModule = freeExports && \"object\" == \"object\" && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n    /**\n\t * Creates a clone of  `buffer`.\n\t *\n\t * @private\n\t * @param {Buffer} buffer The buffer to clone.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Buffer} Returns the cloned buffer.\n\t */ function cloneBuffer(buffer, isDeep) {\n        if (isDeep) {\n            return buffer.slice();\n        }\n        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n        buffer.copy(result);\n        return result;\n    }\n    module.exports = cloneBuffer;\n})(_cloneBuffer, _cloneBuffer.exports);\nvar _cloneBufferExports = _cloneBuffer.exports;\nvar Uint8Array$1 = _Uint8Array;\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */ function cloneArrayBuffer$1(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));\n    return result;\n}\nvar _cloneArrayBuffer = cloneArrayBuffer$1;\nvar cloneArrayBuffer = _cloneArrayBuffer;\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */ function cloneTypedArray$1(typedArray, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\nvar _cloneTypedArray = cloneTypedArray$1;\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */ function copyArray$1(source, array) {\n    var index = -1, length = source.length;\n    array || (array = Array(length));\n    while(++index < length){\n        array[index] = source[index];\n    }\n    return array;\n}\nvar _copyArray = copyArray$1;\nvar isObject$4 = isObject_1;\n/** Built-in value references. */ var objectCreate = Object.create;\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */ var baseCreate$1 = function() {\n    function object() {}\n    return function(proto) {\n        if (!isObject$4(proto)) {\n            return {};\n        }\n        if (objectCreate) {\n            return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n    };\n}();\nvar _baseCreate = baseCreate$1;\nvar overArg = _overArg;\n/** Built-in value references. */ var getPrototype$2 = overArg(Object.getPrototypeOf, Object);\nvar _getPrototype = getPrototype$2;\nvar baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype$1 = _isPrototype;\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */ function initCloneObject$1(object) {\n    return typeof object.constructor == \"function\" && !isPrototype$1(object) ? baseCreate(getPrototype$1(object)) : {};\n}\nvar _initCloneObject = initCloneObject$1;\nvar isArrayLike$3 = isArrayLike_1, isObjectLike$1 = isObjectLike_1;\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */ function isArrayLikeObject$1(value) {\n    return isObjectLike$1(value) && isArrayLike$3(value);\n}\nvar isArrayLikeObject_1 = isArrayLikeObject$1;\nvar baseGetTag = _baseGetTag, getPrototype = _getPrototype, isObjectLike = isObjectLike_1;\n/** `Object#toString` result references. */ var objectTag = \"[object Object]\";\n/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto$2 = Object.prototype;\n/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n/** Used to check objects for own properties. */ var hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n/** Used to infer the `Object` constructor. */ var objectCtorString = funcToString.call(Object);\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */ function isPlainObject$1(value) {\n    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n    }\n    var proto = getPrototype(value);\n    if (proto === null) {\n        return true;\n    }\n    var Ctor = hasOwnProperty$2.call(proto, \"constructor\") && proto.constructor;\n    return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n}\nvar isPlainObject_1 = isPlainObject$1;\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */ function safeGet$2(object, key) {\n    if (key === \"constructor\" && typeof object[key] === \"function\") {\n        return;\n    }\n    if (key == \"__proto__\") {\n        return;\n    }\n    return object[key];\n}\nvar _safeGet = safeGet$2;\nvar baseAssignValue$3 = _baseAssignValue, eq$1 = eq_1;\n/** Used for built-in method references. */ var objectProto$1 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function assignValue$1(object, key, value) {\n    var objValue = object[key];\n    if (!(hasOwnProperty$1.call(object, key) && eq$1(objValue, value)) || value === undefined && !(key in object)) {\n        baseAssignValue$3(object, key, value);\n    }\n}\nvar _assignValue = assignValue$1;\nvar assignValue = _assignValue, baseAssignValue$2 = _baseAssignValue;\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */ function copyObject$1(source, props, object, customizer) {\n    var isNew = !object;\n    object || (object = {});\n    var index = -1, length = props.length;\n    while(++index < length){\n        var key = props[index];\n        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;\n        if (newValue === undefined) {\n            newValue = source[key];\n        }\n        if (isNew) {\n            baseAssignValue$2(object, key, newValue);\n        } else {\n            assignValue(object, key, newValue);\n        }\n    }\n    return object;\n}\nvar _copyObject = copyObject$1;\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function nativeKeysIn$1(object) {\n    var result = [];\n    if (object != null) {\n        for(var key in Object(object)){\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _nativeKeysIn = nativeKeysIn$1;\nvar isObject$3 = isObject_1, isPrototype = _isPrototype, nativeKeysIn = _nativeKeysIn;\n/** Used for built-in method references. */ var objectProto = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function baseKeysIn$1(object) {\n    if (!isObject$3(object)) {\n        return nativeKeysIn(object);\n    }\n    var isProto = isPrototype(object), result = [];\n    for(var key in object){\n        if (!(key == \"constructor\" && (isProto || !hasOwnProperty.call(object, key)))) {\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _baseKeysIn = baseKeysIn$1;\nvar arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$2 = isArrayLike_1;\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */ function keysIn$2(object) {\n    return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\nvar keysIn_1 = keysIn$2;\nvar copyObject = _copyObject, keysIn$1 = keysIn_1;\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */ function toPlainObject$1(value) {\n    return copyObject(value, keysIn$1(value));\n}\nvar toPlainObject_1 = toPlainObject$1;\nvar assignMergeValue$1 = _assignMergeValue, cloneBuffer = _cloneBufferExports, cloneTypedArray = _cloneTypedArray, copyArray = _copyArray, initCloneObject = _initCloneObject, isArguments$1 = isArguments_1, isArray$3 = isArray_1, isArrayLikeObject = isArrayLikeObject_1, isBuffer = isBufferExports, isFunction = isFunction_1, isObject$2 = isObject_1, isPlainObject = isPlainObject_1, isTypedArray = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */ function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n    var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);\n    if (stacked) {\n        assignMergeValue$1(object, key, stacked);\n        return;\n    }\n    var newValue = customizer ? customizer(objValue, srcValue, key + \"\", object, source, stack) : undefined;\n    var isCommon = newValue === undefined;\n    if (isCommon) {\n        var isArr = isArray$3(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n            if (isArray$3(objValue)) {\n                newValue = objValue;\n            } else if (isArrayLikeObject(objValue)) {\n                newValue = copyArray(objValue);\n            } else if (isBuff) {\n                isCommon = false;\n                newValue = cloneBuffer(srcValue, true);\n            } else if (isTyped) {\n                isCommon = false;\n                newValue = cloneTypedArray(srcValue, true);\n            } else {\n                newValue = [];\n            }\n        } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {\n            newValue = objValue;\n            if (isArguments$1(objValue)) {\n                newValue = toPlainObject(objValue);\n            } else if (!isObject$2(objValue) || isFunction(objValue)) {\n                newValue = initCloneObject(srcValue);\n            }\n        } else {\n            isCommon = false;\n        }\n    }\n    if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack[\"delete\"](srcValue);\n    }\n    assignMergeValue$1(object, key, newValue);\n}\nvar _baseMergeDeep = baseMergeDeep$1;\nvar Stack = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$1 = isObject_1, keysIn = keysIn_1, safeGet = _safeGet;\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */ function baseMerge$2(object, source, srcIndex, customizer, stack) {\n    if (object === source) {\n        return;\n    }\n    baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject$1(srcValue)) {\n            baseMergeDeep(object, source, key, srcIndex, baseMerge$2, customizer, stack);\n        } else {\n            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + \"\", object, source, stack) : undefined;\n            if (newValue === undefined) {\n                newValue = srcValue;\n            }\n            assignMergeValue(object, key, newValue);\n        }\n    }, keysIn);\n}\nvar _baseMerge = baseMerge$2;\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */ function apply$1(func, thisArg, args) {\n    switch(args.length){\n        case 0:\n            return func.call(thisArg);\n        case 1:\n            return func.call(thisArg, args[0]);\n        case 2:\n            return func.call(thisArg, args[0], args[1]);\n        case 3:\n            return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n}\nvar _apply = apply$1;\nvar apply = _apply;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */ function overRest$1(func, start, transform) {\n    start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n    return function() {\n        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);\n        while(++index < length){\n            array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while(++index < start){\n            otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n    };\n}\nvar _overRest = overRest$1;\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */ function constant$1(value) {\n    return function() {\n        return value;\n    };\n}\nvar constant_1 = constant$1;\nvar constant = constant_1, defineProperty = _defineProperty, identity$2 = identity_1;\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */ var baseSetToString$1 = !defineProperty ? identity$2 : function(func, string) {\n    return defineProperty(func, \"toString\", {\n        \"configurable\": true,\n        \"enumerable\": false,\n        \"value\": constant(string),\n        \"writable\": true\n    });\n};\nvar _baseSetToString = baseSetToString$1;\n/** Used to detect hot functions by number of calls within a span of milliseconds. */ var HOT_COUNT = 800, HOT_SPAN = 16;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeNow = Date.now;\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */ function shortOut$1(func) {\n    var count = 0, lastCalled = 0;\n    return function() {\n        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n        lastCalled = stamp;\n        if (remaining > 0) {\n            if (++count >= HOT_COUNT) {\n                return arguments[0];\n            }\n        } else {\n            count = 0;\n        }\n        return func.apply(undefined, arguments);\n    };\n}\nvar _shortOut = shortOut$1;\nvar baseSetToString = _baseSetToString, shortOut = _shortOut;\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */ var setToString$1 = shortOut(baseSetToString);\nvar _setToString = setToString$1;\nvar identity$1 = identity_1, overRest = _overRest, setToString = _setToString;\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */ function baseRest$2(func, start) {\n    return setToString(overRest(func, start, identity$1), func + \"\");\n}\nvar _baseRest = baseRest$2;\nvar eq = eq_1, isArrayLike$1 = isArrayLike_1, isIndex = _isIndex, isObject = isObject_1;\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */ function isIterateeCall$2(value, index, object) {\n    if (!isObject(object)) {\n        return false;\n    }\n    var type = typeof index;\n    if (type == \"number\" ? isArrayLike$1(object) && isIndex(index, object.length) : type == \"string\" && index in object) {\n        return eq(object[index], value);\n    }\n    return false;\n}\nvar _isIterateeCall = isIterateeCall$2;\nvar baseRest$1 = _baseRest, isIterateeCall$1 = _isIterateeCall;\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */ function createAssigner$2(assigner) {\n    return baseRest$1(function(object, sources) {\n        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;\n        customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : undefined;\n        if (guard && isIterateeCall$1(sources[0], sources[1], guard)) {\n            customizer = length < 3 ? undefined : customizer;\n            length = 1;\n        }\n        object = Object(object);\n        while(++index < length){\n            var source = sources[index];\n            if (source) {\n                assigner(object, source, index, customizer);\n            }\n        }\n        return object;\n    });\n}\nvar _createAssigner = createAssigner$2;\nvar baseMerge$1 = _baseMerge, createAssigner$1 = _createAssigner;\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */ var merge = createAssigner$1(function(object, source, srcIndex) {\n    baseMerge$1(object, source, srcIndex);\n});\nvar merge_1 = merge;\nvar merge$1 = /*@__PURE__*/ getDefaultExportFromCjs(merge_1);\nvar baseMerge = _baseMerge, createAssigner = _createAssigner;\n/**\n * This method is like `_.merge` except that it accepts `customizer` which\n * is invoked to produce the merged values of the destination and source\n * properties. If `customizer` returns `undefined`, merging is handled by the\n * method instead. The `customizer` is invoked with six arguments:\n * (objValue, srcValue, key, object, source, stack).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   if (_.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * }\n *\n * var object = { 'a': [1], 'b': [2] };\n * var other = { 'a': [3], 'b': [4] };\n *\n * _.mergeWith(object, other, customizer);\n * // => { 'a': [1, 3], 'b': [2, 4] }\n */ var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n    baseMerge(object, source, srcIndex, customizer);\n});\nvar mergeWith_1 = mergeWith;\nvar mergeWith$1 = /*@__PURE__*/ getDefaultExportFromCjs(mergeWith_1);\nvar baseAssignValue$1 = _baseAssignValue, baseForOwn = _baseForOwn, baseIteratee$2 = _baseIteratee;\n/**\n * The opposite of `_.mapValues`; this method creates an object with the\n * same values as `object` and keys generated by running each own enumerable\n * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n * with three arguments: (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 3.8.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapValues\n * @example\n *\n * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n *   return key + value;\n * });\n * // => { 'a1': 1, 'b2': 2 }\n */ function mapKeys(object, iteratee) {\n    var result = {};\n    iteratee = baseIteratee$2(iteratee);\n    baseForOwn(object, function(value, key, object) {\n        baseAssignValue$1(result, iteratee(value, key, object), value);\n    });\n    return result;\n}\nvar mapKeys_1 = mapKeys;\nvar mapKeys$1 = /*@__PURE__*/ getDefaultExportFromCjs(mapKeys_1);\n/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */ function basePropertyOf$1(object) {\n    return function(key) {\n        return object == null ? undefined : object[key];\n    };\n}\nvar _basePropertyOf = basePropertyOf$1;\nvar basePropertyOf = _basePropertyOf;\n/** Used to map Latin Unicode letters to basic Latin letters. */ var deburredLetters = {\n    // Latin-1 Supplement block.\n    \"\\xc0\": \"A\",\n    \"\\xc1\": \"A\",\n    \"\\xc2\": \"A\",\n    \"\\xc3\": \"A\",\n    \"\\xc4\": \"A\",\n    \"\\xc5\": \"A\",\n    \"\\xe0\": \"a\",\n    \"\\xe1\": \"a\",\n    \"\\xe2\": \"a\",\n    \"\\xe3\": \"a\",\n    \"\\xe4\": \"a\",\n    \"\\xe5\": \"a\",\n    \"\\xc7\": \"C\",\n    \"\\xe7\": \"c\",\n    \"\\xd0\": \"D\",\n    \"\\xf0\": \"d\",\n    \"\\xc8\": \"E\",\n    \"\\xc9\": \"E\",\n    \"\\xca\": \"E\",\n    \"\\xcb\": \"E\",\n    \"\\xe8\": \"e\",\n    \"\\xe9\": \"e\",\n    \"\\xea\": \"e\",\n    \"\\xeb\": \"e\",\n    \"\\xcc\": \"I\",\n    \"\\xcd\": \"I\",\n    \"\\xce\": \"I\",\n    \"\\xcf\": \"I\",\n    \"\\xec\": \"i\",\n    \"\\xed\": \"i\",\n    \"\\xee\": \"i\",\n    \"\\xef\": \"i\",\n    \"\\xd1\": \"N\",\n    \"\\xf1\": \"n\",\n    \"\\xd2\": \"O\",\n    \"\\xd3\": \"O\",\n    \"\\xd4\": \"O\",\n    \"\\xd5\": \"O\",\n    \"\\xd6\": \"O\",\n    \"\\xd8\": \"O\",\n    \"\\xf2\": \"o\",\n    \"\\xf3\": \"o\",\n    \"\\xf4\": \"o\",\n    \"\\xf5\": \"o\",\n    \"\\xf6\": \"o\",\n    \"\\xf8\": \"o\",\n    \"\\xd9\": \"U\",\n    \"\\xda\": \"U\",\n    \"\\xdb\": \"U\",\n    \"\\xdc\": \"U\",\n    \"\\xf9\": \"u\",\n    \"\\xfa\": \"u\",\n    \"\\xfb\": \"u\",\n    \"\\xfc\": \"u\",\n    \"\\xdd\": \"Y\",\n    \"\\xfd\": \"y\",\n    \"\\xff\": \"y\",\n    \"\\xc6\": \"Ae\",\n    \"\\xe6\": \"ae\",\n    \"\\xde\": \"Th\",\n    \"\\xfe\": \"th\",\n    \"\\xdf\": \"ss\",\n    // Latin Extended-A block.\n    \"Ā\": \"A\",\n    \"Ă\": \"A\",\n    \"Ą\": \"A\",\n    \"ā\": \"a\",\n    \"ă\": \"a\",\n    \"ą\": \"a\",\n    \"Ć\": \"C\",\n    \"Ĉ\": \"C\",\n    \"Ċ\": \"C\",\n    \"Č\": \"C\",\n    \"ć\": \"c\",\n    \"ĉ\": \"c\",\n    \"ċ\": \"c\",\n    \"č\": \"c\",\n    \"Ď\": \"D\",\n    \"Đ\": \"D\",\n    \"ď\": \"d\",\n    \"đ\": \"d\",\n    \"Ē\": \"E\",\n    \"Ĕ\": \"E\",\n    \"Ė\": \"E\",\n    \"Ę\": \"E\",\n    \"Ě\": \"E\",\n    \"ē\": \"e\",\n    \"ĕ\": \"e\",\n    \"ė\": \"e\",\n    \"ę\": \"e\",\n    \"ě\": \"e\",\n    \"Ĝ\": \"G\",\n    \"Ğ\": \"G\",\n    \"Ġ\": \"G\",\n    \"Ģ\": \"G\",\n    \"ĝ\": \"g\",\n    \"ğ\": \"g\",\n    \"ġ\": \"g\",\n    \"ģ\": \"g\",\n    \"Ĥ\": \"H\",\n    \"Ħ\": \"H\",\n    \"ĥ\": \"h\",\n    \"ħ\": \"h\",\n    \"Ĩ\": \"I\",\n    \"Ī\": \"I\",\n    \"Ĭ\": \"I\",\n    \"Į\": \"I\",\n    \"İ\": \"I\",\n    \"ĩ\": \"i\",\n    \"ī\": \"i\",\n    \"ĭ\": \"i\",\n    \"į\": \"i\",\n    \"ı\": \"i\",\n    \"Ĵ\": \"J\",\n    \"ĵ\": \"j\",\n    \"Ķ\": \"K\",\n    \"ķ\": \"k\",\n    \"ĸ\": \"k\",\n    \"Ĺ\": \"L\",\n    \"Ļ\": \"L\",\n    \"Ľ\": \"L\",\n    \"Ŀ\": \"L\",\n    \"Ł\": \"L\",\n    \"ĺ\": \"l\",\n    \"ļ\": \"l\",\n    \"ľ\": \"l\",\n    \"ŀ\": \"l\",\n    \"ł\": \"l\",\n    \"Ń\": \"N\",\n    \"Ņ\": \"N\",\n    \"Ň\": \"N\",\n    \"Ŋ\": \"N\",\n    \"ń\": \"n\",\n    \"ņ\": \"n\",\n    \"ň\": \"n\",\n    \"ŋ\": \"n\",\n    \"Ō\": \"O\",\n    \"Ŏ\": \"O\",\n    \"Ő\": \"O\",\n    \"ō\": \"o\",\n    \"ŏ\": \"o\",\n    \"ő\": \"o\",\n    \"Ŕ\": \"R\",\n    \"Ŗ\": \"R\",\n    \"Ř\": \"R\",\n    \"ŕ\": \"r\",\n    \"ŗ\": \"r\",\n    \"ř\": \"r\",\n    \"Ś\": \"S\",\n    \"Ŝ\": \"S\",\n    \"Ş\": \"S\",\n    \"Š\": \"S\",\n    \"ś\": \"s\",\n    \"ŝ\": \"s\",\n    \"ş\": \"s\",\n    \"š\": \"s\",\n    \"Ţ\": \"T\",\n    \"Ť\": \"T\",\n    \"Ŧ\": \"T\",\n    \"ţ\": \"t\",\n    \"ť\": \"t\",\n    \"ŧ\": \"t\",\n    \"Ũ\": \"U\",\n    \"Ū\": \"U\",\n    \"Ŭ\": \"U\",\n    \"Ů\": \"U\",\n    \"Ű\": \"U\",\n    \"Ų\": \"U\",\n    \"ũ\": \"u\",\n    \"ū\": \"u\",\n    \"ŭ\": \"u\",\n    \"ů\": \"u\",\n    \"ű\": \"u\",\n    \"ų\": \"u\",\n    \"Ŵ\": \"W\",\n    \"ŵ\": \"w\",\n    \"Ŷ\": \"Y\",\n    \"ŷ\": \"y\",\n    \"Ÿ\": \"Y\",\n    \"Ź\": \"Z\",\n    \"Ż\": \"Z\",\n    \"Ž\": \"Z\",\n    \"ź\": \"z\",\n    \"ż\": \"z\",\n    \"ž\": \"z\",\n    \"Ĳ\": \"IJ\",\n    \"ĳ\": \"ij\",\n    \"Œ\": \"Oe\",\n    \"œ\": \"oe\",\n    \"ŉ\": \"'n\",\n    \"ſ\": \"s\"\n};\n/**\n * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n * letters to basic Latin letters.\n *\n * @private\n * @param {string} letter The matched letter to deburr.\n * @returns {string} Returns the deburred letter.\n */ var deburrLetter$1 = basePropertyOf(deburredLetters);\nvar _deburrLetter = deburrLetter$1;\nvar deburrLetter = _deburrLetter, toString$2 = toString_1;\n/** Used to match Latin Unicode letters (excluding mathematical operators). */ var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n/** Used to compose unicode character classes. */ var rsComboMarksRange$3 = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange$3 = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange$3 = \"\\\\u20d0-\\\\u20ff\", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;\n/** Used to compose unicode capture groups. */ var rsCombo$2 = \"[\" + rsComboRange$3 + \"]\";\n/**\n * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n */ var reComboMark = RegExp(rsCombo$2, \"g\");\n/**\n * Deburrs `string` by converting\n * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n * letters to basic Latin letters and removing\n * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to deburr.\n * @returns {string} Returns the deburred string.\n * @example\n *\n * _.deburr('déjà vu');\n * // => 'deja vu'\n */ function deburr$1(string) {\n    string = toString$2(string);\n    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, \"\");\n}\nvar deburr_1 = deburr$1;\n/** Used to match words composed of alphanumeric characters. */ var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n/**\n * Splits an ASCII `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */ function asciiWords$1(string) {\n    return string.match(reAsciiWord) || [];\n}\nvar _asciiWords = asciiWords$1;\n/** Used to detect strings that need a more robust regexp to match words. */ var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n/**\n * Checks if `string` contains a word composed of Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a word is found, else `false`.\n */ function hasUnicodeWord$1(string) {\n    return reHasUnicodeWord.test(string);\n}\nvar _hasUnicodeWord = hasUnicodeWord$1;\n/** Used to compose unicode character classes. */ var rsAstralRange$2 = \"\\ud800-\\udfff\", rsComboMarksRange$2 = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange$2 = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange$2 = \"\\\\u20d0-\\\\u20ff\", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsDingbatRange = \"\\\\u2700-\\\\u27bf\", rsLowerRange = \"a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff\", rsMathOpRange = \"\\\\xac\\\\xb1\\\\xd7\\\\xf7\", rsNonCharRange = \"\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\", rsPunctuationRange = \"\\\\u2000-\\\\u206f\", rsSpaceRange = \" \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\", rsUpperRange = \"A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\", rsVarRange$2 = \"\\\\ufe0e\\\\ufe0f\", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n/** Used to compose unicode capture groups. */ var rsApos$1 = \"['’]\", rsBreak = \"[\" + rsBreakRange + \"]\", rsCombo$1 = \"[\" + rsComboRange$2 + \"]\", rsDigits = \"\\\\d+\", rsDingbat = \"[\" + rsDingbatRange + \"]\", rsLower = \"[\" + rsLowerRange + \"]\", rsMisc = \"[^\" + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + \"]\", rsFitz$1 = \"\\ud83c[\\udffb-\\udfff]\", rsModifier$1 = \"(?:\" + rsCombo$1 + \"|\" + rsFitz$1 + \")\", rsNonAstral$1 = \"[^\" + rsAstralRange$2 + \"]\", rsRegional$1 = \"(?:\\ud83c[\\udde6-\\uddff]){2}\", rsSurrPair$1 = \"[\\ud800-\\udbff][\\udc00-\\udfff]\", rsUpper = \"[\" + rsUpperRange + \"]\", rsZWJ$2 = \"\\\\u200d\";\n/** Used to compose unicode regexes. */ var rsMiscLower = \"(?:\" + rsLower + \"|\" + rsMisc + \")\", rsMiscUpper = \"(?:\" + rsUpper + \"|\" + rsMisc + \")\", rsOptContrLower = \"(?:\" + rsApos$1 + \"(?:d|ll|m|re|s|t|ve))?\", rsOptContrUpper = \"(?:\" + rsApos$1 + \"(?:D|LL|M|RE|S|T|VE))?\", reOptMod$1 = rsModifier$1 + \"?\", rsOptVar$1 = \"[\" + rsVarRange$2 + \"]?\", rsOptJoin$1 = \"(?:\" + rsZWJ$2 + \"(?:\" + [\n    rsNonAstral$1,\n    rsRegional$1,\n    rsSurrPair$1\n].join(\"|\") + \")\" + rsOptVar$1 + reOptMod$1 + \")*\", rsOrdLower = \"\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])\", rsOrdUpper = \"\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])\", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsEmoji = \"(?:\" + [\n    rsDingbat,\n    rsRegional$1,\n    rsSurrPair$1\n].join(\"|\") + \")\" + rsSeq$1;\n/** Used to match complex or compound words. */ var reUnicodeWord = RegExp([\n    rsUpper + \"?\" + rsLower + \"+\" + rsOptContrLower + \"(?=\" + [\n        rsBreak,\n        rsUpper,\n        \"$\"\n    ].join(\"|\") + \")\",\n    rsMiscUpper + \"+\" + rsOptContrUpper + \"(?=\" + [\n        rsBreak,\n        rsUpper + rsMiscLower,\n        \"$\"\n    ].join(\"|\") + \")\",\n    rsUpper + \"?\" + rsMiscLower + \"+\" + rsOptContrLower,\n    rsUpper + \"+\" + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n].join(\"|\"), \"g\");\n/**\n * Splits a Unicode `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */ function unicodeWords$1(string) {\n    return string.match(reUnicodeWord) || [];\n}\nvar _unicodeWords = unicodeWords$1;\nvar asciiWords = _asciiWords, hasUnicodeWord = _hasUnicodeWord, toString$1 = toString_1, unicodeWords = _unicodeWords;\n/**\n * Splits `string` into an array of its words.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {RegExp|string} [pattern] The pattern to match words.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the words of `string`.\n * @example\n *\n * _.words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * _.words('fred, barney, & pebbles', /[^, ]+/g);\n * // => ['fred', 'barney', '&', 'pebbles']\n */ function words$1(string, pattern, guard) {\n    string = toString$1(string);\n    pattern = guard ? undefined : pattern;\n    if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n    }\n    return string.match(pattern) || [];\n}\nvar words_1 = words$1;\nvar arrayReduce = _arrayReduce, deburr = deburr_1, words = words_1;\n/** Used to compose unicode capture groups. */ var rsApos = \"['’]\";\n/** Used to match apostrophes. */ var reApos = RegExp(rsApos, \"g\");\n/**\n * Creates a function like `_.camelCase`.\n *\n * @private\n * @param {Function} callback The function to combine each word.\n * @returns {Function} Returns the new compounder function.\n */ function createCompounder$1(callback) {\n    return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, \"\")), callback, \"\");\n    };\n}\nvar _createCompounder = createCompounder$1;\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */ function baseSlice$1(array, start, end) {\n    var index = -1, length = array.length;\n    if (start < 0) {\n        start = -start > length ? 0 : length + start;\n    }\n    end = end > length ? length : end;\n    if (end < 0) {\n        end += length;\n    }\n    length = start > end ? 0 : end - start >>> 0;\n    start >>>= 0;\n    var result = Array(length);\n    while(++index < length){\n        result[index] = array[index + start];\n    }\n    return result;\n}\nvar _baseSlice = baseSlice$1;\nvar baseSlice = _baseSlice;\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */ function castSlice$1(array, start, end) {\n    var length = array.length;\n    end = end === undefined ? length : end;\n    return !start && end >= length ? array : baseSlice(array, start, end);\n}\nvar _castSlice = castSlice$1;\n/** Used to compose unicode character classes. */ var rsAstralRange$1 = \"\\ud800-\\udfff\", rsComboMarksRange$1 = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange$1 = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange$1 = \"\\\\u20d0-\\\\u20ff\", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */ var rsZWJ$1 = \"\\\\u200d\";\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */ var reHasUnicode = RegExp(\"[\" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + \"]\");\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */ function hasUnicode$2(string) {\n    return reHasUnicode.test(string);\n}\nvar _hasUnicode = hasUnicode$2;\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function asciiToArray$1(string) {\n    return string.split(\"\");\n}\nvar _asciiToArray = asciiToArray$1;\n/** Used to compose unicode character classes. */ var rsAstralRange = \"\\ud800-\\udfff\", rsComboMarksRange = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */ var rsAstral = \"[\" + rsAstralRange + \"]\", rsCombo = \"[\" + rsComboRange + \"]\", rsFitz = \"\\ud83c[\\udffb-\\udfff]\", rsModifier = \"(?:\" + rsCombo + \"|\" + rsFitz + \")\", rsNonAstral = \"[^\" + rsAstralRange + \"]\", rsRegional = \"(?:\\ud83c[\\udde6-\\uddff]){2}\", rsSurrPair = \"[\\ud800-\\udbff][\\udc00-\\udfff]\", rsZWJ = \"\\\\u200d\";\n/** Used to compose unicode regexes. */ var reOptMod = rsModifier + \"?\", rsOptVar = \"[\" + rsVarRange + \"]?\", rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [\n    rsNonAstral,\n    rsRegional,\n    rsSurrPair\n].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = \"(?:\" + [\n    rsNonAstral + rsCombo + \"?\",\n    rsCombo,\n    rsRegional,\n    rsSurrPair,\n    rsAstral\n].join(\"|\") + \")\";\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */ var reUnicode = RegExp(rsFitz + \"(?=\" + rsFitz + \")|\" + rsSymbol + rsSeq, \"g\");\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function unicodeToArray$1(string) {\n    return string.match(reUnicode) || [];\n}\nvar _unicodeToArray = unicodeToArray$1;\nvar asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function stringToArray$1(string) {\n    return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);\n}\nvar _stringToArray = stringToArray$1;\nvar castSlice = _castSlice, hasUnicode = _hasUnicode, stringToArray = _stringToArray, toString = toString_1;\n/**\n * Creates a function like `_.lowerFirst`.\n *\n * @private\n * @param {string} methodName The name of the `String` case method to use.\n * @returns {Function} Returns the new case function.\n */ function createCaseFirst$1(methodName) {\n    return function(string) {\n        string = toString(string);\n        var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;\n        var chr = strSymbols ? strSymbols[0] : string.charAt(0);\n        var trailing = strSymbols ? castSlice(strSymbols, 1).join(\"\") : string.slice(1);\n        return chr[methodName]() + trailing;\n    };\n}\nvar _createCaseFirst = createCaseFirst$1;\nvar createCaseFirst = _createCaseFirst;\n/**\n * Converts the first character of `string` to upper case.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.upperFirst('fred');\n * // => 'Fred'\n *\n * _.upperFirst('FRED');\n * // => 'FRED'\n */ var upperFirst$1 = createCaseFirst(\"toUpperCase\");\nvar upperFirst_1 = upperFirst$1;\nvar createCompounder = _createCompounder, upperFirst = upperFirst_1;\n/**\n * Converts `string` to\n * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n *\n * @static\n * @memberOf _\n * @since 3.1.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the start cased string.\n * @example\n *\n * _.startCase('--foo-bar--');\n * // => 'Foo Bar'\n *\n * _.startCase('fooBar');\n * // => 'Foo Bar'\n *\n * _.startCase('__FOO_BAR__');\n * // => 'FOO BAR'\n */ var startCase = createCompounder(function(result, word, index) {\n    return result + (index ? \" \" : \"\") + upperFirst(word);\n});\nvar startCase_1 = startCase;\nvar startCase$1 = /*@__PURE__*/ getDefaultExportFromCjs(startCase_1);\nvar Symbol$1 = _Symbol, isArguments = isArguments_1, isArray$2 = isArray_1;\n/** Built-in value references. */ var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */ function isFlattenable$1(value) {\n    return isArray$2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\nvar _isFlattenable = isFlattenable$1;\nvar arrayPush = _arrayPush, isFlattenable = _isFlattenable;\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */ function baseFlatten$1(array, depth, predicate, isStrict, result) {\n    var index = -1, length = array.length;\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n    while(++index < length){\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n            if (depth > 1) {\n                // Recursively flatten arrays (susceptible to call stack limits).\n                baseFlatten$1(value, depth - 1, predicate, isStrict, result);\n            } else {\n                arrayPush(result, value);\n            }\n        } else if (!isStrict) {\n            result[result.length] = value;\n        }\n    }\n    return result;\n}\nvar _baseFlatten = baseFlatten$1;\nvar baseEach$1 = _baseEach, isArrayLike = isArrayLike_1;\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */ function baseMap$1(collection, iteratee) {\n    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];\n    baseEach$1(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n    });\n    return result;\n}\nvar _baseMap = baseMap$1;\n/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */ function baseSortBy$1(array, comparer) {\n    var length = array.length;\n    array.sort(comparer);\n    while(length--){\n        array[length] = array[length].value;\n    }\n    return array;\n}\nvar _baseSortBy = baseSortBy$1;\nvar isSymbol = isSymbol_1;\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */ function compareAscending$1(value, other) {\n    if (value !== other) {\n        var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);\n        var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);\n        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\n            return 1;\n        }\n        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\n            return -1;\n        }\n    }\n    return 0;\n}\nvar _compareAscending = compareAscending$1;\nvar compareAscending = _compareAscending;\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */ function compareMultiple$1(object, other, orders) {\n    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;\n    while(++index < length){\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n            if (index >= ordersLength) {\n                return result;\n            }\n            var order = orders[index];\n            return result * (order == \"desc\" ? -1 : 1);\n        }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value for\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    // for more details.\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n    return object.index - other.index;\n}\nvar _compareMultiple = compareMultiple$1;\nvar arrayMap = _arrayMap, baseGet = _baseGet, baseIteratee$1 = _baseIteratee, baseMap = _baseMap, baseSortBy = _baseSortBy, baseUnary = _baseUnary, compareMultiple = _compareMultiple, identity = identity_1, isArray$1 = isArray_1;\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */ function baseOrderBy$1(collection, iteratees, orders) {\n    if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n            if (isArray$1(iteratee)) {\n                return function(value) {\n                    return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n                };\n            }\n            return iteratee;\n        });\n    } else {\n        iteratees = [\n            identity\n        ];\n    }\n    var index = -1;\n    iteratees = arrayMap(iteratees, baseUnary(baseIteratee$1));\n    var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n            return iteratee(value);\n        });\n        return {\n            \"criteria\": criteria,\n            \"index\": ++index,\n            \"value\": value\n        };\n    });\n    return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n    });\n}\nvar _baseOrderBy = baseOrderBy$1;\nvar baseFlatten = _baseFlatten, baseOrderBy = _baseOrderBy, baseRest = _baseRest, isIterateeCall = _isIterateeCall;\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 30 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n */ var sortBy = baseRest(function(collection, iteratees) {\n    if (collection == null) {\n        return [];\n    }\n    var length = iteratees.length;\n    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [\n            iteratees[0]\n        ];\n    }\n    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\nvar sortBy_1 = sortBy;\nvar sortBy$1 = /*@__PURE__*/ getDefaultExportFromCjs(sortBy_1);\nvar baseIsEqual = _baseIsEqual;\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */ function isEqual(value, other) {\n    return baseIsEqual(value, other);\n}\nvar isEqual_1 = isEqual;\nvar isEqual$1 = /*@__PURE__*/ getDefaultExportFromCjs(isEqual_1);\n/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */ function arrayAggregator$1(array, setter, iteratee, accumulator) {\n    var index = -1, length = array == null ? 0 : array.length;\n    while(++index < length){\n        var value = array[index];\n        setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n}\nvar _arrayAggregator = arrayAggregator$1;\nvar baseEach = _baseEach;\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */ function baseAggregator$1(collection, setter, iteratee, accumulator) {\n    baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n    });\n    return accumulator;\n}\nvar _baseAggregator = baseAggregator$1;\nvar arrayAggregator = _arrayAggregator, baseAggregator = _baseAggregator, baseIteratee = _baseIteratee, isArray = isArray_1;\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */ function createAggregator$1(setter, initializer) {\n    return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};\n        return func(collection, setter, baseIteratee(iteratee), accumulator);\n    };\n}\nvar _createAggregator = createAggregator$1;\nvar baseAssignValue = _baseAssignValue, createAggregator = _createAggregator;\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The corresponding value of\n * each key is the last element responsible for generating the key. The\n * iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * var array = [\n *   { 'dir': 'left', 'code': 97 },\n *   { 'dir': 'right', 'code': 100 }\n * ];\n *\n * _.keyBy(array, function(o) {\n *   return String.fromCharCode(o.code);\n * });\n * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n *\n * _.keyBy(array, 'dir');\n * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n */ var keyBy = createAggregator(function(result, value, key) {\n    baseAssignValue(result, key, value);\n});\nvar keyBy_1 = keyBy;\nvar keyBy$1 = /*@__PURE__*/ getDefaultExportFromCjs(keyBy_1);\nconst e = Math.exp(1);\nconst EMAIL_REGEX = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/;\n/**\n * Detects if the current environment is the browser\n *\n * @returns `true` or `false`\n */ const isBrowser = ()=>!!( false && 0);\n/**\n * Merges classNames objects together, key by key\n *\n * @returns a classNames object\n */ const mergeClassNamesDeep = ({ classNames1 = {}, classNames2 = {} })=>{\n    const newClassNames = {};\n    const keys = [\n        ...Object.keys(classNames1 || {}),\n        ...Object.keys(classNames2 || {})\n    ];\n    keys.forEach((key)=>{\n        newClassNames[key] = (0, _classnames.default)(classNames1[key], classNames2[key]);\n    });\n    return newClassNames;\n};\nconst mergeClassNamesFunctionsDeep = ({ classNames1 = {}, classNames2 = {} })=>{\n    const newClassNames = {};\n    const keys = [\n        ...Object.keys(classNames1 || {}),\n        ...Object.keys(classNames2 || {})\n    ];\n    keys.forEach((key)=>{\n        newClassNames[key] = (args)=>(0, _classnames.default)((classNames1[key] || (()=>\"\"))(args), (classNames2[key] || (()=>\"\"))(args));\n    });\n    return newClassNames;\n};\n/** Typing on this function is confusing but does work! */ const removeUndefinedValuesFromObj = (inputObject)=>{\n    const result = {};\n    // eslint-disable-next-line\n    for(const key in inputObject){\n        if (inputObject[key] !== undefined) {\n            result[key] = inputObject[key];\n        }\n    }\n    return result;\n};\n/** Typing on this function is confusing but does work! */ const removeUndefinedAndEmptyStringValuesFromObj = (inputObject)=>{\n    const result = {};\n    // eslint-disable-next-line\n    for(const key in inputObject){\n        if (inputObject[key] !== undefined && inputObject[key] !== \"\") {\n            result[key] = inputObject[key];\n        }\n    }\n    return result;\n};\n/** Typing on this function is confusing but does work! */ const removeUndefinedAndNullValuesFromObj = (inputObject)=>{\n    const result = {};\n    // eslint-disable-next-line\n    for(const key in inputObject){\n        if (inputObject[key] !== undefined && inputObject[key] !== null) {\n            result[key] = inputObject[key];\n        }\n    }\n    return result;\n};\n/**\n * Generates a query string from an object of key value pairs\n *\n * @returns a classNames object\n *\n * @example\n * generateQueryString(\\{ field1: 'value1', field2: 'value2' \\}) =\\> \"?field1=value1&field2=value2\"\n * generateQueryString(\\{ field1: 'value1', field2: 'value2', excludeQuestionMark \\}) =\\> \"field1=value1&field2=value2\"\n */ const generateQueryString = ({ queryParams = {}, excludeQuestionMark = false, excludeEmptyStringValues = false })=>{\n    // The first parameter in a querystring is preceded by a ?\n    // This flag denotes whether we already have one param set in the query string\n    let prefixQuestionMark = !excludeQuestionMark;\n    return reduce$1(excludeEmptyStringValues ? removeUndefinedAndEmptyStringValuesFromObj(queryParams || {}) : removeUndefinedValuesFromObj(queryParams || {}), (acc, field, key)=>{\n        // If the field is falsey then do not append this query param\n        if (field === undefined) {\n            return acc;\n        }\n        if (!prefixQuestionMark) {\n            return `${acc}&${key}=${field}`;\n        }\n        prefixQuestionMark = false;\n        return `${acc}?${key}=${field}`;\n    }, \"\");\n};\n/**\n * Rounds a number to N decimal places (defaults to 2)\n *\n * @returns a rounded number\n */ const roundNumber = (num, decimalPlaces = 2)=>{\n    return +`${Math.round(+`${num}e+${decimalPlaces}`)}e-${decimalPlaces}`;\n};\nconst getNRandomElementsFromArray = (array, n)=>{\n    if (array.length <= n) {\n        return [];\n    }\n    let count = n;\n    const result = new Array(count);\n    let len = array.length;\n    const taken = new Array(len);\n    if (count > len) throw new RangeError(\"getRandom: more elements taken than available\");\n    while(count--){\n        const x = Math.floor(Math.random() * len);\n        result[count] = array[x in taken ? taken[x] : x];\n        taken[x] = --len in taken ? taken[len] : len;\n    }\n    return result;\n};\nconst getRandomElementsFromArray = (array)=>{\n    const elementsCount = Math.floor(Math.random() * array.length) + 1;\n    return getNRandomElementsFromArray(array, elementsCount);\n};\nconst getRandomElementFromArray = (array)=>getNRandomElementsFromArray(array, 1)[0];\n/**\n * Converts an rgba string to a hex color code\n *\n * @returns a hex color code as a string\n */ const RGBAToHexA = (rgba, forceRemoveAlpha = false)=>{\n    const hexColor = rgba.replace(/^rgba?\\(|\\s+|\\)$/g, \"\") // Get's rgba / rgb string values\n    .split(\",\") // splits them by \",\"\n    .filter((str, index)=>!forceRemoveAlpha || index !== 3).map((str)=>parseFloat(str)) // Converts them to numbers\n    .map((number, index)=>index === 3 ? Math.round(number * 255) : number) // Converts alpha to 255 number\n    .map((number)=>number.toString(16)) // Converts numbers to hex\n    .map((str)=>str.length === 1 ? `0${str}` : str) // Adds 0 when length of one number is 1\n    .join(\"\");\n    return `#${hexColor}`;\n};\nconst isTruthyOrZero = (value)=>value !== undefined && value !== null && (!!value || value !== \"\" && Number(value) === 0);\nconst conditionalOrIfTruthyOrZero = (values)=>{\n    const value = values.find((v)=>isTruthyOrZero(v));\n    return value === undefined ? values[values.length - 1] : value;\n};\nconst arrayWithoutElements = ({ array, excludeArray })=>{\n    const toExclude = new Set(excludeArray || []);\n    return (array || []).filter((v)=>!toExclude.has(v));\n};\nconst capitaliseFirstLetter = (text = \"\")=>{\n    return text.charAt(0).toUpperCase() + text.slice(1);\n};\nconst cleanString = (text = \"\")=>{\n    return (text || \"\").trim();\n};\nconst normaliseString = (text = \"\")=>{\n    return cleanString(text).toLowerCase();\n};\nconst parseEnvVariable = (v)=>{\n    if (v === \"false\") {\n        return false;\n    }\n    if (v === \"true\") {\n        return true;\n    }\n    if (v?.[0] === \"$\") {\n        return Number(v.replace(\"$\", \"\"));\n    }\n    return v;\n};\nconst parseEnvVariables = (env)=>mapValues$1(env, (v)=>parseEnvVariable(v));\nconst getNextJSQueryParam = ({ query, id, defaultToEmptyString = false })=>{\n    const returnDefault = defaultToEmptyString ? \"\" : undefined;\n    if (!query) {\n        return returnDefault;\n    }\n    return (Array.isArray(query?.[id]) ? query?.[id]?.[0]?.toString() : query?.[id]?.toString()) || returnDefault;\n};\nconst evaluateTruthyIfNotUndefined = (v)=>{\n    if (v === undefined) {\n        return undefined;\n    }\n    return !!v;\n};\nconst evaluateOneOrZeroBooleanIfNotEmptyString = (v)=>{\n    if (v === \"\") {\n        return undefined;\n    }\n    return v === \"1\";\n};\nconst evaluateOneOrZeroBooleanIfNotUndefined = (v)=>{\n    if (v === undefined) {\n        return undefined;\n    }\n    return v === \"1\";\n};\nconst downloadFromObjectURL = ({ fileName, url })=>{\n    /** Create a link and download from it */ const link = document.createElement(\"a\");\n    link.href = url;\n    link.download = fileName;\n    document.body.appendChild(link);\n    link.click();\n    /** Clear up the element and object url */ URL.revokeObjectURL(url);\n    link.remove();\n};\nconst generateCSV = ({ data, columnHeaderNames = undefined, autoGenerateColumnHeaderNames = true, startCaseForColunmHeaderNames = false })=>{\n    return stringify(startCaseForColunmHeaderNames ? data.map((d)=>d ? mapKeys$1(d, (_v, key)=>startCase$1(key)) : d) : data, {\n        ...autoGenerateColumnHeaderNames || autoGenerateColumnHeaderNames ? {\n            header: true\n        } : {},\n        ...columnHeaderNames ? {\n            columns: columnHeaderNames\n        } : {}\n    });\n};\nconst downloadCSV = ({ csv, fileName })=>{\n    /** Create url to the csv file */ const blob = new Blob([\n        csv\n    ], {\n        type: \"text/csv;charset=utf-8,\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    downloadFromObjectURL({\n        fileName: `${fileName}.csv`,\n        url: blobUrl\n    });\n};\nconst downloadJSON = ({ json, fileName })=>{\n    /** Create url to the json file */ const blob = new Blob([\n        json\n    ], {\n        type: \"text/application/json;charset=utf-8,\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    downloadFromObjectURL({\n        fileName: `${fileName}.json`,\n        url: blobUrl\n    });\n};\nconst getReactQueryStatus = ({ isFetching = false, isLoading = true, isError = false, isSuccess, dataUpdatedAt }, { isReady = false, shouldLoadInitially = true, status })=>{\n    return {\n        isFetching,\n        isLoading: shouldLoadInitially ? !!isLoading || !isError && !isReady : !!isLoading,\n        isError,\n        isSuccess,\n        is401: status === 401,\n        updatedAt: dataUpdatedAt\n    };\n};\nconst sanitiseTextTerm = (textTerm = \"\")=>(textTerm || \"\").trim().toLowerCase();\nconst stringsEqualInsensitive = (str1, str2)=>{\n    if (str1 === undefined || str1 === null) {\n        return false;\n    }\n    return sanitiseTextTerm(str1) === sanitiseTextTerm(str2);\n};\nconst checkIfTextTermMatchesSingle = ({ sourceValue: sourceValueRaw = \"\", inputValue: inputValueRaw = \"\", useFuzzy = true })=>{\n    /** Fuzzysort match minimum threshold. 0 is a perfect match, lower is a worse match */ const FUZZYSORT_MATCH_THRESHOLD = -75;\n    const sourceValue = sanitiseTextTerm(sourceValueRaw);\n    const inputValue = sanitiseTextTerm(inputValueRaw);\n    if (!sourceValue || !inputValue) {\n        return {\n            matches: false,\n            score: -Infinity\n        };\n    }\n    if (sourceValue === inputValue) {\n        return {\n            matches: true,\n            score: 0\n        };\n    }\n    if (useFuzzy) {\n        let score = _fuzzysort.default.single(inputValue, sourceValue)?.score;\n        if (score === undefined || score === null) {\n            score = -Infinity;\n        }\n        if (sourceValue.includes(inputValue) || score > FUZZYSORT_MATCH_THRESHOLD) {\n            return {\n                matches: true,\n                score\n            };\n        }\n    }\n    return {\n        matches: false,\n        score: -Infinity\n    };\n};\nconst checkIfTextTermMatchesArray = ({ inputValue, array, useFuzzy = true })=>{\n    if ((inputValue || \"\").trim()) {\n        for(let arrayIndex = 0; arrayIndex < array.length; arrayIndex++){\n            const value = array[arrayIndex];\n            if ((value || \"\").trim()) {\n                if (checkIfTextTermMatchesSingle({\n                    sourceValue: value,\n                    inputValue,\n                    useFuzzy\n                }).matches) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    return true;\n};\nconst createCustomKey = (keys)=>keys.reduce((key, currentKey)=>{\n        const compositeKeyIsTruthy = isTruthyOrZero(key);\n        const currentKeyIsTruthy = isTruthyOrZero(currentKey);\n        return `${key}${compositeKeyIsTruthy ? \"|\" : \"\"}${currentKeyIsTruthy ? currentKey : \"\"}`;\n    }, \"\");\nconst createCustomKeyFromObject = (obj, options = {})=>{\n    const { keyValueSeparator, separator } = options;\n    const kvSep = keyValueSeparator || \":\";\n    const sep = separator || \"|\";\n    return sortBy$1(Object.entries(removeUndefinedValuesFromObj(obj)), ([k, v])=>`${k}:${v}`).reduce((key, [currentKey, currentValue])=>{\n        const shouldExcludeValue = !currentKey || currentValue === \"\" || isArray$f(currentValue) && !currentValue?.length;\n        const valueIsObject = isObject$9(currentValue);\n        const valueIsArray = isArray$f(currentValue);\n        const valueNeedsTransforming = valueIsArray || valueIsObject;\n        let value = currentValue;\n        if (valueNeedsTransforming) {\n            if (valueIsArray) {\n                value = currentValue.join(\",\");\n            } else if (valueIsObject) {\n                value = createCustomKeyFromObject(currentValue, options);\n            }\n        }\n        if (!shouldExcludeValue) {\n            return key === \"\" ? `${currentKey}${kvSep}${value}` : `${key}${sep}${currentKey}${kvSep}${value}`;\n        }\n        return key;\n    }, \"\");\n};\nconst createCustomFileNameKeyFromObject = (obj)=>createCustomKeyFromObject(mapValues$1(obj, (v)=>{\n        if (v === true || v === \"true\") {\n            return \"1\";\n        }\n        if (v === false || v === \"false\") {\n            return \"0\";\n        }\n        return v;\n    }), {\n        separator: \"_\",\n        keyValueSeparator: \"=\"\n    });\nconst createCustomKeyFromSrcTgt = ({ srcID, tgtID })=>createCustomKey([\n        srcID,\n        tgtID\n    ]);\nconst isEmail = (v)=>!!(!!v && typeof v === \"string\" && v.length && EMAIL_REGEX.test(v));\nconst sleep = (ms)=>{\n    return new Promise((resolve)=>{\n        setTimeout(resolve, ms);\n    });\n};\nconst mergeObject = (...params)=>merge$1({}, ...params);\nconst mergeObjectReplacingArrays = (...params)=>mergeWith$1({}, ...params, (_a, b)=>isArray$f(b) ? b : undefined);\nconst log = (n, base = e)=>{\n    return Math.log(n) / (base ? Math.log(base) : 1);\n};\nconst antilog = (n, base = e)=>{\n    if (base === e) return Math.exp(n);\n    return base ** n;\n};\nconst openUrlInNewTab = (url)=>{\n    if (isBrowser()) {\n        window.open(url, \"_blank\")?.focus();\n    }\n};\nconst isEqualIgnoringOrder = (a, b)=>{\n    if (isArray$f(a) && isArray$f(b)) {\n        return isEqual$1(sortBy$1(a, [\n            (v)=>v\n        ]), sortBy$1(b, [\n            (v)=>v\n        ]));\n    }\n    return isEqual$1(a, b);\n};\nconst clampValue = ({ min, max, value })=>{\n    if (value === undefined) {\n        return min;\n    }\n    if (value <= min) {\n        return min;\n    }\n    if (value >= max) {\n        return max;\n    }\n    return value;\n};\nconst keyByWithUndefined = (collection, iteratee)=>{\n    return collection ? keyBy$1(collection, iteratee) : {};\n};\nconst getRandomNumber = (min, max)=>{\n    const range = max - min;\n    const distanceThroughRange = Math.random() * range;\n    return min + distanceThroughRange;\n};\nconst getRandomInteger = (min, max)=>{\n    const randomNumber = getRandomNumber(min, max);\n    const roundedDown = Math.floor(randomNumber);\n    const roundedUp = Math.ceil(randomNumber);\n    const number = Math.random() > 0.5 ? roundedDown : roundedUp;\n    if (number > max) {\n        return number - 1;\n    }\n    if (number < min) {\n        return number + 1;\n    }\n    return number;\n};\nconst assertTruthyOrZero = (value)=>isTruthyOrZero(value);\nconst CACHE_TIME_72_HOURS = 1000 * 60 * 60 * 72;\nconst CACHE_TIME_48_HOURS = 1000 * 60 * 60 * 48;\nconst CACHE_TIME_1_HOUR = 1000 * 60 * 60 * 1;\nconst CACHE_TIME_30_MINUTES = 1000 * 60 * 30;\nconst createTimeMsInMinutes = (minutes = 0)=>1000 * 60 * minutes;\nconst createTimeMsInHours = (hours = 0)=>createTimeMsInMinutes(60 * hours);\nconst createTimeMsInDays = (days = 0)=>createTimeMsInHours(24 * days);\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SyxLQUFVO0lBQ3hELEtBQVU7SUFBTSxLQUFVO0lBQUssS0FBVTtJQUFLLEtBQVU7SUFDeEQsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN4RCxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN2RSxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN2RSxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQ3hELEtBQVU7SUFBTSxLQUFVO0lBQUssS0FBVTtJQUFLLEtBQVU7SUFDeEQsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN4RCxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN2RSxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN2RSxLQUFVO0lBQU0sS0FBVTtJQUMxQixLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFDekMsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUFLLEtBQVU7SUFDdkUsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUFLLEtBQVU7SUFDdkUsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN4RCxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQ3hELEtBQVU7SUFBTSxLQUFVO0lBQUssS0FBVTtJQUN6QyxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFDekMsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQ3pDLEtBQVU7SUFBTSxLQUFVO0lBQUssS0FBVTtJQUN6QyxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQ3hELEtBQVU7SUFBTSxLQUFVO0lBQUssS0FBVTtJQUFLLEtBQVU7SUFDeEQsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQ3pDLEtBQVU7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RixvQkFBb0IsT0FBTyxLQUFLLEtBQUs7QUFDM0MsTUFBTUMsd0JBQXdCLE9BQU8sS0FBSztBQUMxQyxNQUFNbUIsd0JBQXdCLENBQUMyakQsVUFBVSxDQUFDLEdBQUssT0FBTyxLQUFLQTtBQUMzRCxNQUFNNWpELHNCQUFzQixDQUFDNmpELFFBQVEsQ0FBQyxHQUFLNWpELHNCQUFzQixLQUFLNGpEO0FBQ3RFLE1BQU05akQscUJBQXFCLENBQUMrakQsT0FBTyxDQUFDLEdBQUs5akQsb0JBQW9CLEtBQUs4akQ7Q0FHbEUscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uLi9saWItdXRpbGl0aWVzL2xpYi9pbmRleC5lc20uanM/YjJhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBmdXp6eXNvcnQgZnJvbSAnZnV6enlzb3J0JztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuXG5mdW5jdGlvbiBhcnJheVJlZHVjZSQyKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbnZhciBfYXJyYXlSZWR1Y2UgPSBhcnJheVJlZHVjZSQyO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQmFzZUZvciQxKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IkMTtcblxudmFyIGNyZWF0ZUJhc2VGb3IgPSBfY3JlYXRlQmFzZUZvcjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yJDIgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbnZhciBfYmFzZUZvciA9IGJhc2VGb3IkMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cblxuZnVuY3Rpb24gYmFzZVRpbWVzJDEobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZVRpbWVzID0gYmFzZVRpbWVzJDE7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG5cbnZhciBmcmVlR2xvYmFsJDEgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cbnZhciBfZnJlZUdsb2JhbCA9IGZyZWVHbG9iYWwkMTtcblxudmFyIGZyZWVHbG9iYWwgPSBfZnJlZUdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290JDggPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBfcm9vdCA9IHJvb3QkODtcblxudmFyIHJvb3QkNyA9IF9yb290O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wkNiA9IHJvb3QkNy5TeW1ib2w7XG5cbnZhciBfU3ltYm9sID0gU3ltYm9sJDY7XG5cbnZhciBTeW1ib2wkNSA9IF9TeW1ib2w7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkYiA9IG9iamVjdFByb3RvJGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kZS50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IFN5bWJvbCQ1ID8gU3ltYm9sJDUudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnJDEodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkkYi5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyQxKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZyQxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cbnZhciBvYmplY3RQcm90byRkID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8kZC50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nJDEodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG52YXIgX29iamVjdFRvU3RyaW5nID0gb2JqZWN0VG9TdHJpbmckMTtcblxudmFyIFN5bWJvbCQ0ID0gX1N5bWJvbCxcbiAgICBnZXRSYXdUYWcgPSBfZ2V0UmF3VGFnLFxuICAgIG9iamVjdFRvU3RyaW5nID0gX29iamVjdFRvU3RyaW5nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wkNCA/IFN5bWJvbCQ0LnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyQ2KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxudmFyIF9iYXNlR2V0VGFnID0gYmFzZUdldFRhZyQ2O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdExpa2UkNyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbnZhciBpc09iamVjdExpa2VfMSA9IGlzT2JqZWN0TGlrZSQ3O1xuXG52YXIgYmFzZUdldFRhZyQ1ID0gX2Jhc2VHZXRUYWcsXG4gICAgaXNPYmplY3RMaWtlJDYgPSBpc09iamVjdExpa2VfMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWckMiA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyQxKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UkNih2YWx1ZSkgJiYgYmFzZUdldFRhZyQ1KHZhbHVlKSA9PSBhcmdzVGFnJDI7XG59XG5cbnZhciBfYmFzZUlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzJDE7XG5cbnZhciBiYXNlSXNBcmd1bWVudHMgPSBfYmFzZUlzQXJndW1lbnRzLFxuICAgIGlzT2JqZWN0TGlrZSQ1ID0gaXNPYmplY3RMaWtlXzE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRjID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkYSA9IG9iamVjdFByb3RvJGMuaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlJDEgPSBvYmplY3RQcm90byRjLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMkNCA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UkNSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkkYS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUkMS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG52YXIgaXNBcmd1bWVudHNfMSA9IGlzQXJndW1lbnRzJDQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG52YXIgaXNBcnJheSRlID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGlzQXJyYXlfMSA9IGlzQXJyYXkkZTtcblxudmFyIGlzQXJyYXkkZiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpc0FycmF5XzEpO1xuXG52YXIgaXNCdWZmZXIkNCA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgc3R1YkZhbHNlXzEgPSBzdHViRmFsc2U7XG5cbmlzQnVmZmVyJDQuZXhwb3J0cztcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0dmFyIHJvb3QgPSBfcm9vdCxcblx0ICAgIHN0dWJGYWxzZSA9IHN0dWJGYWxzZV8xO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG5cdHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG5cdC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cdHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG5cdC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblx0dmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4zLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHR2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjsgXG59IChpc0J1ZmZlciQ0LCBpc0J1ZmZlciQ0LmV4cG9ydHMpKTtcblxudmFyIGlzQnVmZmVyRXhwb3J0cyA9IGlzQnVmZmVyJDQuZXhwb3J0cztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSJDEgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgkMyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIkMSA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbnZhciBfaXNJbmRleCA9IGlzSW5kZXgkMztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoJDModmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxudmFyIGlzTGVuZ3RoXzEgPSBpc0xlbmd0aCQzO1xuXG52YXIgYmFzZUdldFRhZyQ0ID0gX2Jhc2VHZXRUYWcsXG4gICAgaXNMZW5ndGgkMiA9IGlzTGVuZ3RoXzEsXG4gICAgaXNPYmplY3RMaWtlJDQgPSBpc09iamVjdExpa2VfMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWckMSA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnJDEgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWckMSA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnJDEgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWckMSA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyQxID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWckMiA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyQxID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnJDMgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWckMSA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyQyID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnJDEgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnJDEgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyQxID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyQyID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWckMV0gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZyQxXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWckMV0gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWckMl0gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnJDFdID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnJDFdID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZyQxXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWckMl0gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWckMV0gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnJDNdID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnJDFdID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZyQyXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZyQxXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnJDFdID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkkMSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlJDQodmFsdWUpICYmXG4gICAgaXNMZW5ndGgkMih2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyQ0KHZhbHVlKV07XG59XG5cbnZhciBfYmFzZUlzVHlwZWRBcnJheSA9IGJhc2VJc1R5cGVkQXJyYXkkMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBiYXNlVW5hcnkkMihmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxudmFyIF9iYXNlVW5hcnkgPSBiYXNlVW5hcnkkMjtcblxudmFyIF9ub2RlVXRpbCA9IHtleHBvcnRzOiB7fX07XG5cbl9ub2RlVXRpbC5leHBvcnRzO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHR2YXIgZnJlZUdsb2JhbCA9IF9mcmVlR2xvYmFsO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG5cdHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG5cdC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cdHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuXHR2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuXHQvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cblx0dmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuXHQgIHRyeSB7XG5cdCAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cblx0ICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG5cdCAgICBpZiAodHlwZXMpIHtcblx0ICAgICAgcmV0dXJuIHR5cGVzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuXHQgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuXHQgIH0gY2F0Y2ggKGUpIHt9XG5cdH0oKSk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDsgXG59IChfbm9kZVV0aWwsIF9ub2RlVXRpbC5leHBvcnRzKSk7XG5cbnZhciBfbm9kZVV0aWxFeHBvcnRzID0gX25vZGVVdGlsLmV4cG9ydHM7XG5cbnZhciBiYXNlSXNUeXBlZEFycmF5ID0gX2Jhc2VJc1R5cGVkQXJyYXksXG4gICAgYmFzZVVuYXJ5JDEgPSBfYmFzZVVuYXJ5LFxuICAgIG5vZGVVdGlsID0gX25vZGVVdGlsRXhwb3J0cztcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5JDMgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5JDEobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG52YXIgaXNUeXBlZEFycmF5XzEgPSBpc1R5cGVkQXJyYXkkMztcblxudmFyIGJhc2VUaW1lcyA9IF9iYXNlVGltZXMsXG4gICAgaXNBcmd1bWVudHMkMyA9IGlzQXJndW1lbnRzXzEsXG4gICAgaXNBcnJheSRkID0gaXNBcnJheV8xLFxuICAgIGlzQnVmZmVyJDMgPSBpc0J1ZmZlckV4cG9ydHMsXG4gICAgaXNJbmRleCQyID0gX2lzSW5kZXgsXG4gICAgaXNUeXBlZEFycmF5JDIgPSBpc1R5cGVkQXJyYXlfMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ5ID0gb2JqZWN0UHJvdG8kYi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyQyKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSRkKHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzJDModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlciQzKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkkMih2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkkOS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgkMihrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYXJyYXlMaWtlS2V5cyA9IGFycmF5TGlrZUtleXMkMjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXG52YXIgb2JqZWN0UHJvdG8kYSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSQzKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90byRhO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbnZhciBfaXNQcm90b3R5cGUgPSBpc1Byb3RvdHlwZSQzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBvdmVyQXJnJDIoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbnZhciBfb3ZlckFyZyA9IG92ZXJBcmckMjtcblxudmFyIG92ZXJBcmckMSA9IF9vdmVyQXJnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyQxID0gb3ZlckFyZyQxKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG52YXIgX25hdGl2ZUtleXMgPSBuYXRpdmVLZXlzJDE7XG5cbnZhciBpc1Byb3RvdHlwZSQyID0gX2lzUHJvdG90eXBlLFxuICAgIG5hdGl2ZUtleXMgPSBfbmF0aXZlS2V5cztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDkgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ4ID0gb2JqZWN0UHJvdG8kOS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzJDEob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUkMihvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQ4LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VLZXlzID0gYmFzZUtleXMkMTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdCQ4KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0JDg7XG5cbnZhciBpc09iamVjdCQ5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGlzT2JqZWN0XzEpO1xuXG52YXIgYmFzZUdldFRhZyQzID0gX2Jhc2VHZXRUYWcsXG4gICAgaXNPYmplY3QkNyA9IGlzT2JqZWN0XzE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24kMyh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0JDcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWckMyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbnZhciBpc0Z1bmN0aW9uXzEgPSBpc0Z1bmN0aW9uJDM7XG5cbnZhciBpc0Z1bmN0aW9uJDIgPSBpc0Z1bmN0aW9uXzEsXG4gICAgaXNMZW5ndGgkMSA9IGlzTGVuZ3RoXzE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlJDYodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgkMSh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uJDIodmFsdWUpO1xufVxuXG52YXIgaXNBcnJheUxpa2VfMSA9IGlzQXJyYXlMaWtlJDY7XG5cbnZhciBhcnJheUxpa2VLZXlzJDEgPSBfYXJyYXlMaWtlS2V5cyxcbiAgICBiYXNlS2V5cyA9IF9iYXNlS2V5cyxcbiAgICBpc0FycmF5TGlrZSQ1ID0gaXNBcnJheUxpa2VfMTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzJDMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZSQ1KG9iamVjdCkgPyBhcnJheUxpa2VLZXlzJDEob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbnZhciBrZXlzXzEgPSBrZXlzJDM7XG5cbnZhciBiYXNlRm9yJDEgPSBfYmFzZUZvcixcbiAgICBrZXlzJDIgPSBrZXlzXzE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93biQzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yJDEob2JqZWN0LCBpdGVyYXRlZSwga2V5cyQyKTtcbn1cblxudmFyIF9iYXNlRm9yT3duID0gYmFzZUZvck93biQzO1xuXG52YXIgaXNBcnJheUxpa2UkNCA9IGlzQXJyYXlMaWtlXzE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2gkMShlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlJDQoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG52YXIgX2NyZWF0ZUJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2gkMTtcblxudmFyIGJhc2VGb3JPd24kMiA9IF9iYXNlRm9yT3duLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gX2NyZWF0ZUJhc2VFYWNoO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2gkMyA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24kMik7XG5cbnZhciBfYmFzZUVhY2ggPSBiYXNlRWFjaCQzO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cblxuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIkMSgpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2xpc3RDYWNoZUNsZWFyID0gbGlzdENhY2hlQ2xlYXIkMTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5cbmZ1bmN0aW9uIGVxJDUodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG52YXIgZXFfMSA9IGVxJDU7XG5cbnZhciBlcSQ0ID0gZXFfMTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mJDQoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEkNChhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbnZhciBfYXNzb2NJbmRleE9mID0gYXNzb2NJbmRleE9mJDQ7XG5cbnZhciBhc3NvY0luZGV4T2YkMyA9IF9hc3NvY0luZGV4T2Y7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlJDEoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mJDMoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBfbGlzdENhY2hlRGVsZXRlID0gbGlzdENhY2hlRGVsZXRlJDE7XG5cbnZhciBhc3NvY0luZGV4T2YkMiA9IF9hc3NvY0luZGV4T2Y7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldCQxKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZiQyKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG52YXIgX2xpc3RDYWNoZUdldCA9IGxpc3RDYWNoZUdldCQxO1xuXG52YXIgYXNzb2NJbmRleE9mJDEgPSBfYXNzb2NJbmRleE9mO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzJDEoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YkMSh0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbnZhciBfbGlzdENhY2hlSGFzID0gbGlzdENhY2hlSGFzJDE7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfYXNzb2NJbmRleE9mO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldCQxKGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9saXN0Q2FjaGVTZXQgPSBsaXN0Q2FjaGVTZXQkMTtcblxudmFyIGxpc3RDYWNoZUNsZWFyID0gX2xpc3RDYWNoZUNsZWFyLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IF9saXN0Q2FjaGVEZWxldGUsXG4gICAgbGlzdENhY2hlR2V0ID0gX2xpc3RDYWNoZUdldCxcbiAgICBsaXN0Q2FjaGVIYXMgPSBfbGlzdENhY2hlSGFzLFxuICAgIGxpc3RDYWNoZVNldCA9IF9saXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlJDQoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZSQ0LnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlJDQucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZSQ0LnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUkNC5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlJDQucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxudmFyIF9MaXN0Q2FjaGUgPSBMaXN0Q2FjaGUkNDtcblxudmFyIExpc3RDYWNoZSQzID0gX0xpc3RDYWNoZTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyJDEoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlJDM7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbnZhciBfc3RhY2tDbGVhciA9IHN0YWNrQ2xlYXIkMTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBzdGFja0RlbGV0ZSQxKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9zdGFja0RlbGV0ZSA9IHN0YWNrRGVsZXRlJDE7XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cblxuZnVuY3Rpb24gc3RhY2tHZXQkMShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbnZhciBfc3RhY2tHZXQgPSBzdGFja0dldCQxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBzdGFja0hhcyQxKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxudmFyIF9zdGFja0hhcyA9IHN0YWNrSGFzJDE7XG5cbnZhciByb290JDYgPSBfcm9vdDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEkMSA9IHJvb3QkNlsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbnZhciBfY29yZUpzRGF0YSA9IGNvcmVKc0RhdGEkMTtcblxudmFyIGNvcmVKc0RhdGEgPSBfY29yZUpzRGF0YTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkJDEoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG52YXIgX2lzTWFza2VkID0gaXNNYXNrZWQkMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXG52YXIgZnVuY1Byb3RvJDIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmckMiA9IGZ1bmNQcm90byQyLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UkMihmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZyQyLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgX3RvU291cmNlID0gdG9Tb3VyY2UkMjtcblxudmFyIGlzRnVuY3Rpb24kMSA9IGlzRnVuY3Rpb25fMSxcbiAgICBpc01hc2tlZCA9IF9pc01hc2tlZCxcbiAgICBpc09iamVjdCQ2ID0gaXNPYmplY3RfMSxcbiAgICB0b1NvdXJjZSQxID0gX3RvU291cmNlO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byQxID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvJDggPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nJDEgPSBmdW5jUHJvdG8kMS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNyA9IG9iamVjdFByb3RvJDguaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmckMS5jYWxsKGhhc093blByb3BlcnR5JDcpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSQxKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QkNih2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbiQxKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UkMSh2YWx1ZSkpO1xufVxuXG52YXIgX2Jhc2VJc05hdGl2ZSA9IGJhc2VJc05hdGl2ZSQxO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cbmZ1bmN0aW9uIGdldFZhbHVlJDEob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbnZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZSQxO1xuXG52YXIgYmFzZUlzTmF0aXZlID0gX2Jhc2VJc05hdGl2ZSxcbiAgICBnZXRWYWx1ZSA9IF9nZXRWYWx1ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlJDcob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2dldE5hdGl2ZSA9IGdldE5hdGl2ZSQ3O1xuXG52YXIgZ2V0TmF0aXZlJDYgPSBfZ2V0TmF0aXZlLFxuICAgIHJvb3QkNSA9IF9yb290O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwJDMgPSBnZXROYXRpdmUkNihyb290JDUsICdNYXAnKTtcblxudmFyIF9NYXAgPSBNYXAkMztcblxudmFyIGdldE5hdGl2ZSQ1ID0gX2dldE5hdGl2ZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSQ0ID0gZ2V0TmF0aXZlJDUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbnZhciBfbmF0aXZlQ3JlYXRlID0gbmF0aXZlQ3JlYXRlJDQ7XG5cbnZhciBuYXRpdmVDcmVhdGUkMyA9IF9uYXRpdmVDcmVhdGU7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhciQxKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlJDMgPyBuYXRpdmVDcmVhdGUkMyhudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2hhc2hDbGVhciA9IGhhc2hDbGVhciQxO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNoRGVsZXRlJDEoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZSQxO1xuXG52YXIgbmF0aXZlQ3JlYXRlJDIgPSBfbmF0aXZlQ3JlYXRlO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQkMiA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDcgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ2ID0gb2JqZWN0UHJvdG8kNy5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQkMShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlJDIpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEJDIgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5JDYuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2hhc2hHZXQgPSBoYXNoR2V0JDE7XG5cbnZhciBuYXRpdmVDcmVhdGUkMSA9IF9uYXRpdmVDcmVhdGU7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ2ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNSA9IG9iamVjdFByb3RvJDYuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyQxKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUkMSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eSQ1LmNhbGwoZGF0YSwga2V5KTtcbn1cblxudmFyIF9oYXNoSGFzID0gaGFzaEhhcyQxO1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX25hdGl2ZUNyZWF0ZTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEJDEgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQkMShrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEJDEgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfaGFzaFNldCA9IGhhc2hTZXQkMTtcblxudmFyIGhhc2hDbGVhciA9IF9oYXNoQ2xlYXIsXG4gICAgaGFzaERlbGV0ZSA9IF9oYXNoRGVsZXRlLFxuICAgIGhhc2hHZXQgPSBfaGFzaEdldCxcbiAgICBoYXNoSGFzID0gX2hhc2hIYXMsXG4gICAgaGFzaFNldCA9IF9oYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaCQxKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaCQxLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gkMS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gkMS5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gkMS5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gkMS5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxudmFyIF9IYXNoID0gSGFzaCQxO1xuXG52YXIgSGFzaCA9IF9IYXNoLFxuICAgIExpc3RDYWNoZSQyID0gX0xpc3RDYWNoZSxcbiAgICBNYXAkMiA9IF9NYXA7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIkMSgpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCQyIHx8IExpc3RDYWNoZSQyKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxudmFyIF9tYXBDYWNoZUNsZWFyID0gbWFwQ2FjaGVDbGVhciQxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBpc0tleWFibGUkMSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG52YXIgX2lzS2V5YWJsZSA9IGlzS2V5YWJsZSQxO1xuXG52YXIgaXNLZXlhYmxlID0gX2lzS2V5YWJsZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YSQ0KG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbnZhciBfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGEkNDtcblxudmFyIGdldE1hcERhdGEkMyA9IF9nZXRNYXBEYXRhO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUkMShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEkMyh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWFwQ2FjaGVEZWxldGUgPSBtYXBDYWNoZURlbGV0ZSQxO1xuXG52YXIgZ2V0TWFwRGF0YSQyID0gX2dldE1hcERhdGE7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldCQxKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSQyKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbnZhciBfbWFwQ2FjaGVHZXQgPSBtYXBDYWNoZUdldCQxO1xuXG52YXIgZ2V0TWFwRGF0YSQxID0gX2dldE1hcERhdGE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMkMShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEkMSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG52YXIgX21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXMkMTtcblxudmFyIGdldE1hcERhdGEgPSBfZ2V0TWFwRGF0YTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldCQxKGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfbWFwQ2FjaGVTZXQgPSBtYXBDYWNoZVNldCQxO1xuXG52YXIgbWFwQ2FjaGVDbGVhciA9IF9tYXBDYWNoZUNsZWFyLFxuICAgIG1hcENhY2hlRGVsZXRlID0gX21hcENhY2hlRGVsZXRlLFxuICAgIG1hcENhY2hlR2V0ID0gX21hcENhY2hlR2V0LFxuICAgIG1hcENhY2hlSGFzID0gX21hcENhY2hlSGFzLFxuICAgIG1hcENhY2hlU2V0ID0gX21hcENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUkMyhlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZSQzLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZSQzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlJDMucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUkMy5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZSQzLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxudmFyIF9NYXBDYWNoZSA9IE1hcENhY2hlJDM7XG5cbnZhciBMaXN0Q2FjaGUkMSA9IF9MaXN0Q2FjaGUsXG4gICAgTWFwJDEgPSBfTWFwLFxuICAgIE1hcENhY2hlJDIgPSBfTWFwQ2FjaGU7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0JDEoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlJDEpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwJDEgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUkMihwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfc3RhY2tTZXQgPSBzdGFja1NldCQxO1xuXG52YXIgTGlzdENhY2hlID0gX0xpc3RDYWNoZSxcbiAgICBzdGFja0NsZWFyID0gX3N0YWNrQ2xlYXIsXG4gICAgc3RhY2tEZWxldGUgPSBfc3RhY2tEZWxldGUsXG4gICAgc3RhY2tHZXQgPSBfc3RhY2tHZXQsXG4gICAgc3RhY2tIYXMgPSBfc3RhY2tIYXMsXG4gICAgc3RhY2tTZXQgPSBfc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrJDMoZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjayQzLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjayQzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrJDMucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2skMy5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjayQzLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxudmFyIF9TdGFjayA9IFN0YWNrJDM7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cblxudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQkMSh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9zZXRDYWNoZUFkZCA9IHNldENhY2hlQWRkJDE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyQxKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbnZhciBfc2V0Q2FjaGVIYXMgPSBzZXRDYWNoZUhhcyQxO1xuXG52YXIgTWFwQ2FjaGUkMSA9IF9NYXBDYWNoZSxcbiAgICBzZXRDYWNoZUFkZCA9IF9zZXRDYWNoZUFkZCxcbiAgICBzZXRDYWNoZUhhcyA9IF9zZXRDYWNoZUhhcztcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSQxKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZSQxO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZSQxLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZSQxLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZSQxLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxudmFyIF9TZXRDYWNoZSA9IFNldENhY2hlJDE7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5cbmZ1bmN0aW9uIGFycmF5U29tZSQxKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2FycmF5U29tZSA9IGFycmF5U29tZSQxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5cbmZ1bmN0aW9uIGNhY2hlSGFzJDEoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbnZhciBfY2FjaGVIYXMgPSBjYWNoZUhhcyQxO1xuXG52YXIgU2V0Q2FjaGUgPSBfU2V0Q2FjaGUsXG4gICAgYXJyYXlTb21lID0gX2FycmF5U29tZSxcbiAgICBjYWNoZUhhcyA9IF9jYWNoZUhhcztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyQzID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzJDIoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgcmV0dXJuIGFyclN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBhcnJheTtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDMpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9lcXVhbEFycmF5cyA9IGVxdWFsQXJyYXlzJDI7XG5cbnZhciByb290JDQgPSBfcm9vdDtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSQzID0gcm9vdCQ0LlVpbnQ4QXJyYXk7XG5cbnZhciBfVWludDhBcnJheSA9IFVpbnQ4QXJyYXkkMztcblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5cbmZ1bmN0aW9uIG1hcFRvQXJyYXkkMShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWFwVG9BcnJheSA9IG1hcFRvQXJyYXkkMTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIHNldFRvQXJyYXkkMShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfc2V0VG9BcnJheSA9IHNldFRvQXJyYXkkMTtcblxudmFyIFN5bWJvbCQzID0gX1N5bWJvbCxcbiAgICBVaW50OEFycmF5JDIgPSBfVWludDhBcnJheSxcbiAgICBlcSQzID0gZXFfMSxcbiAgICBlcXVhbEFycmF5cyQxID0gX2VxdWFsQXJyYXlzLFxuICAgIG1hcFRvQXJyYXkgPSBfbWFwVG9BcnJheSxcbiAgICBzZXRUb0FycmF5ID0gX3NldFRvQXJyYXk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDQgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMiA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyQxID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnJDEgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWckMSA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnJDEgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byQxID0gU3ltYm9sJDMgPyBTeW1ib2wkMy5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvJDEgPyBzeW1ib2xQcm90byQxLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWckMShvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnJDE6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheSQyKG9iamVjdCksIG5ldyBVaW50OEFycmF5JDIob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSQzKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnJDE6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZyQxOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyQ0O1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRyQyO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyQxKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWckMTpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIF9lcXVhbEJ5VGFnID0gZXF1YWxCeVRhZyQxO1xuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuXG5mdW5jdGlvbiBhcnJheVB1c2gkMihhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG52YXIgX2FycmF5UHVzaCA9IGFycmF5UHVzaCQyO1xuXG52YXIgYXJyYXlQdXNoJDEgPSBfYXJyYXlQdXNoLFxuICAgIGlzQXJyYXkkYyA9IGlzQXJyYXlfMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyQxKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheSRjKG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gkMShyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG52YXIgX2Jhc2VHZXRBbGxLZXlzID0gYmFzZUdldEFsbEtleXMkMTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cblxuZnVuY3Rpb24gYXJyYXlGaWx0ZXIkMShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9hcnJheUZpbHRlciA9IGFycmF5RmlsdGVyJDE7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBzdHViQXJyYXkkMSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG52YXIgc3R1YkFycmF5XzEgPSBzdHViQXJyYXkkMTtcblxudmFyIGFycmF5RmlsdGVyID0gX2FycmF5RmlsdGVyLFxuICAgIHN0dWJBcnJheSA9IHN0dWJBcnJheV8xO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8kNS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMkMSA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbnZhciBfZ2V0U3ltYm9scyA9IGdldFN5bWJvbHMkMTtcblxudmFyIGJhc2VHZXRBbGxLZXlzID0gX2Jhc2VHZXRBbGxLZXlzLFxuICAgIGdldFN5bWJvbHMgPSBfZ2V0U3ltYm9scyxcbiAgICBrZXlzJDEgPSBrZXlzXzE7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyQxKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzJDEsIGdldFN5bWJvbHMpO1xufVxuXG52YXIgX2dldEFsbEtleXMgPSBnZXRBbGxLZXlzJDE7XG5cbnZhciBnZXRBbGxLZXlzID0gX2dldEFsbEtleXM7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDMgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDQgPSBvYmplY3RQcm90byQ0Lmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMkMShvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5JDQuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfZXF1YWxPYmplY3RzID0gZXF1YWxPYmplY3RzJDE7XG5cbnZhciBnZXROYXRpdmUkNCA9IF9nZXROYXRpdmUsXG4gICAgcm9vdCQzID0gX3Jvb3Q7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyQxID0gZ2V0TmF0aXZlJDQocm9vdCQzLCAnRGF0YVZpZXcnKTtcblxudmFyIF9EYXRhVmlldyA9IERhdGFWaWV3JDE7XG5cbnZhciBnZXROYXRpdmUkMyA9IF9nZXROYXRpdmUsXG4gICAgcm9vdCQyID0gX3Jvb3Q7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlJDIgPSBnZXROYXRpdmUkMyhyb290JDIsICdQcm9taXNlJyk7XG5cbnZhciBfUHJvbWlzZSA9IFByb21pc2UkMjtcblxudmFyIGdldE5hdGl2ZSQyID0gX2dldE5hdGl2ZSxcbiAgICByb290JDEgPSBfcm9vdDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCQyID0gZ2V0TmF0aXZlJDIocm9vdCQxLCAnU2V0Jyk7XG5cbnZhciBfU2V0ID0gU2V0JDI7XG5cbnZhciBnZXROYXRpdmUkMSA9IF9nZXROYXRpdmUsXG4gICAgcm9vdCA9IF9yb290O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCQxID0gZ2V0TmF0aXZlJDEocm9vdCwgJ1dlYWtNYXAnKTtcblxudmFyIF9XZWFrTWFwID0gV2Vha01hcCQxO1xuXG52YXIgRGF0YVZpZXcgPSBfRGF0YVZpZXcsXG4gICAgTWFwID0gX01hcCxcbiAgICBQcm9taXNlJDEgPSBfUHJvbWlzZSxcbiAgICBTZXQkMSA9IF9TZXQsXG4gICAgV2Vha01hcCA9IF9XZWFrTWFwLFxuICAgIGJhc2VHZXRUYWckMiA9IF9iYXNlR2V0VGFnLFxuICAgIHRvU291cmNlID0gX3RvU291cmNlO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnJDIgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSQxKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0JDEpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWckMiA9IGJhc2VHZXRUYWckMjtcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWckMihuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWckMihuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UkMSAmJiBnZXRUYWckMihQcm9taXNlJDEucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQkMSAmJiBnZXRUYWckMihuZXcgU2V0JDEpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWckMihuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnJDIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnJDIodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyQyID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxudmFyIF9nZXRUYWcgPSBnZXRUYWckMjtcblxudmFyIFN0YWNrJDIgPSBfU3RhY2ssXG4gICAgZXF1YWxBcnJheXMgPSBfZXF1YWxBcnJheXMsXG4gICAgZXF1YWxCeVRhZyA9IF9lcXVhbEJ5VGFnLFxuICAgIGVxdWFsT2JqZWN0cyA9IF9lcXVhbE9iamVjdHMsXG4gICAgZ2V0VGFnJDEgPSBfZ2V0VGFnLFxuICAgIGlzQXJyYXkkYiA9IGlzQXJyYXlfMSxcbiAgICBpc0J1ZmZlciQyID0gaXNCdWZmZXJFeHBvcnRzLFxuICAgIGlzVHlwZWRBcnJheSQxID0gaXNUeXBlZEFycmF5XzE7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDIgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWckMSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDMgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcCQxKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheSRiKG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkkYihvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnJDEob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWckMShvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWckMSA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWckMSA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnJDEsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWckMSxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlciQyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyJDIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrJDIpO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5JDEob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyQyKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eSQzLmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkkMy5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2skMik7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayQyKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxudmFyIF9iYXNlSXNFcXVhbERlZXAgPSBiYXNlSXNFcXVhbERlZXAkMTtcblxudmFyIGJhc2VJc0VxdWFsRGVlcCA9IF9iYXNlSXNFcXVhbERlZXAsXG4gICAgaXNPYmplY3RMaWtlJDMgPSBpc09iamVjdExpa2VfMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwkMyh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlJDModmFsdWUpICYmICFpc09iamVjdExpa2UkMyhvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsJDMsIHN0YWNrKTtcbn1cblxudmFyIF9iYXNlSXNFcXVhbCA9IGJhc2VJc0VxdWFsJDM7XG5cbnZhciBTdGFjayQxID0gX1N0YWNrLFxuICAgIGJhc2VJc0VxdWFsJDIgPSBfYmFzZUlzRXF1YWw7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDEgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMSA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaCQxKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2skMTtcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwkMihzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHJDEgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBfYmFzZUlzTWF0Y2ggPSBiYXNlSXNNYXRjaCQxO1xuXG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0XzE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlJDIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QkNSh2YWx1ZSk7XG59XG5cbnZhciBfaXNTdHJpY3RDb21wYXJhYmxlID0gaXNTdHJpY3RDb21wYXJhYmxlJDI7XG5cbnZhciBpc1N0cmljdENvbXBhcmFibGUkMSA9IF9pc1N0cmljdENvbXBhcmFibGUsXG4gICAga2V5cyA9IGtleXNfMTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEkMShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlJDEodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2dldE1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YSQxO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUkMihrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG52YXIgX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUkMjtcblxudmFyIGJhc2VJc01hdGNoID0gX2Jhc2VJc01hdGNoLFxuICAgIGdldE1hdGNoRGF0YSA9IF9nZXRNYXRjaERhdGEsXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUkMSA9IF9tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMkMShzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQxKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG52YXIgX2Jhc2VNYXRjaGVzID0gYmFzZU1hdGNoZXMkMTtcblxudmFyIGJhc2VHZXRUYWckMSA9IF9iYXNlR2V0VGFnLFxuICAgIGlzT2JqZWN0TGlrZSQyID0gaXNPYmplY3RMaWtlXzE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCQ1KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlJDIodmFsdWUpICYmIGJhc2VHZXRUYWckMSh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxudmFyIGlzU3ltYm9sXzEgPSBpc1N5bWJvbCQ1O1xuXG52YXIgaXNBcnJheSRhID0gaXNBcnJheV8xLFxuICAgIGlzU3ltYm9sJDQgPSBpc1N5bWJvbF8xO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wJDEgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AkMSA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5JDQodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSRhKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCQ0KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wJDEudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcCQxLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxudmFyIF9pc0tleSA9IGlzS2V5JDQ7XG5cbnZhciBNYXBDYWNoZSA9IF9NYXBDYWNoZTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUkMShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZSQxLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUkMS5DYWNoZSA9IE1hcENhY2hlO1xuXG52YXIgbWVtb2l6ZV8xID0gbWVtb2l6ZSQxO1xuXG52YXIgbWVtb2l6ZSA9IG1lbW9pemVfMTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQkMShmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWVtb2l6ZUNhcHBlZCA9IG1lbW9pemVDYXBwZWQkMTtcblxudmFyIG1lbW9pemVDYXBwZWQgPSBfbWVtb2l6ZUNhcHBlZDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUkMSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyJDEgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoJDIgPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lJDEsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciQxLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxudmFyIF9zdHJpbmdUb1BhdGggPSBzdHJpbmdUb1BhdGgkMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cblxuZnVuY3Rpb24gYXJyYXlNYXAkMihhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYXJyYXlNYXAgPSBhcnJheU1hcCQyO1xuXG52YXIgU3ltYm9sJDIgPSBfU3ltYm9sLFxuICAgIGFycmF5TWFwJDEgPSBfYXJyYXlNYXAsXG4gICAgaXNBcnJheSQ5ID0gaXNBcnJheV8xLFxuICAgIGlzU3ltYm9sJDMgPSBpc1N5bWJvbF8xO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSQyID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sJDIgPyBTeW1ib2wkMi5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyQxKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkkOSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCQxKHZhbHVlLCBiYXNlVG9TdHJpbmckMSkgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wkMyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkkMikgPyAnLTAnIDogcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VUb1N0cmluZyA9IGJhc2VUb1N0cmluZyQxO1xuXG52YXIgYmFzZVRvU3RyaW5nID0gX2Jhc2VUb1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nJDUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbnZhciB0b1N0cmluZ18xID0gdG9TdHJpbmckNTtcblxudmFyIGlzQXJyYXkkOCA9IGlzQXJyYXlfMSxcbiAgICBpc0tleSQzID0gX2lzS2V5LFxuICAgIHN0cmluZ1RvUGF0aCQxID0gX3N0cmluZ1RvUGF0aCxcbiAgICB0b1N0cmluZyQ0ID0gdG9TdHJpbmdfMTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoJDModmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSQ4KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkkMyh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgkMSh0b1N0cmluZyQ0KHZhbHVlKSk7XG59XG5cbnZhciBfY2FzdFBhdGggPSBjYXN0UGF0aCQzO1xuXG52YXIgaXNTeW1ib2wkMiA9IGlzU3ltYm9sXzE7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZJDEgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSQ1KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wkMih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSQxKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbnZhciBfdG9LZXkgPSB0b0tleSQ1O1xuXG52YXIgY2FzdFBhdGgkMiA9IF9jYXN0UGF0aCxcbiAgICB0b0tleSQ0ID0gX3RvS2V5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldCQzKG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgkMihwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkkNChwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2Jhc2VHZXQgPSBiYXNlR2V0JDM7XG5cbnZhciBiYXNlR2V0JDIgPSBfYmFzZUdldDtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0JDIob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldCQyKG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxudmFyIGdldF8xID0gZ2V0JDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxuZnVuY3Rpb24gYmFzZUhhc0luJDEob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxudmFyIF9iYXNlSGFzSW4gPSBiYXNlSGFzSW4kMTtcblxudmFyIGNhc3RQYXRoJDEgPSBfY2FzdFBhdGgsXG4gICAgaXNBcmd1bWVudHMkMiA9IGlzQXJndW1lbnRzXzEsXG4gICAgaXNBcnJheSQ3ID0gaXNBcnJheV8xLFxuICAgIGlzSW5kZXgkMSA9IF9pc0luZGV4LFxuICAgIGlzTGVuZ3RoID0gaXNMZW5ndGhfMSxcbiAgICB0b0tleSQzID0gX3RvS2V5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoJDEob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aCQxKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5JDMocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgkMShrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheSQ3KG9iamVjdCkgfHwgaXNBcmd1bWVudHMkMihvYmplY3QpKTtcbn1cblxudmFyIF9oYXNQYXRoID0gaGFzUGF0aCQxO1xuXG52YXIgYmFzZUhhc0luID0gX2Jhc2VIYXNJbixcbiAgICBoYXNQYXRoID0gX2hhc1BhdGg7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4kMShvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG52YXIgaGFzSW5fMSA9IGhhc0luJDE7XG5cbnZhciBiYXNlSXNFcXVhbCQxID0gX2Jhc2VJc0VxdWFsLFxuICAgIGdldCQxID0gZ2V0XzEsXG4gICAgaGFzSW4gPSBoYXNJbl8xLFxuICAgIGlzS2V5JDIgPSBfaXNLZXksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gX2lzU3RyaWN0Q29tcGFyYWJsZSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IF9tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSxcbiAgICB0b0tleSQyID0gX3RvS2V5O1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkkMShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkkMihwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5JDIocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0JDEob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsJDEoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG52YXIgX2Jhc2VNYXRjaGVzUHJvcGVydHkgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5JDE7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5cbmZ1bmN0aW9uIGlkZW50aXR5JDQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgaWRlbnRpdHlfMSA9IGlkZW50aXR5JDQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkkMShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG52YXIgX2Jhc2VQcm9wZXJ0eSA9IGJhc2VQcm9wZXJ0eSQxO1xuXG52YXIgYmFzZUdldCQxID0gX2Jhc2VHZXQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcCQxKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0JDEob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxudmFyIF9iYXNlUHJvcGVydHlEZWVwID0gYmFzZVByb3BlcnR5RGVlcCQxO1xuXG52YXIgYmFzZVByb3BlcnR5ID0gX2Jhc2VQcm9wZXJ0eSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gX2Jhc2VQcm9wZXJ0eURlZXAsXG4gICAgaXNLZXkkMSA9IF9pc0tleSxcbiAgICB0b0tleSQxID0gX3RvS2V5O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5JDEocGF0aCkge1xuICByZXR1cm4gaXNLZXkkMShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleSQxKHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbnZhciBwcm9wZXJ0eV8xID0gcHJvcGVydHkkMTtcblxudmFyIGJhc2VNYXRjaGVzID0gX2Jhc2VNYXRjaGVzLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSBfYmFzZU1hdGNoZXNQcm9wZXJ0eSxcbiAgICBpZGVudGl0eSQzID0gaWRlbnRpdHlfMSxcbiAgICBpc0FycmF5JDYgPSBpc0FycmF5XzEsXG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eV8xO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUkNSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHkkMztcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkkNih2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG52YXIgX2Jhc2VJdGVyYXRlZSA9IGJhc2VJdGVyYXRlZSQ1O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuXG5mdW5jdGlvbiBiYXNlUmVkdWNlJDEoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG52YXIgX2Jhc2VSZWR1Y2UgPSBiYXNlUmVkdWNlJDE7XG5cbnZhciBhcnJheVJlZHVjZSQxID0gX2FycmF5UmVkdWNlLFxuICAgIGJhc2VFYWNoJDIgPSBfYmFzZUVhY2gsXG4gICAgYmFzZUl0ZXJhdGVlJDQgPSBfYmFzZUl0ZXJhdGVlLFxuICAgIGJhc2VSZWR1Y2UgPSBfYmFzZVJlZHVjZSxcbiAgICBpc0FycmF5JDUgPSBpc0FycmF5XzE7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAqIGFuZCBgc29ydEJ5YFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICogICByZXR1cm4gc3VtICsgbjtcbiAqIH0sIDApO1xuICogLy8gPT4gM1xuICpcbiAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkkNShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlJDEgOiBiYXNlUmVkdWNlLFxuICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlJDQoaXRlcmF0ZWUpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCQyKTtcbn1cblxudmFyIHJlZHVjZV8xID0gcmVkdWNlO1xuXG52YXIgcmVkdWNlJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocmVkdWNlXzEpO1xuXG52YXIgZ2xvYmFsJDEgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gICAgICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcblxudmFyIGxvb2t1cCA9IFtdO1xudmFyIHJldkxvb2t1cCA9IFtdO1xudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbnZhciBpbml0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluaXQgKCkge1xuICBpbml0ZWQgPSB0cnVlO1xuICB2YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIHJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MjtcbiAgcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzO1xufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIGlmICghaW5pdGVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aDtcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcGxhY2VIb2xkZXJzID0gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMDtcblxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7XG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW47XG5cbiAgdmFyIEwgPSAwO1xuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCk7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKTtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wO1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgdG1wO1xuICB2YXIgbGVuID0gdWludDgubGVuZ3RoO1xuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKTtcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gJz09JztcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKTtcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9JztcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KTtcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IC03O1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwO1xuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7XG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmZ1bmN0aW9uIHdyaXRlIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYztcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCk7XG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSk7XG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMTtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufVxuXG52YXIgdG9TdHJpbmckMyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgaXNBcnJheSQ0ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZyQzLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWU7XG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmtNYXhMZW5ndGgoKTtcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIHJldHVybiBhcnJcbn07XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufTtcblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7XG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikgO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn07XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKTtcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5JDQob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5CdWZmZXIuaXNCdWZmZXIgPSBpc0J1ZmZlciQxO1xuZnVuY3Rpb24gaW50ZXJuYWxJc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGEpIHx8ICFpbnRlcm5hbElzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn07XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5JDQobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhciBwb3MgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufTtcblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMDtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl07XG4gIGJbbl0gPSBiW21dO1xuICBiW21dID0gaTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDA7XG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTO1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJztcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDA7XG4gIGVuZCA+Pj49IDA7XG4gIHRoaXNTdGFydCA+Pj49IDA7XG4gIHRoaXNFbmQgPj4+PSAwO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMTtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgdmFsTGVuZ3RoIC89IDI7XG4gICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59O1xuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gIHZhciByZXMgPSBbXTtcblxuICB2YXIgaSA9IHN0YXJ0O1xuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxO1xuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7XG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwO1xuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pO1xuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBzdGFydCA9IH5+c3RhcnQ7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbjtcbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIHZhciBuZXdCdWY7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59O1xuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgdmFyIG11bCA9IDE7XG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufTtcblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBpO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGVuXG59O1xuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG4gIGlmICghdmFsKSB2YWwgPSAwO1xuXG4gIHZhciBpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSk7XG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpO1xuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSc7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gIHZhciBjb2RlUG9pbnQ7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvO1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGkgPSBjID4+IDg7XG4gICAgbG8gPSBjICUgMjU2O1xuICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiB0b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG4vLyB0aGUgZm9sbG93aW5nIGlzIGZyb20gaXMtYnVmZmVyLCBhbHNvIGJ5IEZlcm9zcyBBYm91a2hhZGlqZWggYW5kIHdpdGggc2FtZSBsaXNlbmNlXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5mdW5jdGlvbiBpc0J1ZmZlciQxKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKCEhb2JqLl9pc0J1ZmZlciB8fCBpc0Zhc3RCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSlcbn1cblxuZnVuY3Rpb24gaXNGYXN0QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNGYXN0QnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cblxuLy8gTG9kYXNoIGltcGxlbWVudGF0aW9uIG9mIGBnZXRgXG5cbmNvbnN0IGNoYXJDb2RlT2ZEb3QgPSBcIi5cIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5jb25zdCByZVByb3BOYW1lID0gUmVnRXhwKFxuICAvLyBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgZG90IG9yIGJyYWNrZXQuXG4gIFwiW14uW1xcXFxdXStcIiArXG4gICAgXCJ8XCIgK1xuICAgIC8vIE9yIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBicmFja2V0cy5cbiAgICBcIlxcXFxbKD86XCIgK1xuICAgIC8vIE1hdGNoIGEgbm9uLXN0cmluZyBleHByZXNzaW9uLlxuICAgIFwiKFteXFxcIiddW15bXSopXCIgK1xuICAgIFwifFwiICtcbiAgICAvLyBPciBtYXRjaCBzdHJpbmdzIChzdXBwb3J0cyBlc2NhcGluZyBjaGFyYWN0ZXJzKS5cbiAgICBcIihbXFxcIiddKSgoPzooPyFcXFxcMilbXlxcXFxcXFxcXXxcXFxcXFxcXC4pKj8pXFxcXDJcIiArXG4gICAgXCIpXFxcXF1cIiArXG4gICAgXCJ8XCIgK1xuICAgIC8vIE9yIG1hdGNoIFwiXCIgYXMgdGhlIHNwYWNlIGJldHdlZW4gY29uc2VjdXRpdmUgZG90cyBvciBlbXB0eSBicmFja2V0cy5cbiAgICBcIig/PSg/OlxcXFwufFxcXFxbXFxcXF0pKD86XFxcXC58XFxcXFtcXFxcXXwkKSlcIixcbiAgXCJnXCIsXG4pO1xuY29uc3QgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLztcbmNvbnN0IHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuY29uc3QgZ2V0VGFnID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xufTtcblxuY29uc3QgaXNTeW1ib2wkMSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKFxuICAgIHR5cGUgPT09IFwic3ltYm9sXCIgfHxcbiAgICAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAmJiBnZXRUYWcodmFsdWUpID09PSBcIltvYmplY3QgU3ltYm9sXVwiKVxuICApO1xufTtcblxuY29uc3QgaXNLZXkgPSBmdW5jdGlvbiAodmFsdWUsIG9iamVjdCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKFxuICAgIHR5cGUgPT09IFwibnVtYmVyXCIgfHxcbiAgICB0eXBlID09PSBcInN5bWJvbFwiIHx8XG4gICAgdHlwZSA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAhdmFsdWUgfHxcbiAgICBpc1N5bWJvbCQxKHZhbHVlKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKVxuICApO1xufTtcblxuY29uc3Qgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gKHN0cmluZykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSBjaGFyQ29kZU9mRG90KSB7XG4gICAgcmVzdWx0LnB1c2goXCJcIik7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBleHByZXNzaW9uLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgbGV0IGtleSA9IG1hdGNoO1xuICAgIGlmIChxdW90ZSkge1xuICAgICAga2V5ID0gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCBcIiQxXCIpO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbikge1xuICAgICAga2V5ID0gZXhwcmVzc2lvbi50cmltKCk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY2FzdFBhdGggPSBmdW5jdGlvbiAodmFsdWUsIG9iamVjdCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG4gIH1cbn07XG5cbmNvbnN0IHRvS2V5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgaXNTeW1ib2wkMSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgY29uc3QgcmVzdWx0ID0gYCR7dmFsdWV9YDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHJldHVybiByZXN1bHQgPT0gXCIwXCIgJiYgMSAvIHZhbHVlID09IC1JTkZJTklUWSA/IFwiLTBcIiA6IHJlc3VsdDtcbn07XG5cbmNvbnN0IGdldCA9IGZ1bmN0aW9uIChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiBpbmRleCAmJiBpbmRleCA9PT0gbGVuZ3RoID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufTtcblxuY29uc3QgaXNfb2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZV9jb2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbnMpIHtcbiAgaWYgKGNvbHVtbnMgPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5zID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gIH1cbiAgaWYgKHR5cGVvZiBjb2x1bW5zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIFtFcnJvcignSW52YWxpZCBvcHRpb24gXCJjb2x1bW5zXCI6IGV4cGVjdCBhbiBhcnJheSBvciBhbiBvYmplY3QnKV07XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbHVtbnMpKSB7XG4gICAgY29uc3QgbmV3Y29sdW1ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgayBpbiBjb2x1bW5zKSB7XG4gICAgICBuZXdjb2x1bW5zLnB1c2goe1xuICAgICAgICBrZXk6IGssXG4gICAgICAgIGhlYWRlcjogY29sdW1uc1trXSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb2x1bW5zID0gbmV3Y29sdW1ucztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuZXdjb2x1bW5zID0gW107XG4gICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgICAgaWYgKHR5cGVvZiBjb2x1bW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmV3Y29sdW1ucy5wdXNoKHtcbiAgICAgICAgICBrZXk6IGNvbHVtbixcbiAgICAgICAgICBoZWFkZXI6IGNvbHVtbixcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2YgY29sdW1uID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGNvbHVtbiAhPT0gbnVsbCAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShjb2x1bW4pXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFjb2x1bW4ua2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEVycm9yKCdJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiBwcm9wZXJ0eSBcImtleVwiIGlzIHJlcXVpcmVkJyksXG4gICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uLmhlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29sdW1uLmhlYWRlciA9IGNvbHVtbi5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Y29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIEVycm9yKFwiSW52YWxpZCBjb2x1bW4gZGVmaW5pdGlvbjogZXhwZWN0IGEgc3RyaW5nIG9yIGFuIG9iamVjdFwiKSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29sdW1ucyA9IG5ld2NvbHVtbnM7XG4gIH1cbiAgcmV0dXJuIFt1bmRlZmluZWQsIGNvbHVtbnNdO1xufTtcblxuY2xhc3MgQ3N2RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIC4uLmNvbnRleHRzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIG1lc3NhZ2UgPSBtZXNzYWdlLmpvaW4oXCIgXCIpO1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDc3ZFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgZm9yIChjb25zdCBjb250ZXh0IG9mIGNvbnRleHRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dFtrZXldO1xuICAgICAgICB0aGlzW2tleV0gPSBpc0J1ZmZlciQxKHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgIDogdmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHVuZGVyc2NvcmUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoXywgbWF0Y2gpIHtcbiAgICByZXR1cm4gXCJfXCIgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZV9vcHRpb25zID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAvLyBNZXJnZSB3aXRoIHVzZXIgb3B0aW9uc1xuICBmb3IgKGNvbnN0IG9wdCBpbiBvcHRzKSB7XG4gICAgb3B0aW9uc1t1bmRlcnNjb3JlKG9wdCldID0gb3B0c1tvcHRdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGJvbWBcbiAgaWYgKFxuICAgIG9wdGlvbnMuYm9tID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLmJvbSA9PT0gbnVsbCB8fFxuICAgIG9wdGlvbnMuYm9tID09PSBmYWxzZVxuICApIHtcbiAgICBvcHRpb25zLmJvbSA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuYm9tICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fQk9PTEVBTl9JTlZBTElEX1RZUEVcIiwgW1xuICAgICAgICBcIm9wdGlvbiBgYm9tYCBpcyBvcHRpb25hbCBhbmQgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWUsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvbSl9YCxcbiAgICAgIF0pLFxuICAgIF07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZGVsaW1pdGVyYFxuICBpZiAob3B0aW9ucy5kZWxpbWl0ZXIgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmRlbGltaXRlciA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gXCIsXCI7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIkMShvcHRpb25zLmRlbGltaXRlcikpIHtcbiAgICBvcHRpb25zLmRlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fREVMSU1JVEVSX0lOVkFMSURfVFlQRVwiLCBbXG4gICAgICAgIFwib3B0aW9uIGBkZWxpbWl0ZXJgIG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmRlbGltaXRlcil9YCxcbiAgICAgIF0pLFxuICAgIF07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVgXG4gIGlmIChvcHRpb25zLnF1b3RlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMucXVvdGUgPSAnXCInO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMucXVvdGUgPT09IHRydWUpIHtcbiAgICBvcHRpb25zLnF1b3RlID0gJ1wiJztcbiAgfSBlbHNlIGlmIChvcHRpb25zLnF1b3RlID09PSBmYWxzZSkge1xuICAgIG9wdGlvbnMucXVvdGUgPSBcIlwiO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyJDEob3B0aW9ucy5xdW90ZSkpIHtcbiAgICBvcHRpb25zLnF1b3RlID0gb3B0aW9ucy5xdW90ZS50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnF1b3RlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fUVVPVEVfSU5WQUxJRF9UWVBFXCIsIFtcbiAgICAgICAgXCJvcHRpb24gYHF1b3RlYCBtdXN0IGJlIGEgYm9vbGVhbiwgYSBidWZmZXIgb3IgYSBzdHJpbmcsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnF1b3RlKX1gLFxuICAgICAgXSksXG4gICAgXTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWRgXG4gIGlmIChvcHRpb25zLnF1b3RlZCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGVkID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy5xdW90ZWQgPSBmYWxzZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBlc2NhcGVfZm9ybXVsYXNgXG4gIGlmIChcbiAgICBvcHRpb25zLmVzY2FwZV9mb3JtdWxhcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgPT09IG51bGxcbiAgKSB7XG4gICAgb3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgPSBmYWxzZTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fRVNDQVBFX0ZPUk1VTEFTX0lOVkFMSURfVFlQRVwiLCBbXG4gICAgICAgIFwib3B0aW9uIGBlc2NhcGVfZm9ybXVsYXNgIG11c3QgYmUgYSBib29sZWFuLFwiLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMpfWAsXG4gICAgICBdKSxcbiAgICBdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHF1b3RlZF9lbXB0eWBcbiAgaWYgKG9wdGlvbnMucXVvdGVkX2VtcHR5ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZWRfZW1wdHkgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLnF1b3RlZF9lbXB0eSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWRfbWF0Y2hgXG4gIGlmIChcbiAgICBvcHRpb25zLnF1b3RlZF9tYXRjaCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5xdW90ZWRfbWF0Y2ggPT09IG51bGwgfHxcbiAgICBvcHRpb25zLnF1b3RlZF9tYXRjaCA9PT0gZmFsc2VcbiAgKSB7XG4gICAgb3B0aW9ucy5xdW90ZWRfbWF0Y2ggPSBudWxsO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMucXVvdGVkX21hdGNoKSkge1xuICAgIG9wdGlvbnMucXVvdGVkX21hdGNoID0gW29wdGlvbnMucXVvdGVkX21hdGNoXTtcbiAgfVxuICBpZiAob3B0aW9ucy5xdW90ZWRfbWF0Y2gpIHtcbiAgICBmb3IgKGNvbnN0IHF1b3RlZF9tYXRjaCBvZiBvcHRpb25zLnF1b3RlZF9tYXRjaCkge1xuICAgICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgcXVvdGVkX21hdGNoID09PSBcInN0cmluZ1wiO1xuICAgICAgY29uc3QgaXNSZWdFeHAgPSBxdW90ZWRfbWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICBpZiAoIWlzU3RyaW5nICYmICFpc1JlZ0V4cCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgT3B0aW9uOiBxdW90ZWRfbWF0Y2ggbXVzdCBiZSBhIHN0cmluZyBvciBhIHJlZ2V4LCBnb3QgJHtKU09OLnN0cmluZ2lmeShxdW90ZWRfbWF0Y2gpfWAsXG4gICAgICAgICAgKSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVkX3N0cmluZ2BcbiAgaWYgKG9wdGlvbnMucXVvdGVkX3N0cmluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGVkX3N0cmluZyA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMucXVvdGVkX3N0cmluZyA9IGZhbHNlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGVvZmBcbiAgaWYgKG9wdGlvbnMuZW9mID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5lb2YgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLmVvZiA9IHRydWU7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZXNjYXBlYFxuICBpZiAob3B0aW9ucy5lc2NhcGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmVzY2FwZSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuZXNjYXBlID0gJ1wiJztcbiAgfSBlbHNlIGlmIChpc0J1ZmZlciQxKG9wdGlvbnMuZXNjYXBlKSkge1xuICAgIG9wdGlvbnMuZXNjYXBlID0gb3B0aW9ucy5lc2NhcGUudG9TdHJpbmcoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lc2NhcGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIE9wdGlvbjogZXNjYXBlIG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuZXNjYXBlKX1gLFxuICAgICAgKSxcbiAgICBdO1xuICB9XG4gIGlmIChvcHRpb25zLmVzY2FwZS5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIEVycm9yKFxuICAgICAgICBgSW52YWxpZCBPcHRpb246IGVzY2FwZSBtdXN0IGJlIG9uZSBjaGFyYWN0ZXIsIGdvdCAke29wdGlvbnMuZXNjYXBlLmxlbmd0aH0gY2hhcmFjdGVyc2AsXG4gICAgICApLFxuICAgIF07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgaGVhZGVyYFxuICBpZiAob3B0aW9ucy5oZWFkZXIgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmhlYWRlciA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuaGVhZGVyID0gZmFsc2U7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgY29sdW1uc2BcbiAgY29uc3QgW2VyckNvbHVtbnMsIGNvbHVtbnNdID0gbm9ybWFsaXplX2NvbHVtbnMob3B0aW9ucy5jb2x1bW5zKTtcbiAgaWYgKGVyckNvbHVtbnMgIT09IHVuZGVmaW5lZCkgcmV0dXJuIFtlcnJDb2x1bW5zXTtcbiAgb3B0aW9ucy5jb2x1bW5zID0gY29sdW1ucztcbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVkYFxuICBpZiAob3B0aW9ucy5xdW90ZWQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnF1b3RlZCA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMucXVvdGVkID0gZmFsc2U7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgY2FzdGBcbiAgaWYgKG9wdGlvbnMuY2FzdCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdCA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuY2FzdCA9IHt9O1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5iaWdpbnRcbiAgaWYgKG9wdGlvbnMuY2FzdC5iaWdpbnQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3QuYmlnaW50ID09PSBudWxsKSB7XG4gICAgLy8gQ2FzdCBib29sZWFuIHRvIHN0cmluZyBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0LmJpZ2ludCA9ICh2YWx1ZSkgPT4gXCJcIiArIHZhbHVlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5ib29sZWFuXG4gIGlmIChvcHRpb25zLmNhc3QuYm9vbGVhbiA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5ib29sZWFuID09PSBudWxsKSB7XG4gICAgLy8gQ2FzdCBib29sZWFuIHRvIHN0cmluZyBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0LmJvb2xlYW4gPSAodmFsdWUpID0+ICh2YWx1ZSA/IFwiMVwiIDogXCJcIik7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBjYXN0LmRhdGVcbiAgaWYgKG9wdGlvbnMuY2FzdC5kYXRlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0LmRhdGUgPT09IG51bGwpIHtcbiAgICAvLyBDYXN0IGRhdGUgdG8gdGltZXN0YW1wIHN0cmluZyBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0LmRhdGUgPSAodmFsdWUpID0+IFwiXCIgKyB2YWx1ZS5nZXRUaW1lKCk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBjYXN0Lm51bWJlclxuICBpZiAob3B0aW9ucy5jYXN0Lm51bWJlciA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5udW1iZXIgPT09IG51bGwpIHtcbiAgICAvLyBDYXN0IG51bWJlciB0byBzdHJpbmcgdXNpbmcgbmF0aXZlIGNhc3RpbmcgYnkgZGVmYXVsdFxuICAgIG9wdGlvbnMuY2FzdC5udW1iZXIgPSAodmFsdWUpID0+IFwiXCIgKyB2YWx1ZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGNhc3Qub2JqZWN0XG4gIGlmIChvcHRpb25zLmNhc3Qub2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0Lm9iamVjdCA9PT0gbnVsbCkge1xuICAgIC8vIFN0cmluZ2lmeSBvYmplY3QgYXMgSlNPTiBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0Lm9iamVjdCA9ICh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5zdHJpbmdcbiAgaWYgKG9wdGlvbnMuY2FzdC5zdHJpbmcgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3Quc3RyaW5nID09PSBudWxsKSB7XG4gICAgLy8gTGVhdmUgc3RyaW5nIHVudG91Y2hlZFxuICAgIG9wdGlvbnMuY2FzdC5zdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYG9uX3JlY29yZGBcbiAgaWYgKFxuICAgIG9wdGlvbnMub25fcmVjb3JkICE9PSB1bmRlZmluZWQgJiZcbiAgICB0eXBlb2Ygb3B0aW9ucy5vbl9yZWNvcmQgIT09IFwiZnVuY3Rpb25cIlxuICApIHtcbiAgICByZXR1cm4gW0Vycm9yKGBJbnZhbGlkIE9wdGlvbjogXCJvbl9yZWNvcmRcIiBtdXN0IGJlIGEgZnVuY3Rpb24uYCldO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHJlY29yZF9kZWxpbWl0ZXJgXG4gIGlmIChcbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9PT0gbnVsbFxuICApIHtcbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBcIlxcblwiO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyJDEob3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyKSkge1xuICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IG9wdGlvbnMucmVjb3JkX2RlbGltaXRlci50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIE9wdGlvbjogcmVjb3JkX2RlbGltaXRlciBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpfWAsXG4gICAgICApLFxuICAgIF07XG4gIH1cbiAgc3dpdGNoIChvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpIHtcbiAgICBjYXNlIFwidW5peFwiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXG5cIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtYWNcIjpcbiAgICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFwiXFxyXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwid2luZG93c1wiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXHJcXG5cIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXHUwMDFlXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidW5pY29kZVwiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXHUyMDI4XCI7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gW3VuZGVmaW5lZCwgb3B0aW9uc107XG59O1xuXG5jb25zdCBib21fdXRmOCA9IEJ1ZmZlci5mcm9tKFsyMzksIDE4NywgMTkxXSk7XG5cbmNvbnN0IHN0cmluZ2lmaWVyID0gZnVuY3Rpb24gKG9wdGlvbnMsIHN0YXRlLCBpbmZvKSB7XG4gIHJldHVybiB7XG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgaW5mbzogaW5mbyxcbiAgICBfX3RyYW5zZm9ybTogZnVuY3Rpb24gKGNodW5rLCBwdXNoKSB7XG4gICAgICAvLyBDaHVuayB2YWxpZGF0aW9uXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgUmVjb3JkOiBleHBlY3QgYW4gYXJyYXkgb3IgYW4gb2JqZWN0LCBnb3QgJHtKU09OLnN0cmluZ2lmeShjaHVuayl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBjb2x1bW5zIGZyb20gdGhlIGZpcnN0IHJlY29yZFxuICAgICAgaWYgKHRoaXMuaW5mby5yZWNvcmRzID09PSAwKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNodW5rKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oZWFkZXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb2x1bW5zID09PSB1bmRlZmluZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcihcbiAgICAgICAgICAgICAgXCJVbmRpc2NvdmVyYWJsZSBDb2x1bW5zOiBoZWFkZXIgb3B0aW9uIHJlcXVpcmVzIGNvbHVtbiBvcHRpb24gb3Igb2JqZWN0IHJlY29yZHNcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb2x1bW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBbZXJyLCBjb2x1bW5zXSA9IG5vcm1hbGl6ZV9jb2x1bW5zKE9iamVjdC5rZXlzKGNodW5rKSk7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5jb2x1bW5zID0gY29sdW1ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRW1pdCB0aGUgaGVhZGVyXG4gICAgICBpZiAodGhpcy5pbmZvLnJlY29yZHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5ib20ocHVzaCk7XG4gICAgICAgIGNvbnN0IGVyciA9IHRoaXMuaGVhZGVycyhwdXNoKTtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIC8vIEVtaXQgYW5kIHN0cmluZ2lmeSB0aGUgcmVjb3JkIGlmIGFuIG9iamVjdCBvciBhbiBhcnJheVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdGhpcy5lbWl0KCdyZWNvcmQnLCBjaHVuaywgdGhpcy5pbmZvLnJlY29yZHMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uX3JlY29yZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbl9yZWNvcmQoY2h1bmssIHRoaXMuaW5mby5yZWNvcmRzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICAvLyBDb252ZXJ0IHRoZSByZWNvcmQgaW50byBhIHN0cmluZ1xuICAgICAgbGV0IGVyciwgY2h1bmtfc3RyaW5nO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lb2YpIHtcbiAgICAgICAgW2VyciwgY2h1bmtfc3RyaW5nXSA9IHRoaXMuc3RyaW5naWZ5KGNodW5rKTtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGVycjtcbiAgICAgICAgaWYgKGNodW5rX3N0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNodW5rX3N0cmluZyA9IGNodW5rX3N0cmluZyArIHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbZXJyLCBjaHVua19zdHJpbmddID0gdGhpcy5zdHJpbmdpZnkoY2h1bmspO1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gZXJyO1xuICAgICAgICBpZiAoY2h1bmtfc3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXIgfHwgdGhpcy5pbmZvLnJlY29yZHMpIHtcbiAgICAgICAgICAgIGNodW5rX3N0cmluZyA9IHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyICsgY2h1bmtfc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRW1pdCB0aGUgY3N2XG4gICAgICB0aGlzLmluZm8ucmVjb3JkcysrO1xuICAgICAgcHVzaChjaHVua19zdHJpbmcpO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2h1bmssIGNodW5rSXNIZWFkZXIgPSBmYWxzZSkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgY2h1bmtdO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjb2x1bW5zIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCByZWNvcmQgPSBbXTtcbiAgICAgIC8vIFJlY29yZCBpcyBhbiBhcnJheVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2h1bmspKSB7XG4gICAgICAgIC8vIFdlIGFyZSBnZXR0aW5nIGFuIGFycmF5IGJ1dCB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIG91dHB1dCBjb2x1bW5zLiBJblxuICAgICAgICAvLyB0aGlzIGNhc2UsIHdlIHJlc3BlY3QgdGhlIGNvbHVtbnMgaW5kZXhlc1xuICAgICAgICBpZiAoY29sdW1ucykge1xuICAgICAgICAgIGNodW5rLnNwbGljZShjb2x1bW5zLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FzdCByZWNvcmQgZWxlbWVudHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkID0gY2h1bmtbaV07XG4gICAgICAgICAgY29uc3QgW2VyciwgdmFsdWVdID0gdGhpcy5fX2Nhc3QoZmllbGQsIHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgY29sdW1uOiBpLFxuICAgICAgICAgICAgcmVjb3JkczogdGhpcy5pbmZvLnJlY29yZHMsXG4gICAgICAgICAgICBoZWFkZXI6IGNodW5rSXNIZWFkZXIsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIFtlcnJdO1xuICAgICAgICAgIHJlY29yZFtpXSA9IFt2YWx1ZSwgZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY29yZCBpcyBhIGxpdGVyYWwgb2JqZWN0XG4gICAgICAgIC8vIGBjb2x1bW5zYCBpcyBhbHdheXMgZGVmaW5lZDogaXQgaXMgZWl0aGVyIHByb3ZpZGVkIG9yIGRpc2NvdmVyZWQuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChjaHVuaywgY29sdW1uc1tpXS5rZXkpO1xuICAgICAgICAgIGNvbnN0IFtlcnIsIHZhbHVlXSA9IHRoaXMuX19jYXN0KGZpZWxkLCB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uc1tpXS5rZXksXG4gICAgICAgICAgICByZWNvcmRzOiB0aGlzLmluZm8ucmVjb3JkcyxcbiAgICAgICAgICAgIGhlYWRlcjogY2h1bmtJc0hlYWRlcixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gW2Vycl07XG4gICAgICAgICAgcmVjb3JkW2ldID0gW3ZhbHVlLCBmaWVsZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjc3ZyZWNvcmQgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvcmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG9wdGlvbnMsIGVycjtcblxuICAgICAgICBsZXQgW3ZhbHVlLCBmaWVsZF0gPSByZWNvcmRbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX29iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICBvcHRpb25zID0gdmFsdWU7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnZhbHVlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgSW52YWxpZCBDYXN0aW5nIFZhbHVlOiByZXR1cm5lZCB2YWx1ZSBtdXN0IHJldHVybiBhIHN0cmluZywgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgIFtlcnIsIG9wdGlvbnNdID0gbm9ybWFsaXplX29wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Vycl07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgQ2FzdGluZyBWYWx1ZTogcmV0dXJuZWQgdmFsdWUgbXVzdCByZXR1cm4gYSBzdHJpbmcsIGFuIG9iamVjdCwgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkZWxpbWl0ZXIsXG4gICAgICAgICAgZXNjYXBlLFxuICAgICAgICAgIHF1b3RlLFxuICAgICAgICAgIHF1b3RlZCxcbiAgICAgICAgICBxdW90ZWRfZW1wdHksXG4gICAgICAgICAgcXVvdGVkX3N0cmluZyxcbiAgICAgICAgICBxdW90ZWRfbWF0Y2gsXG4gICAgICAgICAgcmVjb3JkX2RlbGltaXRlcixcbiAgICAgICAgICBlc2NhcGVfZm9ybXVsYXMsXG4gICAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoXCJcIiA9PT0gdmFsdWUgJiYgXCJcIiA9PT0gZmllbGQpIHtcbiAgICAgICAgICBsZXQgcXVvdGVkTWF0Y2ggPVxuICAgICAgICAgICAgcXVvdGVkX21hdGNoICYmXG4gICAgICAgICAgICBxdW90ZWRfbWF0Y2guZmlsdGVyKChxdW90ZWRfbWF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxdW90ZWRfbWF0Y2ggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihxdW90ZWRfbWF0Y2gpICE9PSAtMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGVkX21hdGNoLnRlc3QodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBxdW90ZWRNYXRjaCA9IHF1b3RlZE1hdGNoICYmIHF1b3RlZE1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkUXVvdGUgPVxuICAgICAgICAgICAgcXVvdGVkTWF0Y2ggfHxcbiAgICAgICAgICAgIHRydWUgPT09IHF1b3RlZF9lbXB0eSB8fFxuICAgICAgICAgICAgKHRydWUgPT09IHF1b3RlZF9zdHJpbmcgJiYgZmFsc2UgIT09IHF1b3RlZF9lbXB0eSk7XG4gICAgICAgICAgaWYgKHNob3VsZFF1b3RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHF1b3RlICsgdmFsdWUgKyBxdW90ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3N2cmVjb3JkICs9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEZvcm1hdHRlciBtdXN0IHJldHVybiBhIHN0cmluZywgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29udGFpbnNkZWxpbWl0ZXIgPVxuICAgICAgICAgICAgZGVsaW1pdGVyLmxlbmd0aCAmJiB2YWx1ZS5pbmRleE9mKGRlbGltaXRlcikgPj0gMDtcbiAgICAgICAgICBjb25zdCBjb250YWluc1F1b3RlID0gcXVvdGUgIT09IFwiXCIgJiYgdmFsdWUuaW5kZXhPZihxdW90ZSkgPj0gMDtcbiAgICAgICAgICBjb25zdCBjb250YWluc0VzY2FwZSA9IHZhbHVlLmluZGV4T2YoZXNjYXBlKSA+PSAwICYmIGVzY2FwZSAhPT0gcXVvdGU7XG4gICAgICAgICAgY29uc3QgY29udGFpbnNSZWNvcmREZWxpbWl0ZXIgPSB2YWx1ZS5pbmRleE9mKHJlY29yZF9kZWxpbWl0ZXIpID49IDA7XG4gICAgICAgICAgY29uc3QgcXVvdGVkU3RyaW5nID0gcXVvdGVkX3N0cmluZyAmJiB0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgbGV0IHF1b3RlZE1hdGNoID1cbiAgICAgICAgICAgIHF1b3RlZF9tYXRjaCAmJlxuICAgICAgICAgICAgcXVvdGVkX21hdGNoLmZpbHRlcigocXVvdGVkX21hdGNoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcXVvdGVkX21hdGNoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmluZGV4T2YocXVvdGVkX21hdGNoKSAhPT0gLTE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1b3RlZF9tYXRjaC50ZXN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgcXVvdGVkTWF0Y2ggPSBxdW90ZWRNYXRjaCAmJiBxdW90ZWRNYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYWRhbHRhcy9ub2RlLWNzdi9wdWxsLzM4N1xuICAgICAgICAgIC8vIE1vcmUgYWJvdXQgQ1NWIGluamVjdGlvbiBvciBmb3JtdWxhIGluamVjdGlvbiwgd2hlbiB3ZWJzaXRlcyBlbWJlZFxuICAgICAgICAgIC8vIHVudHJ1c3RlZCBpbnB1dCBpbnNpZGUgQ1NWIGZpbGVzOlxuICAgICAgICAgIC8vIGh0dHBzOi8vb3dhc3Aub3JnL3d3dy1jb21tdW5pdHkvYXR0YWNrcy9DU1ZfSW5qZWN0aW9uXG4gICAgICAgICAgLy8gaHR0cDovL2dlb3JnZW1hdWVyLm5ldC8yMDE3LzEwLzA3L2Nzdi1pbmplY3Rpb24uaHRtbFxuICAgICAgICAgIC8vIEFwcGxlIE51bWJlcnMgdW5pY29kZSBub3JtYWxpemF0aW9uIGlzIGVtcGlyaWNhbCBmcm9tIHRlc3RpbmdcbiAgICAgICAgICBpZiAoZXNjYXBlX2Zvcm11bGFzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJAXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYxRFwiOiAvLyBVbmljb2RlICc9J1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYwQlwiOiAvLyBVbmljb2RlICcrJ1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYwRFwiOiAvLyBVbmljb2RlICctJ1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYyMFwiOiAvLyBVbmljb2RlICdAJ1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYCcke3ZhbHVlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNob3VsZFF1b3RlID1cbiAgICAgICAgICAgIGNvbnRhaW5zUXVvdGUgPT09IHRydWUgfHxcbiAgICAgICAgICAgIGNvbnRhaW5zZGVsaW1pdGVyIHx8XG4gICAgICAgICAgICBjb250YWluc1JlY29yZERlbGltaXRlciB8fFxuICAgICAgICAgICAgcXVvdGVkIHx8XG4gICAgICAgICAgICBxdW90ZWRTdHJpbmcgfHxcbiAgICAgICAgICAgIHF1b3RlZE1hdGNoO1xuICAgICAgICAgIGlmIChzaG91bGRRdW90ZSA9PT0gdHJ1ZSAmJiBjb250YWluc0VzY2FwZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXhwID1cbiAgICAgICAgICAgICAgZXNjYXBlID09PSBcIlxcXFxcIlxuICAgICAgICAgICAgICAgID8gbmV3IFJlZ0V4cChlc2NhcGUgKyBlc2NhcGUsIFwiZ1wiKVxuICAgICAgICAgICAgICAgIDogbmV3IFJlZ0V4cChlc2NhcGUsIFwiZ1wiKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZWdleHAsIGVzY2FwZSArIGVzY2FwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb250YWluc1F1b3RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKHF1b3RlLCBcImdcIik7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVnZXhwLCBlc2NhcGUgKyBxdW90ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGRRdW90ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBxdW90ZSArIHZhbHVlICsgcXVvdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNzdnJlY29yZCArPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBxdW90ZWRfZW1wdHkgPT09IHRydWUgfHxcbiAgICAgICAgICAoZmllbGQgPT09IFwiXCIgJiYgcXVvdGVkX3N0cmluZyA9PT0gdHJ1ZSAmJiBxdW90ZWRfZW1wdHkgIT09IGZhbHNlKVxuICAgICAgICApIHtcbiAgICAgICAgICBjc3ZyZWNvcmQgKz0gcXVvdGUgKyBxdW90ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAhPT0gcmVjb3JkLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjc3ZyZWNvcmQgKz0gZGVsaW1pdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW3VuZGVmaW5lZCwgY3N2cmVjb3JkXTtcbiAgICB9LFxuICAgIGJvbTogZnVuY3Rpb24gKHB1c2gpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm9tICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHB1c2goYm9tX3V0ZjgpO1xuICAgIH0sXG4gICAgaGVhZGVyczogZnVuY3Rpb24gKHB1c2gpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVyID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbHVtbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZXJyO1xuICAgICAgbGV0IGhlYWRlcnMgPSB0aGlzLm9wdGlvbnMuY29sdW1ucy5tYXAoKGNvbHVtbikgPT4gY29sdW1uLmhlYWRlcik7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVvZikge1xuICAgICAgICBbZXJyLCBoZWFkZXJzXSA9IHRoaXMuc3RyaW5naWZ5KGhlYWRlcnMsIHRydWUpO1xuICAgICAgICBoZWFkZXJzICs9IHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgW2VyciwgaGVhZGVyc10gPSB0aGlzLnN0cmluZ2lmeShoZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIpIHJldHVybiBlcnI7XG4gICAgICBwdXNoKGhlYWRlcnMpO1xuICAgIH0sXG4gICAgX19jYXN0OiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIC8vIEZpbmUgZm9yIDk5JSBvZiB0aGUgY2FzZXNcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3Quc3RyaW5nKHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMuY2FzdC5iaWdpbnQodmFsdWUsIGNvbnRleHQpXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0Lm51bWJlcih2YWx1ZSwgY29udGV4dCldO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0LmJvb2xlYW4odmFsdWUsIGNvbnRleHQpXTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3QuZGF0ZSh2YWx1ZSwgY29udGV4dCldO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3Qub2JqZWN0KHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHZhbHVlLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gW2Vycl07XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn07XG5cbmNvbnN0IHN0cmluZ2lmeSA9IGZ1bmN0aW9uIChyZWNvcmRzLCBvcHRzID0ge30pIHtcbiAgY29uc3QgZGF0YSA9IFtdO1xuICBjb25zdCBbZXJyLCBvcHRpb25zXSA9IG5vcm1hbGl6ZV9vcHRpb25zKG9wdHMpO1xuICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHRocm93IGVycjtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgc3RvcDogZmFsc2UsXG4gIH07XG4gIC8vIEluZm9ybWF0aW9uXG4gIGNvbnN0IGluZm8gPSB7XG4gICAgcmVjb3JkczogMCxcbiAgfTtcbiAgY29uc3QgYXBpID0gc3RyaW5naWZpZXIob3B0aW9ucywgc3RhdGUsIGluZm8pO1xuICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgY29uc3QgZXJyID0gYXBpLl9fdHJhbnNmb3JtKHJlY29yZCwgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgZGF0YS5wdXNoKHJlY29yZCk7XG4gICAgfSk7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnI7XG4gIH1cbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgYXBpLmJvbSgoZCkgPT4ge1xuICAgICAgZGF0YS5wdXNoKGQpO1xuICAgIH0pO1xuICAgIGNvbnN0IGVyciA9IGFwaS5oZWFkZXJzKChoZWFkZXJzKSA9PiB7XG4gICAgICBkYXRhLnB1c2goaGVhZGVycyk7XG4gICAgfSk7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGRhdGEuam9pbihcIlwiKTtcbn07XG5cbnZhciBnZXROYXRpdmUgPSBfZ2V0TmF0aXZlO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHkkMjtcblxudmFyIGRlZmluZVByb3BlcnR5JDEgPSBfZGVmaW5lUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUkNihvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSQxKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbnZhciBfYmFzZUFzc2lnblZhbHVlID0gYmFzZUFzc2lnblZhbHVlJDY7XG5cbnZhciBiYXNlQXNzaWduVmFsdWUkNSA9IF9iYXNlQXNzaWduVmFsdWUsXG4gICAgYmFzZUZvck93biQxID0gX2Jhc2VGb3JPd24sXG4gICAgYmFzZUl0ZXJhdGVlJDMgPSBfYmFzZUl0ZXJhdGVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICogQHNlZSBfLm1hcEtleXNcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0ge1xuICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAqIH07XG4gKlxuICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUkMyhpdGVyYXRlZSk7XG5cbiAgYmFzZUZvck93biQxKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgYmFzZUFzc2lnblZhbHVlJDUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIG1hcFZhbHVlc18xID0gbWFwVmFsdWVzO1xuXG52YXIgbWFwVmFsdWVzJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobWFwVmFsdWVzXzEpO1xuXG52YXIgYmFzZUFzc2lnblZhbHVlJDQgPSBfYmFzZUFzc2lnblZhbHVlLFxuICAgIGVxJDIgPSBlcV8xO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZSQyKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxJDIob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlJDQob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgX2Fzc2lnbk1lcmdlVmFsdWUgPSBhc3NpZ25NZXJnZVZhbHVlJDI7XG5cbnZhciBfY2xvbmVCdWZmZXIgPSB7ZXhwb3J0czoge319O1xuXG5fY2xvbmVCdWZmZXIuZXhwb3J0cztcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0dmFyIHJvb3QgPSBfcm9vdDtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuXHR2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuXHQvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuXHR2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuXHQvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0dmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcblx0ICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG5cdCAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG5cdCAqL1xuXHRmdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuXHQgIGlmIChpc0RlZXApIHtcblx0ICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcblx0ICB9XG5cdCAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG5cdCAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuXHQgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7IFxufSAoX2Nsb25lQnVmZmVyLCBfY2xvbmVCdWZmZXIuZXhwb3J0cykpO1xuXG52YXIgX2Nsb25lQnVmZmVyRXhwb3J0cyA9IF9jbG9uZUJ1ZmZlci5leHBvcnRzO1xuXG52YXIgVWludDhBcnJheSQxID0gX1VpbnQ4QXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIkMShhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheSQxKHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5JDEoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9jbG9uZUFycmF5QnVmZmVyID0gY2xvbmVBcnJheUJ1ZmZlciQxO1xuXG52YXIgY2xvbmVBcnJheUJ1ZmZlciA9IF9jbG9uZUFycmF5QnVmZmVyO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSQxKHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbnZhciBfY2xvbmVUeXBlZEFycmF5ID0gY2xvbmVUeXBlZEFycmF5JDE7XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuXG5mdW5jdGlvbiBjb3B5QXJyYXkkMShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxudmFyIF9jb3B5QXJyYXkgPSBjb3B5QXJyYXkkMTtcblxudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdF8xO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSQxID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0JDQocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxudmFyIF9iYXNlQ3JlYXRlID0gYmFzZUNyZWF0ZSQxO1xuXG52YXIgb3ZlckFyZyA9IF9vdmVyQXJnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUkMiA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG52YXIgX2dldFByb3RvdHlwZSA9IGdldFByb3RvdHlwZSQyO1xuXG52YXIgYmFzZUNyZWF0ZSA9IF9iYXNlQ3JlYXRlLFxuICAgIGdldFByb3RvdHlwZSQxID0gX2dldFByb3RvdHlwZSxcbiAgICBpc1Byb3RvdHlwZSQxID0gX2lzUHJvdG90eXBlO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdCQxKG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUkMShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUkMShvYmplY3QpKVxuICAgIDoge307XG59XG5cbnZhciBfaW5pdENsb25lT2JqZWN0ID0gaW5pdENsb25lT2JqZWN0JDE7XG5cbnZhciBpc0FycmF5TGlrZSQzID0gaXNBcnJheUxpa2VfMSxcbiAgICBpc09iamVjdExpa2UkMSA9IGlzT2JqZWN0TGlrZV8xO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCQxKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UkMSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UkMyh2YWx1ZSk7XG59XG5cbnZhciBpc0FycmF5TGlrZU9iamVjdF8xID0gaXNBcnJheUxpa2VPYmplY3QkMTtcblxudmFyIGJhc2VHZXRUYWcgPSBfYmFzZUdldFRhZyxcbiAgICBnZXRQcm90b3R5cGUgPSBfZ2V0UHJvdG90eXBlLFxuICAgIGlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZV8xO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDIgPSBvYmplY3RQcm90byQyLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QkMSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkkMi5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG52YXIgaXNQbGFpbk9iamVjdF8xID0gaXNQbGFpbk9iamVjdCQxO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cbmZ1bmN0aW9uIHNhZmVHZXQkMihvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5cbnZhciBfc2FmZUdldCA9IHNhZmVHZXQkMjtcblxudmFyIGJhc2VBc3NpZ25WYWx1ZSQzID0gX2Jhc2VBc3NpZ25WYWx1ZSxcbiAgICBlcSQxID0gZXFfMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlJDEob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eSQxLmNhbGwob2JqZWN0LCBrZXkpICYmIGVxJDEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlJDMob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgX2Fzc2lnblZhbHVlID0gYXNzaWduVmFsdWUkMTtcblxudmFyIGFzc2lnblZhbHVlID0gX2Fzc2lnblZhbHVlLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSQyID0gX2Jhc2VBc3NpZ25WYWx1ZTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdCQxKHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUkMihvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG52YXIgX2NvcHlPYmplY3QgPSBjb3B5T2JqZWN0JDE7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbiQxKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9uYXRpdmVLZXlzSW4gPSBuYXRpdmVLZXlzSW4kMTtcblxudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdF8xLFxuICAgIGlzUHJvdG90eXBlID0gX2lzUHJvdG90eXBlLFxuICAgIG5hdGl2ZUtleXNJbiA9IF9uYXRpdmVLZXlzSW47XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4kMShvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdCQzKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VLZXlzSW4gPSBiYXNlS2V5c0luJDE7XG5cbnZhciBhcnJheUxpa2VLZXlzID0gX2FycmF5TGlrZUtleXMsXG4gICAgYmFzZUtleXNJbiA9IF9iYXNlS2V5c0luLFxuICAgIGlzQXJyYXlMaWtlJDIgPSBpc0FycmF5TGlrZV8xO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luJDIob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZSQyKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbnZhciBrZXlzSW5fMSA9IGtleXNJbiQyO1xuXG52YXIgY29weU9iamVjdCA9IF9jb3B5T2JqZWN0LFxuICAgIGtleXNJbiQxID0ga2V5c0luXzE7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0JDEodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbiQxKHZhbHVlKSk7XG59XG5cbnZhciB0b1BsYWluT2JqZWN0XzEgPSB0b1BsYWluT2JqZWN0JDE7XG5cbnZhciBhc3NpZ25NZXJnZVZhbHVlJDEgPSBfYXNzaWduTWVyZ2VWYWx1ZSxcbiAgICBjbG9uZUJ1ZmZlciA9IF9jbG9uZUJ1ZmZlckV4cG9ydHMsXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gX2Nsb25lVHlwZWRBcnJheSxcbiAgICBjb3B5QXJyYXkgPSBfY29weUFycmF5LFxuICAgIGluaXRDbG9uZU9iamVjdCA9IF9pbml0Q2xvbmVPYmplY3QsXG4gICAgaXNBcmd1bWVudHMkMSA9IGlzQXJndW1lbnRzXzEsXG4gICAgaXNBcnJheSQzID0gaXNBcnJheV8xLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gaXNBcnJheUxpa2VPYmplY3RfMSxcbiAgICBpc0J1ZmZlciA9IGlzQnVmZmVyRXhwb3J0cyxcbiAgICBpc0Z1bmN0aW9uID0gaXNGdW5jdGlvbl8xLFxuICAgIGlzT2JqZWN0JDIgPSBpc09iamVjdF8xLFxuICAgIGlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0XzEsXG4gICAgaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5XzEsXG4gICAgc2FmZUdldCQxID0gX3NhZmVHZXQsXG4gICAgdG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3RfMTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwJDEob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldCQxKG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldCQxKHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZSQxKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkkMyhzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5JDMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMkMShzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMkMShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdCQyKG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUkMShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG52YXIgX2Jhc2VNZXJnZURlZXAgPSBiYXNlTWVyZ2VEZWVwJDE7XG5cbnZhciBTdGFjayA9IF9TdGFjayxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gX2Fzc2lnbk1lcmdlVmFsdWUsXG4gICAgYmFzZUZvciA9IF9iYXNlRm9yLFxuICAgIGJhc2VNZXJnZURlZXAgPSBfYmFzZU1lcmdlRGVlcCxcbiAgICBpc09iamVjdCQxID0gaXNPYmplY3RfMSxcbiAgICBrZXlzSW4gPSBrZXlzSW5fMSxcbiAgICBzYWZlR2V0ID0gX3NhZmVHZXQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZSQyKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICBpZiAoaXNPYmplY3QkMShzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSQyLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxudmFyIF9iYXNlTWVyZ2UgPSBiYXNlTWVyZ2UkMjtcblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuXG5mdW5jdGlvbiBhcHBseSQxKGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxudmFyIF9hcHBseSA9IGFwcGx5JDE7XG5cbnZhciBhcHBseSA9IF9hcHBseTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0JDEoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG52YXIgX292ZXJSZXN0ID0gb3ZlclJlc3QkMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cblxuZnVuY3Rpb24gY29uc3RhbnQkMSh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG52YXIgY29uc3RhbnRfMSA9IGNvbnN0YW50JDE7XG5cbnZhciBjb25zdGFudCA9IGNvbnN0YW50XzEsXG4gICAgZGVmaW5lUHJvcGVydHkgPSBfZGVmaW5lUHJvcGVydHksXG4gICAgaWRlbnRpdHkkMiA9IGlkZW50aXR5XzE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyQxID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkkMiA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxudmFyIF9iYXNlU2V0VG9TdHJpbmcgPSBiYXNlU2V0VG9TdHJpbmckMTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQkMShmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIF9zaG9ydE91dCA9IHNob3J0T3V0JDE7XG5cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSBfYmFzZVNldFRvU3RyaW5nLFxuICAgIHNob3J0T3V0ID0gX3Nob3J0T3V0O1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmckMSA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbnZhciBfc2V0VG9TdHJpbmcgPSBzZXRUb1N0cmluZyQxO1xuXG52YXIgaWRlbnRpdHkkMSA9IGlkZW50aXR5XzEsXG4gICAgb3ZlclJlc3QgPSBfb3ZlclJlc3QsXG4gICAgc2V0VG9TdHJpbmcgPSBfc2V0VG9TdHJpbmc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0JDIoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSQxKSwgZnVuYyArICcnKTtcbn1cblxudmFyIF9iYXNlUmVzdCA9IGJhc2VSZXN0JDI7XG5cbnZhciBlcSA9IGVxXzEsXG4gICAgaXNBcnJheUxpa2UkMSA9IGlzQXJyYXlMaWtlXzEsXG4gICAgaXNJbmRleCA9IF9pc0luZGV4LFxuICAgIGlzT2JqZWN0ID0gaXNPYmplY3RfMTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwkMih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlJDEob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIF9pc0l0ZXJhdGVlQ2FsbCA9IGlzSXRlcmF0ZWVDYWxsJDI7XG5cbnZhciBiYXNlUmVzdCQxID0gX2Jhc2VSZXN0LFxuICAgIGlzSXRlcmF0ZWVDYWxsJDEgPSBfaXNJdGVyYXRlZUNhbGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIkMihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QkMShmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbCQxKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbnZhciBfY3JlYXRlQXNzaWduZXIgPSBjcmVhdGVBc3NpZ25lciQyO1xuXG52YXIgYmFzZU1lcmdlJDEgPSBfYmFzZU1lcmdlLFxuICAgIGNyZWF0ZUFzc2lnbmVyJDEgPSBfY3JlYXRlQXNzaWduZXI7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyJDEoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZSQxKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxudmFyIG1lcmdlXzEgPSBtZXJnZTtcblxudmFyIG1lcmdlJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobWVyZ2VfMSk7XG5cbnZhciBiYXNlTWVyZ2UgPSBfYmFzZU1lcmdlLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gX2NyZWF0ZUFzc2lnbmVyO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAqXG4gKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAqL1xudmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbn0pO1xuXG52YXIgbWVyZ2VXaXRoXzEgPSBtZXJnZVdpdGg7XG5cbnZhciBtZXJnZVdpdGgkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhtZXJnZVdpdGhfMSk7XG5cbnZhciBiYXNlQXNzaWduVmFsdWUkMSA9IF9iYXNlQXNzaWduVmFsdWUsXG4gICAgYmFzZUZvck93biA9IF9iYXNlRm9yT3duLFxuICAgIGJhc2VJdGVyYXRlZSQyID0gX2Jhc2VJdGVyYXRlZTtcblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gKiBAc2VlIF8ubWFwVmFsdWVzXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubWFwS2V5cyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICogfSk7XG4gKiAvLyA9PiB7ICdhMSc6IDEsICdiMic6IDIgfVxuICovXG5mdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZSQyKGl0ZXJhdGVlKTtcblxuICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgYmFzZUFzc2lnblZhbHVlJDEocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgbWFwS2V5c18xID0gbWFwS2V5cztcblxudmFyIG1hcEtleXMkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhtYXBLZXlzXzEpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2YkMShvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG52YXIgX2Jhc2VQcm9wZXJ0eU9mID0gYmFzZVByb3BlcnR5T2YkMTtcblxudmFyIGJhc2VQcm9wZXJ0eU9mID0gX2Jhc2VQcm9wZXJ0eU9mO1xuXG4vKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJyxcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gKi9cbnZhciBkZWJ1cnJMZXR0ZXIkMSA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbnZhciBfZGVidXJyTGV0dGVyID0gZGVidXJyTGV0dGVyJDE7XG5cbnZhciBkZWJ1cnJMZXR0ZXIgPSBfZGVidXJyTGV0dGVyLFxuICAgIHRvU3RyaW5nJDIgPSB0b1N0cmluZ18xO1xuXG4vKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbnZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0NvbWJvTWFya3NSYW5nZSQzID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQzID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMyA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UkMyA9IHJzQ29tYm9NYXJrc1JhbmdlJDMgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMyArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQ29tYm8kMiA9ICdbJyArIHJzQ29tYm9SYW5nZSQzICsgJ10nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gKi9cbnZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvJDIsICdnJyk7XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyJDEoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nJDIoc3RyaW5nKTtcbiAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbn1cblxudmFyIGRlYnVycl8xID0gZGVidXJyJDE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xuXG52YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbi8qKlxuICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gYXNjaWlXb3JkcyQxKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbn1cblxudmFyIF9hc2NpaVdvcmRzID0gYXNjaWlXb3JkcyQxO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG5cbnZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlV29yZCQxKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG59XG5cbnZhciBfaGFzVW5pY29kZVdvcmQgPSBoYXNVbmljb2RlV29yZCQxO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG5cbnZhciByc0FzdHJhbFJhbmdlJDIgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UkMiA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMiA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlJDIgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlJDIgPSByc0NvbWJvTWFya3NSYW5nZSQyICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDIgKyByc0NvbWJvU3ltYm9sc1JhbmdlJDIsXG4gICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgIHJzVmFyUmFuZ2UkMiA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyQxID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICByc0NvbWJvJDEgPSAnWycgKyByc0NvbWJvUmFuZ2UkMiArICddJyxcbiAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UkMiArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6JDEgPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyJDEgPSAnKD86JyArIHJzQ29tYm8kMSArICd8JyArIHJzRml0eiQxICsgJyknLFxuICAgIHJzTm9uQXN0cmFsJDEgPSAnW14nICsgcnNBc3RyYWxSYW5nZSQyICsgJ10nLFxuICAgIHJzUmVnaW9uYWwkMSA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyJDEgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzWldKJDIgPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MkMSArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyQxICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgIHJlT3B0TW9kJDEgPSByc01vZGlmaWVyJDEgKyAnPycsXG4gICAgcnNPcHRWYXIkMSA9ICdbJyArIHJzVmFyUmFuZ2UkMiArICddPycsXG4gICAgcnNPcHRKb2luJDEgPSAnKD86JyArIHJzWldKJDIgKyAnKD86JyArIFtyc05vbkFzdHJhbCQxLCByc1JlZ2lvbmFsJDEsIHJzU3VyclBhaXIkMV0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIkMSArIHJlT3B0TW9kJDEgKyAnKSonLFxuICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgcnNTZXEkMSA9IHJzT3B0VmFyJDEgKyByZU9wdE1vZCQxICsgcnNPcHRKb2luJDEsXG4gICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCQxLCByc1N1cnJQYWlyJDFdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxJDE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG52YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICByc09yZFVwcGVyLFxuICByc09yZExvd2VyLFxuICByc0RpZ2l0cyxcbiAgcnNFbW9qaVxuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVXb3JkcyQxKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xufVxuXG52YXIgX3VuaWNvZGVXb3JkcyA9IHVuaWNvZGVXb3JkcyQxO1xuXG52YXIgYXNjaWlXb3JkcyA9IF9hc2NpaVdvcmRzLFxuICAgIGhhc1VuaWNvZGVXb3JkID0gX2hhc1VuaWNvZGVXb3JkLFxuICAgIHRvU3RyaW5nJDEgPSB0b1N0cmluZ18xLFxuICAgIHVuaWNvZGVXb3JkcyA9IF91bmljb2RlV29yZHM7XG5cbi8qKlxuICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gKi9cbmZ1bmN0aW9uIHdvcmRzJDEoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICBzdHJpbmcgPSB0b1N0cmluZyQxKHN0cmluZyk7XG4gIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbn1cblxudmFyIHdvcmRzXzEgPSB3b3JkcyQxO1xuXG52YXIgYXJyYXlSZWR1Y2UgPSBfYXJyYXlSZWR1Y2UsXG4gICAgZGVidXJyID0gZGVidXJyXzEsXG4gICAgd29yZHMgPSB3b3Jkc18xO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCI7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xudmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlciQxKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQ29tcG91bmRlciA9IGNyZWF0ZUNvbXBvdW5kZXIkMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuXG5mdW5jdGlvbiBiYXNlU2xpY2UkMShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlU2xpY2UgPSBiYXNlU2xpY2UkMTtcblxudmFyIGJhc2VTbGljZSA9IF9iYXNlU2xpY2U7XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZSQxKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbn1cblxudmFyIF9jYXN0U2xpY2UgPSBjYXN0U2xpY2UkMTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuXG52YXIgcnNBc3RyYWxSYW5nZSQxID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlJDEgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDEgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSQxID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSQxID0gcnNDb21ib01hcmtzUmFuZ2UkMSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQxICsgcnNDb21ib1N5bWJvbHNSYW5nZSQxLFxuICAgIHJzVmFyUmFuZ2UkMSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0okMSA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0okMSArIHJzQXN0cmFsUmFuZ2UkMSAgKyByc0NvbWJvUmFuZ2UkMSArIHJzVmFyUmFuZ2UkMSArICddJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZSQyKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxudmFyIF9oYXNVbmljb2RlID0gaGFzVW5pY29kZSQyO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheSQxKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbn1cblxudmFyIF9hc2NpaVRvQXJyYXkgPSBhc2NpaVRvQXJyYXkkMTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkkMShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xufVxuXG52YXIgX3VuaWNvZGVUb0FycmF5ID0gdW5pY29kZVRvQXJyYXkkMTtcblxudmFyIGFzY2lpVG9BcnJheSA9IF9hc2NpaVRvQXJyYXksXG4gICAgaGFzVW5pY29kZSQxID0gX2hhc1VuaWNvZGUsXG4gICAgdW5pY29kZVRvQXJyYXkgPSBfdW5pY29kZVRvQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkkMShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUkMShzdHJpbmcpXG4gICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbn1cblxudmFyIF9zdHJpbmdUb0FycmF5ID0gc3RyaW5nVG9BcnJheSQxO1xuXG52YXIgY2FzdFNsaWNlID0gX2Nhc3RTbGljZSxcbiAgICBoYXNVbmljb2RlID0gX2hhc1VuaWNvZGUsXG4gICAgc3RyaW5nVG9BcnJheSA9IF9zdHJpbmdUb0FycmF5LFxuICAgIHRvU3RyaW5nID0gdG9TdHJpbmdfMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdCQxKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQ2FzZUZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0JDE7XG5cbnZhciBjcmVhdGVDYXNlRmlyc3QgPSBfY3JlYXRlQ2FzZUZpcnN0O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGUkVEJ1xuICovXG52YXIgdXBwZXJGaXJzdCQxID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG52YXIgdXBwZXJGaXJzdF8xID0gdXBwZXJGaXJzdCQxO1xuXG52YXIgY3JlYXRlQ29tcG91bmRlciA9IF9jcmVhdGVDb21wb3VuZGVyLFxuICAgIHVwcGVyRmlyc3QgPSB1cHBlckZpcnN0XzE7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAqIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4xLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXItLScpO1xuICogLy8gPT4gJ0ZvbyBCYXInXG4gKlxuICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICogLy8gPT4gJ0ZvbyBCYXInXG4gKlxuICogXy5zdGFydENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnRk9PIEJBUidcbiAqL1xudmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbn0pO1xuXG52YXIgc3RhcnRDYXNlXzEgPSBzdGFydENhc2U7XG5cbnZhciBzdGFydENhc2UkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzdGFydENhc2VfMSk7XG5cbnZhciBTeW1ib2wkMSA9IF9TeW1ib2wsXG4gICAgaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50c18xLFxuICAgIGlzQXJyYXkkMiA9IGlzQXJyYXlfMTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCQxID8gU3ltYm9sJDEuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUkMSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSQyKHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxudmFyIF9pc0ZsYXR0ZW5hYmxlID0gaXNGbGF0dGVuYWJsZSQxO1xuXG52YXIgYXJyYXlQdXNoID0gX2FycmF5UHVzaCxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gX2lzRmxhdHRlbmFibGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4kMShhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4kMSh2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlRmxhdHRlbiA9IGJhc2VGbGF0dGVuJDE7XG5cbnZhciBiYXNlRWFjaCQxID0gX2Jhc2VFYWNoLFxuICAgIGlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2VfMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcCQxKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaCQxKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZU1hcCA9IGJhc2VNYXAkMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cblxuZnVuY3Rpb24gYmFzZVNvcnRCeSQxKGFycmF5LCBjb21wYXJlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfYmFzZVNvcnRCeSA9IGJhc2VTb3J0QnkkMTtcblxudmFyIGlzU3ltYm9sID0gaXNTeW1ib2xfMTtcblxuLyoqXG4gKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyQxKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBfY29tcGFyZUFzY2VuZGluZyA9IGNvbXBhcmVBc2NlbmRpbmckMTtcblxudmFyIGNvbXBhcmVBc2NlbmRpbmcgPSBfY29tcGFyZUFzY2VuZGluZztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICpcbiAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlJDEob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG52YXIgX2NvbXBhcmVNdWx0aXBsZSA9IGNvbXBhcmVNdWx0aXBsZSQxO1xuXG52YXIgYXJyYXlNYXAgPSBfYXJyYXlNYXAsXG4gICAgYmFzZUdldCA9IF9iYXNlR2V0LFxuICAgIGJhc2VJdGVyYXRlZSQxID0gX2Jhc2VJdGVyYXRlZSxcbiAgICBiYXNlTWFwID0gX2Jhc2VNYXAsXG4gICAgYmFzZVNvcnRCeSA9IF9iYXNlU29ydEJ5LFxuICAgIGJhc2VVbmFyeSA9IF9iYXNlVW5hcnksXG4gICAgY29tcGFyZU11bHRpcGxlID0gX2NvbXBhcmVNdWx0aXBsZSxcbiAgICBpZGVudGl0eSA9IGlkZW50aXR5XzEsXG4gICAgaXNBcnJheSQxID0gaXNBcnJheV8xO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlT3JkZXJCeSQxKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIGlmIChpdGVyYXRlZXMubGVuZ3RoKSB7XG4gICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgaWYgKGlzQXJyYXkkMShpdGVyYXRlZSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShiYXNlSXRlcmF0ZWUkMSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG52YXIgX2Jhc2VPcmRlckJ5ID0gYmFzZU9yZGVyQnkkMTtcblxudmFyIGJhc2VGbGF0dGVuID0gX2Jhc2VGbGF0dGVuLFxuICAgIGJhc2VPcmRlckJ5ID0gX2Jhc2VPcmRlckJ5LFxuICAgIGJhc2VSZXN0ID0gX2Jhc2VSZXN0LFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gX2lzSXRlcmF0ZWVDYWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAqIF07XG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgMzBdXVxuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0OF1dXG4gKi9cbnZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW107XG4gIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG59KTtcblxudmFyIHNvcnRCeV8xID0gc29ydEJ5O1xuXG52YXIgc29ydEJ5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc29ydEJ5XzEpO1xuXG52YXIgYmFzZUlzRXF1YWwgPSBfYmFzZUlzRXF1YWw7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG52YXIgaXNFcXVhbF8xID0gaXNFcXVhbDtcblxudmFyIGlzRXF1YWwkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpc0VxdWFsXzEpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gKi9cblxuZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yJDEoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG52YXIgX2FycmF5QWdncmVnYXRvciA9IGFycmF5QWdncmVnYXRvciQxO1xuXG52YXIgYmFzZUVhY2ggPSBfYmFzZUVhY2g7XG5cbi8qKlxuICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yJDEoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbnZhciBfYmFzZUFnZ3JlZ2F0b3IgPSBiYXNlQWdncmVnYXRvciQxO1xuXG52YXIgYXJyYXlBZ2dyZWdhdG9yID0gX2FycmF5QWdncmVnYXRvcixcbiAgICBiYXNlQWdncmVnYXRvciA9IF9iYXNlQWdncmVnYXRvcixcbiAgICBiYXNlSXRlcmF0ZWUgPSBfYmFzZUl0ZXJhdGVlLFxuICAgIGlzQXJyYXkgPSBpc0FycmF5XzE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3IkMShzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUpLCBhY2N1bXVsYXRvcik7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQWdncmVnYXRvciA9IGNyZWF0ZUFnZ3JlZ2F0b3IkMTtcblxudmFyIGJhc2VBc3NpZ25WYWx1ZSA9IF9iYXNlQXNzaWduVmFsdWUsXG4gICAgY3JlYXRlQWdncmVnYXRvciA9IF9jcmVhdGVBZ2dyZWdhdG9yO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheSA9IFtcbiAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAqIF07XG4gKlxuICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xuICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICogfSk7XG4gKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gKlxuICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAqL1xudmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG59KTtcblxudmFyIGtleUJ5XzEgPSBrZXlCeTtcblxudmFyIGtleUJ5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoa2V5QnlfMSk7XG5cbmNvbnN0IGUgPSBNYXRoLmV4cCgxKTtcbmNvbnN0IEVNQUlMX1JFR0VYID0gL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kLztcbi8qKlxuICogRGV0ZWN0cyBpZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyB0aGUgYnJvd3NlclxuICpcbiAqIEByZXR1cm5zIGB0cnVlYCBvciBgZmFsc2VgXG4gKi9cbmNvbnN0IGlzQnJvd3NlciA9ICgpID0+ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgd2luZG93LmRvY3VtZW50ICYmXG4gICAgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuLyoqXG4gKiBNZXJnZXMgY2xhc3NOYW1lcyBvYmplY3RzIHRvZ2V0aGVyLCBrZXkgYnkga2V5XG4gKlxuICogQHJldHVybnMgYSBjbGFzc05hbWVzIG9iamVjdFxuICovXG5jb25zdCBtZXJnZUNsYXNzTmFtZXNEZWVwID0gKHsgY2xhc3NOYW1lczEgPSB7fSwgY2xhc3NOYW1lczIgPSB7fSwgfSkgPT4ge1xuICAgIGNvbnN0IG5ld0NsYXNzTmFtZXMgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAuLi5PYmplY3Qua2V5cyhjbGFzc05hbWVzMSB8fCB7fSksXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKGNsYXNzTmFtZXMyIHx8IHt9KSxcbiAgICBdO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIG5ld0NsYXNzTmFtZXNba2V5XSA9IGNsYXNzTmFtZXMoY2xhc3NOYW1lczFba2V5XSwgY2xhc3NOYW1lczJba2V5XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0NsYXNzTmFtZXM7XG59O1xuY29uc3QgbWVyZ2VDbGFzc05hbWVzRnVuY3Rpb25zRGVlcCA9ICh7IGNsYXNzTmFtZXMxID0ge30sIGNsYXNzTmFtZXMyID0ge30sIH0pID0+IHtcbiAgICBjb25zdCBuZXdDbGFzc05hbWVzID0ge307XG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgLi4uT2JqZWN0LmtleXMoY2xhc3NOYW1lczEgfHwge30pLFxuICAgICAgICAuLi5PYmplY3Qua2V5cyhjbGFzc05hbWVzMiB8fCB7fSksXG4gICAgXTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBuZXdDbGFzc05hbWVzW2tleV0gPSAoYXJncykgPT4gY2xhc3NOYW1lcygoY2xhc3NOYW1lczFba2V5XSB8fCAoKCkgPT4gJycpKShhcmdzKSwgKGNsYXNzTmFtZXMyW2tleV0gfHwgKCgpID0+ICcnKSkoYXJncykpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdDbGFzc05hbWVzO1xufTtcbi8qKiBUeXBpbmcgb24gdGhpcyBmdW5jdGlvbiBpcyBjb25mdXNpbmcgYnV0IGRvZXMgd29yayEgKi9cbmNvbnN0IHJlbW92ZVVuZGVmaW5lZFZhbHVlc0Zyb21PYmogPSAoaW5wdXRPYmplY3QpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICBpZiAoaW5wdXRPYmplY3Rba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGlucHV0T2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKiogVHlwaW5nIG9uIHRoaXMgZnVuY3Rpb24gaXMgY29uZnVzaW5nIGJ1dCBkb2VzIHdvcmshICovXG5jb25zdCByZW1vdmVVbmRlZmluZWRBbmRFbXB0eVN0cmluZ1ZhbHVlc0Zyb21PYmogPSAoaW5wdXRPYmplY3QpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICBpZiAoaW5wdXRPYmplY3Rba2V5XSAhPT0gdW5kZWZpbmVkICYmIGlucHV0T2JqZWN0W2tleV0gIT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGlucHV0T2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKiogVHlwaW5nIG9uIHRoaXMgZnVuY3Rpb24gaXMgY29uZnVzaW5nIGJ1dCBkb2VzIHdvcmshICovXG5jb25zdCByZW1vdmVVbmRlZmluZWRBbmROdWxsVmFsdWVzRnJvbU9iaiA9IChpbnB1dE9iamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgIGlmIChpbnB1dE9iamVjdFtrZXldICE9PSB1bmRlZmluZWQgJiYgaW5wdXRPYmplY3Rba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpbnB1dE9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBxdWVyeSBzdHJpbmcgZnJvbSBhbiBvYmplY3Qgb2Yga2V5IHZhbHVlIHBhaXJzXG4gKlxuICogQHJldHVybnMgYSBjbGFzc05hbWVzIG9iamVjdFxuICpcbiAqIEBleGFtcGxlXG4gKiBnZW5lcmF0ZVF1ZXJ5U3RyaW5nKFxceyBmaWVsZDE6ICd2YWx1ZTEnLCBmaWVsZDI6ICd2YWx1ZTInIFxcfSkgPVxcPiBcIj9maWVsZDE9dmFsdWUxJmZpZWxkMj12YWx1ZTJcIlxuICogZ2VuZXJhdGVRdWVyeVN0cmluZyhcXHsgZmllbGQxOiAndmFsdWUxJywgZmllbGQyOiAndmFsdWUyJywgZXhjbHVkZVF1ZXN0aW9uTWFyayBcXH0pID1cXD4gXCJmaWVsZDE9dmFsdWUxJmZpZWxkMj12YWx1ZTJcIlxuICovXG5jb25zdCBnZW5lcmF0ZVF1ZXJ5U3RyaW5nID0gKHsgcXVlcnlQYXJhbXMgPSB7fSwgZXhjbHVkZVF1ZXN0aW9uTWFyayA9IGZhbHNlLCBleGNsdWRlRW1wdHlTdHJpbmdWYWx1ZXMgPSBmYWxzZSwgfSkgPT4ge1xuICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaW4gYSBxdWVyeXN0cmluZyBpcyBwcmVjZWRlZCBieSBhID9cbiAgICAvLyBUaGlzIGZsYWcgZGVub3RlcyB3aGV0aGVyIHdlIGFscmVhZHkgaGF2ZSBvbmUgcGFyYW0gc2V0IGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICBsZXQgcHJlZml4UXVlc3Rpb25NYXJrID0gIWV4Y2x1ZGVRdWVzdGlvbk1hcms7XG4gICAgcmV0dXJuIHJlZHVjZSQxKGV4Y2x1ZGVFbXB0eVN0cmluZ1ZhbHVlc1xuICAgICAgICA/IHJlbW92ZVVuZGVmaW5lZEFuZEVtcHR5U3RyaW5nVmFsdWVzRnJvbU9iaihxdWVyeVBhcmFtcyB8fCB7fSlcbiAgICAgICAgOiByZW1vdmVVbmRlZmluZWRWYWx1ZXNGcm9tT2JqKHF1ZXJ5UGFyYW1zIHx8IHt9KSwgKGFjYywgZmllbGQsIGtleSkgPT4ge1xuICAgICAgICAvLyBJZiB0aGUgZmllbGQgaXMgZmFsc2V5IHRoZW4gZG8gbm90IGFwcGVuZCB0aGlzIHF1ZXJ5IHBhcmFtXG4gICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJlZml4UXVlc3Rpb25NYXJrKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSYke2tleX09JHtmaWVsZH1gO1xuICAgICAgICB9XG4gICAgICAgIHByZWZpeFF1ZXN0aW9uTWFyayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYCR7YWNjfT8ke2tleX09JHtmaWVsZH1gO1xuICAgIH0sICcnKTtcbn07XG4vKipcbiAqIFJvdW5kcyBhIG51bWJlciB0byBOIGRlY2ltYWwgcGxhY2VzIChkZWZhdWx0cyB0byAyKVxuICpcbiAqIEByZXR1cm5zIGEgcm91bmRlZCBudW1iZXJcbiAqL1xuY29uc3Qgcm91bmROdW1iZXIgPSAobnVtLCBkZWNpbWFsUGxhY2VzID0gMikgPT4ge1xuICAgIHJldHVybiArYCR7TWF0aC5yb3VuZCgrYCR7bnVtfWUrJHtkZWNpbWFsUGxhY2VzfWApfWUtJHtkZWNpbWFsUGxhY2VzfWA7XG59O1xuY29uc3QgZ2V0TlJhbmRvbUVsZW1lbnRzRnJvbUFycmF5ID0gKGFycmF5LCBuKSA9PiB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA8PSBuKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGNvdW50ID0gbjtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgY29uc3QgdGFrZW4gPSBuZXcgQXJyYXkobGVuKTtcbiAgICBpZiAoY291bnQgPiBsZW4pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdnZXRSYW5kb206IG1vcmUgZWxlbWVudHMgdGFrZW4gdGhhbiBhdmFpbGFibGUnKTtcbiAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKTtcbiAgICAgICAgcmVzdWx0W2NvdW50XSA9IGFycmF5W3ggaW4gdGFrZW4gPyB0YWtlblt4XSA6IHhdO1xuICAgICAgICB0YWtlblt4XSA9IC0tbGVuIGluIHRha2VuID8gdGFrZW5bbGVuXSA6IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBnZXRSYW5kb21FbGVtZW50c0Zyb21BcnJheSA9IChhcnJheSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzQ291bnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnJheS5sZW5ndGgpICsgMTtcbiAgICByZXR1cm4gZ2V0TlJhbmRvbUVsZW1lbnRzRnJvbUFycmF5KGFycmF5LCBlbGVtZW50c0NvdW50KTtcbn07XG5jb25zdCBnZXRSYW5kb21FbGVtZW50RnJvbUFycmF5ID0gKGFycmF5KSA9PiBnZXROUmFuZG9tRWxlbWVudHNGcm9tQXJyYXkoYXJyYXksIDEpWzBdO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiByZ2JhIHN0cmluZyB0byBhIGhleCBjb2xvciBjb2RlXG4gKlxuICogQHJldHVybnMgYSBoZXggY29sb3IgY29kZSBhcyBhIHN0cmluZ1xuICovXG5jb25zdCBSR0JBVG9IZXhBID0gKHJnYmEsIGZvcmNlUmVtb3ZlQWxwaGEgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGhleENvbG9yID0gcmdiYVxuICAgICAgICAucmVwbGFjZSgvXnJnYmE/XFwofFxccyt8XFwpJC9nLCAnJykgLy8gR2V0J3MgcmdiYSAvIHJnYiBzdHJpbmcgdmFsdWVzXG4gICAgICAgIC5zcGxpdCgnLCcpIC8vIHNwbGl0cyB0aGVtIGJ5IFwiLFwiXG4gICAgICAgIC5maWx0ZXIoKHN0ciwgaW5kZXgpID0+ICFmb3JjZVJlbW92ZUFscGhhIHx8IGluZGV4ICE9PSAzKVxuICAgICAgICAubWFwKChzdHIpID0+IHBhcnNlRmxvYXQoc3RyKSkgLy8gQ29udmVydHMgdGhlbSB0byBudW1iZXJzXG4gICAgICAgIC5tYXAoKG51bWJlciwgaW5kZXgpID0+IChpbmRleCA9PT0gMyA/IE1hdGgucm91bmQobnVtYmVyICogMjU1KSA6IG51bWJlcikpIC8vIENvbnZlcnRzIGFscGhhIHRvIDI1NSBudW1iZXJcbiAgICAgICAgLm1hcCgobnVtYmVyKSA9PiBudW1iZXIudG9TdHJpbmcoMTYpKSAvLyBDb252ZXJ0cyBudW1iZXJzIHRvIGhleFxuICAgICAgICAubWFwKChzdHIpID0+IChzdHIubGVuZ3RoID09PSAxID8gYDAke3N0cn1gIDogc3RyKSkgLy8gQWRkcyAwIHdoZW4gbGVuZ3RoIG9mIG9uZSBudW1iZXIgaXMgMVxuICAgICAgICAuam9pbignJyk7XG4gICAgcmV0dXJuIGAjJHtoZXhDb2xvcn1gO1xufTtcbmNvbnN0IGlzVHJ1dGh5T3JaZXJvID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAoISF2YWx1ZSB8fCAodmFsdWUgIT09ICcnICYmIE51bWJlcih2YWx1ZSkgPT09IDApKTtcbmNvbnN0IGNvbmRpdGlvbmFsT3JJZlRydXRoeU9yWmVybyA9ICh2YWx1ZXMpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlcy5maW5kKCh2KSA9PiBpc1RydXRoeU9yWmVybyh2KSk7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdIDogdmFsdWU7XG59O1xuY29uc3QgYXJyYXlXaXRob3V0RWxlbWVudHMgPSAoeyBhcnJheSwgZXhjbHVkZUFycmF5LCB9KSA9PiB7XG4gICAgY29uc3QgdG9FeGNsdWRlID0gbmV3IFNldChleGNsdWRlQXJyYXkgfHwgW10pO1xuICAgIHJldHVybiAoYXJyYXkgfHwgW10pLmZpbHRlcigodikgPT4gIXRvRXhjbHVkZS5oYXModikpO1xufTtcbmNvbnN0IGNhcGl0YWxpc2VGaXJzdExldHRlciA9ICh0ZXh0ID0gJycpID0+IHtcbiAgICByZXR1cm4gdGV4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleHQuc2xpY2UoMSk7XG59O1xuY29uc3QgY2xlYW5TdHJpbmcgPSAodGV4dCA9ICcnKSA9PiB7XG4gICAgcmV0dXJuICh0ZXh0IHx8ICcnKS50cmltKCk7XG59O1xuY29uc3Qgbm9ybWFsaXNlU3RyaW5nID0gKHRleHQgPSAnJykgPT4ge1xuICAgIHJldHVybiBjbGVhblN0cmluZyh0ZXh0KS50b0xvd2VyQ2FzZSgpO1xufTtcbmNvbnN0IHBhcnNlRW52VmFyaWFibGUgPSAodikgPT4ge1xuICAgIGlmICh2ID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHYgPT09ICd0cnVlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHY/LlswXSA9PT0gJyQnKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodi5yZXBsYWNlKCckJywgJycpKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuY29uc3QgcGFyc2VFbnZWYXJpYWJsZXMgPSAoZW52KSA9PiBtYXBWYWx1ZXMkMShlbnYsICh2KSA9PiBwYXJzZUVudlZhcmlhYmxlKHYpKTtcbmNvbnN0IGdldE5leHRKU1F1ZXJ5UGFyYW0gPSAoeyBxdWVyeSwgaWQsIGRlZmF1bHRUb0VtcHR5U3RyaW5nID0gZmFsc2UsIH0pID0+IHtcbiAgICBjb25zdCByZXR1cm5EZWZhdWx0ID0gZGVmYXVsdFRvRW1wdHlTdHJpbmcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiByZXR1cm5EZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gKChBcnJheS5pc0FycmF5KHF1ZXJ5Py5baWRdKVxuICAgICAgICA/IHF1ZXJ5Py5baWRdPy5bMF0/LnRvU3RyaW5nKClcbiAgICAgICAgOiBxdWVyeT8uW2lkXT8udG9TdHJpbmcoKSkgfHwgcmV0dXJuRGVmYXVsdCk7XG59O1xuY29uc3QgZXZhbHVhdGVUcnV0aHlJZk5vdFVuZGVmaW5lZCA9ICh2KSA9PiB7XG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gISF2O1xufTtcbmNvbnN0IGV2YWx1YXRlT25lT3JaZXJvQm9vbGVhbklmTm90RW1wdHlTdHJpbmcgPSAodikgPT4ge1xuICAgIGlmICh2ID09PSAnJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdiA9PT0gJzEnO1xufTtcbmNvbnN0IGV2YWx1YXRlT25lT3JaZXJvQm9vbGVhbklmTm90VW5kZWZpbmVkID0gKHYpID0+IHtcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB2ID09PSAnMSc7XG59O1xuY29uc3QgZG93bmxvYWRGcm9tT2JqZWN0VVJMID0gKHsgZmlsZU5hbWUsIHVybCwgfSkgPT4ge1xuICAgIC8qKiBDcmVhdGUgYSBsaW5rIGFuZCBkb3dubG9hZCBmcm9tIGl0ICovXG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgbGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgbGluay5jbGljaygpO1xuICAgIC8qKiBDbGVhciB1cCB0aGUgZWxlbWVudCBhbmQgb2JqZWN0IHVybCAqL1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICBsaW5rLnJlbW92ZSgpO1xufTtcbmNvbnN0IGdlbmVyYXRlQ1NWID0gKHsgZGF0YSwgY29sdW1uSGVhZGVyTmFtZXMgPSB1bmRlZmluZWQsIGF1dG9HZW5lcmF0ZUNvbHVtbkhlYWRlck5hbWVzID0gdHJ1ZSwgc3RhcnRDYXNlRm9yQ29sdW5tSGVhZGVyTmFtZXMgPSBmYWxzZSwgfSkgPT4ge1xuICAgIHJldHVybiBzdHJpbmdpZnkoc3RhcnRDYXNlRm9yQ29sdW5tSGVhZGVyTmFtZXNcbiAgICAgICAgPyBkYXRhLm1hcCgoZCkgPT4gKGQgPyBtYXBLZXlzJDEoZCwgKF92LCBrZXkpID0+IHN0YXJ0Q2FzZSQxKGtleSkpIDogZCkpXG4gICAgICAgIDogZGF0YSwge1xuICAgICAgICAuLi4oYXV0b0dlbmVyYXRlQ29sdW1uSGVhZGVyTmFtZXMgfHwgYXV0b0dlbmVyYXRlQ29sdW1uSGVhZGVyTmFtZXNcbiAgICAgICAgICAgID8geyBoZWFkZXI6IHRydWUgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLihjb2x1bW5IZWFkZXJOYW1lcyA/IHsgY29sdW1uczogY29sdW1uSGVhZGVyTmFtZXMgfSA6IHt9KSxcbiAgICB9KTtcbn07XG5jb25zdCBkb3dubG9hZENTViA9ICh7IGNzdiwgZmlsZU5hbWUsIH0pID0+IHtcbiAgICAvKiogQ3JlYXRlIHVybCB0byB0aGUgY3N2IGZpbGUgKi9cbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2Nzdl0sIHsgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTgsJyB9KTtcbiAgICBjb25zdCBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICBkb3dubG9hZEZyb21PYmplY3RVUkwoeyBmaWxlTmFtZTogYCR7ZmlsZU5hbWV9LmNzdmAsIHVybDogYmxvYlVybCB9KTtcbn07XG5jb25zdCBkb3dubG9hZEpTT04gPSAoeyBqc29uLCBmaWxlTmFtZSwgfSkgPT4ge1xuICAgIC8qKiBDcmVhdGUgdXJsIHRvIHRoZSBqc29uIGZpbGUgKi9cbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2pzb25dLCB7XG4gICAgICAgIHR5cGU6ICd0ZXh0L2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCwnLFxuICAgIH0pO1xuICAgIGNvbnN0IGJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIGRvd25sb2FkRnJvbU9iamVjdFVSTCh7IGZpbGVOYW1lOiBgJHtmaWxlTmFtZX0uanNvbmAsIHVybDogYmxvYlVybCB9KTtcbn07XG5jb25zdCBnZXRSZWFjdFF1ZXJ5U3RhdHVzID0gKHsgaXNGZXRjaGluZyA9IGZhbHNlLCBpc0xvYWRpbmcgPSB0cnVlLCBpc0Vycm9yID0gZmFsc2UsIGlzU3VjY2VzcywgZGF0YVVwZGF0ZWRBdCwgfSwgeyBpc1JlYWR5ID0gZmFsc2UsIHNob3VsZExvYWRJbml0aWFsbHkgPSB0cnVlLCBzdGF0dXMsIH0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0ZldGNoaW5nLFxuICAgICAgICBpc0xvYWRpbmc6IHNob3VsZExvYWRJbml0aWFsbHlcbiAgICAgICAgICAgID8gISFpc0xvYWRpbmcgfHwgKCFpc0Vycm9yICYmICFpc1JlYWR5KVxuICAgICAgICAgICAgOiAhIWlzTG9hZGluZyxcbiAgICAgICAgaXNFcnJvcixcbiAgICAgICAgaXNTdWNjZXNzLFxuICAgICAgICBpczQwMTogc3RhdHVzID09PSA0MDEsXG4gICAgICAgIHVwZGF0ZWRBdDogZGF0YVVwZGF0ZWRBdCxcbiAgICB9O1xufTtcbmNvbnN0IHNhbml0aXNlVGV4dFRlcm0gPSAodGV4dFRlcm0gPSAnJykgPT4gKHRleHRUZXJtIHx8ICcnKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbmNvbnN0IHN0cmluZ3NFcXVhbEluc2Vuc2l0aXZlID0gKHN0cjEsIHN0cjIpID0+IHtcbiAgICBpZiAoc3RyMSA9PT0gdW5kZWZpbmVkIHx8IHN0cjEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2FuaXRpc2VUZXh0VGVybShzdHIxKSA9PT0gc2FuaXRpc2VUZXh0VGVybShzdHIyKTtcbn07XG5jb25zdCBjaGVja0lmVGV4dFRlcm1NYXRjaGVzU2luZ2xlID0gKHsgc291cmNlVmFsdWU6IHNvdXJjZVZhbHVlUmF3ID0gJycsIGlucHV0VmFsdWU6IGlucHV0VmFsdWVSYXcgPSAnJywgdXNlRnV6enkgPSB0cnVlLCB9KSA9PiB7XG4gICAgLyoqIEZ1enp5c29ydCBtYXRjaCBtaW5pbXVtIHRocmVzaG9sZC4gMCBpcyBhIHBlcmZlY3QgbWF0Y2gsIGxvd2VyIGlzIGEgd29yc2UgbWF0Y2ggKi9cbiAgICBjb25zdCBGVVpaWVNPUlRfTUFUQ0hfVEhSRVNIT0xEID0gLTc1O1xuICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc2FuaXRpc2VUZXh0VGVybShzb3VyY2VWYWx1ZVJhdyk7XG4gICAgY29uc3QgaW5wdXRWYWx1ZSA9IHNhbml0aXNlVGV4dFRlcm0oaW5wdXRWYWx1ZVJhdyk7XG4gICAgaWYgKCFzb3VyY2VWYWx1ZSB8fCAhaW5wdXRWYWx1ZSkge1xuICAgICAgICByZXR1cm4geyBtYXRjaGVzOiBmYWxzZSwgc2NvcmU6IC1JbmZpbml0eSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlVmFsdWUgPT09IGlucHV0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgbWF0Y2hlczogdHJ1ZSwgc2NvcmU6IDAgfTtcbiAgICB9XG4gICAgaWYgKHVzZUZ1enp5KSB7XG4gICAgICAgIGxldCBzY29yZSA9IGZ1enp5c29ydC5zaW5nbGUoaW5wdXRWYWx1ZSwgc291cmNlVmFsdWUpPy5zY29yZTtcbiAgICAgICAgaWYgKHNjb3JlID09PSB1bmRlZmluZWQgfHwgc2NvcmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHNjb3JlID0gLUluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VWYWx1ZS5pbmNsdWRlcyhpbnB1dFZhbHVlKSB8fCBzY29yZSA+IEZVWlpZU09SVF9NQVRDSF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoZXM6IHRydWUsIHNjb3JlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWF0Y2hlczogZmFsc2UsIHNjb3JlOiAtSW5maW5pdHkgfTtcbn07XG5jb25zdCBjaGVja0lmVGV4dFRlcm1NYXRjaGVzQXJyYXkgPSAoeyBpbnB1dFZhbHVlLCBhcnJheSwgdXNlRnV6enkgPSB0cnVlLCB9KSA9PiB7XG4gICAgaWYgKChpbnB1dFZhbHVlIHx8ICcnKS50cmltKCkpIHtcbiAgICAgICAgZm9yIChsZXQgYXJyYXlJbmRleCA9IDA7IGFycmF5SW5kZXggPCBhcnJheS5sZW5ndGg7IGFycmF5SW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheVthcnJheUluZGV4XTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgfHwgJycpLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0lmVGV4dFRlcm1NYXRjaGVzU2luZ2xlKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB1c2VGdXp6eSxcbiAgICAgICAgICAgICAgICB9KS5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGNyZWF0ZUN1c3RvbUtleSA9IChrZXlzKSA9PiBrZXlzLnJlZHVjZSgoa2V5LCBjdXJyZW50S2V5KSA9PiB7XG4gICAgY29uc3QgY29tcG9zaXRlS2V5SXNUcnV0aHkgPSBpc1RydXRoeU9yWmVybyhrZXkpO1xuICAgIGNvbnN0IGN1cnJlbnRLZXlJc1RydXRoeSA9IGlzVHJ1dGh5T3JaZXJvKGN1cnJlbnRLZXkpO1xuICAgIHJldHVybiBgJHtrZXl9JHtjb21wb3NpdGVLZXlJc1RydXRoeSA/ICd8JyA6ICcnfSR7Y3VycmVudEtleUlzVHJ1dGh5ID8gY3VycmVudEtleSA6ICcnfWA7XG59LCAnJyk7XG5jb25zdCBjcmVhdGVDdXN0b21LZXlGcm9tT2JqZWN0ID0gKG9iaiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBrZXlWYWx1ZVNlcGFyYXRvciwgc2VwYXJhdG9yIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGt2U2VwID0ga2V5VmFsdWVTZXBhcmF0b3IgfHwgJzonO1xuICAgIGNvbnN0IHNlcCA9IHNlcGFyYXRvciB8fCAnfCc7XG4gICAgcmV0dXJuIHNvcnRCeSQxKE9iamVjdC5lbnRyaWVzKHJlbW92ZVVuZGVmaW5lZFZhbHVlc0Zyb21PYmoob2JqKSksIChbaywgdl0pID0+IGAke2t9OiR7dn1gKS5yZWR1Y2UoKGtleSwgW2N1cnJlbnRLZXksIGN1cnJlbnRWYWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3Qgc2hvdWxkRXhjbHVkZVZhbHVlID0gIWN1cnJlbnRLZXkgfHxcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9PT0gJycgfHxcbiAgICAgICAgICAgIChpc0FycmF5JGYoY3VycmVudFZhbHVlKSAmJiAhY3VycmVudFZhbHVlPy5sZW5ndGgpO1xuICAgICAgICBjb25zdCB2YWx1ZUlzT2JqZWN0ID0gaXNPYmplY3QkOShjdXJyZW50VmFsdWUpO1xuICAgICAgICBjb25zdCB2YWx1ZUlzQXJyYXkgPSBpc0FycmF5JGYoY3VycmVudFZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWVOZWVkc1RyYW5zZm9ybWluZyA9IHZhbHVlSXNBcnJheSB8fCB2YWx1ZUlzT2JqZWN0O1xuICAgICAgICBsZXQgdmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZU5lZWRzVHJhbnNmb3JtaW5nKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjdXJyZW50VmFsdWUuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVJc09iamVjdCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY3JlYXRlQ3VzdG9tS2V5RnJvbU9iamVjdChjdXJyZW50VmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2hvdWxkRXhjbHVkZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSAnJ1xuICAgICAgICAgICAgICAgID8gYCR7Y3VycmVudEtleX0ke2t2U2VwfSR7dmFsdWV9YFxuICAgICAgICAgICAgICAgIDogYCR7a2V5fSR7c2VwfSR7Y3VycmVudEtleX0ke2t2U2VwfSR7dmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH0sICcnKTtcbn07XG5jb25zdCBjcmVhdGVDdXN0b21GaWxlTmFtZUtleUZyb21PYmplY3QgPSAob2JqKSA9PiBjcmVhdGVDdXN0b21LZXlGcm9tT2JqZWN0KG1hcFZhbHVlcyQxKG9iaiwgKHYpID0+IHtcbiAgICBpZiAodiA9PT0gdHJ1ZSB8fCB2ID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmV0dXJuICcxJztcbiAgICB9XG4gICAgaWYgKHYgPT09IGZhbHNlIHx8IHYgPT09ICdmYWxzZScpIHtcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59KSwgeyBzZXBhcmF0b3I6ICdfJywga2V5VmFsdWVTZXBhcmF0b3I6ICc9JyB9KTtcbmNvbnN0IGNyZWF0ZUN1c3RvbUtleUZyb21TcmNUZ3QgPSAoeyBzcmNJRCwgdGd0SUQsIH0pID0+IGNyZWF0ZUN1c3RvbUtleShbc3JjSUQsIHRndElEXSk7XG5jb25zdCBpc0VtYWlsID0gKHYpID0+ICEhKCEhdiAmJiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgdi5sZW5ndGggJiYgRU1BSUxfUkVHRVgudGVzdCh2KSk7XG5jb25zdCBzbGVlcCA9IChtcykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgICB9KTtcbn07XG5jb25zdCBtZXJnZU9iamVjdCA9ICguLi5wYXJhbXMpID0+IG1lcmdlJDEoe30sIC4uLnBhcmFtcyk7XG5jb25zdCBtZXJnZU9iamVjdFJlcGxhY2luZ0FycmF5cyA9ICguLi5wYXJhbXMpID0+IG1lcmdlV2l0aCQxKHt9LCAuLi5wYXJhbXMsIChfYSwgYikgPT4gaXNBcnJheSRmKGIpID8gYiA6IHVuZGVmaW5lZCk7XG5jb25zdCBsb2cgPSAobiwgYmFzZSA9IGUpID0+IHtcbiAgICByZXR1cm4gTWF0aC5sb2cobikgLyAoYmFzZSA/IE1hdGgubG9nKGJhc2UpIDogMSk7XG59O1xuY29uc3QgYW50aWxvZyA9IChuLCBiYXNlID0gZSkgPT4ge1xuICAgIGlmIChiYXNlID09PSBlKVxuICAgICAgICByZXR1cm4gTWF0aC5leHAobik7XG4gICAgcmV0dXJuIGJhc2UgKiogbjtcbn07XG5jb25zdCBvcGVuVXJsSW5OZXdUYWIgPSAodXJsKSA9PiB7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgIHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycpPy5mb2N1cygpO1xuICAgIH1cbn07XG5jb25zdCBpc0VxdWFsSWdub3JpbmdPcmRlciA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGlzQXJyYXkkZihhKSAmJiBpc0FycmF5JGYoYikpIHtcbiAgICAgICAgcmV0dXJuIGlzRXF1YWwkMShzb3J0QnkkMShhLCBbKHYpID0+IHZdKSwgc29ydEJ5JDEoYiwgWyh2KSA9PiB2XSkpO1xuICAgIH1cbiAgICByZXR1cm4gaXNFcXVhbCQxKGEsIGIpO1xufTtcbmNvbnN0IGNsYW1wVmFsdWUgPSAoeyBtaW4sIG1heCwgdmFsdWUsIH0pID0+IHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPD0gbWluKSB7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IGtleUJ5V2l0aFVuZGVmaW5lZCA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSkgPT4ge1xuICAgIHJldHVybiAoY29sbGVjdGlvbiA/IGtleUJ5JDEoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIDoge30pO1xufTtcbmNvbnN0IGdldFJhbmRvbU51bWJlciA9IChtaW4sIG1heCkgPT4ge1xuICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICAgIGNvbnN0IGRpc3RhbmNlVGhyb3VnaFJhbmdlID0gTWF0aC5yYW5kb20oKSAqIHJhbmdlO1xuICAgIHJldHVybiBtaW4gKyBkaXN0YW5jZVRocm91Z2hSYW5nZTtcbn07XG5jb25zdCBnZXRSYW5kb21JbnRlZ2VyID0gKG1pbiwgbWF4KSA9PiB7XG4gICAgY29uc3QgcmFuZG9tTnVtYmVyID0gZ2V0UmFuZG9tTnVtYmVyKG1pbiwgbWF4KTtcbiAgICBjb25zdCByb3VuZGVkRG93biA9IE1hdGguZmxvb3IocmFuZG9tTnVtYmVyKTtcbiAgICBjb25zdCByb3VuZGVkVXAgPSBNYXRoLmNlaWwocmFuZG9tTnVtYmVyKTtcbiAgICBjb25zdCBudW1iZXIgPSBNYXRoLnJhbmRvbSgpID4gMC41ID8gcm91bmRlZERvd24gOiByb3VuZGVkVXA7XG4gICAgaWYgKG51bWJlciA+IG1heCkge1xuICAgICAgICByZXR1cm4gbnVtYmVyIC0gMTtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IG1pbikge1xuICAgICAgICByZXR1cm4gbnVtYmVyICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIG51bWJlcjtcbn07XG5cbmNvbnN0IGFzc2VydFRydXRoeU9yWmVybyA9ICh2YWx1ZSkgPT4gaXNUcnV0aHlPclplcm8odmFsdWUpO1xuXG5jb25zdCBDQUNIRV9USU1FXzcyX0hPVVJTID0gMTAwMCAqIDYwICogNjAgKiA3MjtcbmNvbnN0IENBQ0hFX1RJTUVfNDhfSE9VUlMgPSAxMDAwICogNjAgKiA2MCAqIDQ4O1xuY29uc3QgQ0FDSEVfVElNRV8xX0hPVVIgPSAxMDAwICogNjAgKiA2MCAqIDE7XG5jb25zdCBDQUNIRV9USU1FXzMwX01JTlVURVMgPSAxMDAwICogNjAgKiAzMDtcbmNvbnN0IGNyZWF0ZVRpbWVNc0luTWludXRlcyA9IChtaW51dGVzID0gMCkgPT4gMTAwMCAqIDYwICogbWludXRlcztcbmNvbnN0IGNyZWF0ZVRpbWVNc0luSG91cnMgPSAoaG91cnMgPSAwKSA9PiBjcmVhdGVUaW1lTXNJbk1pbnV0ZXMoNjAgKiBob3Vycyk7XG5jb25zdCBjcmVhdGVUaW1lTXNJbkRheXMgPSAoZGF5cyA9IDApID0+IGNyZWF0ZVRpbWVNc0luSG91cnMoMjQgKiBkYXlzKTtcblxuZXhwb3J0IHsgQ0FDSEVfVElNRV8xX0hPVVIsIENBQ0hFX1RJTUVfMzBfTUlOVVRFUywgQ0FDSEVfVElNRV80OF9IT1VSUywgQ0FDSEVfVElNRV83Ml9IT1VSUywgUkdCQVRvSGV4QSwgYW50aWxvZywgYXJyYXlXaXRob3V0RWxlbWVudHMsIGFzc2VydFRydXRoeU9yWmVybywgY2FwaXRhbGlzZUZpcnN0TGV0dGVyLCBjaGVja0lmVGV4dFRlcm1NYXRjaGVzQXJyYXksIGNoZWNrSWZUZXh0VGVybU1hdGNoZXNTaW5nbGUsIGNsYW1wVmFsdWUsIGNsZWFuU3RyaW5nLCBjb25kaXRpb25hbE9ySWZUcnV0aHlPclplcm8sIGNyZWF0ZUN1c3RvbUZpbGVOYW1lS2V5RnJvbU9iamVjdCwgY3JlYXRlQ3VzdG9tS2V5LCBjcmVhdGVDdXN0b21LZXlGcm9tT2JqZWN0LCBjcmVhdGVDdXN0b21LZXlGcm9tU3JjVGd0LCBjcmVhdGVUaW1lTXNJbkRheXMsIGNyZWF0ZVRpbWVNc0luSG91cnMsIGNyZWF0ZVRpbWVNc0luTWludXRlcywgZG93bmxvYWRDU1YsIGRvd25sb2FkRnJvbU9iamVjdFVSTCwgZG93bmxvYWRKU09OLCBldmFsdWF0ZU9uZU9yWmVyb0Jvb2xlYW5JZk5vdEVtcHR5U3RyaW5nLCBldmFsdWF0ZU9uZU9yWmVyb0Jvb2xlYW5JZk5vdFVuZGVmaW5lZCwgZXZhbHVhdGVUcnV0aHlJZk5vdFVuZGVmaW5lZCwgZ2VuZXJhdGVDU1YsIGdlbmVyYXRlUXVlcnlTdHJpbmcsIGdldE5SYW5kb21FbGVtZW50c0Zyb21BcnJheSwgZ2V0TmV4dEpTUXVlcnlQYXJhbSwgZ2V0UmFuZG9tRWxlbWVudEZyb21BcnJheSwgZ2V0UmFuZG9tRWxlbWVudHNGcm9tQXJyYXksIGdldFJhbmRvbUludGVnZXIsIGdldFJhbmRvbU51bWJlciwgZ2V0UmVhY3RRdWVyeVN0YXR1cywgaXNCcm93c2VyLCBpc0VtYWlsLCBpc0VxdWFsSWdub3JpbmdPcmRlciwgaXNUcnV0aHlPclplcm8sIGtleUJ5V2l0aFVuZGVmaW5lZCwgbG9nLCBtZXJnZUNsYXNzTmFtZXNEZWVwLCBtZXJnZUNsYXNzTmFtZXNGdW5jdGlvbnNEZWVwLCBtZXJnZU9iamVjdCwgbWVyZ2VPYmplY3RSZXBsYWNpbmdBcnJheXMsIG5vcm1hbGlzZVN0cmluZywgb3BlblVybEluTmV3VGFiLCBwYXJzZUVudlZhcmlhYmxlLCBwYXJzZUVudlZhcmlhYmxlcywgcmVtb3ZlVW5kZWZpbmVkQW5kRW1wdHlTdHJpbmdWYWx1ZXNGcm9tT2JqLCByZW1vdmVVbmRlZmluZWRBbmROdWxsVmFsdWVzRnJvbU9iaiwgcmVtb3ZlVW5kZWZpbmVkVmFsdWVzRnJvbU9iaiwgcm91bmROdW1iZXIsIHNhbml0aXNlVGV4dFRlcm0sIHNsZWVwLCBzdHJpbmdzRXF1YWxJbnNlbnNpdGl2ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkNBQ0hFX1RJTUVfMV9IT1VSIiwiQ0FDSEVfVElNRV8zMF9NSU5VVEVTIiwiQ0FDSEVfVElNRV80OF9IT1VSUyIsIkNBQ0hFX1RJTUVfNzJfSE9VUlMiLCJSR0JBVG9IZXhBIiwiYW50aWxvZyIsImFycmF5V2l0aG91dEVsZW1lbnRzIiwiYXNzZXJ0VHJ1dGh5T3JaZXJvIiwiY2FwaXRhbGlzZUZpcnN0TGV0dGVyIiwiY2hlY2tJZlRleHRUZXJtTWF0Y2hlc0FycmF5IiwiY2hlY2tJZlRleHRUZXJtTWF0Y2hlc1NpbmdsZSIsImNsYW1wVmFsdWUiLCJjbGVhblN0cmluZyIsImNvbmRpdGlvbmFsT3JJZlRydXRoeU9yWmVybyIsImNyZWF0ZUN1c3RvbUZpbGVOYW1lS2V5RnJvbU9iamVjdCIsImNyZWF0ZUN1c3RvbUtleSIsImNyZWF0ZUN1c3RvbUtleUZyb21PYmplY3QiLCJjcmVhdGVDdXN0b21LZXlGcm9tU3JjVGd0IiwiY3JlYXRlVGltZU1zSW5EYXlzIiwiY3JlYXRlVGltZU1zSW5Ib3VycyIsImNyZWF0ZVRpbWVNc0luTWludXRlcyIsImRvd25sb2FkQ1NWIiwiZG93bmxvYWRGcm9tT2JqZWN0VVJMIiwiZG93bmxvYWRKU09OIiwiZXZhbHVhdGVPbmVPclplcm9Cb29sZWFuSWZOb3RFbXB0eVN0cmluZyIsImV2YWx1YXRlT25lT3JaZXJvQm9vbGVhbklmTm90VW5kZWZpbmVkIiwiZXZhbHVhdGVUcnV0aHlJZk5vdFVuZGVmaW5lZCIsImdlbmVyYXRlQ1NWIiwiZ2VuZXJhdGVRdWVyeVN0cmluZyIsImdldE5SYW5kb21FbGVtZW50c0Zyb21BcnJheSIsImdldE5leHRKU1F1ZXJ5UGFyYW0iLCJnZXRSYW5kb21FbGVtZW50RnJvbUFycmF5IiwiZ2V0UmFuZG9tRWxlbWVudHNGcm9tQXJyYXkiLCJnZXRSYW5kb21JbnRlZ2VyIiwiZ2V0UmFuZG9tTnVtYmVyIiwiZ2V0UmVhY3RRdWVyeVN0YXR1cyIsImlzQnJvd3NlciIsImlzRW1haWwiLCJpc0VxdWFsSWdub3JpbmdPcmRlciIsImlzVHJ1dGh5T3JaZXJvIiwia2V5QnlXaXRoVW5kZWZpbmVkIiwibG9nIiwibWVyZ2VDbGFzc05hbWVzRGVlcCIsIm1lcmdlQ2xhc3NOYW1lc0Z1bmN0aW9uc0RlZXAiLCJtZXJnZU9iamVjdCIsIm1lcmdlT2JqZWN0UmVwbGFjaW5nQXJyYXlzIiwibm9ybWFsaXNlU3RyaW5nIiwib3BlblVybEluTmV3VGFiIiwicGFyc2VFbnZWYXJpYWJsZSIsInBhcnNlRW52VmFyaWFibGVzIiwicmVtb3ZlVW5kZWZpbmVkQW5kRW1wdHlTdHJpbmdWYWx1ZXNGcm9tT2JqIiwicmVtb3ZlVW5kZWZpbmVkQW5kTnVsbFZhbHVlc0Zyb21PYmoiLCJyZW1vdmVVbmRlZmluZWRWYWx1ZXNGcm9tT2JqIiwicm91bmROdW1iZXIiLCJzYW5pdGlzZVRleHRUZXJtIiwic2xlZXAiLCJzdHJpbmdzRXF1YWxJbnNlbnNpdGl2ZSIsImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIngiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXJyYXlSZWR1Y2UkMiIsImFycmF5IiwiaXRlcmF0ZWUiLCJhY2N1bXVsYXRvciIsImluaXRBY2N1bSIsImluZGV4IiwibGVuZ3RoIiwiX2FycmF5UmVkdWNlIiwiY3JlYXRlQmFzZUZvciQxIiwiZnJvbVJpZ2h0Iiwib2JqZWN0Iiwia2V5c0Z1bmMiLCJpdGVyYWJsZSIsInByb3BzIiwia2V5IiwiX2NyZWF0ZUJhc2VGb3IiLCJjcmVhdGVCYXNlRm9yIiwiYmFzZUZvciQyIiwiX2Jhc2VGb3IiLCJiYXNlVGltZXMkMSIsIm4iLCJyZXN1bHQiLCJBcnJheSIsIl9iYXNlVGltZXMiLCJmcmVlR2xvYmFsJDEiLCJfZnJlZUdsb2JhbCIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QkOCIsIkZ1bmN0aW9uIiwiX3Jvb3QiLCJyb290JDciLCJTeW1ib2wkNiIsIlN5bWJvbCIsIl9TeW1ib2wiLCJTeW1ib2wkNSIsIm9iamVjdFByb3RvJGUiLCJoYXNPd25Qcm9wZXJ0eSRiIiwibmF0aXZlT2JqZWN0VG9TdHJpbmckMSIsInRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWckMSIsInRvU3RyaW5nVGFnIiwidW5kZWZpbmVkIiwiZ2V0UmF3VGFnJDEiLCJ2YWx1ZSIsImlzT3duIiwidGFnIiwidW5tYXNrZWQiLCJlIiwiX2dldFJhd1RhZyIsIm9iamVjdFByb3RvJGQiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsIm9iamVjdFRvU3RyaW5nJDEiLCJfb2JqZWN0VG9TdHJpbmciLCJTeW1ib2wkNCIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwiYmFzZUdldFRhZyQ2IiwiX2Jhc2VHZXRUYWciLCJpc09iamVjdExpa2UkNyIsImlzT2JqZWN0TGlrZV8xIiwiYmFzZUdldFRhZyQ1IiwiaXNPYmplY3RMaWtlJDYiLCJhcmdzVGFnJDIiLCJiYXNlSXNBcmd1bWVudHMkMSIsIl9iYXNlSXNBcmd1bWVudHMiLCJiYXNlSXNBcmd1bWVudHMiLCJpc09iamVjdExpa2UkNSIsIm9iamVjdFByb3RvJGMiLCJoYXNPd25Qcm9wZXJ0eSRhIiwicHJvcGVydHlJc0VudW1lcmFibGUkMSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMkNCIsImFyZ3VtZW50cyIsImlzQXJndW1lbnRzXzEiLCJpc0FycmF5JGUiLCJpc0FycmF5IiwiaXNBcnJheV8xIiwiaXNBcnJheSRmIiwiaXNCdWZmZXIkNCIsImV4cG9ydHMiLCJzdHViRmFsc2UiLCJzdHViRmFsc2VfMSIsIm1vZHVsZSIsInJvb3QiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiaXNCdWZmZXJFeHBvcnRzIiwiTUFYX1NBRkVfSU5URUdFUiQxIiwicmVJc1VpbnQiLCJpc0luZGV4JDMiLCJ0eXBlIiwidGVzdCIsIl9pc0luZGV4IiwiTUFYX1NBRkVfSU5URUdFUiIsImlzTGVuZ3RoJDMiLCJpc0xlbmd0aF8xIiwiYmFzZUdldFRhZyQ0IiwiaXNMZW5ndGgkMiIsImlzT2JqZWN0TGlrZSQ0IiwiYXJnc1RhZyQxIiwiYXJyYXlUYWckMSIsImJvb2xUYWckMSIsImRhdGVUYWckMSIsImVycm9yVGFnJDEiLCJmdW5jVGFnJDEiLCJtYXBUYWckMiIsIm51bWJlclRhZyQxIiwib2JqZWN0VGFnJDMiLCJyZWdleHBUYWckMSIsInNldFRhZyQyIiwic3RyaW5nVGFnJDEiLCJ3ZWFrTWFwVGFnJDEiLCJhcnJheUJ1ZmZlclRhZyQxIiwiZGF0YVZpZXdUYWckMiIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSQxIiwiX2Jhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkkMiIsImZ1bmMiLCJfYmFzZVVuYXJ5IiwiX25vZGVVdGlsIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwiX25vZGVVdGlsRXhwb3J0cyIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkkMSIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkkMyIsImlzVHlwZWRBcnJheV8xIiwiYmFzZVRpbWVzIiwiaXNBcmd1bWVudHMkMyIsImlzQXJyYXkkZCIsImlzQnVmZmVyJDMiLCJpc0luZGV4JDIiLCJpc1R5cGVkQXJyYXkkMiIsIm9iamVjdFByb3RvJGIiLCJoYXNPd25Qcm9wZXJ0eSQ5IiwiYXJyYXlMaWtlS2V5cyQyIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiU3RyaW5nIiwicHVzaCIsIl9hcnJheUxpa2VLZXlzIiwib2JqZWN0UHJvdG8kYSIsImlzUHJvdG90eXBlJDMiLCJDdG9yIiwiY29uc3RydWN0b3IiLCJwcm90byIsIl9pc1Byb3RvdHlwZSIsIm92ZXJBcmckMiIsInRyYW5zZm9ybSIsImFyZyIsIl9vdmVyQXJnIiwib3ZlckFyZyQxIiwibmF0aXZlS2V5cyQxIiwia2V5cyIsIl9uYXRpdmVLZXlzIiwiaXNQcm90b3R5cGUkMiIsIm5hdGl2ZUtleXMiLCJvYmplY3RQcm90byQ5IiwiaGFzT3duUHJvcGVydHkkOCIsImJhc2VLZXlzJDEiLCJfYmFzZUtleXMiLCJpc09iamVjdCQ4IiwiaXNPYmplY3RfMSIsImlzT2JqZWN0JDkiLCJiYXNlR2V0VGFnJDMiLCJpc09iamVjdCQ3IiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uJDMiLCJpc0Z1bmN0aW9uXzEiLCJpc0Z1bmN0aW9uJDIiLCJpc0xlbmd0aCQxIiwiaXNBcnJheUxpa2UkNiIsImlzQXJyYXlMaWtlXzEiLCJhcnJheUxpa2VLZXlzJDEiLCJiYXNlS2V5cyIsImlzQXJyYXlMaWtlJDUiLCJrZXlzJDMiLCJrZXlzXzEiLCJiYXNlRm9yJDEiLCJrZXlzJDIiLCJiYXNlRm9yT3duJDMiLCJfYmFzZUZvck93biIsImlzQXJyYXlMaWtlJDQiLCJjcmVhdGVCYXNlRWFjaCQxIiwiZWFjaEZ1bmMiLCJjb2xsZWN0aW9uIiwiX2NyZWF0ZUJhc2VFYWNoIiwiYmFzZUZvck93biQyIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRWFjaCQzIiwiX2Jhc2VFYWNoIiwibGlzdENhY2hlQ2xlYXIkMSIsIl9fZGF0YV9fIiwic2l6ZSIsIl9saXN0Q2FjaGVDbGVhciIsImVxJDUiLCJvdGhlciIsImVxXzEiLCJlcSQ0IiwiYXNzb2NJbmRleE9mJDQiLCJfYXNzb2NJbmRleE9mIiwiYXNzb2NJbmRleE9mJDMiLCJhcnJheVByb3RvIiwic3BsaWNlIiwibGlzdENhY2hlRGVsZXRlJDEiLCJkYXRhIiwibGFzdEluZGV4IiwicG9wIiwiX2xpc3RDYWNoZURlbGV0ZSIsImFzc29jSW5kZXhPZiQyIiwibGlzdENhY2hlR2V0JDEiLCJfbGlzdENhY2hlR2V0IiwiYXNzb2NJbmRleE9mJDEiLCJsaXN0Q2FjaGVIYXMkMSIsIl9saXN0Q2FjaGVIYXMiLCJhc3NvY0luZGV4T2YiLCJsaXN0Q2FjaGVTZXQkMSIsIl9saXN0Q2FjaGVTZXQiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSQ0IiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJzZXQiLCJnZXQiLCJoYXMiLCJfTGlzdENhY2hlIiwiTGlzdENhY2hlJDMiLCJzdGFja0NsZWFyJDEiLCJfc3RhY2tDbGVhciIsInN0YWNrRGVsZXRlJDEiLCJfc3RhY2tEZWxldGUiLCJzdGFja0dldCQxIiwiX3N0YWNrR2V0Iiwic3RhY2tIYXMkMSIsIl9zdGFja0hhcyIsInJvb3QkNiIsImNvcmVKc0RhdGEkMSIsIl9jb3JlSnNEYXRhIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwiSUVfUFJPVE8iLCJpc01hc2tlZCQxIiwiX2lzTWFza2VkIiwiZnVuY1Byb3RvJDIiLCJmdW5jVG9TdHJpbmckMiIsInRvU291cmNlJDIiLCJfdG9Tb3VyY2UiLCJpc0Z1bmN0aW9uJDEiLCJpc01hc2tlZCIsImlzT2JqZWN0JDYiLCJ0b1NvdXJjZSQxIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwiZnVuY1Byb3RvJDEiLCJvYmplY3RQcm90byQ4IiwiZnVuY1RvU3RyaW5nJDEiLCJoYXNPd25Qcm9wZXJ0eSQ3IiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsInJlcGxhY2UiLCJiYXNlSXNOYXRpdmUkMSIsInBhdHRlcm4iLCJfYmFzZUlzTmF0aXZlIiwiZ2V0VmFsdWUkMSIsIl9nZXRWYWx1ZSIsImJhc2VJc05hdGl2ZSIsImdldFZhbHVlIiwiZ2V0TmF0aXZlJDciLCJfZ2V0TmF0aXZlIiwiZ2V0TmF0aXZlJDYiLCJyb290JDUiLCJNYXAkMyIsIl9NYXAiLCJnZXROYXRpdmUkNSIsIm5hdGl2ZUNyZWF0ZSQ0IiwiX25hdGl2ZUNyZWF0ZSIsIm5hdGl2ZUNyZWF0ZSQzIiwiaGFzaENsZWFyJDEiLCJfaGFzaENsZWFyIiwiaGFzaERlbGV0ZSQxIiwiX2hhc2hEZWxldGUiLCJuYXRpdmVDcmVhdGUkMiIsIkhBU0hfVU5ERUZJTkVEJDIiLCJvYmplY3RQcm90byQ3IiwiaGFzT3duUHJvcGVydHkkNiIsImhhc2hHZXQkMSIsIl9oYXNoR2V0IiwibmF0aXZlQ3JlYXRlJDEiLCJvYmplY3RQcm90byQ2IiwiaGFzT3duUHJvcGVydHkkNSIsImhhc2hIYXMkMSIsIl9oYXNoSGFzIiwibmF0aXZlQ3JlYXRlIiwiSEFTSF9VTkRFRklORUQkMSIsImhhc2hTZXQkMSIsIl9oYXNoU2V0IiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2gkMSIsIl9IYXNoIiwiSGFzaCIsIkxpc3RDYWNoZSQyIiwiTWFwJDIiLCJtYXBDYWNoZUNsZWFyJDEiLCJfbWFwQ2FjaGVDbGVhciIsImlzS2V5YWJsZSQxIiwiX2lzS2V5YWJsZSIsImlzS2V5YWJsZSIsImdldE1hcERhdGEkNCIsIm1hcCIsIl9nZXRNYXBEYXRhIiwiZ2V0TWFwRGF0YSQzIiwibWFwQ2FjaGVEZWxldGUkMSIsIl9tYXBDYWNoZURlbGV0ZSIsImdldE1hcERhdGEkMiIsIm1hcENhY2hlR2V0JDEiLCJfbWFwQ2FjaGVHZXQiLCJnZXRNYXBEYXRhJDEiLCJtYXBDYWNoZUhhcyQxIiwiX21hcENhY2hlSGFzIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlU2V0JDEiLCJfbWFwQ2FjaGVTZXQiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSQzIiwiX01hcENhY2hlIiwiTGlzdENhY2hlJDEiLCJNYXAkMSIsIk1hcENhY2hlJDIiLCJMQVJHRV9BUlJBWV9TSVpFIiwic3RhY2tTZXQkMSIsInBhaXJzIiwiX3N0YWNrU2V0IiwiTGlzdENhY2hlIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiU3RhY2skMyIsIl9TdGFjayIsIkhBU0hfVU5ERUZJTkVEIiwic2V0Q2FjaGVBZGQkMSIsIl9zZXRDYWNoZUFkZCIsInNldENhY2hlSGFzJDEiLCJfc2V0Q2FjaGVIYXMiLCJNYXBDYWNoZSQxIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlNldENhY2hlJDEiLCJ2YWx1ZXMiLCJhZGQiLCJfU2V0Q2FjaGUiLCJhcnJheVNvbWUkMSIsInByZWRpY2F0ZSIsIl9hcnJheVNvbWUiLCJjYWNoZUhhcyQxIiwiY2FjaGUiLCJfY2FjaGVIYXMiLCJTZXRDYWNoZSIsImFycmF5U29tZSIsImNhY2hlSGFzIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMyIsImVxdWFsQXJyYXlzJDIiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsImVxdWFsRnVuYyIsInN0YWNrIiwiaXNQYXJ0aWFsIiwiYXJyTGVuZ3RoIiwib3RoTGVuZ3RoIiwiYXJyU3RhY2tlZCIsIm90aFN0YWNrZWQiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJfZXF1YWxBcnJheXMiLCJyb290JDQiLCJVaW50OEFycmF5JDMiLCJVaW50OEFycmF5IiwiX1VpbnQ4QXJyYXkiLCJtYXBUb0FycmF5JDEiLCJmb3JFYWNoIiwiX21hcFRvQXJyYXkiLCJzZXRUb0FycmF5JDEiLCJfc2V0VG9BcnJheSIsIlN5bWJvbCQzIiwiVWludDhBcnJheSQyIiwiZXEkMyIsImVxdWFsQXJyYXlzJDEiLCJtYXBUb0FycmF5Iiwic2V0VG9BcnJheSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDQiLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHJDIiLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnJDEiLCJudW1iZXJUYWciLCJyZWdleHBUYWciLCJzZXRUYWckMSIsInN0cmluZ1RhZyIsInN5bWJvbFRhZyQxIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyQxIiwic3ltYm9sUHJvdG8kMSIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiZXF1YWxCeVRhZyQxIiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJidWZmZXIiLCJuYW1lIiwibWVzc2FnZSIsImNvbnZlcnQiLCJzdGFja2VkIiwiX2VxdWFsQnlUYWciLCJhcnJheVB1c2gkMiIsIm9mZnNldCIsIl9hcnJheVB1c2giLCJhcnJheVB1c2gkMSIsImlzQXJyYXkkYyIsImJhc2VHZXRBbGxLZXlzJDEiLCJzeW1ib2xzRnVuYyIsIl9iYXNlR2V0QWxsS2V5cyIsImFycmF5RmlsdGVyJDEiLCJyZXNJbmRleCIsIl9hcnJheUZpbHRlciIsInN0dWJBcnJheSQxIiwic3R1YkFycmF5XzEiLCJhcnJheUZpbHRlciIsInN0dWJBcnJheSIsIm9iamVjdFByb3RvJDUiLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0U3ltYm9scyQxIiwic3ltYm9sIiwiX2dldFN5bWJvbHMiLCJiYXNlR2V0QWxsS2V5cyIsImdldFN5bWJvbHMiLCJrZXlzJDEiLCJnZXRBbGxLZXlzJDEiLCJfZ2V0QWxsS2V5cyIsImdldEFsbEtleXMiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyQzIiwib2JqZWN0UHJvdG8kNCIsImhhc093blByb3BlcnR5JDQiLCJlcXVhbE9iamVjdHMkMSIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJvYmpTdGFja2VkIiwic2tpcEN0b3IiLCJvYmpWYWx1ZSIsIm9iakN0b3IiLCJvdGhDdG9yIiwiX2VxdWFsT2JqZWN0cyIsImdldE5hdGl2ZSQ0Iiwicm9vdCQzIiwiRGF0YVZpZXckMSIsIl9EYXRhVmlldyIsImdldE5hdGl2ZSQzIiwicm9vdCQyIiwiUHJvbWlzZSQyIiwiX1Byb21pc2UiLCJnZXROYXRpdmUkMiIsInJvb3QkMSIsIlNldCQyIiwiX1NldCIsImdldE5hdGl2ZSQxIiwiV2Vha01hcCQxIiwiX1dlYWtNYXAiLCJEYXRhVmlldyIsIk1hcCIsIlByb21pc2UkMSIsIlNldCQxIiwiV2Vha01hcCIsImJhc2VHZXRUYWckMiIsInRvU291cmNlIiwibWFwVGFnIiwib2JqZWN0VGFnJDIiLCJwcm9taXNlVGFnIiwic2V0VGFnIiwid2Vha01hcFRhZyIsImRhdGFWaWV3VGFnIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiZ2V0VGFnJDIiLCJBcnJheUJ1ZmZlciIsInJlc29sdmUiLCJjdG9yU3RyaW5nIiwiX2dldFRhZyIsIlN0YWNrJDIiLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJlcXVhbE9iamVjdHMiLCJnZXRUYWckMSIsImlzQXJyYXkkYiIsImlzQnVmZmVyJDIiLCJpc1R5cGVkQXJyYXkkMSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDIiLCJhcmdzVGFnIiwiYXJyYXlUYWciLCJvYmplY3RUYWckMSIsIm9iamVjdFByb3RvJDMiLCJoYXNPd25Qcm9wZXJ0eSQzIiwiYmFzZUlzRXF1YWxEZWVwJDEiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsIl9iYXNlSXNFcXVhbERlZXAiLCJiYXNlSXNFcXVhbERlZXAiLCJpc09iamVjdExpa2UkMyIsImJhc2VJc0VxdWFsJDMiLCJfYmFzZUlzRXF1YWwiLCJTdGFjayQxIiwiYmFzZUlzRXF1YWwkMiIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDEiLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEiLCJiYXNlSXNNYXRjaCQxIiwic291cmNlIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwic3JjVmFsdWUiLCJfYmFzZUlzTWF0Y2giLCJpc09iamVjdCQ1IiwiaXNTdHJpY3RDb21wYXJhYmxlJDIiLCJfaXNTdHJpY3RDb21wYXJhYmxlIiwiaXNTdHJpY3RDb21wYXJhYmxlJDEiLCJnZXRNYXRjaERhdGEkMSIsIl9nZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQyIiwiX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiYmFzZUlzTWF0Y2giLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQxIiwiYmFzZU1hdGNoZXMkMSIsIl9iYXNlTWF0Y2hlcyIsImJhc2VHZXRUYWckMSIsImlzT2JqZWN0TGlrZSQyIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wkNSIsImlzU3ltYm9sXzEiLCJpc0FycmF5JGEiLCJpc1N5bWJvbCQ0IiwicmVJc0RlZXBQcm9wJDEiLCJyZUlzUGxhaW5Qcm9wJDEiLCJpc0tleSQ0IiwiX2lzS2V5IiwiTWFwQ2FjaGUiLCJGVU5DX0VSUk9SX1RFWFQiLCJtZW1vaXplJDEiLCJyZXNvbHZlciIsIlR5cGVFcnJvciIsIm1lbW9pemVkIiwiYXJncyIsImFwcGx5IiwiQ2FjaGUiLCJtZW1vaXplXzEiLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQkMSIsIl9tZW1vaXplQ2FwcGVkIiwibWVtb2l6ZUNhcHBlZCIsInJlUHJvcE5hbWUkMSIsInJlRXNjYXBlQ2hhciQxIiwic3RyaW5nVG9QYXRoJDIiLCJzdHJpbmciLCJjaGFyQ29kZUF0IiwibWF0Y2giLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsIl9zdHJpbmdUb1BhdGgiLCJhcnJheU1hcCQyIiwiX2FycmF5TWFwIiwiU3ltYm9sJDIiLCJhcnJheU1hcCQxIiwiaXNBcnJheSQ5IiwiaXNTeW1ib2wkMyIsIklORklOSVRZJDIiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nJDEiLCJfYmFzZVRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nIiwidG9TdHJpbmckNSIsInRvU3RyaW5nXzEiLCJpc0FycmF5JDgiLCJpc0tleSQzIiwic3RyaW5nVG9QYXRoJDEiLCJ0b1N0cmluZyQ0IiwiY2FzdFBhdGgkMyIsIl9jYXN0UGF0aCIsImlzU3ltYm9sJDIiLCJJTkZJTklUWSQxIiwidG9LZXkkNSIsIl90b0tleSIsImNhc3RQYXRoJDIiLCJ0b0tleSQ0IiwiYmFzZUdldCQzIiwicGF0aCIsIl9iYXNlR2V0IiwiYmFzZUdldCQyIiwiZ2V0JDIiLCJkZWZhdWx0VmFsdWUiLCJnZXRfMSIsImJhc2VIYXNJbiQxIiwiX2Jhc2VIYXNJbiIsImNhc3RQYXRoJDEiLCJpc0FyZ3VtZW50cyQyIiwiaXNBcnJheSQ3IiwiaXNJbmRleCQxIiwiaXNMZW5ndGgiLCJ0b0tleSQzIiwiaGFzUGF0aCQxIiwiaGFzRnVuYyIsIl9oYXNQYXRoIiwiYmFzZUhhc0luIiwiaGFzUGF0aCIsImhhc0luJDEiLCJoYXNJbl8xIiwiYmFzZUlzRXF1YWwkMSIsImdldCQxIiwiaGFzSW4iLCJpc0tleSQyIiwiaXNTdHJpY3RDb21wYXJhYmxlIiwibWF0Y2hlc1N0cmljdENvbXBhcmFibGUiLCJ0b0tleSQyIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSQxIiwiX2Jhc2VNYXRjaGVzUHJvcGVydHkiLCJpZGVudGl0eSQ0IiwiaWRlbnRpdHlfMSIsImJhc2VQcm9wZXJ0eSQxIiwiX2Jhc2VQcm9wZXJ0eSIsImJhc2VHZXQkMSIsImJhc2VQcm9wZXJ0eURlZXAkMSIsIl9iYXNlUHJvcGVydHlEZWVwIiwiYmFzZVByb3BlcnR5IiwiYmFzZVByb3BlcnR5RGVlcCIsImlzS2V5JDEiLCJ0b0tleSQxIiwicHJvcGVydHkkMSIsInByb3BlcnR5XzEiLCJiYXNlTWF0Y2hlcyIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJpZGVudGl0eSQzIiwiaXNBcnJheSQ2IiwicHJvcGVydHkiLCJiYXNlSXRlcmF0ZWUkNSIsIl9iYXNlSXRlcmF0ZWUiLCJiYXNlUmVkdWNlJDEiLCJfYmFzZVJlZHVjZSIsImFycmF5UmVkdWNlJDEiLCJiYXNlRWFjaCQyIiwiYmFzZUl0ZXJhdGVlJDQiLCJiYXNlUmVkdWNlIiwiaXNBcnJheSQ1IiwicmVkdWNlIiwicmVkdWNlXzEiLCJyZWR1Y2UkMSIsImdsb2JhbCQxIiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiaW5pdGVkIiwiaW5pdCIsImNvZGUiLCJpIiwibGVuIiwidG9CeXRlQXJyYXkiLCJiNjQiLCJqIiwibCIsInRtcCIsInBsYWNlSG9sZGVycyIsImFyciIsIkVycm9yIiwiTCIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJzdGFydCIsImVuZCIsIm91dHB1dCIsImpvaW4iLCJmcm9tQnl0ZUFycmF5IiwiZXh0cmFCeXRlcyIsInBhcnRzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwicmVhZCIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwibSIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsImQiLCJzIiwiTmFOIiwiSW5maW5pdHkiLCJNYXRoIiwicG93Iiwid3JpdGUiLCJjIiwicnQiLCJhYnMiLCJpc05hTiIsImZsb29yIiwiTE4yIiwidG9TdHJpbmckMyIsImlzQXJyYXkkNCIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsImtNYXhMZW5ndGgiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiUmFuZ2VFcnJvciIsIl9fcHJvdG9fXyIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJzcGVjaWVzIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiZmlsbCIsImVuY29kaW5nIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsImlzRW5jb2RpbmciLCJhY3R1YWwiLCJzbGljZSIsImZyb21BcnJheUxpa2UiLCJvYmoiLCJpbnRlcm5hbElzQnVmZmVyIiwiY29weSIsImlzbmFuIiwiaXNCdWZmZXIkMSIsImIiLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwiYSIsInkiLCJtaW4iLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImxpc3QiLCJwb3MiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwiaW5zcGVjdCIsInN0ciIsIm1heCIsInRhcmdldCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsInZhbCIsImRpciIsImFycmF5SW5kZXhPZiIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsInZhbExlbmd0aCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJOdW1iZXIiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZWQiLCJwYXJzZUludCIsInN1YnN0ciIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsInJldCIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzdWJhcnJheSIsInNsaWNlTGVuIiwiY2hlY2tPZmZzZXQiLCJleHQiLCJyZWFkVUludExFIiwibm9Bc3NlcnQiLCJtdWwiLCJyZWFkVUludEJFIiwicmVhZFVJbnQ4IiwicmVhZFVJbnQxNkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludExFIiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ0cmltIiwidW5pdHMiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsInNyYyIsImRzdCIsImlzRmFzdEJ1ZmZlciIsImlzU2xvd0J1ZmZlciIsImNoYXJDb2RlT2ZEb3QiLCJyZUVzY2FwZUNoYXIiLCJyZVByb3BOYW1lIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsImdldFRhZyIsImlzU3ltYm9sJDEiLCJpc0tleSIsInN0cmluZ1RvUGF0aCIsImV4cHJlc3Npb24iLCJjYXN0UGF0aCIsInRvS2V5IiwiSU5GSU5JVFkiLCJpc19vYmplY3QiLCJub3JtYWxpemVfY29sdW1ucyIsImNvbHVtbnMiLCJuZXdjb2x1bW5zIiwiayIsImhlYWRlciIsImNvbHVtbiIsIkNzdkVycm9yIiwiY29udGV4dHMiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImNvbnRleHQiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJ1bmRlcnNjb3JlIiwiXyIsIm5vcm1hbGl6ZV9vcHRpb25zIiwib3B0cyIsIm9wdGlvbnMiLCJvcHQiLCJib20iLCJkZWxpbWl0ZXIiLCJxdW90ZWQiLCJlc2NhcGVfZm9ybXVsYXMiLCJxdW90ZWRfZW1wdHkiLCJxdW90ZWRfbWF0Y2giLCJpc1N0cmluZyIsImlzUmVnRXhwIiwicXVvdGVkX3N0cmluZyIsImVvZiIsImVzY2FwZSIsImVyckNvbHVtbnMiLCJjYXN0IiwiYmlnaW50IiwiYm9vbGVhbiIsImRhdGUiLCJnZXRUaW1lIiwib25fcmVjb3JkIiwicmVjb3JkX2RlbGltaXRlciIsImJvbV91dGY4Iiwic3RyaW5naWZpZXIiLCJzdGF0ZSIsImluZm8iLCJfX3RyYW5zZm9ybSIsImNodW5rIiwicmVjb3JkcyIsImVyciIsImhlYWRlcnMiLCJjaHVua19zdHJpbmciLCJjaHVua0lzSGVhZGVyIiwicmVjb3JkIiwiZmllbGQiLCJfX2Nhc3QiLCJjc3ZyZWNvcmQiLCJxdW90ZWRNYXRjaCIsImZpbHRlciIsInNob3VsZFF1b3RlIiwiY29udGFpbnNkZWxpbWl0ZXIiLCJjb250YWluc1F1b3RlIiwiY29udGFpbnNFc2NhcGUiLCJjb250YWluc1JlY29yZERlbGltaXRlciIsInF1b3RlZFN0cmluZyIsInJlZ2V4cCIsIkRhdGUiLCJzdG9wIiwiYXBpIiwiZ2V0TmF0aXZlIiwiZGVmaW5lUHJvcGVydHkkMiIsIl9kZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5JDEiLCJiYXNlQXNzaWduVmFsdWUkNiIsIl9iYXNlQXNzaWduVmFsdWUiLCJiYXNlQXNzaWduVmFsdWUkNSIsImJhc2VGb3JPd24kMSIsImJhc2VJdGVyYXRlZSQzIiwibWFwVmFsdWVzIiwibWFwVmFsdWVzXzEiLCJtYXBWYWx1ZXMkMSIsImJhc2VBc3NpZ25WYWx1ZSQ0IiwiZXEkMiIsImFzc2lnbk1lcmdlVmFsdWUkMiIsIl9hc3NpZ25NZXJnZVZhbHVlIiwiX2Nsb25lQnVmZmVyIiwiY2xvbmVCdWZmZXIiLCJpc0RlZXAiLCJfY2xvbmVCdWZmZXJFeHBvcnRzIiwiVWludDhBcnJheSQxIiwiY2xvbmVBcnJheUJ1ZmZlciQxIiwiYXJyYXlCdWZmZXIiLCJfY2xvbmVBcnJheUJ1ZmZlciIsImNsb25lQXJyYXlCdWZmZXIiLCJjbG9uZVR5cGVkQXJyYXkkMSIsInR5cGVkQXJyYXkiLCJfY2xvbmVUeXBlZEFycmF5IiwiY29weUFycmF5JDEiLCJfY29weUFycmF5IiwiaXNPYmplY3QkNCIsIm9iamVjdENyZWF0ZSIsImNyZWF0ZSIsImJhc2VDcmVhdGUkMSIsIl9iYXNlQ3JlYXRlIiwib3ZlckFyZyIsImdldFByb3RvdHlwZSQyIiwiZ2V0UHJvdG90eXBlT2YiLCJfZ2V0UHJvdG90eXBlIiwiYmFzZUNyZWF0ZSIsImdldFByb3RvdHlwZSQxIiwiaXNQcm90b3R5cGUkMSIsImluaXRDbG9uZU9iamVjdCQxIiwiX2luaXRDbG9uZU9iamVjdCIsImlzQXJyYXlMaWtlJDMiLCJpc09iamVjdExpa2UkMSIsImlzQXJyYXlMaWtlT2JqZWN0JDEiLCJpc0FycmF5TGlrZU9iamVjdF8xIiwiYmFzZUdldFRhZyIsImdldFByb3RvdHlwZSIsImlzT2JqZWN0TGlrZSIsIm9iamVjdFRhZyIsImZ1bmNQcm90byIsIm9iamVjdFByb3RvJDIiLCJmdW5jVG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSQyIiwib2JqZWN0Q3RvclN0cmluZyIsImlzUGxhaW5PYmplY3QkMSIsImlzUGxhaW5PYmplY3RfMSIsInNhZmVHZXQkMiIsIl9zYWZlR2V0IiwiYmFzZUFzc2lnblZhbHVlJDMiLCJlcSQxIiwib2JqZWN0UHJvdG8kMSIsImhhc093blByb3BlcnR5JDEiLCJhc3NpZ25WYWx1ZSQxIiwiX2Fzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJiYXNlQXNzaWduVmFsdWUkMiIsImNvcHlPYmplY3QkMSIsImlzTmV3IiwibmV3VmFsdWUiLCJfY29weU9iamVjdCIsIm5hdGl2ZUtleXNJbiQxIiwiX25hdGl2ZUtleXNJbiIsImlzT2JqZWN0JDMiLCJpc1Byb3RvdHlwZSIsIm5hdGl2ZUtleXNJbiIsIm9iamVjdFByb3RvIiwiYmFzZUtleXNJbiQxIiwiaXNQcm90byIsIl9iYXNlS2V5c0luIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzSW4iLCJpc0FycmF5TGlrZSQyIiwia2V5c0luJDIiLCJrZXlzSW5fMSIsImNvcHlPYmplY3QiLCJrZXlzSW4kMSIsInRvUGxhaW5PYmplY3QkMSIsInRvUGxhaW5PYmplY3RfMSIsImFzc2lnbk1lcmdlVmFsdWUkMSIsImNsb25lVHlwZWRBcnJheSIsImNvcHlBcnJheSIsImluaXRDbG9uZU9iamVjdCIsImlzQXJndW1lbnRzJDEiLCJpc0FycmF5JDMiLCJpc0FycmF5TGlrZU9iamVjdCIsImlzRnVuY3Rpb24iLCJpc09iamVjdCQyIiwiaXNQbGFpbk9iamVjdCIsInNhZmVHZXQkMSIsInRvUGxhaW5PYmplY3QiLCJiYXNlTWVyZ2VEZWVwJDEiLCJzcmNJbmRleCIsIm1lcmdlRnVuYyIsImlzQ29tbW9uIiwiaXNUeXBlZCIsIl9iYXNlTWVyZ2VEZWVwIiwiU3RhY2siLCJhc3NpZ25NZXJnZVZhbHVlIiwiYmFzZUZvciIsImJhc2VNZXJnZURlZXAiLCJpc09iamVjdCQxIiwia2V5c0luIiwic2FmZUdldCIsImJhc2VNZXJnZSQyIiwiX2Jhc2VNZXJnZSIsImFwcGx5JDEiLCJ0aGlzQXJnIiwiX2FwcGx5IiwibmF0aXZlTWF4Iiwib3ZlclJlc3QkMSIsIm90aGVyQXJncyIsIl9vdmVyUmVzdCIsImNvbnN0YW50JDEiLCJjb25zdGFudF8xIiwiY29uc3RhbnQiLCJkZWZpbmVQcm9wZXJ0eSIsImlkZW50aXR5JDIiLCJiYXNlU2V0VG9TdHJpbmckMSIsIl9iYXNlU2V0VG9TdHJpbmciLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsIm5vdyIsInNob3J0T3V0JDEiLCJjb3VudCIsImxhc3RDYWxsZWQiLCJzdGFtcCIsIl9zaG9ydE91dCIsImJhc2VTZXRUb1N0cmluZyIsInNob3J0T3V0Iiwic2V0VG9TdHJpbmckMSIsIl9zZXRUb1N0cmluZyIsImlkZW50aXR5JDEiLCJvdmVyUmVzdCIsInNldFRvU3RyaW5nIiwiYmFzZVJlc3QkMiIsIl9iYXNlUmVzdCIsImVxIiwiaXNBcnJheUxpa2UkMSIsImlzSW5kZXgiLCJpc09iamVjdCIsImlzSXRlcmF0ZWVDYWxsJDIiLCJfaXNJdGVyYXRlZUNhbGwiLCJiYXNlUmVzdCQxIiwiaXNJdGVyYXRlZUNhbGwkMSIsImNyZWF0ZUFzc2lnbmVyJDIiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsIl9jcmVhdGVBc3NpZ25lciIsImJhc2VNZXJnZSQxIiwiY3JlYXRlQXNzaWduZXIkMSIsIm1lcmdlIiwibWVyZ2VfMSIsIm1lcmdlJDEiLCJiYXNlTWVyZ2UiLCJjcmVhdGVBc3NpZ25lciIsIm1lcmdlV2l0aCIsIm1lcmdlV2l0aF8xIiwibWVyZ2VXaXRoJDEiLCJiYXNlQXNzaWduVmFsdWUkMSIsImJhc2VGb3JPd24iLCJiYXNlSXRlcmF0ZWUkMiIsIm1hcEtleXMiLCJtYXBLZXlzXzEiLCJtYXBLZXlzJDEiLCJiYXNlUHJvcGVydHlPZiQxIiwiX2Jhc2VQcm9wZXJ0eU9mIiwiYmFzZVByb3BlcnR5T2YiLCJkZWJ1cnJlZExldHRlcnMiLCJkZWJ1cnJMZXR0ZXIkMSIsIl9kZWJ1cnJMZXR0ZXIiLCJkZWJ1cnJMZXR0ZXIiLCJ0b1N0cmluZyQyIiwicmVMYXRpbiIsInJzQ29tYm9NYXJrc1JhbmdlJDMiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMyIsInJzQ29tYm9TeW1ib2xzUmFuZ2UkMyIsInJzQ29tYm9SYW5nZSQzIiwicnNDb21ibyQyIiwicmVDb21ib01hcmsiLCJkZWJ1cnIkMSIsImRlYnVycl8xIiwicmVBc2NpaVdvcmQiLCJhc2NpaVdvcmRzJDEiLCJfYXNjaWlXb3JkcyIsInJlSGFzVW5pY29kZVdvcmQiLCJoYXNVbmljb2RlV29yZCQxIiwiX2hhc1VuaWNvZGVXb3JkIiwicnNBc3RyYWxSYW5nZSQyIiwicnNDb21ib01hcmtzUmFuZ2UkMiIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSQyIiwicnNDb21ib1N5bWJvbHNSYW5nZSQyIiwicnNDb21ib1JhbmdlJDIiLCJyc0RpbmdiYXRSYW5nZSIsInJzTG93ZXJSYW5nZSIsInJzTWF0aE9wUmFuZ2UiLCJyc05vbkNoYXJSYW5nZSIsInJzUHVuY3R1YXRpb25SYW5nZSIsInJzU3BhY2VSYW5nZSIsInJzVXBwZXJSYW5nZSIsInJzVmFyUmFuZ2UkMiIsInJzQnJlYWtSYW5nZSIsInJzQXBvcyQxIiwicnNCcmVhayIsInJzQ29tYm8kMSIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiQxIiwicnNNb2RpZmllciQxIiwicnNOb25Bc3RyYWwkMSIsInJzUmVnaW9uYWwkMSIsInJzU3VyclBhaXIkMSIsInJzVXBwZXIiLCJyc1pXSiQyIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJlT3B0TW9kJDEiLCJyc09wdFZhciQxIiwicnNPcHRKb2luJDEiLCJyc09yZExvd2VyIiwicnNPcmRVcHBlciIsInJzU2VxJDEiLCJyc0Vtb2ppIiwicmVVbmljb2RlV29yZCIsInVuaWNvZGVXb3JkcyQxIiwiX3VuaWNvZGVXb3JkcyIsImFzY2lpV29yZHMiLCJoYXNVbmljb2RlV29yZCIsInRvU3RyaW5nJDEiLCJ1bmljb2RlV29yZHMiLCJ3b3JkcyQxIiwid29yZHNfMSIsImFycmF5UmVkdWNlIiwiZGVidXJyIiwid29yZHMiLCJyc0Fwb3MiLCJyZUFwb3MiLCJjcmVhdGVDb21wb3VuZGVyJDEiLCJjYWxsYmFjayIsIl9jcmVhdGVDb21wb3VuZGVyIiwiYmFzZVNsaWNlJDEiLCJfYmFzZVNsaWNlIiwiYmFzZVNsaWNlIiwiY2FzdFNsaWNlJDEiLCJfY2FzdFNsaWNlIiwicnNBc3RyYWxSYW5nZSQxIiwicnNDb21ib01hcmtzUmFuZ2UkMSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSQxIiwicnNDb21ib1N5bWJvbHNSYW5nZSQxIiwicnNDb21ib1JhbmdlJDEiLCJyc1ZhclJhbmdlJDEiLCJyc1pXSiQxIiwicmVIYXNVbmljb2RlIiwiaGFzVW5pY29kZSQyIiwiX2hhc1VuaWNvZGUiLCJhc2NpaVRvQXJyYXkkMSIsInNwbGl0IiwiX2FzY2lpVG9BcnJheSIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNBc3RyYWwiLCJyc0NvbWJvIiwicnNGaXR6IiwicnNNb2RpZmllciIsInJzTm9uQXN0cmFsIiwicnNSZWdpb25hbCIsInJzU3VyclBhaXIiLCJyc1pXSiIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc1NlcSIsInJzU3ltYm9sIiwicmVVbmljb2RlIiwidW5pY29kZVRvQXJyYXkkMSIsIl91bmljb2RlVG9BcnJheSIsImFzY2lpVG9BcnJheSIsImhhc1VuaWNvZGUkMSIsInVuaWNvZGVUb0FycmF5Iiwic3RyaW5nVG9BcnJheSQxIiwiX3N0cmluZ1RvQXJyYXkiLCJjYXN0U2xpY2UiLCJoYXNVbmljb2RlIiwic3RyaW5nVG9BcnJheSIsImNyZWF0ZUNhc2VGaXJzdCQxIiwibWV0aG9kTmFtZSIsInN0clN5bWJvbHMiLCJjaHIiLCJjaGFyQXQiLCJ0cmFpbGluZyIsIl9jcmVhdGVDYXNlRmlyc3QiLCJjcmVhdGVDYXNlRmlyc3QiLCJ1cHBlckZpcnN0JDEiLCJ1cHBlckZpcnN0XzEiLCJjcmVhdGVDb21wb3VuZGVyIiwidXBwZXJGaXJzdCIsInN0YXJ0Q2FzZSIsIndvcmQiLCJzdGFydENhc2VfMSIsInN0YXJ0Q2FzZSQxIiwiU3ltYm9sJDEiLCJpc0FyZ3VtZW50cyIsImlzQXJyYXkkMiIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJpc0ZsYXR0ZW5hYmxlJDEiLCJfaXNGbGF0dGVuYWJsZSIsImFycmF5UHVzaCIsImlzRmxhdHRlbmFibGUiLCJiYXNlRmxhdHRlbiQxIiwiZGVwdGgiLCJpc1N0cmljdCIsIl9iYXNlRmxhdHRlbiIsImJhc2VFYWNoJDEiLCJpc0FycmF5TGlrZSIsImJhc2VNYXAkMSIsIl9iYXNlTWFwIiwiYmFzZVNvcnRCeSQxIiwiY29tcGFyZXIiLCJzb3J0IiwiX2Jhc2VTb3J0QnkiLCJpc1N5bWJvbCIsImNvbXBhcmVBc2NlbmRpbmckMSIsInZhbElzRGVmaW5lZCIsInZhbElzTnVsbCIsInZhbElzUmVmbGV4aXZlIiwidmFsSXNTeW1ib2wiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwiX2NvbXBhcmVBc2NlbmRpbmciLCJjb21wYXJlQXNjZW5kaW5nIiwiY29tcGFyZU11bHRpcGxlJDEiLCJvcmRlcnMiLCJvYmpDcml0ZXJpYSIsImNyaXRlcmlhIiwib3RoQ3JpdGVyaWEiLCJvcmRlcnNMZW5ndGgiLCJvcmRlciIsIl9jb21wYXJlTXVsdGlwbGUiLCJhcnJheU1hcCIsImJhc2VHZXQiLCJiYXNlSXRlcmF0ZWUkMSIsImJhc2VNYXAiLCJiYXNlU29ydEJ5IiwiYmFzZVVuYXJ5IiwiY29tcGFyZU11bHRpcGxlIiwiaWRlbnRpdHkiLCJpc0FycmF5JDEiLCJiYXNlT3JkZXJCeSQxIiwiaXRlcmF0ZWVzIiwiX2Jhc2VPcmRlckJ5IiwiYmFzZUZsYXR0ZW4iLCJiYXNlT3JkZXJCeSIsImJhc2VSZXN0IiwiaXNJdGVyYXRlZUNhbGwiLCJzb3J0QnkiLCJzb3J0QnlfMSIsInNvcnRCeSQxIiwiYmFzZUlzRXF1YWwiLCJpc0VxdWFsIiwiaXNFcXVhbF8xIiwiaXNFcXVhbCQxIiwiYXJyYXlBZ2dyZWdhdG9yJDEiLCJzZXR0ZXIiLCJfYXJyYXlBZ2dyZWdhdG9yIiwiYmFzZUVhY2giLCJiYXNlQWdncmVnYXRvciQxIiwiX2Jhc2VBZ2dyZWdhdG9yIiwiYXJyYXlBZ2dyZWdhdG9yIiwiYmFzZUFnZ3JlZ2F0b3IiLCJiYXNlSXRlcmF0ZWUiLCJjcmVhdGVBZ2dyZWdhdG9yJDEiLCJpbml0aWFsaXplciIsIl9jcmVhdGVBZ2dyZWdhdG9yIiwiYmFzZUFzc2lnblZhbHVlIiwiY3JlYXRlQWdncmVnYXRvciIsImtleUJ5Iiwia2V5QnlfMSIsImtleUJ5JDEiLCJleHAiLCJFTUFJTF9SRUdFWCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZXMxIiwiY2xhc3NOYW1lczIiLCJuZXdDbGFzc05hbWVzIiwiY2xhc3NOYW1lcyIsImlucHV0T2JqZWN0IiwicXVlcnlQYXJhbXMiLCJleGNsdWRlUXVlc3Rpb25NYXJrIiwiZXhjbHVkZUVtcHR5U3RyaW5nVmFsdWVzIiwicHJlZml4UXVlc3Rpb25NYXJrIiwiYWNjIiwiZGVjaW1hbFBsYWNlcyIsInJvdW5kIiwidGFrZW4iLCJyYW5kb20iLCJlbGVtZW50c0NvdW50IiwicmdiYSIsImZvcmNlUmVtb3ZlQWxwaGEiLCJoZXhDb2xvciIsInBhcnNlRmxvYXQiLCJmaW5kIiwidiIsImV4Y2x1ZGVBcnJheSIsInRvRXhjbHVkZSIsIlNldCIsInRleHQiLCJ0b1VwcGVyQ2FzZSIsImVudiIsInF1ZXJ5IiwiaWQiLCJkZWZhdWx0VG9FbXB0eVN0cmluZyIsInJldHVybkRlZmF1bHQiLCJmaWxlTmFtZSIsInVybCIsImxpbmsiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsIlVSTCIsInJldm9rZU9iamVjdFVSTCIsInJlbW92ZSIsImNvbHVtbkhlYWRlck5hbWVzIiwiYXV0b0dlbmVyYXRlQ29sdW1uSGVhZGVyTmFtZXMiLCJzdGFydENhc2VGb3JDb2x1bm1IZWFkZXJOYW1lcyIsIl92IiwiY3N2IiwiYmxvYiIsIkJsb2IiLCJibG9iVXJsIiwiY3JlYXRlT2JqZWN0VVJMIiwianNvbiIsImlzRmV0Y2hpbmciLCJpc0xvYWRpbmciLCJpc0Vycm9yIiwiaXNTdWNjZXNzIiwiZGF0YVVwZGF0ZWRBdCIsImlzUmVhZHkiLCJzaG91bGRMb2FkSW5pdGlhbGx5Iiwic3RhdHVzIiwiaXM0MDEiLCJ1cGRhdGVkQXQiLCJ0ZXh0VGVybSIsInN0cjEiLCJzdHIyIiwic291cmNlVmFsdWUiLCJzb3VyY2VWYWx1ZVJhdyIsImlucHV0VmFsdWUiLCJpbnB1dFZhbHVlUmF3IiwidXNlRnV6enkiLCJGVVpaWVNPUlRfTUFUQ0hfVEhSRVNIT0xEIiwibWF0Y2hlcyIsInNjb3JlIiwiZnV6enlzb3J0Iiwic2luZ2xlIiwiYXJyYXlJbmRleCIsImN1cnJlbnRLZXkiLCJjb21wb3NpdGVLZXlJc1RydXRoeSIsImN1cnJlbnRLZXlJc1RydXRoeSIsImtleVZhbHVlU2VwYXJhdG9yIiwic2VwYXJhdG9yIiwia3ZTZXAiLCJzZXAiLCJjdXJyZW50VmFsdWUiLCJzaG91bGRFeGNsdWRlVmFsdWUiLCJ2YWx1ZUlzT2JqZWN0IiwidmFsdWVJc0FycmF5IiwidmFsdWVOZWVkc1RyYW5zZm9ybWluZyIsInNyY0lEIiwidGd0SUQiLCJtcyIsIlByb21pc2UiLCJzZXRUaW1lb3V0IiwicGFyYW1zIiwiX2EiLCJiYXNlIiwib3BlbiIsImZvY3VzIiwicmFuZ2UiLCJkaXN0YW5jZVRocm91Z2hSYW5nZSIsInJhbmRvbU51bWJlciIsInJvdW5kZWREb3duIiwicm91bmRlZFVwIiwiY2VpbCIsIm1pbnV0ZXMiLCJob3VycyIsImRheXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../lib-utilities/lib/index.esm.js\n");

/***/ }),

/***/ "../app-front-end-components/lib/index.esm.css":
/*!*****************************************************!*\
  !*** ../app-front-end-components/lib/index.esm.css ***!
  \*****************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-front-end-components/lib/sass/root.scss":
/*!******************************************************!*\
  !*** ../app-front-end-components/lib/sass/root.scss ***!
  \******************************************************/
/***/ (() => {



/***/ }),

/***/ "./src/styles/global.css":
/*!*******************************!*\
  !*** ./src/styles/global.css ***!
  \*******************************/
/***/ (() => {



/***/ }),

/***/ "./src/styles/sass/root.scss":
/*!***********************************!*\
  !*** ./src/styles/sass/root.scss ***!
  \***********************************/
/***/ (() => {



/***/ }),

/***/ "@floating-ui/react":
/*!*************************************!*\
  !*** external "@floating-ui/react" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@floating-ui/react");

/***/ }),

/***/ "@radix-ui/react-checkbox":
/*!*******************************************!*\
  !*** external "@radix-ui/react-checkbox" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@radix-ui/react-checkbox");

/***/ }),

/***/ "@radix-ui/react-icons":
/*!****************************************!*\
  !*** external "@radix-ui/react-icons" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@radix-ui/react-icons");

/***/ }),

/***/ "classnames":
/*!*****************************!*\
  !*** external "classnames" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("classnames");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("dotenv");

/***/ }),

/***/ "fuzzysort":
/*!****************************!*\
  !*** external "fuzzysort" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("fuzzysort");

/***/ }),

/***/ "lodash/isFunction":
/*!************************************!*\
  !*** external "lodash/isFunction" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash/isFunction");

/***/ }),

/***/ "lodash/mapValues":
/*!***********************************!*\
  !*** external "lodash/mapValues" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash/mapValues");

/***/ }),

/***/ "lodash/merge":
/*!*******************************!*\
  !*** external "lodash/merge" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash/merge");

/***/ }),

/***/ "lodash/omit":
/*!******************************!*\
  !*** external "lodash/omit" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash/omit");

/***/ }),

/***/ "lodash/startCase":
/*!***********************************!*\
  !*** external "lodash/startCase" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash/startCase");

/***/ }),

/***/ "next/head":
/*!****************************!*\
  !*** external "next/head" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/head");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-dom");

/***/ }),

/***/ "react-resize-detector":
/*!****************************************!*\
  !*** external "react-resize-detector" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-resize-detector");

/***/ }),

/***/ "react-select":
/*!*******************************!*\
  !*** external "react-select" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-select");

/***/ }),

/***/ "react-slider":
/*!*******************************!*\
  !*** external "react-slider" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-slider");

/***/ }),

/***/ "react-window":
/*!*******************************!*\
  !*** external "react-window" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-window");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "zustand-mutative":
/*!***********************************!*\
  !*** external "zustand-mutative" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("zustand-mutative");

/***/ }),

/***/ "react-error-boundary":
/*!***************************************!*\
  !*** external "react-error-boundary" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = import("react-error-boundary");;

/***/ }),

/***/ "react-toastify":
/*!*********************************!*\
  !*** external "react-toastify" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = import("react-toastify");;

/***/ }),

/***/ "zustand":
/*!**************************!*\
  !*** external "zustand" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = import("zustand");;

/***/ }),

/***/ "zustand/middleware":
/*!*************************************!*\
  !*** external "zustand/middleware" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = import("zustand/middleware");;

/***/ }),

/***/ "zustand/shallow":
/*!**********************************!*\
  !*** external "zustand/shallow" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = import("zustand/shallow");;

/***/ }),

/***/ "zustand/traditional":
/*!**************************************!*\
  !*** external "zustand/traditional" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = import("zustand/traditional");;

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/@swc","vendor-chunks/use-debounce","vendor-chunks/react-toastify"], () => (__webpack_exec__("./src/pages/_app.tsx")));
module.exports = __webpack_exports__;

})();
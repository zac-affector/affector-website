"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/_document";
exports.ids = ["pages/_document"];
exports.modules = {

/***/ "./src/config/app-universal.ts":
/*!*************************************!*\
  !*** ./src/config/app-universal.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APP_CONFIG_UNIVERSAL: () => (/* binding */ APP_CONFIG_UNIVERSAL)\n/* harmony export */ });\n/**\n * This is the config object for configuring application wide settings, which can also work in middleware\n */ const APP_CONFIG_UNIVERSAL = {\n    appTitleShort: \"Affector\",\n    disableSEOSharingTags: true,\n    disableSEOIndexing: true,\n    reactQueryCacheVersion: \"1.0.0\",\n    stateCacheVersion: 1\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29uZmlnL2FwcC11bml2ZXJzYWwudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztDQUVDLEdBQ00sTUFBTUEsdUJBQXVCO0lBQ2xDQyxlQUFlO0lBQ2ZDLHVCQUF1QjtJQUN2QkMsb0JBQW9CO0lBQ3BCQyx3QkFBd0I7SUFDeEJDLG1CQUFtQjtBQUNyQixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9jb25maWcvYXBwLXVuaXZlcnNhbC50cz9lZWMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBpcyB0aGUgY29uZmlnIG9iamVjdCBmb3IgY29uZmlndXJpbmcgYXBwbGljYXRpb24gd2lkZSBzZXR0aW5ncywgd2hpY2ggY2FuIGFsc28gd29yayBpbiBtaWRkbGV3YXJlXG4gKi9cbmV4cG9ydCBjb25zdCBBUFBfQ09ORklHX1VOSVZFUlNBTCA9IHtcbiAgYXBwVGl0bGVTaG9ydDogJ0FmZmVjdG9yJyxcbiAgZGlzYWJsZVNFT1NoYXJpbmdUYWdzOiB0cnVlLFxuICBkaXNhYmxlU0VPSW5kZXhpbmc6IHRydWUsXG4gIHJlYWN0UXVlcnlDYWNoZVZlcnNpb246ICcxLjAuMCcsXG4gIHN0YXRlQ2FjaGVWZXJzaW9uOiAxLFxufTtcbiJdLCJuYW1lcyI6WyJBUFBfQ09ORklHX1VOSVZFUlNBTCIsImFwcFRpdGxlU2hvcnQiLCJkaXNhYmxlU0VPU2hhcmluZ1RhZ3MiLCJkaXNhYmxlU0VPSW5kZXhpbmciLCJyZWFjdFF1ZXJ5Q2FjaGVWZXJzaW9uIiwic3RhdGVDYWNoZVZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/config/app-universal.ts\n");

/***/ }),

/***/ "./src/config/app.ts":
/*!***************************!*\
  !*** ./src/config/app.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APP_CONFIG: () => (/* binding */ APP_CONFIG)\n/* harmony export */ });\n/* harmony import */ var lodash_startCase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/startCase */ \"lodash/startCase\");\n/* harmony import */ var lodash_startCase__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_startCase__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! env */ \"./src/env.ts\");\n/* harmony import */ var _app_universal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app-universal */ \"./src/config/app-universal.ts\");\n\n\n\nconst appEnv = (0,env__WEBPACK_IMPORTED_MODULE_1__.getEnvVariable)(\"NEXT_PUBLIC_APP_ENV\");\nconst basePath = (0,env__WEBPACK_IMPORTED_MODULE_1__.getEnvVariable)(\"NEXT_PUBLIC_BASE_PATH\");\n/**\n * This is the config object for configuring application wide settings\n */ const APP_CONFIG = {\n    ..._app_universal__WEBPACK_IMPORTED_MODULE_2__.APP_CONFIG_UNIVERSAL,\n    basePath,\n    appEnv,\n    appTitle: `Affector${appEnv === \"production\" || !appEnv ? \"\" : ` - ${lodash_startCase__WEBPACK_IMPORTED_MODULE_0___default()(appEnv)}`}`\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29uZmlnL2FwcC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5QztBQUNKO0FBQ2tCO0FBRXZELE1BQU1HLFNBQVNGLG1EQUFjQSxDQUFDO0FBQzlCLE1BQU1HLFdBQVdILG1EQUFjQSxDQUFDO0FBRWhDOztDQUVDLEdBQ00sTUFBTUksYUFBYTtJQUN4QixHQUFHSCxnRUFBb0I7SUFDdkJFO0lBQ0FEO0lBQ0FHLFVBQVUsQ0FBQyxRQUFRLEVBQ2pCSCxXQUFXLGdCQUFnQixDQUFDQSxTQUFTLEtBQUssQ0FBQyxHQUFHLEVBQUVILHVEQUFTQSxDQUFDRyxRQUFRLENBQUMsQ0FDcEUsQ0FBQztBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL2NvbmZpZy9hcHAudHM/YjJhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3RhcnRDYXNlIGZyb20gJ2xvZGFzaC9zdGFydENhc2UnO1xuaW1wb3J0IHsgZ2V0RW52VmFyaWFibGUgfSBmcm9tICdlbnYnO1xuaW1wb3J0IHsgQVBQX0NPTkZJR19VTklWRVJTQUwgfSBmcm9tICcuL2FwcC11bml2ZXJzYWwnO1xuXG5jb25zdCBhcHBFbnYgPSBnZXRFbnZWYXJpYWJsZSgnTkVYVF9QVUJMSUNfQVBQX0VOVicpO1xuY29uc3QgYmFzZVBhdGggPSBnZXRFbnZWYXJpYWJsZSgnTkVYVF9QVUJMSUNfQkFTRV9QQVRIJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29uZmlnIG9iamVjdCBmb3IgY29uZmlndXJpbmcgYXBwbGljYXRpb24gd2lkZSBzZXR0aW5nc1xuICovXG5leHBvcnQgY29uc3QgQVBQX0NPTkZJRyA9IHtcbiAgLi4uQVBQX0NPTkZJR19VTklWRVJTQUwsXG4gIGJhc2VQYXRoLFxuICBhcHBFbnYsXG4gIGFwcFRpdGxlOiBgQWZmZWN0b3Ike1xuICAgIGFwcEVudiA9PT0gJ3Byb2R1Y3Rpb24nIHx8ICFhcHBFbnYgPyAnJyA6IGAgLSAke3N0YXJ0Q2FzZShhcHBFbnYpfWBcbiAgfWAsXG59O1xuIl0sIm5hbWVzIjpbInN0YXJ0Q2FzZSIsImdldEVudlZhcmlhYmxlIiwiQVBQX0NPTkZJR19VTklWRVJTQUwiLCJhcHBFbnYiLCJiYXNlUGF0aCIsIkFQUF9DT05GSUciLCJhcHBUaXRsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/config/app.ts\n");

/***/ }),

/***/ "./src/env.ts":
/*!********************!*\
  !*** ./src/env.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getEnvVariable: () => (/* binding */ getEnvVariable)\n/* harmony export */ });\n/* harmony import */ var _fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fx/lib-utilities */ \"../lib-utilities/lib/index.esm.js\");\n/* harmony import */ var _fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dotenv */ \"dotenv\");\n/* harmony import */ var dotenv__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dotenv__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst result = dotenv__WEBPACK_IMPORTED_MODULE_1___default().config();\nconst env = (0,_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0__.parseEnvVariables)({\n    ...result.error ? process.env : {\n        /**\n         * Prioritise env variables already in the process.env\n         * This is because deployment env variables (via pm2) are not set in the local dotenv above.\n         */ ...result.parsed || {},\n        ...process.env\n    },\n    /**\n   * NEXT_PUBLIC_BASE_PATH needs to be added manually to the env variables.\n   * That's because it is injected in next.config.js rather than via .env files.\n   * It must be extracted without destructuring: https://nextjs.org/docs/pages/api-reference/next-config-js/env\n   */ NEXT_PUBLIC_BASE_PATH: \"\"\n});\nconst getEnvVariable = (key, { asNumber, asCommaSeparatedList } = {})=>{\n    let value;\n    if ((0,_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0__.isBrowser)()) {\n        const variable = (0,_fx_lib_utilities__WEBPACK_IMPORTED_MODULE_0__.parseEnvVariable)(window?.__ENV?.[key]);\n        value = variable === undefined ? env[key] : variable;\n    } else {\n        value = env[key];\n    }\n    if (asCommaSeparatedList) {\n        return (value || \"\").split(\",\").map((v)=>asNumber ? Number(v.trim()) : v.trim());\n    }\n    if (asNumber) {\n        return Number(value);\n    }\n    return value;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (env);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZW52LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUkyQjtBQUNDO0FBRTVCLE1BQU1JLFNBQVNELG9EQUFhO0FBRTVCLE1BQU1HLE1BQU1MLG9FQUFpQkEsQ0FBQztJQUM1QixHQUFJRyxPQUFPRyxLQUFLLEdBQ1pDLFFBQVFGLEdBQUcsR0FDWDtRQUNFOzs7U0FHQyxHQUNELEdBQUlGLE9BQU9LLE1BQU0sSUFBSSxDQUFDLENBQUM7UUFDdkIsR0FBR0QsUUFBUUYsR0FBRztJQUNoQixDQUFDO0lBQ0w7Ozs7R0FJQyxHQUNESSx1QkFBdUJGLEVBQWlDO0FBQzFEO0FBRU8sTUFBTUcsaUJBQWlCLENBQzVCQyxLQUNBLEVBQ0VDLFFBQVEsRUFDUkMsb0JBQW9CLEVBQ21DLEdBQUcsQ0FBQyxDQUFDO0lBRTlELElBQUlDO0lBRUosSUFBSWYsNERBQVNBLElBQUk7UUFDZixNQUFNZ0IsV0FBV2QsbUVBQWdCQSxDQUM5QmUsUUFBMkRDLE9BQU8sQ0FBQ04sSUFBSTtRQUcxRUcsUUFBUUMsYUFBYUcsWUFBWWIsR0FBRyxDQUFDTSxJQUFJLEdBQUdJO0lBQzlDLE9BQU87UUFDTEQsUUFBUVQsR0FBRyxDQUFDTSxJQUFJO0lBQ2xCO0lBRUEsSUFBSUUsc0JBQXNCO1FBQ3hCLE9BQU8sQ0FBQ0MsU0FBUyxFQUFDLEVBQ2ZLLEtBQUssQ0FBQyxLQUNOQyxHQUFHLENBQUMsQ0FBQ0MsSUFBZVQsV0FBV1UsT0FBT0QsRUFBRUUsSUFBSSxNQUFNRixFQUFFRSxJQUFJO0lBQzdEO0lBRUEsSUFBSVgsVUFBVTtRQUNaLE9BQU9VLE9BQU9SO0lBQ2hCO0lBRUEsT0FBT0E7QUFDVCxFQUFFO0FBRUYsaUVBQWVULEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZngvYXBwLWZyb250LWVuZC13ZWJzaXRlLy4vc3JjL2Vudi50cz83MWI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGlzQnJvd3NlcixcbiAgcGFyc2VFbnZWYXJpYWJsZXMsXG4gIHBhcnNlRW52VmFyaWFibGUsXG59IGZyb20gJ0BmeC9saWItdXRpbGl0aWVzJztcbmltcG9ydCBkb3RlbnYgZnJvbSAnZG90ZW52JztcblxuY29uc3QgcmVzdWx0ID0gZG90ZW52LmNvbmZpZygpO1xuXG5jb25zdCBlbnYgPSBwYXJzZUVudlZhcmlhYmxlcyh7XG4gIC4uLihyZXN1bHQuZXJyb3JcbiAgICA/IHByb2Nlc3MuZW52XG4gICAgOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmlvcml0aXNlIGVudiB2YXJpYWJsZXMgYWxyZWFkeSBpbiB0aGUgcHJvY2Vzcy5lbnZcbiAgICAgICAgICogVGhpcyBpcyBiZWNhdXNlIGRlcGxveW1lbnQgZW52IHZhcmlhYmxlcyAodmlhIHBtMikgYXJlIG5vdCBzZXQgaW4gdGhlIGxvY2FsIGRvdGVudiBhYm92ZS5cbiAgICAgICAgICovXG4gICAgICAgIC4uLihyZXN1bHQucGFyc2VkIHx8IHt9KSxcbiAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICB9KSxcbiAgLyoqXG4gICAqIE5FWFRfUFVCTElDX0JBU0VfUEFUSCBuZWVkcyB0byBiZSBhZGRlZCBtYW51YWxseSB0byB0aGUgZW52IHZhcmlhYmxlcy5cbiAgICogVGhhdCdzIGJlY2F1c2UgaXQgaXMgaW5qZWN0ZWQgaW4gbmV4dC5jb25maWcuanMgcmF0aGVyIHRoYW4gdmlhIC5lbnYgZmlsZXMuXG4gICAqIEl0IG11c3QgYmUgZXh0cmFjdGVkIHdpdGhvdXQgZGVzdHJ1Y3R1cmluZzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvcGFnZXMvYXBpLXJlZmVyZW5jZS9uZXh0LWNvbmZpZy1qcy9lbnZcbiAgICovXG4gIE5FWFRfUFVCTElDX0JBU0VfUEFUSDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFTRV9QQVRILFxufSk7XG5cbmV4cG9ydCBjb25zdCBnZXRFbnZWYXJpYWJsZSA9IChcbiAga2V5OiBzdHJpbmcsXG4gIHtcbiAgICBhc051bWJlcixcbiAgICBhc0NvbW1hU2VwYXJhdGVkTGlzdCxcbiAgfTogeyBhc051bWJlcj86IGJvb2xlYW47IGFzQ29tbWFTZXBhcmF0ZWRMaXN0PzogYm9vbGVhbiB9ID0ge31cbikgPT4ge1xuICBsZXQgdmFsdWU7XG5cbiAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgY29uc3QgdmFyaWFibGUgPSBwYXJzZUVudlZhcmlhYmxlKFxuICAgICAgKHdpbmRvdyBhcyB0eXBlb2Ygd2luZG93ICYgeyBfX0VOVjogUmVjb3JkPHN0cmluZywgYW55PiB9KT8uX19FTlY/LltrZXldXG4gICAgKTtcblxuICAgIHZhbHVlID0gdmFyaWFibGUgPT09IHVuZGVmaW5lZCA/IGVudltrZXldIDogdmFyaWFibGU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBlbnZba2V5XTtcbiAgfVxuXG4gIGlmIChhc0NvbW1hU2VwYXJhdGVkTGlzdCkge1xuICAgIHJldHVybiAodmFsdWUgfHwgJycpXG4gICAgICAuc3BsaXQoJywnKVxuICAgICAgLm1hcCgodjogc3RyaW5nKSA9PiAoYXNOdW1iZXIgPyBOdW1iZXIodi50cmltKCkpIDogdi50cmltKCkpKTtcbiAgfVxuXG4gIGlmIChhc051bWJlcikge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZW52O1xuIl0sIm5hbWVzIjpbImlzQnJvd3NlciIsInBhcnNlRW52VmFyaWFibGVzIiwicGFyc2VFbnZWYXJpYWJsZSIsImRvdGVudiIsInJlc3VsdCIsImNvbmZpZyIsImVudiIsImVycm9yIiwicHJvY2VzcyIsInBhcnNlZCIsIk5FWFRfUFVCTElDX0JBU0VfUEFUSCIsImdldEVudlZhcmlhYmxlIiwia2V5IiwiYXNOdW1iZXIiLCJhc0NvbW1hU2VwYXJhdGVkTGlzdCIsInZhbHVlIiwidmFyaWFibGUiLCJ3aW5kb3ciLCJfX0VOViIsInVuZGVmaW5lZCIsInNwbGl0IiwibWFwIiwidiIsIk51bWJlciIsInRyaW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/env.ts\n");

/***/ }),

/***/ "./src/pages/_document.tsx":
/*!*********************************!*\
  !*** ./src/pages/_document.tsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _Document)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_document__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/document */ \"../../node_modules/next/document.js\");\n/* harmony import */ var next_document__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_document__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var utilities_routing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! utilities/routing */ \"./src/utilities/routing.ts\");\n\n\n\nclass _Document extends (next_document__WEBPACK_IMPORTED_MODULE_1___default()) {\n    render() {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_document__WEBPACK_IMPORTED_MODULE_1__.Html, {\n            lang: \"en\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_document__WEBPACK_IMPORTED_MODULE_1__.Head, {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"script\", {\n                        src: (0,utilities_routing__WEBPACK_IMPORTED_MODULE_2__.pathWithBasePath)(\"/__ENV.js\")\n                    }, void 0, false, {\n                        fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_document.tsx\",\n                        lineNumber: 10,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_document.tsx\",\n                    lineNumber: 8,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"body\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_document__WEBPACK_IMPORTED_MODULE_1__.Main, {}, void 0, false, {\n                            fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_document.tsx\",\n                            lineNumber: 13,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_document__WEBPACK_IMPORTED_MODULE_1__.NextScript, {}, void 0, false, {\n                            fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_document.tsx\",\n                            lineNumber: 14,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_document.tsx\",\n                    lineNumber: 12,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/zac/Code/affector.io/packages/app-front-end-website/src/pages/_document.tsx\",\n            lineNumber: 7,\n            columnNumber: 7\n        }, this);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvX2RvY3VtZW50LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXVFO0FBQ2xCO0FBRXRDLE1BQU1NLGtCQUFrQk4sc0RBQVFBO0lBQzdDTyxTQUFTO1FBQ1AscUJBQ0UsOERBQUNMLCtDQUFJQTtZQUFDTSxNQUFLOzs4QkFDVCw4REFBQ1AsK0NBQUlBOzhCQUVILDRFQUFDUTt3QkFBT0MsS0FBS0wsbUVBQWdCQSxDQUFDOzs7Ozs7Ozs7Ozs4QkFFaEMsOERBQUNNOztzQ0FDQyw4REFBQ1IsK0NBQUlBOzs7OztzQ0FDTCw4REFBQ0MscURBQVVBOzs7Ozs7Ozs7Ozs7Ozs7OztJQUluQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uL3NyYy9wYWdlcy9fZG9jdW1lbnQudHN4PzE4OGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERvY3VtZW50LCB7IEhlYWQsIEh0bWwsIE1haW4sIE5leHRTY3JpcHQgfSBmcm9tICduZXh0L2RvY3VtZW50JztcbmltcG9ydCB7IHBhdGhXaXRoQmFzZVBhdGggfSBmcm9tICd1dGlsaXRpZXMvcm91dGluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIF9Eb2N1bWVudCBleHRlbmRzIERvY3VtZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8SHRtbCBsYW5nPVwiZW5cIj5cbiAgICAgICAgPEhlYWQ+XG4gICAgICAgICAgey8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAbmV4dC9uZXh0L25vLXN5bmMtc2NyaXB0cyAqL31cbiAgICAgICAgICA8c2NyaXB0IHNyYz17cGF0aFdpdGhCYXNlUGF0aCgnL19fRU5WLmpzJyl9IC8+XG4gICAgICAgIDwvSGVhZD5cbiAgICAgICAgPGJvZHk+XG4gICAgICAgICAgPE1haW4gLz5cbiAgICAgICAgICA8TmV4dFNjcmlwdCAvPlxuICAgICAgICA8L2JvZHk+XG4gICAgICA8L0h0bWw+XG4gICAgKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkRvY3VtZW50IiwiSGVhZCIsIkh0bWwiLCJNYWluIiwiTmV4dFNjcmlwdCIsInBhdGhXaXRoQmFzZVBhdGgiLCJfRG9jdW1lbnQiLCJyZW5kZXIiLCJsYW5nIiwic2NyaXB0Iiwic3JjIiwiYm9keSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/_document.tsx\n");

/***/ }),

/***/ "./src/utilities/routing.ts":
/*!**********************************!*\
  !*** ./src/utilities/routing.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pathWithBasePath: () => (/* binding */ pathWithBasePath)\n/* harmony export */ });\n/* harmony import */ var config_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config/app */ \"./src/config/app.ts\");\n\nconst { basePath } = config_app__WEBPACK_IMPORTED_MODULE_0__.APP_CONFIG;\nconst pathWithBasePath = (path)=>`${basePath || \"\"}${path}`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL3JvdXRpbmcudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0M7QUFFeEMsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0Qsa0RBQVVBO0FBRXhCLE1BQU1FLG1CQUFtQixDQUFDQyxPQUFpQixDQUFDLEVBQUVGLFlBQVksR0FBRyxFQUFFRSxLQUFLLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BmeC9hcHAtZnJvbnQtZW5kLXdlYnNpdGUvLi9zcmMvdXRpbGl0aWVzL3JvdXRpbmcudHM/NzgyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBUFBfQ09ORklHIH0gZnJvbSAnY29uZmlnL2FwcCc7XG5cbmNvbnN0IHsgYmFzZVBhdGggfSA9IEFQUF9DT05GSUc7XG5cbmV4cG9ydCBjb25zdCBwYXRoV2l0aEJhc2VQYXRoID0gKHBhdGg6IHN0cmluZykgPT4gYCR7YmFzZVBhdGggfHwgJyd9JHtwYXRofWA7XG4iXSwibmFtZXMiOlsiQVBQX0NPTkZJRyIsImJhc2VQYXRoIiwicGF0aFdpdGhCYXNlUGF0aCIsInBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utilities/routing.ts\n");

/***/ }),

/***/ "../lib-utilities/lib/index.esm.js":
/*!*****************************************!*\
  !*** ../lib-utilities/lib/index.esm.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    CACHE_TIME_1_HOUR: function() {\n        return CACHE_TIME_1_HOUR;\n    },\n    CACHE_TIME_30_MINUTES: function() {\n        return CACHE_TIME_30_MINUTES;\n    },\n    CACHE_TIME_48_HOURS: function() {\n        return CACHE_TIME_48_HOURS;\n    },\n    CACHE_TIME_72_HOURS: function() {\n        return CACHE_TIME_72_HOURS;\n    },\n    RGBAToHexA: function() {\n        return RGBAToHexA;\n    },\n    antilog: function() {\n        return antilog;\n    },\n    arrayWithoutElements: function() {\n        return arrayWithoutElements;\n    },\n    assertTruthyOrZero: function() {\n        return assertTruthyOrZero;\n    },\n    capitaliseFirstLetter: function() {\n        return capitaliseFirstLetter;\n    },\n    checkIfTextTermMatchesArray: function() {\n        return checkIfTextTermMatchesArray;\n    },\n    checkIfTextTermMatchesSingle: function() {\n        return checkIfTextTermMatchesSingle;\n    },\n    clampValue: function() {\n        return clampValue;\n    },\n    cleanString: function() {\n        return cleanString;\n    },\n    conditionalOrIfTruthyOrZero: function() {\n        return conditionalOrIfTruthyOrZero;\n    },\n    createCustomFileNameKeyFromObject: function() {\n        return createCustomFileNameKeyFromObject;\n    },\n    createCustomKey: function() {\n        return createCustomKey;\n    },\n    createCustomKeyFromObject: function() {\n        return createCustomKeyFromObject;\n    },\n    createCustomKeyFromSrcTgt: function() {\n        return createCustomKeyFromSrcTgt;\n    },\n    createTimeMsInDays: function() {\n        return createTimeMsInDays;\n    },\n    createTimeMsInHours: function() {\n        return createTimeMsInHours;\n    },\n    createTimeMsInMinutes: function() {\n        return createTimeMsInMinutes;\n    },\n    downloadCSV: function() {\n        return downloadCSV;\n    },\n    downloadFromObjectURL: function() {\n        return downloadFromObjectURL;\n    },\n    downloadJSON: function() {\n        return downloadJSON;\n    },\n    evaluateOneOrZeroBooleanIfNotEmptyString: function() {\n        return evaluateOneOrZeroBooleanIfNotEmptyString;\n    },\n    evaluateOneOrZeroBooleanIfNotUndefined: function() {\n        return evaluateOneOrZeroBooleanIfNotUndefined;\n    },\n    evaluateTruthyIfNotUndefined: function() {\n        return evaluateTruthyIfNotUndefined;\n    },\n    generateCSV: function() {\n        return generateCSV;\n    },\n    generateQueryString: function() {\n        return generateQueryString;\n    },\n    getNRandomElementsFromArray: function() {\n        return getNRandomElementsFromArray;\n    },\n    getNextJSQueryParam: function() {\n        return getNextJSQueryParam;\n    },\n    getRandomElementFromArray: function() {\n        return getRandomElementFromArray;\n    },\n    getRandomElementsFromArray: function() {\n        return getRandomElementsFromArray;\n    },\n    getRandomInteger: function() {\n        return getRandomInteger;\n    },\n    getRandomNumber: function() {\n        return getRandomNumber;\n    },\n    getReactQueryStatus: function() {\n        return getReactQueryStatus;\n    },\n    isBrowser: function() {\n        return isBrowser;\n    },\n    isEmail: function() {\n        return isEmail;\n    },\n    isEqualIgnoringOrder: function() {\n        return isEqualIgnoringOrder;\n    },\n    isTruthyOrZero: function() {\n        return isTruthyOrZero;\n    },\n    keyByWithUndefined: function() {\n        return keyByWithUndefined;\n    },\n    log: function() {\n        return log;\n    },\n    mergeClassNamesDeep: function() {\n        return mergeClassNamesDeep;\n    },\n    mergeClassNamesFunctionsDeep: function() {\n        return mergeClassNamesFunctionsDeep;\n    },\n    mergeObject: function() {\n        return mergeObject;\n    },\n    mergeObjectReplacingArrays: function() {\n        return mergeObjectReplacingArrays;\n    },\n    normaliseString: function() {\n        return normaliseString;\n    },\n    openUrlInNewTab: function() {\n        return openUrlInNewTab;\n    },\n    parseEnvVariable: function() {\n        return parseEnvVariable;\n    },\n    parseEnvVariables: function() {\n        return parseEnvVariables;\n    },\n    removeUndefinedAndEmptyStringValuesFromObj: function() {\n        return removeUndefinedAndEmptyStringValuesFromObj;\n    },\n    removeUndefinedAndNullValuesFromObj: function() {\n        return removeUndefinedAndNullValuesFromObj;\n    },\n    removeUndefinedValuesFromObj: function() {\n        return removeUndefinedValuesFromObj;\n    },\n    roundNumber: function() {\n        return roundNumber;\n    },\n    sanitiseTextTerm: function() {\n        return sanitiseTextTerm;\n    },\n    sleep: function() {\n        return sleep;\n    },\n    stringsEqualInsensitive: function() {\n        return stringsEqualInsensitive;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"../../node_modules/@swc/helpers/cjs/_interop_require_default.cjs\");\nconst _classnames = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! classnames */ \"classnames\"));\nconst _fuzzysort = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! fuzzysort */ \"fuzzysort\"));\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */ function arrayReduce$2(array, iteratee, accumulator, initAccum) {\n    var index = -1, length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n        accumulator = array[++index];\n    }\n    while(++index < length){\n        accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n}\nvar _arrayReduce = arrayReduce$2;\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */ function createBaseFor$1(fromRight) {\n    return function(object, iteratee, keysFunc) {\n        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;\n        while(length--){\n            var key = props[fromRight ? length : ++index];\n            if (iteratee(iterable[key], key, iterable) === false) {\n                break;\n            }\n        }\n        return object;\n    };\n}\nvar _createBaseFor = createBaseFor$1;\nvar createBaseFor = _createBaseFor;\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */ var baseFor$2 = createBaseFor();\nvar _baseFor = baseFor$2;\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */ function baseTimes$1(n, iteratee) {\n    var index = -1, result = Array(n);\n    while(++index < n){\n        result[index] = iteratee(index);\n    }\n    return result;\n}\nvar _baseTimes = baseTimes$1;\n/** Detect free variable `global` from Node.js. */ var freeGlobal$1 = typeof commonjsGlobal == \"object\" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\nvar _freeGlobal = freeGlobal$1;\nvar freeGlobal = _freeGlobal;\n/** Detect free variable `self`. */ var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n/** Used as a reference to the global object. */ var root$8 = freeGlobal || freeSelf || Function(\"return this\")();\nvar _root = root$8;\nvar root$7 = _root;\n/** Built-in value references. */ var Symbol$6 = root$7.Symbol;\nvar _Symbol = Symbol$6;\nvar Symbol$5 = _Symbol;\n/** Used for built-in method references. */ var objectProto$e = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$b = objectProto$e.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var nativeObjectToString$1 = objectProto$e.toString;\n/** Built-in value references. */ var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : undefined;\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */ function getRawTag$1(value) {\n    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];\n    try {\n        value[symToStringTag$1] = undefined;\n        var unmasked = true;\n    } catch (e) {}\n    var result = nativeObjectToString$1.call(value);\n    if (unmasked) {\n        if (isOwn) {\n            value[symToStringTag$1] = tag;\n        } else {\n            delete value[symToStringTag$1];\n        }\n    }\n    return result;\n}\nvar _getRawTag = getRawTag$1;\n/** Used for built-in method references. */ var objectProto$d = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */ var nativeObjectToString = objectProto$d.toString;\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */ function objectToString$1(value) {\n    return nativeObjectToString.call(value);\n}\nvar _objectToString = objectToString$1;\nvar Symbol$4 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;\n/** `Object#toString` result references. */ var nullTag = \"[object Null]\", undefinedTag = \"[object Undefined]\";\n/** Built-in value references. */ var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : undefined;\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */ function baseGetTag$6(value) {\n    if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n    }\n    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n}\nvar _baseGetTag = baseGetTag$6;\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ function isObjectLike$7(value) {\n    return value != null && typeof value == \"object\";\n}\nvar isObjectLike_1 = isObjectLike$7;\nvar baseGetTag$5 = _baseGetTag, isObjectLike$6 = isObjectLike_1;\n/** `Object#toString` result references. */ var argsTag$2 = \"[object Arguments]\";\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */ function baseIsArguments$1(value) {\n    return isObjectLike$6(value) && baseGetTag$5(value) == argsTag$2;\n}\nvar _baseIsArguments = baseIsArguments$1;\nvar baseIsArguments = _baseIsArguments, isObjectLike$5 = isObjectLike_1;\n/** Used for built-in method references. */ var objectProto$c = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$a = objectProto$c.hasOwnProperty;\n/** Built-in value references. */ var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */ var isArguments$4 = baseIsArguments(function() {\n    return arguments;\n}()) ? baseIsArguments : function(value) {\n    return isObjectLike$5(value) && hasOwnProperty$a.call(value, \"callee\") && !propertyIsEnumerable$1.call(value, \"callee\");\n};\nvar isArguments_1 = isArguments$4;\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */ var isArray$e = Array.isArray;\nvar isArray_1 = isArray$e;\nvar isArray$f = /*@__PURE__*/ getDefaultExportFromCjs(isArray_1);\nvar isBuffer$4 = {\n    exports: {}\n};\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */ function stubFalse() {\n    return false;\n}\nvar stubFalse_1 = stubFalse;\nisBuffer$4.exports;\n(function(module, exports1) {\n    var root = _root, stubFalse = stubFalse_1;\n    /** Detect free variable `exports`. */ var freeExports = exports1 && !exports1.nodeType && exports1;\n    /** Detect free variable `module`. */ var freeModule = freeExports && \"object\" == \"object\" && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined;\n    /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n    /**\n\t * Checks if `value` is a buffer.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.3.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n\t * @example\n\t *\n\t * _.isBuffer(new Buffer(2));\n\t * // => true\n\t *\n\t * _.isBuffer(new Uint8Array(2));\n\t * // => false\n\t */ var isBuffer = nativeIsBuffer || stubFalse;\n    module.exports = isBuffer;\n})(isBuffer$4, isBuffer$4.exports);\nvar isBufferExports = isBuffer$4.exports;\n/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER$1 = 9007199254740991;\n/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\\d*)$/;\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */ function isIndex$3(value, length) {\n    var type = typeof value;\n    length = length == null ? MAX_SAFE_INTEGER$1 : length;\n    return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n}\nvar _isIndex = isIndex$3;\n/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */ function isLength$3(value) {\n    return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\nvar isLength_1 = isLength$3;\nvar baseGetTag$4 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$4 = isObjectLike_1;\n/** `Object#toString` result references. */ var argsTag$1 = \"[object Arguments]\", arrayTag$1 = \"[object Array]\", boolTag$1 = \"[object Boolean]\", dateTag$1 = \"[object Date]\", errorTag$1 = \"[object Error]\", funcTag$1 = \"[object Function]\", mapTag$2 = \"[object Map]\", numberTag$1 = \"[object Number]\", objectTag$3 = \"[object Object]\", regexpTag$1 = \"[object RegExp]\", setTag$2 = \"[object Set]\", stringTag$1 = \"[object String]\", weakMapTag$1 = \"[object WeakMap]\";\nvar arrayBufferTag$1 = \"[object ArrayBuffer]\", dataViewTag$2 = \"[object DataView]\", float32Tag = \"[object Float32Array]\", float64Tag = \"[object Float64Array]\", int8Tag = \"[object Int8Array]\", int16Tag = \"[object Int16Array]\", int32Tag = \"[object Int32Array]\", uint8Tag = \"[object Uint8Array]\", uint8ClampedTag = \"[object Uint8ClampedArray]\", uint16Tag = \"[object Uint16Array]\", uint32Tag = \"[object Uint32Array]\";\n/** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */ function baseIsTypedArray$1(value) {\n    return isObjectLike$4(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$4(value)];\n}\nvar _baseIsTypedArray = baseIsTypedArray$1;\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */ function baseUnary$2(func) {\n    return function(value) {\n        return func(value);\n    };\n}\nvar _baseUnary = baseUnary$2;\nvar _nodeUtil = {\n    exports: {}\n};\n_nodeUtil.exports;\n(function(module, exports1) {\n    var freeGlobal = _freeGlobal;\n    /** Detect free variable `exports`. */ var freeExports = exports1 && !exports1.nodeType && exports1;\n    /** Detect free variable `module`. */ var freeModule = freeExports && \"object\" == \"object\" && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;\n    /** Used to access faster Node.js helpers. */ var nodeUtil = function() {\n        try {\n            // Use `util.types` for Node.js 10+.\n            var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n            if (types) {\n                return types;\n            }\n            // Legacy `process.binding('util')` for Node.js < 10.\n            return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n        } catch (e) {}\n    }();\n    module.exports = nodeUtil;\n})(_nodeUtil, _nodeUtil.exports);\nvar _nodeUtilExports = _nodeUtil.exports;\nvar baseIsTypedArray = _baseIsTypedArray, baseUnary$1 = _baseUnary, nodeUtil = _nodeUtilExports;\n/* Node.js helper references. */ var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */ var isTypedArray$3 = nodeIsTypedArray ? baseUnary$1(nodeIsTypedArray) : baseIsTypedArray;\nvar isTypedArray_1 = isTypedArray$3;\nvar baseTimes = _baseTimes, isArguments$3 = isArguments_1, isArray$d = isArray_1, isBuffer$3 = isBufferExports, isIndex$2 = _isIndex, isTypedArray$2 = isTypedArray_1;\n/** Used for built-in method references. */ var objectProto$b = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$9 = objectProto$b.hasOwnProperty;\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */ function arrayLikeKeys$2(value, inherited) {\n    var isArr = isArray$d(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$3(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;\n    for(var key in value){\n        if ((inherited || hasOwnProperty$9.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n        (key == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n        isBuff && (key == \"offset\" || key == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n        isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n        isIndex$2(key, length)))) {\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _arrayLikeKeys = arrayLikeKeys$2;\n/** Used for built-in method references. */ var objectProto$a = Object.prototype;\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */ function isPrototype$3(value) {\n    var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$a;\n    return value === proto;\n}\nvar _isPrototype = isPrototype$3;\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */ function overArg$2(func, transform) {\n    return function(arg) {\n        return func(transform(arg));\n    };\n}\nvar _overArg = overArg$2;\nvar overArg$1 = _overArg;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeKeys$1 = overArg$1(Object.keys, Object);\nvar _nativeKeys = nativeKeys$1;\nvar isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;\n/** Used for built-in method references. */ var objectProto$9 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$8 = objectProto$9.hasOwnProperty;\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function baseKeys$1(object) {\n    if (!isPrototype$2(object)) {\n        return nativeKeys(object);\n    }\n    var result = [];\n    for(var key in Object(object)){\n        if (hasOwnProperty$8.call(object, key) && key != \"constructor\") {\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _baseKeys = baseKeys$1;\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ function isObject$8(value) {\n    var type = typeof value;\n    return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_1 = isObject$8;\nvar isObject$9 = /*@__PURE__*/ getDefaultExportFromCjs(isObject_1);\nvar baseGetTag$3 = _baseGetTag, isObject$7 = isObject_1;\n/** `Object#toString` result references. */ var asyncTag = \"[object AsyncFunction]\", funcTag = \"[object Function]\", genTag = \"[object GeneratorFunction]\", proxyTag = \"[object Proxy]\";\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */ function isFunction$3(value) {\n    if (!isObject$7(value)) {\n        return false;\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = baseGetTag$3(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\nvar isFunction_1 = isFunction$3;\nvar isFunction$2 = isFunction_1, isLength$1 = isLength_1;\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */ function isArrayLike$6(value) {\n    return value != null && isLength$1(value.length) && !isFunction$2(value);\n}\nvar isArrayLike_1 = isArrayLike$6;\nvar arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$5 = isArrayLike_1;\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */ function keys$3(object) {\n    return isArrayLike$5(object) ? arrayLikeKeys$1(object) : baseKeys(object);\n}\nvar keys_1 = keys$3;\nvar baseFor$1 = _baseFor, keys$2 = keys_1;\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */ function baseForOwn$3(object, iteratee) {\n    return object && baseFor$1(object, iteratee, keys$2);\n}\nvar _baseForOwn = baseForOwn$3;\nvar isArrayLike$4 = isArrayLike_1;\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */ function createBaseEach$1(eachFunc, fromRight) {\n    return function(collection, iteratee) {\n        if (collection == null) {\n            return collection;\n        }\n        if (!isArrayLike$4(collection)) {\n            return eachFunc(collection, iteratee);\n        }\n        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);\n        while(fromRight ? index-- : ++index < length){\n            if (iteratee(iterable[index], index, iterable) === false) {\n                break;\n            }\n        }\n        return collection;\n    };\n}\nvar _createBaseEach = createBaseEach$1;\nvar baseForOwn$2 = _baseForOwn, createBaseEach = _createBaseEach;\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */ var baseEach$3 = createBaseEach(baseForOwn$2);\nvar _baseEach = baseEach$3;\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */ function listCacheClear$1() {\n    this.__data__ = [];\n    this.size = 0;\n}\nvar _listCacheClear = listCacheClear$1;\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */ function eq$5(value, other) {\n    return value === other || value !== value && other !== other;\n}\nvar eq_1 = eq$5;\nvar eq$4 = eq_1;\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */ function assocIndexOf$4(array, key) {\n    var length = array.length;\n    while(length--){\n        if (eq$4(array[length][0], key)) {\n            return length;\n        }\n    }\n    return -1;\n}\nvar _assocIndexOf = assocIndexOf$4;\nvar assocIndexOf$3 = _assocIndexOf;\n/** Used for built-in method references. */ var arrayProto = Array.prototype;\n/** Built-in value references. */ var splice = arrayProto.splice;\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function listCacheDelete$1(key) {\n    var data = this.__data__, index = assocIndexOf$3(data, key);\n    if (index < 0) {\n        return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n        data.pop();\n    } else {\n        splice.call(data, index, 1);\n    }\n    --this.size;\n    return true;\n}\nvar _listCacheDelete = listCacheDelete$1;\nvar assocIndexOf$2 = _assocIndexOf;\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function listCacheGet$1(key) {\n    var data = this.__data__, index = assocIndexOf$2(data, key);\n    return index < 0 ? undefined : data[index][1];\n}\nvar _listCacheGet = listCacheGet$1;\nvar assocIndexOf$1 = _assocIndexOf;\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function listCacheHas$1(key) {\n    return assocIndexOf$1(this.__data__, key) > -1;\n}\nvar _listCacheHas = listCacheHas$1;\nvar assocIndexOf = _assocIndexOf;\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */ function listCacheSet$1(key, value) {\n    var data = this.__data__, index = assocIndexOf(data, key);\n    if (index < 0) {\n        ++this.size;\n        data.push([\n            key,\n            value\n        ]);\n    } else {\n        data[index][1] = value;\n    }\n    return this;\n}\nvar _listCacheSet = listCacheSet$1;\nvar listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function ListCache$4(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while(++index < length){\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `ListCache`.\nListCache$4.prototype.clear = listCacheClear;\nListCache$4.prototype[\"delete\"] = listCacheDelete;\nListCache$4.prototype.get = listCacheGet;\nListCache$4.prototype.has = listCacheHas;\nListCache$4.prototype.set = listCacheSet;\nvar _ListCache = ListCache$4;\nvar ListCache$3 = _ListCache;\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */ function stackClear$1() {\n    this.__data__ = new ListCache$3;\n    this.size = 0;\n}\nvar _stackClear = stackClear$1;\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function stackDelete$1(key) {\n    var data = this.__data__, result = data[\"delete\"](key);\n    this.size = data.size;\n    return result;\n}\nvar _stackDelete = stackDelete$1;\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function stackGet$1(key) {\n    return this.__data__.get(key);\n}\nvar _stackGet = stackGet$1;\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function stackHas$1(key) {\n    return this.__data__.has(key);\n}\nvar _stackHas = stackHas$1;\nvar root$6 = _root;\n/** Used to detect overreaching core-js shims. */ var coreJsData$1 = root$6[\"__core-js_shared__\"];\nvar _coreJsData = coreJsData$1;\nvar coreJsData = _coreJsData;\n/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {\n    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n    return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */ function isMasked$1(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n}\nvar _isMasked = isMasked$1;\n/** Used for built-in method references. */ var funcProto$2 = Function.prototype;\n/** Used to resolve the decompiled source of functions. */ var funcToString$2 = funcProto$2.toString;\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */ function toSource$2(func) {\n    if (func != null) {\n        try {\n            return funcToString$2.call(func);\n        } catch (e) {}\n        try {\n            return func + \"\";\n        } catch (e) {}\n    }\n    return \"\";\n}\nvar _toSource = toSource$2;\nvar isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$6 = isObject_1, toSource$1 = _toSource;\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */ var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n/** Used for built-in method references. */ var funcProto$1 = Function.prototype, objectProto$8 = Object.prototype;\n/** Used to resolve the decompiled source of functions. */ var funcToString$1 = funcProto$1.toString;\n/** Used to check objects for own properties. */ var hasOwnProperty$7 = objectProto$8.hasOwnProperty;\n/** Used to detect if a method is native. */ var reIsNative = RegExp(\"^\" + funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */ function baseIsNative$1(value) {\n    if (!isObject$6(value) || isMasked(value)) {\n        return false;\n    }\n    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource$1(value));\n}\nvar _baseIsNative = baseIsNative$1;\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */ function getValue$1(object, key) {\n    return object == null ? undefined : object[key];\n}\nvar _getValue = getValue$1;\nvar baseIsNative = _baseIsNative, getValue = _getValue;\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */ function getNative$7(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n}\nvar _getNative = getNative$7;\nvar getNative$6 = _getNative, root$5 = _root;\n/* Built-in method references that are verified to be native. */ var Map$3 = getNative$6(root$5, \"Map\");\nvar _Map = Map$3;\nvar getNative$5 = _getNative;\n/* Built-in method references that are verified to be native. */ var nativeCreate$4 = getNative$5(Object, \"create\");\nvar _nativeCreate = nativeCreate$4;\nvar nativeCreate$3 = _nativeCreate;\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */ function hashClear$1() {\n    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};\n    this.size = 0;\n}\nvar _hashClear = hashClear$1;\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function hashDelete$1(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n}\nvar _hashDelete = hashDelete$1;\nvar nativeCreate$2 = _nativeCreate;\n/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED$2 = \"__lodash_hash_undefined__\";\n/** Used for built-in method references. */ var objectProto$7 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$6 = objectProto$7.hasOwnProperty;\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function hashGet$1(key) {\n    var data = this.__data__;\n    if (nativeCreate$2) {\n        var result = data[key];\n        return result === HASH_UNDEFINED$2 ? undefined : result;\n    }\n    return hasOwnProperty$6.call(data, key) ? data[key] : undefined;\n}\nvar _hashGet = hashGet$1;\nvar nativeCreate$1 = _nativeCreate;\n/** Used for built-in method references. */ var objectProto$6 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$5 = objectProto$6.hasOwnProperty;\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function hashHas$1(key) {\n    var data = this.__data__;\n    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$5.call(data, key);\n}\nvar _hashHas = hashHas$1;\nvar nativeCreate = _nativeCreate;\n/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */ function hashSet$1(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;\n    return this;\n}\nvar _hashSet = hashSet$1;\nvar hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function Hash$1(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while(++index < length){\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `Hash`.\nHash$1.prototype.clear = hashClear;\nHash$1.prototype[\"delete\"] = hashDelete;\nHash$1.prototype.get = hashGet;\nHash$1.prototype.has = hashHas;\nHash$1.prototype.set = hashSet;\nvar _Hash = Hash$1;\nvar Hash = _Hash, ListCache$2 = _ListCache, Map$2 = _Map;\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */ function mapCacheClear$1() {\n    this.size = 0;\n    this.__data__ = {\n        \"hash\": new Hash,\n        \"map\": new (Map$2 || ListCache$2),\n        \"string\": new Hash\n    };\n}\nvar _mapCacheClear = mapCacheClear$1;\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */ function isKeyable$1(value) {\n    var type = typeof value;\n    return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar _isKeyable = isKeyable$1;\nvar isKeyable = _isKeyable;\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */ function getMapData$4(map, key) {\n    var data = map.__data__;\n    return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar _getMapData = getMapData$4;\nvar getMapData$3 = _getMapData;\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ function mapCacheDelete$1(key) {\n    var result = getMapData$3(this, key)[\"delete\"](key);\n    this.size -= result ? 1 : 0;\n    return result;\n}\nvar _mapCacheDelete = mapCacheDelete$1;\nvar getMapData$2 = _getMapData;\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */ function mapCacheGet$1(key) {\n    return getMapData$2(this, key).get(key);\n}\nvar _mapCacheGet = mapCacheGet$1;\nvar getMapData$1 = _getMapData;\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function mapCacheHas$1(key) {\n    return getMapData$1(this, key).has(key);\n}\nvar _mapCacheHas = mapCacheHas$1;\nvar getMapData = _getMapData;\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */ function mapCacheSet$1(key, value) {\n    var data = getMapData(this, key), size = data.size;\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n}\nvar _mapCacheSet = mapCacheSet$1;\nvar mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function MapCache$3(entries) {\n    var index = -1, length = entries == null ? 0 : entries.length;\n    this.clear();\n    while(++index < length){\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n    }\n}\n// Add methods to `MapCache`.\nMapCache$3.prototype.clear = mapCacheClear;\nMapCache$3.prototype[\"delete\"] = mapCacheDelete;\nMapCache$3.prototype.get = mapCacheGet;\nMapCache$3.prototype.has = mapCacheHas;\nMapCache$3.prototype.set = mapCacheSet;\nvar _MapCache = MapCache$3;\nvar ListCache$1 = _ListCache, Map$1 = _Map, MapCache$2 = _MapCache;\n/** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */ function stackSet$1(key, value) {\n    var data = this.__data__;\n    if (data instanceof ListCache$1) {\n        var pairs = data.__data__;\n        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n            pairs.push([\n                key,\n                value\n            ]);\n            this.size = ++data.size;\n            return this;\n        }\n        data = this.__data__ = new MapCache$2(pairs);\n    }\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n}\nvar _stackSet = stackSet$1;\nvar ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */ function Stack$3(entries) {\n    var data = this.__data__ = new ListCache(entries);\n    this.size = data.size;\n}\n// Add methods to `Stack`.\nStack$3.prototype.clear = stackClear;\nStack$3.prototype[\"delete\"] = stackDelete;\nStack$3.prototype.get = stackGet;\nStack$3.prototype.has = stackHas;\nStack$3.prototype.set = stackSet;\nvar _Stack = Stack$3;\n/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */ function setCacheAdd$1(value) {\n    this.__data__.set(value, HASH_UNDEFINED);\n    return this;\n}\nvar _setCacheAdd = setCacheAdd$1;\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */ function setCacheHas$1(value) {\n    return this.__data__.has(value);\n}\nvar _setCacheHas = setCacheHas$1;\nvar MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */ function SetCache$1(values) {\n    var index = -1, length = values == null ? 0 : values.length;\n    this.__data__ = new MapCache$1;\n    while(++index < length){\n        this.add(values[index]);\n    }\n}\n// Add methods to `SetCache`.\nSetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;\nSetCache$1.prototype.has = setCacheHas;\nvar _SetCache = SetCache$1;\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */ function arraySome$1(array, predicate) {\n    var index = -1, length = array == null ? 0 : array.length;\n    while(++index < length){\n        if (predicate(array[index], index, array)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar _arraySome = arraySome$1;\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */ function cacheHas$1(cache, key) {\n    return cache.has(key);\n}\nvar _cacheHas = cacheHas$1;\nvar SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */ function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n    }\n    // Check that cyclic values are equal.\n    var arrStacked = stack.get(array);\n    var othStacked = stack.get(other);\n    if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n    }\n    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache : undefined;\n    stack.set(array, other);\n    stack.set(other, array);\n    // Ignore non-index properties.\n    while(++index < arrLength){\n        var arrValue = array[index], othValue = other[index];\n        if (customizer) {\n            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n            if (compared) {\n                continue;\n            }\n            result = false;\n            break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n            if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                    return seen.push(othIndex);\n                }\n            })) {\n                result = false;\n                break;\n            }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n            result = false;\n            break;\n        }\n    }\n    stack[\"delete\"](array);\n    stack[\"delete\"](other);\n    return result;\n}\nvar _equalArrays = equalArrays$2;\nvar root$4 = _root;\n/** Built-in value references. */ var Uint8Array$3 = root$4.Uint8Array;\nvar _Uint8Array = Uint8Array$3;\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */ function mapToArray$1(map) {\n    var index = -1, result = Array(map.size);\n    map.forEach(function(value, key) {\n        result[++index] = [\n            key,\n            value\n        ];\n    });\n    return result;\n}\nvar _mapToArray = mapToArray$1;\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */ function setToArray$1(set) {\n    var index = -1, result = Array(set.size);\n    set.forEach(function(value) {\n        result[++index] = value;\n    });\n    return result;\n}\nvar _setToArray = setToArray$1;\nvar Symbol$3 = _Symbol, Uint8Array$2 = _Uint8Array, eq$3 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;\n/** `Object#toString` result references. */ var boolTag = \"[object Boolean]\", dateTag = \"[object Date]\", errorTag = \"[object Error]\", mapTag$1 = \"[object Map]\", numberTag = \"[object Number]\", regexpTag = \"[object RegExp]\", setTag$1 = \"[object Set]\", stringTag = \"[object String]\", symbolTag$1 = \"[object Symbol]\";\nvar arrayBufferTag = \"[object ArrayBuffer]\", dataViewTag$1 = \"[object DataView]\";\n/** Used to convert symbols to primitives and strings. */ var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : undefined, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */ function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch(tag){\n        case dataViewTag$1:\n            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n                return false;\n            }\n            object = object.buffer;\n            other = other.buffer;\n        case arrayBufferTag:\n            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {\n                return false;\n            }\n            return true;\n        case boolTag:\n        case dateTag:\n        case numberTag:\n            // Coerce booleans to `1` or `0` and dates to milliseconds.\n            // Invalid dates are coerced to `NaN`.\n            return eq$3(+object, +other);\n        case errorTag:\n            return object.name == other.name && object.message == other.message;\n        case regexpTag:\n        case stringTag:\n            // Coerce regexes to strings and treat strings, primitives and objects,\n            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n            // for more details.\n            return object == other + \"\";\n        case mapTag$1:\n            var convert = mapToArray;\n        case setTag$1:\n            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;\n            convert || (convert = setToArray);\n            if (object.size != other.size && !isPartial) {\n                return false;\n            }\n            // Assume cyclic values are equal.\n            var stacked = stack.get(object);\n            if (stacked) {\n                return stacked == other;\n            }\n            bitmask |= COMPARE_UNORDERED_FLAG$2;\n            // Recursively compare objects (susceptible to call stack limits).\n            stack.set(object, other);\n            var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n            stack[\"delete\"](object);\n            return result;\n        case symbolTag$1:\n            if (symbolValueOf) {\n                return symbolValueOf.call(object) == symbolValueOf.call(other);\n            }\n    }\n    return false;\n}\nvar _equalByTag = equalByTag$1;\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */ function arrayPush$2(array, values) {\n    var index = -1, length = values.length, offset = array.length;\n    while(++index < length){\n        array[offset + index] = values[index];\n    }\n    return array;\n}\nvar _arrayPush = arrayPush$2;\nvar arrayPush$1 = _arrayPush, isArray$c = isArray_1;\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */ function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray$c(object) ? result : arrayPush$1(result, symbolsFunc(object));\n}\nvar _baseGetAllKeys = baseGetAllKeys$1;\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */ function arrayFilter$1(array, predicate) {\n    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n    while(++index < length){\n        var value = array[index];\n        if (predicate(value, index, array)) {\n            result[resIndex++] = value;\n        }\n    }\n    return result;\n}\nvar _arrayFilter = arrayFilter$1;\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */ function stubArray$1() {\n    return [];\n}\nvar stubArray_1 = stubArray$1;\nvar arrayFilter = _arrayFilter, stubArray = stubArray_1;\n/** Used for built-in method references. */ var objectProto$5 = Object.prototype;\n/** Built-in value references. */ var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols;\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */ var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {\n    if (object == null) {\n        return [];\n    }\n    object = Object(object);\n    return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n    });\n};\nvar _getSymbols = getSymbols$1;\nvar baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$1 = keys_1;\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */ function getAllKeys$1(object) {\n    return baseGetAllKeys(object, keys$1, getSymbols);\n}\nvar _getAllKeys = getAllKeys$1;\nvar getAllKeys = _getAllKeys;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$3 = 1;\n/** Used for built-in method references. */ var objectProto$4 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$4 = objectProto$4.hasOwnProperty;\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */ function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;\n    if (objLength != othLength && !isPartial) {\n        return false;\n    }\n    var index = objLength;\n    while(index--){\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {\n            return false;\n        }\n    }\n    // Check that cyclic values are equal.\n    var objStacked = stack.get(object);\n    var othStacked = stack.get(other);\n    if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n    }\n    var result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n    var skipCtor = isPartial;\n    while(++index < objLength){\n        key = objProps[index];\n        var objValue = object[key], othValue = other[key];\n        if (customizer) {\n            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n            result = false;\n            break;\n        }\n        skipCtor || (skipCtor = key == \"constructor\");\n    }\n    if (result && !skipCtor) {\n        var objCtor = object.constructor, othCtor = other.constructor;\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n            result = false;\n        }\n    }\n    stack[\"delete\"](object);\n    stack[\"delete\"](other);\n    return result;\n}\nvar _equalObjects = equalObjects$1;\nvar getNative$4 = _getNative, root$3 = _root;\n/* Built-in method references that are verified to be native. */ var DataView$1 = getNative$4(root$3, \"DataView\");\nvar _DataView = DataView$1;\nvar getNative$3 = _getNative, root$2 = _root;\n/* Built-in method references that are verified to be native. */ var Promise$2 = getNative$3(root$2, \"Promise\");\nvar _Promise = Promise$2;\nvar getNative$2 = _getNative, root$1 = _root;\n/* Built-in method references that are verified to be native. */ var Set$2 = getNative$2(root$1, \"Set\");\nvar _Set = Set$2;\nvar getNative$1 = _getNative, root = _root;\n/* Built-in method references that are verified to be native. */ var WeakMap$1 = getNative$1(root, \"WeakMap\");\nvar _WeakMap = WeakMap$1;\nvar DataView = _DataView, Map = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap = _WeakMap, baseGetTag$2 = _baseGetTag, toSource = _toSource;\n/** `Object#toString` result references. */ var mapTag = \"[object Map]\", objectTag$2 = \"[object Object]\", promiseTag = \"[object Promise]\", setTag = \"[object Set]\", weakMapTag = \"[object WeakMap]\";\nvar dataViewTag = \"[object DataView]\";\n/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap);\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */ var getTag$2 = baseGetTag$2;\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif (DataView && getTag$2(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag$2(new Map) != mapTag || Promise$1 && getTag$2(Promise$1.resolve()) != promiseTag || Set$1 && getTag$2(new Set$1) != setTag || WeakMap && getTag$2(new WeakMap) != weakMapTag) {\n    getTag$2 = function(value) {\n        var result = baseGetTag$2(value), Ctor = result == objectTag$2 ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : \"\";\n        if (ctorString) {\n            switch(ctorString){\n                case dataViewCtorString:\n                    return dataViewTag;\n                case mapCtorString:\n                    return mapTag;\n                case promiseCtorString:\n                    return promiseTag;\n                case setCtorString:\n                    return setTag;\n                case weakMapCtorString:\n                    return weakMapTag;\n            }\n        }\n        return result;\n    };\n}\nvar _getTag = getTag$2;\nvar Stack$2 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$1 = _getTag, isArray$b = isArray_1, isBuffer$2 = isBufferExports, isTypedArray$1 = isTypedArray_1;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$2 = 1;\n/** `Object#toString` result references. */ var argsTag = \"[object Arguments]\", arrayTag = \"[object Array]\", objectTag$1 = \"[object Object]\";\n/** Used for built-in method references. */ var objectProto$3 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */ function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray$b(object), othIsArr = isArray$b(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);\n    objTag = objTag == argsTag ? objectTag$1 : objTag;\n    othTag = othTag == argsTag ? objectTag$1 : othTag;\n    var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;\n    if (isSameTag && isBuffer$2(object)) {\n        if (!isBuffer$2(other)) {\n            return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n    }\n    if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack$2);\n        return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n    }\n    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n        var objIsWrapped = objIsObj && hasOwnProperty$3.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, \"__wrapped__\");\n        if (objIsWrapped || othIsWrapped) {\n            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n            stack || (stack = new Stack$2);\n            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n    }\n    if (!isSameTag) {\n        return false;\n    }\n    stack || (stack = new Stack$2);\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\nvar _baseIsEqualDeep = baseIsEqualDeep$1;\nvar baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$3 = isObjectLike_1;\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */ function baseIsEqual$3(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n        return true;\n    }\n    if (value == null || other == null || !isObjectLike$3(value) && !isObjectLike$3(other)) {\n        return value !== value && other !== other;\n    }\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);\n}\nvar _baseIsEqual = baseIsEqual$3;\nvar Stack$1 = _Stack, baseIsEqual$2 = _baseIsEqual;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */ function baseIsMatch$1(object, source, matchData, customizer) {\n    var index = matchData.length, length = index, noCustomizer = !customizer;\n    if (object == null) {\n        return !length;\n    }\n    object = Object(object);\n    while(index--){\n        var data = matchData[index];\n        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n            return false;\n        }\n    }\n    while(++index < length){\n        data = matchData[index];\n        var key = data[0], objValue = object[key], srcValue = data[1];\n        if (noCustomizer && data[2]) {\n            if (objValue === undefined && !(key in object)) {\n                return false;\n            }\n        } else {\n            var stack = new Stack$1;\n            if (customizer) {\n                var result = customizer(objValue, srcValue, key, object, source, stack);\n            }\n            if (!(result === undefined ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nvar _baseIsMatch = baseIsMatch$1;\nvar isObject$5 = isObject_1;\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */ function isStrictComparable$2(value) {\n    return value === value && !isObject$5(value);\n}\nvar _isStrictComparable = isStrictComparable$2;\nvar isStrictComparable$1 = _isStrictComparable, keys = keys_1;\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */ function getMatchData$1(object) {\n    var result = keys(object), length = result.length;\n    while(length--){\n        var key = result[length], value = object[key];\n        result[length] = [\n            key,\n            value,\n            isStrictComparable$1(value)\n        ];\n    }\n    return result;\n}\nvar _getMatchData = getMatchData$1;\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */ function matchesStrictComparable$2(key, srcValue) {\n    return function(object) {\n        if (object == null) {\n            return false;\n        }\n        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n    };\n}\nvar _matchesStrictComparable = matchesStrictComparable$2;\nvar baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */ function baseMatches$1(source) {\n    var matchData = getMatchData(source);\n    if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);\n    }\n    return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n    };\n}\nvar _baseMatches = baseMatches$1;\nvar baseGetTag$1 = _baseGetTag, isObjectLike$2 = isObjectLike_1;\n/** `Object#toString` result references. */ var symbolTag = \"[object Symbol]\";\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */ function isSymbol$5(value) {\n    return typeof value == \"symbol\" || isObjectLike$2(value) && baseGetTag$1(value) == symbolTag;\n}\nvar isSymbol_1 = isSymbol$5;\nvar isArray$a = isArray_1, isSymbol$4 = isSymbol_1;\n/** Used to match property names within property paths. */ var reIsDeepProp$1 = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp$1 = /^\\w*$/;\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */ function isKey$4(value, object) {\n    if (isArray$a(value)) {\n        return false;\n    }\n    var type = typeof value;\n    if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol$4(value)) {\n        return true;\n    }\n    return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);\n}\nvar _isKey = isKey$4;\nvar MapCache = _MapCache;\n/** Error message constants. */ var FUNC_ERROR_TEXT = \"Expected a function\";\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */ function memoize$1(func, resolver) {\n    if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function() {\n        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n    };\n    memoized.cache = new (memoize$1.Cache || MapCache);\n    return memoized;\n}\n// Expose `MapCache`.\nmemoize$1.Cache = MapCache;\nvar memoize_1 = memoize$1;\nvar memoize = memoize_1;\n/** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */ function memoizeCapped$1(func) {\n    var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n            cache.clear();\n        }\n        return key;\n    });\n    var cache = result.cache;\n    return result;\n}\nvar _memoizeCapped = memoizeCapped$1;\nvar memoizeCapped = _memoizeCapped;\n/** Used to match property names within property paths. */ var rePropName$1 = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n/** Used to match backslashes in property paths. */ var reEscapeChar$1 = /\\\\(\\\\)?/g;\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */ var stringToPath$2 = memoizeCapped(function(string) {\n    var result = [];\n    if (string.charCodeAt(0) === 46 /* . */ ) {\n        result.push(\"\");\n    }\n    string.replace(rePropName$1, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar$1, \"$1\") : number || match);\n    });\n    return result;\n});\nvar _stringToPath = stringToPath$2;\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */ function arrayMap$2(array, iteratee) {\n    var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n    while(++index < length){\n        result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n}\nvar _arrayMap = arrayMap$2;\nvar Symbol$2 = _Symbol, arrayMap$1 = _arrayMap, isArray$9 = isArray_1, isSymbol$3 = isSymbol_1;\n/** Used as references for various `Number` constants. */ var INFINITY$2 = 1 / 0;\n/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */ function baseToString$1(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == \"string\") {\n        return value;\n    }\n    if (isArray$9(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap$1(value, baseToString$1) + \"\";\n    }\n    if (isSymbol$3(value)) {\n        return symbolToString ? symbolToString.call(value) : \"\";\n    }\n    var result = value + \"\";\n    return result == \"0\" && 1 / value == -INFINITY$2 ? \"-0\" : result;\n}\nvar _baseToString = baseToString$1;\nvar baseToString = _baseToString;\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */ function toString$5(value) {\n    return value == null ? \"\" : baseToString(value);\n}\nvar toString_1 = toString$5;\nvar isArray$8 = isArray_1, isKey$3 = _isKey, stringToPath$1 = _stringToPath, toString$4 = toString_1;\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */ function castPath$3(value, object) {\n    if (isArray$8(value)) {\n        return value;\n    }\n    return isKey$3(value, object) ? [\n        value\n    ] : stringToPath$1(toString$4(value));\n}\nvar _castPath = castPath$3;\nvar isSymbol$2 = isSymbol_1;\n/** Used as references for various `Number` constants. */ var INFINITY$1 = 1 / 0;\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */ function toKey$5(value) {\n    if (typeof value == \"string\" || isSymbol$2(value)) {\n        return value;\n    }\n    var result = value + \"\";\n    return result == \"0\" && 1 / value == -INFINITY$1 ? \"-0\" : result;\n}\nvar _toKey = toKey$5;\nvar castPath$2 = _castPath, toKey$4 = _toKey;\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */ function baseGet$3(object, path) {\n    path = castPath$2(path, object);\n    var index = 0, length = path.length;\n    while(object != null && index < length){\n        object = object[toKey$4(path[index++])];\n    }\n    return index && index == length ? object : undefined;\n}\nvar _baseGet = baseGet$3;\nvar baseGet$2 = _baseGet;\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */ function get$2(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet$2(object, path);\n    return result === undefined ? defaultValue : result;\n}\nvar get_1 = get$2;\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */ function baseHasIn$1(object, key) {\n    return object != null && key in Object(object);\n}\nvar _baseHasIn = baseHasIn$1;\nvar castPath$1 = _castPath, isArguments$2 = isArguments_1, isArray$7 = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$3 = _toKey;\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */ function hasPath$1(object, path, hasFunc) {\n    path = castPath$1(path, object);\n    var index = -1, length = path.length, result = false;\n    while(++index < length){\n        var key = toKey$3(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n            break;\n        }\n        object = object[key];\n    }\n    if (result || ++index != length) {\n        return result;\n    }\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex$1(key, length) && (isArray$7(object) || isArguments$2(object));\n}\nvar _hasPath = hasPath$1;\nvar baseHasIn = _baseHasIn, hasPath = _hasPath;\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */ function hasIn$1(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n}\nvar hasIn_1 = hasIn$1;\nvar baseIsEqual$1 = _baseIsEqual, get$1 = get_1, hasIn = hasIn_1, isKey$2 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$2 = _toKey;\n/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */ function baseMatchesProperty$1(path, srcValue) {\n    if (isKey$2(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey$2(path), srcValue);\n    }\n    return function(object) {\n        var objValue = get$1(object, path);\n        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n    };\n}\nvar _baseMatchesProperty = baseMatchesProperty$1;\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */ function identity$4(value) {\n    return value;\n}\nvar identity_1 = identity$4;\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */ function baseProperty$1(key) {\n    return function(object) {\n        return object == null ? undefined : object[key];\n    };\n}\nvar _baseProperty = baseProperty$1;\nvar baseGet$1 = _baseGet;\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */ function basePropertyDeep$1(path) {\n    return function(object) {\n        return baseGet$1(object, path);\n    };\n}\nvar _basePropertyDeep = basePropertyDeep$1;\nvar baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey$1 = _isKey, toKey$1 = _toKey;\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */ function property$1(path) {\n    return isKey$1(path) ? baseProperty(toKey$1(path)) : basePropertyDeep(path);\n}\nvar property_1 = property$1;\nvar baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$3 = identity_1, isArray$6 = isArray_1, property = property_1;\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */ function baseIteratee$5(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == \"function\") {\n        return value;\n    }\n    if (value == null) {\n        return identity$3;\n    }\n    if (typeof value == \"object\") {\n        return isArray$6(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n    }\n    return property(value);\n}\nvar _baseIteratee = baseIteratee$5;\n/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */ function baseReduce$1(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n}\nvar _baseReduce = baseReduce$1;\nvar arrayReduce$1 = _arrayReduce, baseEach$2 = _baseEach, baseIteratee$4 = _baseIteratee, baseReduce = _baseReduce, isArray$5 = isArray_1;\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */ function reduce(collection, iteratee, accumulator) {\n    var func = isArray$5(collection) ? arrayReduce$1 : baseReduce, initAccum = arguments.length < 3;\n    return func(collection, baseIteratee$4(iteratee), accumulator, initAccum, baseEach$2);\n}\nvar reduce_1 = reduce;\nvar reduce$1 = /*@__PURE__*/ getDefaultExportFromCjs(reduce_1);\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self :  false ? 0 : {};\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar inited = false;\nfunction init() {\n    inited = true;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for(var i = 0, len = code.length; i < len; ++i){\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n    }\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n}\nfunction toByteArray(b64) {\n    if (!inited) {\n        init();\n    }\n    var i, j, l, tmp, placeHolders, arr;\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    placeHolders = b64[len - 2] === \"=\" ? 2 : b64[len - 1] === \"=\" ? 1 : 0;\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(len * 3 / 4 - placeHolders);\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? len - 4 : len;\n    var L = 0;\n    for(i = 0, j = 0; i < l; i += 4, j += 3){\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[L++] = tmp >> 16 & 0xFF;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    if (placeHolders === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[L++] = tmp & 0xFF;\n    } else if (placeHolders === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\nfunction encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n    if (!inited) {\n        init();\n    }\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    var output = \"\";\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        output += lookup[tmp >> 2];\n        output += lookup[tmp << 4 & 0x3F];\n        output += \"==\";\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        output += lookup[tmp >> 10];\n        output += lookup[tmp >> 4 & 0x3F];\n        output += lookup[tmp << 2 & 0x3F];\n        output += \"=\";\n    }\n    parts.push(output);\n    return parts.join(\"\");\n}\nfunction read(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    if (e === 0) {\n        e = 1 - eBias;\n    } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n}\nfunction write(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) {\n            value += rt / c;\n        } else {\n            value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}\n    buffer[offset + i - d] |= s * 128;\n}\nvar toString$3 = {}.toString;\nvar isArray$4 = Array.isArray || function(arr) {\n    return toString$3.call(arr) == \"[object Array]\";\n};\nvar INSPECT_MAX_BYTES = 50;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */ Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;\n/*\n * Export kMaxLength after typed array support is determined.\n */ kMaxLength();\nfunction kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\nfunction createBuffer(that, length) {\n    if (kMaxLength() < length) {\n        throw new RangeError(\"Invalid typed array length\");\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length);\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n            that = new Buffer(length);\n        }\n        that.length = length;\n    }\n    return that;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length);\n    }\n    // Common case.\n    if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n            throw new Error(\"If encoding is specified then the first argument must be a string\");\n        }\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, encodingOrOffset, length);\n}\nBuffer.poolSize = 8192; // not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function(arr) {\n    arr.__proto__ = Buffer.prototype;\n    return arr;\n};\nfunction from(that, value, encodingOrOffset, length) {\n    if (typeof value === \"number\") {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === \"string\") {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ Buffer.from = function(value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length);\n};\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    if (typeof Symbol !== \"undefined\" && Symbol.species && Buffer[Symbol.species] === Buffer) ;\n}\nfunction assertSize(size) {\n    if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be a number');\n    } else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n    }\n}\nfunction alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ Buffer.alloc = function(size, fill, encoding) {\n    return alloc(null, size, fill, encoding);\n};\nfunction allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for(var i = 0; i < size; ++i){\n            that[i] = 0;\n        }\n    }\n    return that;\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ Buffer.allocUnsafe = function(size) {\n    return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ Buffer.allocUnsafeSlow = function(size) {\n    return allocUnsafe(null, size);\n};\nfunction fromString(that, string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual);\n    }\n    return that;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for(var i = 0; i < length; i += 1){\n        that[i] = array[i] & 255;\n    }\n    return that;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\");\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\");\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    } else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}\nfunction fromObject(that, obj) {\n    if (internalIsBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        that = createBuffer(that, len);\n        if (that.length === 0) {\n            return that;\n        }\n        obj.copy(that, 0, 0, len);\n        return that;\n    }\n    if (obj) {\n        if (typeof ArrayBuffer !== \"undefined\" && obj.buffer instanceof ArrayBuffer || \"length\" in obj) {\n            if (typeof obj.length !== \"number\" || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === \"Buffer\" && isArray$4(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n}\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + kMaxLength().toString(16) + \" bytes\");\n    }\n    return length | 0;\n}\nBuffer.isBuffer = isBuffer$1;\nfunction internalIsBuffer(b) {\n    return !!(b != null && b._isBuffer);\n}\nBuffer.compare = function compare(a, b) {\n    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n        throw new TypeError(\"Arguments must be Buffers\");\n    }\n    if (a === b) return 0;\n    var x = a.length;\n    var y = b.length;\n    for(var i = 0, len = Math.min(x, y); i < len; ++i){\n        if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return true;\n        default:\n            return false;\n    }\n};\nBuffer.concat = function concat(list, length) {\n    if (!isArray$4(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return Buffer.alloc(0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i){\n            length += list[i].length;\n        }\n    }\n    var buffer = Buffer.allocUnsafe(length);\n    var pos = 0;\n    for(i = 0; i < list.length; ++i){\n        var buf = list[i];\n        if (!internalIsBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction byteLength(string, encoding) {\n    if (internalIsBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n        string = \"\" + string;\n    }\n    var len = string.length;\n    if (len === 0) return 0;\n    // Use a for loop to avoid recursion\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n                return len;\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined:\n                return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return len * 2;\n            case \"hex\":\n                return len >>> 1;\n            case \"base64\":\n                return base64ToBytes(string).length;\n            default:\n                if (loweredCase) return utf8ToBytes(string).length // assume utf8\n                ;\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\nBuffer.byteLength = byteLength;\nfunction slowToString(encoding, start, end) {\n    var loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while(true){\n        switch(encoding){\n            case \"hex\":\n                return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Slice(this, start, end);\n            case \"ascii\":\n                return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Slice(this, start, end);\n            case \"base64\":\n                return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return utf16leSlice(this, start, end);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (encoding + \"\").toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\nfunction swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\nBuffer.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n    for(var i = 0; i < len; i += 2){\n        swap(this, i, i + 1);\n    }\n    return this;\n};\nBuffer.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n    for(var i = 0; i < len; i += 4){\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n    }\n    return this;\n};\nBuffer.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n    for(var i = 0; i < len; i += 8){\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n    }\n    return this;\n};\nBuffer.prototype.toString = function toString() {\n    var length = this.length | 0;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n};\nBuffer.prototype.equals = function equals(b) {\n    if (!internalIsBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return Buffer.compare(this, b) === 0;\n};\nBuffer.prototype.inspect = function inspect() {\n    var str = \"\";\n    var max = INSPECT_MAX_BYTES;\n    if (this.length > 0) {\n        str = this.toString(\"hex\", 0, max).match(/.{2}/g).join(\" \");\n        if (this.length > max) str += \" ... \";\n    }\n    return \"<Buffer \" + str + \">\";\n};\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (!internalIsBuffer(target)) {\n        throw new TypeError(\"Argument must be a Buffer\");\n    }\n    if (start === undefined) {\n        start = 0;\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0;\n    }\n    if (thisStart === undefined) {\n        thisStart = 0;\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n    }\n    if (thisStart >= thisEnd && start >= end) {\n        return 0;\n    }\n    if (thisStart >= thisEnd) {\n        return -1;\n    }\n    if (start >= end) {\n        return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n    for(var i = 0; i < len; ++i){\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n    } else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n    }\n    byteOffset = +byteOffset; // Coerce to Number.\n    if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (internalIsBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 0xFF; // Search for a byte value [0-255]\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++){\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            var found = true;\n            for(var j = 0; j < valLength; j++){\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    // must be an even number of digits\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError(\"Invalid hex string\");\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for(var i = 0; i < length; ++i){\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\nfunction latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length);\n}\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n            if (encoding === undefined) encoding = \"utf8\";\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n    } else {\n        throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n    if (!encoding) encoding = \"utf8\";\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"hex\":\n                return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Write(this, string, offset, length);\n            case \"ascii\":\n                return asciiWrite(this, string, offset, length);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Write(this, string, offset, length);\n            case \"base64\":\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return ucs2Write(this, string, offset, length);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n};\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return fromByteArray(buf);\n    } else {\n        return fromByteArray(buf.slice(start, end));\n    }\n}\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while(i < end){\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte;\n                    }\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n        ;\n    }\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = \"\";\n    var i = 0;\n    while(i < len){\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}\nfunction asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n    return ret;\n}\nfunction latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}\nfunction hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for(var i = start; i < end; ++i){\n        out += toHex(buf[i]);\n    }\n    return out;\n}\nfunction utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for(var i = 0; i < bytes.length; i += 2){\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) {\n        end = len;\n    }\n    if (end < start) end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        newBuf.__proto__ = Buffer.prototype;\n    } else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for(var i = 0; i < sliceLen; ++i){\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n}\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length);\n    }\n    var val = this[offset + --byteLength];\n    var mul = 1;\n    while(byteLength > 0 && (mul *= 0x100)){\n        val += this[offset + --byteLength] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    return this[offset];\n};\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var i = byteLength;\n    var mul = 1;\n    var val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100)){\n        val += this[offset + --i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, true, 23, 4);\n};\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, false, 23, 4);\n};\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, true, 52, 8);\n};\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, false, 52, 8);\n};\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n}\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i){\n        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n    }\n}\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffffffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i){\n        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n    }\n}\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0) value = 0xffffffff + value + 1;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n}\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4);\n    }\n    write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n};\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8);\n    }\n    write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n    }\n    if (start < 0 || start >= this.length) throw new RangeError(\"sourceStart out of bounds\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for(i = len - 1; i >= 0; --i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for(i = 0; i < len; ++i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n        if (encoding !== undefined && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    var i;\n    if (typeof val === \"number\") {\n        for(i = start; i < end; ++i){\n            this[i] = val;\n        }\n    } else {\n        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n        var len = bytes.length;\n        for(i = 0; i < end - start; ++i){\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\n// HELPER FUNCTIONS\n// ================\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\nfunction base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return \"\";\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0){\n        str = str + \"=\";\n    }\n    return str;\n}\nfunction stringtrim(str) {\n    if (str.trim) return str.trim();\n    return str.replace(/^\\s+|\\s+$/g, \"\");\n}\nfunction toHex(n) {\n    if (n < 16) return \"0\" + n.toString(16);\n    return n.toString(16);\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for(var i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}\nfunction asciiToBytes(str) {\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n    return byteArray;\n}\nfunction utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction base64ToBytes(str) {\n    return toByteArray(base64clean(str));\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for(var i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction isnan(val) {\n    return val !== val // eslint-disable-line no-self-compare\n    ;\n}\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer$1(obj) {\n    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));\n}\nfunction isFastBuffer(obj) {\n    return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n}\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer(obj) {\n    return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isFastBuffer(obj.slice(0, 0));\n}\n// Lodash implementation of `get`\nconst charCodeOfDot = \".\".charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(// Match anything that isn't a dot or bracket.\n\"[^.[\\\\]]+\" + \"|\" + // Or match property names within brackets.\n\"\\\\[(?:\" + // Match a non-string expression.\n\"([^\\\"'][^[]*)\" + \"|\" + // Or match strings (supports escaping characters).\n\"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" + \")\\\\]\" + \"|\" + // Or match \"\" as the space between consecutive dots or empty brackets.\n\"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\", \"g\");\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\nconst getTag = function(value) {\n    return Object.prototype.toString.call(value);\n};\nconst isSymbol$1 = function(value) {\n    const type = typeof value;\n    return type === \"symbol\" || type === \"object\" && value && getTag(value) === \"[object Symbol]\";\n};\nconst isKey = function(value, object) {\n    if (Array.isArray(value)) {\n        return false;\n    }\n    const type = typeof value;\n    if (type === \"number\" || type === \"symbol\" || type === \"boolean\" || !value || isSymbol$1(value)) {\n        return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n};\nconst stringToPath = function(string) {\n    const result = [];\n    if (string.charCodeAt(0) === charCodeOfDot) {\n        result.push(\"\");\n    }\n    string.replace(rePropName, function(match, expression, quote, subString) {\n        let key = match;\n        if (quote) {\n            key = subString.replace(reEscapeChar, \"$1\");\n        } else if (expression) {\n            key = expression.trim();\n        }\n        result.push(key);\n    });\n    return result;\n};\nconst castPath = function(value, object) {\n    if (Array.isArray(value)) {\n        return value;\n    } else {\n        return isKey(value, object) ? [\n            value\n        ] : stringToPath(value);\n    }\n};\nconst toKey = function(value) {\n    if (typeof value === \"string\" || isSymbol$1(value)) return value;\n    const result = `${value}`;\n    // eslint-disable-next-line\n    return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n};\nconst get = function(object, path) {\n    path = castPath(path, object);\n    let index = 0;\n    const length = path.length;\n    while(object != null && index < length){\n        object = object[toKey(path[index++])];\n    }\n    return index && index === length ? object : undefined;\n};\nconst is_object = function(obj) {\n    return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n};\nconst normalize_columns = function(columns) {\n    if (columns === undefined || columns === null) {\n        return [\n            undefined,\n            undefined\n        ];\n    }\n    if (typeof columns !== \"object\") {\n        return [\n            Error('Invalid option \"columns\": expect an array or an object')\n        ];\n    }\n    if (!Array.isArray(columns)) {\n        const newcolumns = [];\n        for(const k in columns){\n            newcolumns.push({\n                key: k,\n                header: columns[k]\n            });\n        }\n        columns = newcolumns;\n    } else {\n        const newcolumns = [];\n        for (const column of columns){\n            if (typeof column === \"string\") {\n                newcolumns.push({\n                    key: column,\n                    header: column\n                });\n            } else if (typeof column === \"object\" && column !== null && !Array.isArray(column)) {\n                if (!column.key) {\n                    return [\n                        Error('Invalid column definition: property \"key\" is required')\n                    ];\n                }\n                if (column.header === undefined) {\n                    column.header = column.key;\n                }\n                newcolumns.push(column);\n            } else {\n                return [\n                    Error(\"Invalid column definition: expect a string or an object\")\n                ];\n            }\n        }\n        columns = newcolumns;\n    }\n    return [\n        undefined,\n        columns\n    ];\n};\nclass CsvError extends Error {\n    constructor(code, message, ...contexts){\n        if (Array.isArray(message)) message = message.join(\" \");\n        super(message);\n        if (Error.captureStackTrace !== undefined) {\n            Error.captureStackTrace(this, CsvError);\n        }\n        this.code = code;\n        for (const context of contexts){\n            for(const key in context){\n                const value = context[key];\n                this[key] = isBuffer$1(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n            }\n        }\n    }\n}\nconst underscore = function(str) {\n    return str.replace(/([A-Z])/g, function(_, match) {\n        return \"_\" + match.toLowerCase();\n    });\n};\nconst normalize_options = function(opts) {\n    const options = {};\n    // Merge with user options\n    for(const opt in opts){\n        options[underscore(opt)] = opts[opt];\n    }\n    // Normalize option `bom`\n    if (options.bom === undefined || options.bom === null || options.bom === false) {\n        options.bom = false;\n    } else if (options.bom !== true) {\n        return [\n            new CsvError(\"CSV_OPTION_BOOLEAN_INVALID_TYPE\", [\n                \"option `bom` is optional and must be a boolean value,\",\n                `got ${JSON.stringify(options.bom)}`\n            ])\n        ];\n    }\n    // Normalize option `delimiter`\n    if (options.delimiter === undefined || options.delimiter === null) {\n        options.delimiter = \",\";\n    } else if (isBuffer$1(options.delimiter)) {\n        options.delimiter = options.delimiter.toString();\n    } else if (typeof options.delimiter !== \"string\") {\n        return [\n            new CsvError(\"CSV_OPTION_DELIMITER_INVALID_TYPE\", [\n                \"option `delimiter` must be a buffer or a string,\",\n                `got ${JSON.stringify(options.delimiter)}`\n            ])\n        ];\n    }\n    // Normalize option `quote`\n    if (options.quote === undefined || options.quote === null) {\n        options.quote = '\"';\n    } else if (options.quote === true) {\n        options.quote = '\"';\n    } else if (options.quote === false) {\n        options.quote = \"\";\n    } else if (isBuffer$1(options.quote)) {\n        options.quote = options.quote.toString();\n    } else if (typeof options.quote !== \"string\") {\n        return [\n            new CsvError(\"CSV_OPTION_QUOTE_INVALID_TYPE\", [\n                \"option `quote` must be a boolean, a buffer or a string,\",\n                `got ${JSON.stringify(options.quote)}`\n            ])\n        ];\n    }\n    // Normalize option `quoted`\n    if (options.quoted === undefined || options.quoted === null) {\n        options.quoted = false;\n    }\n    // Normalize option `escape_formulas`\n    if (options.escape_formulas === undefined || options.escape_formulas === null) {\n        options.escape_formulas = false;\n    } else if (typeof options.escape_formulas !== \"boolean\") {\n        return [\n            new CsvError(\"CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE\", [\n                \"option `escape_formulas` must be a boolean,\",\n                `got ${JSON.stringify(options.escape_formulas)}`\n            ])\n        ];\n    }\n    // Normalize option `quoted_empty`\n    if (options.quoted_empty === undefined || options.quoted_empty === null) {\n        options.quoted_empty = undefined;\n    }\n    // Normalize option `quoted_match`\n    if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {\n        options.quoted_match = null;\n    } else if (!Array.isArray(options.quoted_match)) {\n        options.quoted_match = [\n            options.quoted_match\n        ];\n    }\n    if (options.quoted_match) {\n        for (const quoted_match of options.quoted_match){\n            const isString = typeof quoted_match === \"string\";\n            const isRegExp = quoted_match instanceof RegExp;\n            if (!isString && !isRegExp) {\n                return [\n                    Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)\n                ];\n            }\n        }\n    }\n    // Normalize option `quoted_string`\n    if (options.quoted_string === undefined || options.quoted_string === null) {\n        options.quoted_string = false;\n    }\n    // Normalize option `eof`\n    if (options.eof === undefined || options.eof === null) {\n        options.eof = true;\n    }\n    // Normalize option `escape`\n    if (options.escape === undefined || options.escape === null) {\n        options.escape = '\"';\n    } else if (isBuffer$1(options.escape)) {\n        options.escape = options.escape.toString();\n    } else if (typeof options.escape !== \"string\") {\n        return [\n            Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)\n        ];\n    }\n    if (options.escape.length > 1) {\n        return [\n            Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)\n        ];\n    }\n    // Normalize option `header`\n    if (options.header === undefined || options.header === null) {\n        options.header = false;\n    }\n    // Normalize option `columns`\n    const [errColumns, columns] = normalize_columns(options.columns);\n    if (errColumns !== undefined) return [\n        errColumns\n    ];\n    options.columns = columns;\n    // Normalize option `quoted`\n    if (options.quoted === undefined || options.quoted === null) {\n        options.quoted = false;\n    }\n    // Normalize option `cast`\n    if (options.cast === undefined || options.cast === null) {\n        options.cast = {};\n    }\n    // Normalize option cast.bigint\n    if (options.cast.bigint === undefined || options.cast.bigint === null) {\n        // Cast boolean to string by default\n        options.cast.bigint = (value)=>\"\" + value;\n    }\n    // Normalize option cast.boolean\n    if (options.cast.boolean === undefined || options.cast.boolean === null) {\n        // Cast boolean to string by default\n        options.cast.boolean = (value)=>value ? \"1\" : \"\";\n    }\n    // Normalize option cast.date\n    if (options.cast.date === undefined || options.cast.date === null) {\n        // Cast date to timestamp string by default\n        options.cast.date = (value)=>\"\" + value.getTime();\n    }\n    // Normalize option cast.number\n    if (options.cast.number === undefined || options.cast.number === null) {\n        // Cast number to string using native casting by default\n        options.cast.number = (value)=>\"\" + value;\n    }\n    // Normalize option cast.object\n    if (options.cast.object === undefined || options.cast.object === null) {\n        // Stringify object as JSON by default\n        options.cast.object = (value)=>JSON.stringify(value);\n    }\n    // Normalize option cast.string\n    if (options.cast.string === undefined || options.cast.string === null) {\n        // Leave string untouched\n        options.cast.string = function(value) {\n            return value;\n        };\n    }\n    // Normalize option `on_record`\n    if (options.on_record !== undefined && typeof options.on_record !== \"function\") {\n        return [\n            Error(`Invalid Option: \"on_record\" must be a function.`)\n        ];\n    }\n    // Normalize option `record_delimiter`\n    if (options.record_delimiter === undefined || options.record_delimiter === null) {\n        options.record_delimiter = \"\\n\";\n    } else if (isBuffer$1(options.record_delimiter)) {\n        options.record_delimiter = options.record_delimiter.toString();\n    } else if (typeof options.record_delimiter !== \"string\") {\n        return [\n            Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)\n        ];\n    }\n    switch(options.record_delimiter){\n        case \"unix\":\n            options.record_delimiter = \"\\n\";\n            break;\n        case \"mac\":\n            options.record_delimiter = \"\\r\";\n            break;\n        case \"windows\":\n            options.record_delimiter = \"\\r\\n\";\n            break;\n        case \"ascii\":\n            options.record_delimiter = \"\\x1e\";\n            break;\n        case \"unicode\":\n            options.record_delimiter = \"\\u2028\";\n            break;\n    }\n    return [\n        undefined,\n        options\n    ];\n};\nconst bom_utf8 = Buffer.from([\n    239,\n    187,\n    191\n]);\nconst stringifier = function(options, state, info) {\n    return {\n        options: options,\n        state: state,\n        info: info,\n        __transform: function(chunk, push) {\n            // Chunk validation\n            if (!Array.isArray(chunk) && typeof chunk !== \"object\") {\n                return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);\n            }\n            // Detect columns from the first record\n            if (this.info.records === 0) {\n                if (Array.isArray(chunk)) {\n                    if (this.options.header === true && this.options.columns === undefined) {\n                        return Error(\"Undiscoverable Columns: header option requires column option or object records\");\n                    }\n                } else if (this.options.columns === undefined) {\n                    const [err, columns] = normalize_columns(Object.keys(chunk));\n                    if (err) return;\n                    this.options.columns = columns;\n                }\n            }\n            // Emit the header\n            if (this.info.records === 0) {\n                this.bom(push);\n                const err = this.headers(push);\n                if (err) return err;\n            }\n            // Emit and stringify the record if an object or an array\n            try {\n                // this.emit('record', chunk, this.info.records);\n                if (this.options.on_record) {\n                    this.options.on_record(chunk, this.info.records);\n                }\n            } catch (err) {\n                return err;\n            }\n            // Convert the record into a string\n            let err, chunk_string;\n            if (this.options.eof) {\n                [err, chunk_string] = this.stringify(chunk);\n                if (err) return err;\n                if (chunk_string === undefined) {\n                    return;\n                } else {\n                    chunk_string = chunk_string + this.options.record_delimiter;\n                }\n            } else {\n                [err, chunk_string] = this.stringify(chunk);\n                if (err) return err;\n                if (chunk_string === undefined) {\n                    return;\n                } else {\n                    if (this.options.header || this.info.records) {\n                        chunk_string = this.options.record_delimiter + chunk_string;\n                    }\n                }\n            }\n            // Emit the csv\n            this.info.records++;\n            push(chunk_string);\n        },\n        stringify: function(chunk, chunkIsHeader = false) {\n            if (typeof chunk !== \"object\") {\n                return [\n                    undefined,\n                    chunk\n                ];\n            }\n            const { columns } = this.options;\n            const record = [];\n            // Record is an array\n            if (Array.isArray(chunk)) {\n                // We are getting an array but the user has specified output columns. In\n                // this case, we respect the columns indexes\n                if (columns) {\n                    chunk.splice(columns.length);\n                }\n                // Cast record elements\n                for(let i = 0; i < chunk.length; i++){\n                    const field = chunk[i];\n                    const [err, value] = this.__cast(field, {\n                        index: i,\n                        column: i,\n                        records: this.info.records,\n                        header: chunkIsHeader\n                    });\n                    if (err) return [\n                        err\n                    ];\n                    record[i] = [\n                        value,\n                        field\n                    ];\n                }\n            // Record is a literal object\n            // `columns` is always defined: it is either provided or discovered.\n            } else {\n                for(let i = 0; i < columns.length; i++){\n                    const field = get(chunk, columns[i].key);\n                    const [err, value] = this.__cast(field, {\n                        index: i,\n                        column: columns[i].key,\n                        records: this.info.records,\n                        header: chunkIsHeader\n                    });\n                    if (err) return [\n                        err\n                    ];\n                    record[i] = [\n                        value,\n                        field\n                    ];\n                }\n            }\n            let csvrecord = \"\";\n            for(let i = 0; i < record.length; i++){\n                let options, err;\n                let [value, field] = record[i];\n                if (typeof value === \"string\") {\n                    options = this.options;\n                } else if (is_object(value)) {\n                    options = value;\n                    value = options.value;\n                    delete options.value;\n                    if (typeof value !== \"string\" && value !== undefined && value !== null) {\n                        if (err) return [\n                            Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)\n                        ];\n                    }\n                    options = {\n                        ...this.options,\n                        ...options\n                    };\n                    [err, options] = normalize_options(options);\n                    if (err !== undefined) {\n                        return [\n                            err\n                        ];\n                    }\n                } else if (value === undefined || value === null) {\n                    options = this.options;\n                } else {\n                    return [\n                        Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)\n                    ];\n                }\n                const { delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter, escape_formulas } = options;\n                if (\"\" === value && \"\" === field) {\n                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{\n                        if (typeof quoted_match === \"string\") {\n                            return value.indexOf(quoted_match) !== -1;\n                        } else {\n                            return quoted_match.test(value);\n                        }\n                    });\n                    quotedMatch = quotedMatch && quotedMatch.length > 0;\n                    const shouldQuote = quotedMatch || true === quoted_empty || true === quoted_string && false !== quoted_empty;\n                    if (shouldQuote === true) {\n                        value = quote + value + quote;\n                    }\n                    csvrecord += value;\n                } else if (value) {\n                    if (typeof value !== \"string\") {\n                        return [\n                            Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)\n                        ];\n                    }\n                    const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;\n                    const containsQuote = quote !== \"\" && value.indexOf(quote) >= 0;\n                    const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n                    const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n                    const quotedString = quoted_string && typeof field === \"string\";\n                    let quotedMatch = quoted_match && quoted_match.filter((quoted_match)=>{\n                        if (typeof quoted_match === \"string\") {\n                            return value.indexOf(quoted_match) !== -1;\n                        } else {\n                            return quoted_match.test(value);\n                        }\n                    });\n                    quotedMatch = quotedMatch && quotedMatch.length > 0;\n                    // See https://github.com/adaltas/node-csv/pull/387\n                    // More about CSV injection or formula injection, when websites embed\n                    // untrusted input inside CSV files:\n                    // https://owasp.org/www-community/attacks/CSV_Injection\n                    // http://georgemauer.net/2017/10/07/csv-injection.html\n                    // Apple Numbers unicode normalization is empirical from testing\n                    if (escape_formulas) {\n                        switch(value[0]){\n                            case \"=\":\n                            case \"+\":\n                            case \"-\":\n                            case \"@\":\n                            case \"\t\":\n                            case \"\\r\":\n                            case \"＝\":\n                            case \"＋\":\n                            case \"－\":\n                            case \"＠\":\n                                value = `'${value}`;\n                                break;\n                        }\n                    }\n                    const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;\n                    if (shouldQuote === true && containsEscape === true) {\n                        const regexp = escape === \"\\\\\" ? new RegExp(escape + escape, \"g\") : new RegExp(escape, \"g\");\n                        value = value.replace(regexp, escape + escape);\n                    }\n                    if (containsQuote === true) {\n                        const regexp = new RegExp(quote, \"g\");\n                        value = value.replace(regexp, escape + quote);\n                    }\n                    if (shouldQuote === true) {\n                        value = quote + value + quote;\n                    }\n                    csvrecord += value;\n                } else if (quoted_empty === true || field === \"\" && quoted_string === true && quoted_empty !== false) {\n                    csvrecord += quote + quote;\n                }\n                if (i !== record.length - 1) {\n                    csvrecord += delimiter;\n                }\n            }\n            return [\n                undefined,\n                csvrecord\n            ];\n        },\n        bom: function(push) {\n            if (this.options.bom !== true) {\n                return;\n            }\n            push(bom_utf8);\n        },\n        headers: function(push) {\n            if (this.options.header === false) {\n                return;\n            }\n            if (this.options.columns === undefined) {\n                return;\n            }\n            let err;\n            let headers = this.options.columns.map((column)=>column.header);\n            if (this.options.eof) {\n                [err, headers] = this.stringify(headers, true);\n                headers += this.options.record_delimiter;\n            } else {\n                [err, headers] = this.stringify(headers);\n            }\n            if (err) return err;\n            push(headers);\n        },\n        __cast: function(value, context) {\n            const type = typeof value;\n            try {\n                if (type === \"string\") {\n                    // Fine for 99% of the cases\n                    return [\n                        undefined,\n                        this.options.cast.string(value, context)\n                    ];\n                } else if (type === \"bigint\") {\n                    return [\n                        undefined,\n                        this.options.cast.bigint(value, context)\n                    ];\n                } else if (type === \"number\") {\n                    return [\n                        undefined,\n                        this.options.cast.number(value, context)\n                    ];\n                } else if (type === \"boolean\") {\n                    return [\n                        undefined,\n                        this.options.cast.boolean(value, context)\n                    ];\n                } else if (value instanceof Date) {\n                    return [\n                        undefined,\n                        this.options.cast.date(value, context)\n                    ];\n                } else if (type === \"object\" && value !== null) {\n                    return [\n                        undefined,\n                        this.options.cast.object(value, context)\n                    ];\n                } else {\n                    return [\n                        undefined,\n                        value,\n                        value\n                    ];\n                }\n            } catch (err) {\n                return [\n                    err\n                ];\n            }\n        }\n    };\n};\nconst stringify = function(records, opts = {}) {\n    const data = [];\n    const [err, options] = normalize_options(opts);\n    if (err !== undefined) throw err;\n    const state = {\n        stop: false\n    };\n    // Information\n    const info = {\n        records: 0\n    };\n    const api = stringifier(options, state, info);\n    for (const record of records){\n        const err = api.__transform(record, function(record) {\n            data.push(record);\n        });\n        if (err !== undefined) throw err;\n    }\n    if (data.length === 0) {\n        api.bom((d)=>{\n            data.push(d);\n        });\n        const err = api.headers((headers)=>{\n            data.push(headers);\n        });\n        if (err !== undefined) throw err;\n    }\n    return data.join(\"\");\n};\nvar getNative = _getNative;\nvar defineProperty$2 = function() {\n    try {\n        var func = getNative(Object, \"defineProperty\");\n        func({}, \"\", {});\n        return func;\n    } catch (e) {}\n}();\nvar _defineProperty = defineProperty$2;\nvar defineProperty$1 = _defineProperty;\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function baseAssignValue$6(object, key, value) {\n    if (key == \"__proto__\" && defineProperty$1) {\n        defineProperty$1(object, key, {\n            \"configurable\": true,\n            \"enumerable\": true,\n            \"value\": value,\n            \"writable\": true\n        });\n    } else {\n        object[key] = value;\n    }\n}\nvar _baseAssignValue = baseAssignValue$6;\nvar baseAssignValue$5 = _baseAssignValue, baseForOwn$1 = _baseForOwn, baseIteratee$3 = _baseIteratee;\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */ function mapValues(object, iteratee) {\n    var result = {};\n    iteratee = baseIteratee$3(iteratee);\n    baseForOwn$1(object, function(value, key, object) {\n        baseAssignValue$5(result, key, iteratee(value, key, object));\n    });\n    return result;\n}\nvar mapValues_1 = mapValues;\nvar mapValues$1 = /*@__PURE__*/ getDefaultExportFromCjs(mapValues_1);\nvar baseAssignValue$4 = _baseAssignValue, eq$2 = eq_1;\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function assignMergeValue$2(object, key, value) {\n    if (value !== undefined && !eq$2(object[key], value) || value === undefined && !(key in object)) {\n        baseAssignValue$4(object, key, value);\n    }\n}\nvar _assignMergeValue = assignMergeValue$2;\nvar _cloneBuffer = {\n    exports: {}\n};\n_cloneBuffer.exports;\n(function(module, exports1) {\n    var root = _root;\n    /** Detect free variable `exports`. */ var freeExports = exports1 && !exports1.nodeType && exports1;\n    /** Detect free variable `module`. */ var freeModule = freeExports && \"object\" == \"object\" && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n    /**\n\t * Creates a clone of  `buffer`.\n\t *\n\t * @private\n\t * @param {Buffer} buffer The buffer to clone.\n\t * @param {boolean} [isDeep] Specify a deep clone.\n\t * @returns {Buffer} Returns the cloned buffer.\n\t */ function cloneBuffer(buffer, isDeep) {\n        if (isDeep) {\n            return buffer.slice();\n        }\n        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n        buffer.copy(result);\n        return result;\n    }\n    module.exports = cloneBuffer;\n})(_cloneBuffer, _cloneBuffer.exports);\nvar _cloneBufferExports = _cloneBuffer.exports;\nvar Uint8Array$1 = _Uint8Array;\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */ function cloneArrayBuffer$1(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));\n    return result;\n}\nvar _cloneArrayBuffer = cloneArrayBuffer$1;\nvar cloneArrayBuffer = _cloneArrayBuffer;\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */ function cloneTypedArray$1(typedArray, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\nvar _cloneTypedArray = cloneTypedArray$1;\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */ function copyArray$1(source, array) {\n    var index = -1, length = source.length;\n    array || (array = Array(length));\n    while(++index < length){\n        array[index] = source[index];\n    }\n    return array;\n}\nvar _copyArray = copyArray$1;\nvar isObject$4 = isObject_1;\n/** Built-in value references. */ var objectCreate = Object.create;\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */ var baseCreate$1 = function() {\n    function object() {}\n    return function(proto) {\n        if (!isObject$4(proto)) {\n            return {};\n        }\n        if (objectCreate) {\n            return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n    };\n}();\nvar _baseCreate = baseCreate$1;\nvar overArg = _overArg;\n/** Built-in value references. */ var getPrototype$2 = overArg(Object.getPrototypeOf, Object);\nvar _getPrototype = getPrototype$2;\nvar baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype$1 = _isPrototype;\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */ function initCloneObject$1(object) {\n    return typeof object.constructor == \"function\" && !isPrototype$1(object) ? baseCreate(getPrototype$1(object)) : {};\n}\nvar _initCloneObject = initCloneObject$1;\nvar isArrayLike$3 = isArrayLike_1, isObjectLike$1 = isObjectLike_1;\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */ function isArrayLikeObject$1(value) {\n    return isObjectLike$1(value) && isArrayLike$3(value);\n}\nvar isArrayLikeObject_1 = isArrayLikeObject$1;\nvar baseGetTag = _baseGetTag, getPrototype = _getPrototype, isObjectLike = isObjectLike_1;\n/** `Object#toString` result references. */ var objectTag = \"[object Object]\";\n/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto$2 = Object.prototype;\n/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n/** Used to check objects for own properties. */ var hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n/** Used to infer the `Object` constructor. */ var objectCtorString = funcToString.call(Object);\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */ function isPlainObject$1(value) {\n    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n    }\n    var proto = getPrototype(value);\n    if (proto === null) {\n        return true;\n    }\n    var Ctor = hasOwnProperty$2.call(proto, \"constructor\") && proto.constructor;\n    return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n}\nvar isPlainObject_1 = isPlainObject$1;\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */ function safeGet$2(object, key) {\n    if (key === \"constructor\" && typeof object[key] === \"function\") {\n        return;\n    }\n    if (key == \"__proto__\") {\n        return;\n    }\n    return object[key];\n}\nvar _safeGet = safeGet$2;\nvar baseAssignValue$3 = _baseAssignValue, eq$1 = eq_1;\n/** Used for built-in method references. */ var objectProto$1 = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */ function assignValue$1(object, key, value) {\n    var objValue = object[key];\n    if (!(hasOwnProperty$1.call(object, key) && eq$1(objValue, value)) || value === undefined && !(key in object)) {\n        baseAssignValue$3(object, key, value);\n    }\n}\nvar _assignValue = assignValue$1;\nvar assignValue = _assignValue, baseAssignValue$2 = _baseAssignValue;\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */ function copyObject$1(source, props, object, customizer) {\n    var isNew = !object;\n    object || (object = {});\n    var index = -1, length = props.length;\n    while(++index < length){\n        var key = props[index];\n        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;\n        if (newValue === undefined) {\n            newValue = source[key];\n        }\n        if (isNew) {\n            baseAssignValue$2(object, key, newValue);\n        } else {\n            assignValue(object, key, newValue);\n        }\n    }\n    return object;\n}\nvar _copyObject = copyObject$1;\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function nativeKeysIn$1(object) {\n    var result = [];\n    if (object != null) {\n        for(var key in Object(object)){\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _nativeKeysIn = nativeKeysIn$1;\nvar isObject$3 = isObject_1, isPrototype = _isPrototype, nativeKeysIn = _nativeKeysIn;\n/** Used for built-in method references. */ var objectProto = Object.prototype;\n/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */ function baseKeysIn$1(object) {\n    if (!isObject$3(object)) {\n        return nativeKeysIn(object);\n    }\n    var isProto = isPrototype(object), result = [];\n    for(var key in object){\n        if (!(key == \"constructor\" && (isProto || !hasOwnProperty.call(object, key)))) {\n            result.push(key);\n        }\n    }\n    return result;\n}\nvar _baseKeysIn = baseKeysIn$1;\nvar arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$2 = isArrayLike_1;\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */ function keysIn$2(object) {\n    return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\nvar keysIn_1 = keysIn$2;\nvar copyObject = _copyObject, keysIn$1 = keysIn_1;\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */ function toPlainObject$1(value) {\n    return copyObject(value, keysIn$1(value));\n}\nvar toPlainObject_1 = toPlainObject$1;\nvar assignMergeValue$1 = _assignMergeValue, cloneBuffer = _cloneBufferExports, cloneTypedArray = _cloneTypedArray, copyArray = _copyArray, initCloneObject = _initCloneObject, isArguments$1 = isArguments_1, isArray$3 = isArray_1, isArrayLikeObject = isArrayLikeObject_1, isBuffer = isBufferExports, isFunction = isFunction_1, isObject$2 = isObject_1, isPlainObject = isPlainObject_1, isTypedArray = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */ function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n    var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);\n    if (stacked) {\n        assignMergeValue$1(object, key, stacked);\n        return;\n    }\n    var newValue = customizer ? customizer(objValue, srcValue, key + \"\", object, source, stack) : undefined;\n    var isCommon = newValue === undefined;\n    if (isCommon) {\n        var isArr = isArray$3(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n            if (isArray$3(objValue)) {\n                newValue = objValue;\n            } else if (isArrayLikeObject(objValue)) {\n                newValue = copyArray(objValue);\n            } else if (isBuff) {\n                isCommon = false;\n                newValue = cloneBuffer(srcValue, true);\n            } else if (isTyped) {\n                isCommon = false;\n                newValue = cloneTypedArray(srcValue, true);\n            } else {\n                newValue = [];\n            }\n        } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {\n            newValue = objValue;\n            if (isArguments$1(objValue)) {\n                newValue = toPlainObject(objValue);\n            } else if (!isObject$2(objValue) || isFunction(objValue)) {\n                newValue = initCloneObject(srcValue);\n            }\n        } else {\n            isCommon = false;\n        }\n    }\n    if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack[\"delete\"](srcValue);\n    }\n    assignMergeValue$1(object, key, newValue);\n}\nvar _baseMergeDeep = baseMergeDeep$1;\nvar Stack = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$1 = isObject_1, keysIn = keysIn_1, safeGet = _safeGet;\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */ function baseMerge$2(object, source, srcIndex, customizer, stack) {\n    if (object === source) {\n        return;\n    }\n    baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject$1(srcValue)) {\n            baseMergeDeep(object, source, key, srcIndex, baseMerge$2, customizer, stack);\n        } else {\n            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + \"\", object, source, stack) : undefined;\n            if (newValue === undefined) {\n                newValue = srcValue;\n            }\n            assignMergeValue(object, key, newValue);\n        }\n    }, keysIn);\n}\nvar _baseMerge = baseMerge$2;\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */ function apply$1(func, thisArg, args) {\n    switch(args.length){\n        case 0:\n            return func.call(thisArg);\n        case 1:\n            return func.call(thisArg, args[0]);\n        case 2:\n            return func.call(thisArg, args[0], args[1]);\n        case 3:\n            return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n}\nvar _apply = apply$1;\nvar apply = _apply;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */ function overRest$1(func, start, transform) {\n    start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n    return function() {\n        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);\n        while(++index < length){\n            array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while(++index < start){\n            otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n    };\n}\nvar _overRest = overRest$1;\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */ function constant$1(value) {\n    return function() {\n        return value;\n    };\n}\nvar constant_1 = constant$1;\nvar constant = constant_1, defineProperty = _defineProperty, identity$2 = identity_1;\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */ var baseSetToString$1 = !defineProperty ? identity$2 : function(func, string) {\n    return defineProperty(func, \"toString\", {\n        \"configurable\": true,\n        \"enumerable\": false,\n        \"value\": constant(string),\n        \"writable\": true\n    });\n};\nvar _baseSetToString = baseSetToString$1;\n/** Used to detect hot functions by number of calls within a span of milliseconds. */ var HOT_COUNT = 800, HOT_SPAN = 16;\n/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeNow = Date.now;\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */ function shortOut$1(func) {\n    var count = 0, lastCalled = 0;\n    return function() {\n        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n        lastCalled = stamp;\n        if (remaining > 0) {\n            if (++count >= HOT_COUNT) {\n                return arguments[0];\n            }\n        } else {\n            count = 0;\n        }\n        return func.apply(undefined, arguments);\n    };\n}\nvar _shortOut = shortOut$1;\nvar baseSetToString = _baseSetToString, shortOut = _shortOut;\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */ var setToString$1 = shortOut(baseSetToString);\nvar _setToString = setToString$1;\nvar identity$1 = identity_1, overRest = _overRest, setToString = _setToString;\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */ function baseRest$2(func, start) {\n    return setToString(overRest(func, start, identity$1), func + \"\");\n}\nvar _baseRest = baseRest$2;\nvar eq = eq_1, isArrayLike$1 = isArrayLike_1, isIndex = _isIndex, isObject = isObject_1;\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */ function isIterateeCall$2(value, index, object) {\n    if (!isObject(object)) {\n        return false;\n    }\n    var type = typeof index;\n    if (type == \"number\" ? isArrayLike$1(object) && isIndex(index, object.length) : type == \"string\" && index in object) {\n        return eq(object[index], value);\n    }\n    return false;\n}\nvar _isIterateeCall = isIterateeCall$2;\nvar baseRest$1 = _baseRest, isIterateeCall$1 = _isIterateeCall;\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */ function createAssigner$2(assigner) {\n    return baseRest$1(function(object, sources) {\n        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;\n        customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : undefined;\n        if (guard && isIterateeCall$1(sources[0], sources[1], guard)) {\n            customizer = length < 3 ? undefined : customizer;\n            length = 1;\n        }\n        object = Object(object);\n        while(++index < length){\n            var source = sources[index];\n            if (source) {\n                assigner(object, source, index, customizer);\n            }\n        }\n        return object;\n    });\n}\nvar _createAssigner = createAssigner$2;\nvar baseMerge$1 = _baseMerge, createAssigner$1 = _createAssigner;\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */ var merge = createAssigner$1(function(object, source, srcIndex) {\n    baseMerge$1(object, source, srcIndex);\n});\nvar merge_1 = merge;\nvar merge$1 = /*@__PURE__*/ getDefaultExportFromCjs(merge_1);\nvar baseMerge = _baseMerge, createAssigner = _createAssigner;\n/**\n * This method is like `_.merge` except that it accepts `customizer` which\n * is invoked to produce the merged values of the destination and source\n * properties. If `customizer` returns `undefined`, merging is handled by the\n * method instead. The `customizer` is invoked with six arguments:\n * (objValue, srcValue, key, object, source, stack).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   if (_.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * }\n *\n * var object = { 'a': [1], 'b': [2] };\n * var other = { 'a': [3], 'b': [4] };\n *\n * _.mergeWith(object, other, customizer);\n * // => { 'a': [1, 3], 'b': [2, 4] }\n */ var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n    baseMerge(object, source, srcIndex, customizer);\n});\nvar mergeWith_1 = mergeWith;\nvar mergeWith$1 = /*@__PURE__*/ getDefaultExportFromCjs(mergeWith_1);\nvar baseAssignValue$1 = _baseAssignValue, baseForOwn = _baseForOwn, baseIteratee$2 = _baseIteratee;\n/**\n * The opposite of `_.mapValues`; this method creates an object with the\n * same values as `object` and keys generated by running each own enumerable\n * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n * with three arguments: (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 3.8.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapValues\n * @example\n *\n * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n *   return key + value;\n * });\n * // => { 'a1': 1, 'b2': 2 }\n */ function mapKeys(object, iteratee) {\n    var result = {};\n    iteratee = baseIteratee$2(iteratee);\n    baseForOwn(object, function(value, key, object) {\n        baseAssignValue$1(result, iteratee(value, key, object), value);\n    });\n    return result;\n}\nvar mapKeys_1 = mapKeys;\nvar mapKeys$1 = /*@__PURE__*/ getDefaultExportFromCjs(mapKeys_1);\n/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */ function basePropertyOf$1(object) {\n    return function(key) {\n        return object == null ? undefined : object[key];\n    };\n}\nvar _basePropertyOf = basePropertyOf$1;\nvar basePropertyOf = _basePropertyOf;\n/** Used to map Latin Unicode letters to basic Latin letters. */ var deburredLetters = {\n    // Latin-1 Supplement block.\n    \"\\xc0\": \"A\",\n    \"\\xc1\": \"A\",\n    \"\\xc2\": \"A\",\n    \"\\xc3\": \"A\",\n    \"\\xc4\": \"A\",\n    \"\\xc5\": \"A\",\n    \"\\xe0\": \"a\",\n    \"\\xe1\": \"a\",\n    \"\\xe2\": \"a\",\n    \"\\xe3\": \"a\",\n    \"\\xe4\": \"a\",\n    \"\\xe5\": \"a\",\n    \"\\xc7\": \"C\",\n    \"\\xe7\": \"c\",\n    \"\\xd0\": \"D\",\n    \"\\xf0\": \"d\",\n    \"\\xc8\": \"E\",\n    \"\\xc9\": \"E\",\n    \"\\xca\": \"E\",\n    \"\\xcb\": \"E\",\n    \"\\xe8\": \"e\",\n    \"\\xe9\": \"e\",\n    \"\\xea\": \"e\",\n    \"\\xeb\": \"e\",\n    \"\\xcc\": \"I\",\n    \"\\xcd\": \"I\",\n    \"\\xce\": \"I\",\n    \"\\xcf\": \"I\",\n    \"\\xec\": \"i\",\n    \"\\xed\": \"i\",\n    \"\\xee\": \"i\",\n    \"\\xef\": \"i\",\n    \"\\xd1\": \"N\",\n    \"\\xf1\": \"n\",\n    \"\\xd2\": \"O\",\n    \"\\xd3\": \"O\",\n    \"\\xd4\": \"O\",\n    \"\\xd5\": \"O\",\n    \"\\xd6\": \"O\",\n    \"\\xd8\": \"O\",\n    \"\\xf2\": \"o\",\n    \"\\xf3\": \"o\",\n    \"\\xf4\": \"o\",\n    \"\\xf5\": \"o\",\n    \"\\xf6\": \"o\",\n    \"\\xf8\": \"o\",\n    \"\\xd9\": \"U\",\n    \"\\xda\": \"U\",\n    \"\\xdb\": \"U\",\n    \"\\xdc\": \"U\",\n    \"\\xf9\": \"u\",\n    \"\\xfa\": \"u\",\n    \"\\xfb\": \"u\",\n    \"\\xfc\": \"u\",\n    \"\\xdd\": \"Y\",\n    \"\\xfd\": \"y\",\n    \"\\xff\": \"y\",\n    \"\\xc6\": \"Ae\",\n    \"\\xe6\": \"ae\",\n    \"\\xde\": \"Th\",\n    \"\\xfe\": \"th\",\n    \"\\xdf\": \"ss\",\n    // Latin Extended-A block.\n    \"Ā\": \"A\",\n    \"Ă\": \"A\",\n    \"Ą\": \"A\",\n    \"ā\": \"a\",\n    \"ă\": \"a\",\n    \"ą\": \"a\",\n    \"Ć\": \"C\",\n    \"Ĉ\": \"C\",\n    \"Ċ\": \"C\",\n    \"Č\": \"C\",\n    \"ć\": \"c\",\n    \"ĉ\": \"c\",\n    \"ċ\": \"c\",\n    \"č\": \"c\",\n    \"Ď\": \"D\",\n    \"Đ\": \"D\",\n    \"ď\": \"d\",\n    \"đ\": \"d\",\n    \"Ē\": \"E\",\n    \"Ĕ\": \"E\",\n    \"Ė\": \"E\",\n    \"Ę\": \"E\",\n    \"Ě\": \"E\",\n    \"ē\": \"e\",\n    \"ĕ\": \"e\",\n    \"ė\": \"e\",\n    \"ę\": \"e\",\n    \"ě\": \"e\",\n    \"Ĝ\": \"G\",\n    \"Ğ\": \"G\",\n    \"Ġ\": \"G\",\n    \"Ģ\": \"G\",\n    \"ĝ\": \"g\",\n    \"ğ\": \"g\",\n    \"ġ\": \"g\",\n    \"ģ\": \"g\",\n    \"Ĥ\": \"H\",\n    \"Ħ\": \"H\",\n    \"ĥ\": \"h\",\n    \"ħ\": \"h\",\n    \"Ĩ\": \"I\",\n    \"Ī\": \"I\",\n    \"Ĭ\": \"I\",\n    \"Į\": \"I\",\n    \"İ\": \"I\",\n    \"ĩ\": \"i\",\n    \"ī\": \"i\",\n    \"ĭ\": \"i\",\n    \"į\": \"i\",\n    \"ı\": \"i\",\n    \"Ĵ\": \"J\",\n    \"ĵ\": \"j\",\n    \"Ķ\": \"K\",\n    \"ķ\": \"k\",\n    \"ĸ\": \"k\",\n    \"Ĺ\": \"L\",\n    \"Ļ\": \"L\",\n    \"Ľ\": \"L\",\n    \"Ŀ\": \"L\",\n    \"Ł\": \"L\",\n    \"ĺ\": \"l\",\n    \"ļ\": \"l\",\n    \"ľ\": \"l\",\n    \"ŀ\": \"l\",\n    \"ł\": \"l\",\n    \"Ń\": \"N\",\n    \"Ņ\": \"N\",\n    \"Ň\": \"N\",\n    \"Ŋ\": \"N\",\n    \"ń\": \"n\",\n    \"ņ\": \"n\",\n    \"ň\": \"n\",\n    \"ŋ\": \"n\",\n    \"Ō\": \"O\",\n    \"Ŏ\": \"O\",\n    \"Ő\": \"O\",\n    \"ō\": \"o\",\n    \"ŏ\": \"o\",\n    \"ő\": \"o\",\n    \"Ŕ\": \"R\",\n    \"Ŗ\": \"R\",\n    \"Ř\": \"R\",\n    \"ŕ\": \"r\",\n    \"ŗ\": \"r\",\n    \"ř\": \"r\",\n    \"Ś\": \"S\",\n    \"Ŝ\": \"S\",\n    \"Ş\": \"S\",\n    \"Š\": \"S\",\n    \"ś\": \"s\",\n    \"ŝ\": \"s\",\n    \"ş\": \"s\",\n    \"š\": \"s\",\n    \"Ţ\": \"T\",\n    \"Ť\": \"T\",\n    \"Ŧ\": \"T\",\n    \"ţ\": \"t\",\n    \"ť\": \"t\",\n    \"ŧ\": \"t\",\n    \"Ũ\": \"U\",\n    \"Ū\": \"U\",\n    \"Ŭ\": \"U\",\n    \"Ů\": \"U\",\n    \"Ű\": \"U\",\n    \"Ų\": \"U\",\n    \"ũ\": \"u\",\n    \"ū\": \"u\",\n    \"ŭ\": \"u\",\n    \"ů\": \"u\",\n    \"ű\": \"u\",\n    \"ų\": \"u\",\n    \"Ŵ\": \"W\",\n    \"ŵ\": \"w\",\n    \"Ŷ\": \"Y\",\n    \"ŷ\": \"y\",\n    \"Ÿ\": \"Y\",\n    \"Ź\": \"Z\",\n    \"Ż\": \"Z\",\n    \"Ž\": \"Z\",\n    \"ź\": \"z\",\n    \"ż\": \"z\",\n    \"ž\": \"z\",\n    \"Ĳ\": \"IJ\",\n    \"ĳ\": \"ij\",\n    \"Œ\": \"Oe\",\n    \"œ\": \"oe\",\n    \"ŉ\": \"'n\",\n    \"ſ\": \"s\"\n};\n/**\n * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n * letters to basic Latin letters.\n *\n * @private\n * @param {string} letter The matched letter to deburr.\n * @returns {string} Returns the deburred letter.\n */ var deburrLetter$1 = basePropertyOf(deburredLetters);\nvar _deburrLetter = deburrLetter$1;\nvar deburrLetter = _deburrLetter, toString$2 = toString_1;\n/** Used to match Latin Unicode letters (excluding mathematical operators). */ var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n/** Used to compose unicode character classes. */ var rsComboMarksRange$3 = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange$3 = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange$3 = \"\\\\u20d0-\\\\u20ff\", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;\n/** Used to compose unicode capture groups. */ var rsCombo$2 = \"[\" + rsComboRange$3 + \"]\";\n/**\n * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n */ var reComboMark = RegExp(rsCombo$2, \"g\");\n/**\n * Deburrs `string` by converting\n * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n * letters to basic Latin letters and removing\n * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to deburr.\n * @returns {string} Returns the deburred string.\n * @example\n *\n * _.deburr('déjà vu');\n * // => 'deja vu'\n */ function deburr$1(string) {\n    string = toString$2(string);\n    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, \"\");\n}\nvar deburr_1 = deburr$1;\n/** Used to match words composed of alphanumeric characters. */ var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n/**\n * Splits an ASCII `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */ function asciiWords$1(string) {\n    return string.match(reAsciiWord) || [];\n}\nvar _asciiWords = asciiWords$1;\n/** Used to detect strings that need a more robust regexp to match words. */ var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n/**\n * Checks if `string` contains a word composed of Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a word is found, else `false`.\n */ function hasUnicodeWord$1(string) {\n    return reHasUnicodeWord.test(string);\n}\nvar _hasUnicodeWord = hasUnicodeWord$1;\n/** Used to compose unicode character classes. */ var rsAstralRange$2 = \"\\ud800-\\udfff\", rsComboMarksRange$2 = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange$2 = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange$2 = \"\\\\u20d0-\\\\u20ff\", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsDingbatRange = \"\\\\u2700-\\\\u27bf\", rsLowerRange = \"a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff\", rsMathOpRange = \"\\\\xac\\\\xb1\\\\xd7\\\\xf7\", rsNonCharRange = \"\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\", rsPunctuationRange = \"\\\\u2000-\\\\u206f\", rsSpaceRange = \" \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\", rsUpperRange = \"A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\", rsVarRange$2 = \"\\\\ufe0e\\\\ufe0f\", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n/** Used to compose unicode capture groups. */ var rsApos$1 = \"['’]\", rsBreak = \"[\" + rsBreakRange + \"]\", rsCombo$1 = \"[\" + rsComboRange$2 + \"]\", rsDigits = \"\\\\d+\", rsDingbat = \"[\" + rsDingbatRange + \"]\", rsLower = \"[\" + rsLowerRange + \"]\", rsMisc = \"[^\" + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + \"]\", rsFitz$1 = \"\\ud83c[\\udffb-\\udfff]\", rsModifier$1 = \"(?:\" + rsCombo$1 + \"|\" + rsFitz$1 + \")\", rsNonAstral$1 = \"[^\" + rsAstralRange$2 + \"]\", rsRegional$1 = \"(?:\\ud83c[\\udde6-\\uddff]){2}\", rsSurrPair$1 = \"[\\ud800-\\udbff][\\udc00-\\udfff]\", rsUpper = \"[\" + rsUpperRange + \"]\", rsZWJ$2 = \"\\\\u200d\";\n/** Used to compose unicode regexes. */ var rsMiscLower = \"(?:\" + rsLower + \"|\" + rsMisc + \")\", rsMiscUpper = \"(?:\" + rsUpper + \"|\" + rsMisc + \")\", rsOptContrLower = \"(?:\" + rsApos$1 + \"(?:d|ll|m|re|s|t|ve))?\", rsOptContrUpper = \"(?:\" + rsApos$1 + \"(?:D|LL|M|RE|S|T|VE))?\", reOptMod$1 = rsModifier$1 + \"?\", rsOptVar$1 = \"[\" + rsVarRange$2 + \"]?\", rsOptJoin$1 = \"(?:\" + rsZWJ$2 + \"(?:\" + [\n    rsNonAstral$1,\n    rsRegional$1,\n    rsSurrPair$1\n].join(\"|\") + \")\" + rsOptVar$1 + reOptMod$1 + \")*\", rsOrdLower = \"\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])\", rsOrdUpper = \"\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])\", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsEmoji = \"(?:\" + [\n    rsDingbat,\n    rsRegional$1,\n    rsSurrPair$1\n].join(\"|\") + \")\" + rsSeq$1;\n/** Used to match complex or compound words. */ var reUnicodeWord = RegExp([\n    rsUpper + \"?\" + rsLower + \"+\" + rsOptContrLower + \"(?=\" + [\n        rsBreak,\n        rsUpper,\n        \"$\"\n    ].join(\"|\") + \")\",\n    rsMiscUpper + \"+\" + rsOptContrUpper + \"(?=\" + [\n        rsBreak,\n        rsUpper + rsMiscLower,\n        \"$\"\n    ].join(\"|\") + \")\",\n    rsUpper + \"?\" + rsMiscLower + \"+\" + rsOptContrLower,\n    rsUpper + \"+\" + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n].join(\"|\"), \"g\");\n/**\n * Splits a Unicode `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */ function unicodeWords$1(string) {\n    return string.match(reUnicodeWord) || [];\n}\nvar _unicodeWords = unicodeWords$1;\nvar asciiWords = _asciiWords, hasUnicodeWord = _hasUnicodeWord, toString$1 = toString_1, unicodeWords = _unicodeWords;\n/**\n * Splits `string` into an array of its words.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {RegExp|string} [pattern] The pattern to match words.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the words of `string`.\n * @example\n *\n * _.words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * _.words('fred, barney, & pebbles', /[^, ]+/g);\n * // => ['fred', 'barney', '&', 'pebbles']\n */ function words$1(string, pattern, guard) {\n    string = toString$1(string);\n    pattern = guard ? undefined : pattern;\n    if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n    }\n    return string.match(pattern) || [];\n}\nvar words_1 = words$1;\nvar arrayReduce = _arrayReduce, deburr = deburr_1, words = words_1;\n/** Used to compose unicode capture groups. */ var rsApos = \"['’]\";\n/** Used to match apostrophes. */ var reApos = RegExp(rsApos, \"g\");\n/**\n * Creates a function like `_.camelCase`.\n *\n * @private\n * @param {Function} callback The function to combine each word.\n * @returns {Function} Returns the new compounder function.\n */ function createCompounder$1(callback) {\n    return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, \"\")), callback, \"\");\n    };\n}\nvar _createCompounder = createCompounder$1;\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */ function baseSlice$1(array, start, end) {\n    var index = -1, length = array.length;\n    if (start < 0) {\n        start = -start > length ? 0 : length + start;\n    }\n    end = end > length ? length : end;\n    if (end < 0) {\n        end += length;\n    }\n    length = start > end ? 0 : end - start >>> 0;\n    start >>>= 0;\n    var result = Array(length);\n    while(++index < length){\n        result[index] = array[index + start];\n    }\n    return result;\n}\nvar _baseSlice = baseSlice$1;\nvar baseSlice = _baseSlice;\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */ function castSlice$1(array, start, end) {\n    var length = array.length;\n    end = end === undefined ? length : end;\n    return !start && end >= length ? array : baseSlice(array, start, end);\n}\nvar _castSlice = castSlice$1;\n/** Used to compose unicode character classes. */ var rsAstralRange$1 = \"\\ud800-\\udfff\", rsComboMarksRange$1 = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange$1 = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange$1 = \"\\\\u20d0-\\\\u20ff\", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */ var rsZWJ$1 = \"\\\\u200d\";\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */ var reHasUnicode = RegExp(\"[\" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + \"]\");\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */ function hasUnicode$2(string) {\n    return reHasUnicode.test(string);\n}\nvar _hasUnicode = hasUnicode$2;\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function asciiToArray$1(string) {\n    return string.split(\"\");\n}\nvar _asciiToArray = asciiToArray$1;\n/** Used to compose unicode character classes. */ var rsAstralRange = \"\\ud800-\\udfff\", rsComboMarksRange = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */ var rsAstral = \"[\" + rsAstralRange + \"]\", rsCombo = \"[\" + rsComboRange + \"]\", rsFitz = \"\\ud83c[\\udffb-\\udfff]\", rsModifier = \"(?:\" + rsCombo + \"|\" + rsFitz + \")\", rsNonAstral = \"[^\" + rsAstralRange + \"]\", rsRegional = \"(?:\\ud83c[\\udde6-\\uddff]){2}\", rsSurrPair = \"[\\ud800-\\udbff][\\udc00-\\udfff]\", rsZWJ = \"\\\\u200d\";\n/** Used to compose unicode regexes. */ var reOptMod = rsModifier + \"?\", rsOptVar = \"[\" + rsVarRange + \"]?\", rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [\n    rsNonAstral,\n    rsRegional,\n    rsSurrPair\n].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = \"(?:\" + [\n    rsNonAstral + rsCombo + \"?\",\n    rsCombo,\n    rsRegional,\n    rsSurrPair,\n    rsAstral\n].join(\"|\") + \")\";\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */ var reUnicode = RegExp(rsFitz + \"(?=\" + rsFitz + \")|\" + rsSymbol + rsSeq, \"g\");\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function unicodeToArray$1(string) {\n    return string.match(reUnicode) || [];\n}\nvar _unicodeToArray = unicodeToArray$1;\nvar asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function stringToArray$1(string) {\n    return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);\n}\nvar _stringToArray = stringToArray$1;\nvar castSlice = _castSlice, hasUnicode = _hasUnicode, stringToArray = _stringToArray, toString = toString_1;\n/**\n * Creates a function like `_.lowerFirst`.\n *\n * @private\n * @param {string} methodName The name of the `String` case method to use.\n * @returns {Function} Returns the new case function.\n */ function createCaseFirst$1(methodName) {\n    return function(string) {\n        string = toString(string);\n        var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;\n        var chr = strSymbols ? strSymbols[0] : string.charAt(0);\n        var trailing = strSymbols ? castSlice(strSymbols, 1).join(\"\") : string.slice(1);\n        return chr[methodName]() + trailing;\n    };\n}\nvar _createCaseFirst = createCaseFirst$1;\nvar createCaseFirst = _createCaseFirst;\n/**\n * Converts the first character of `string` to upper case.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.upperFirst('fred');\n * // => 'Fred'\n *\n * _.upperFirst('FRED');\n * // => 'FRED'\n */ var upperFirst$1 = createCaseFirst(\"toUpperCase\");\nvar upperFirst_1 = upperFirst$1;\nvar createCompounder = _createCompounder, upperFirst = upperFirst_1;\n/**\n * Converts `string` to\n * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n *\n * @static\n * @memberOf _\n * @since 3.1.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the start cased string.\n * @example\n *\n * _.startCase('--foo-bar--');\n * // => 'Foo Bar'\n *\n * _.startCase('fooBar');\n * // => 'Foo Bar'\n *\n * _.startCase('__FOO_BAR__');\n * // => 'FOO BAR'\n */ var startCase = createCompounder(function(result, word, index) {\n    return result + (index ? \" \" : \"\") + upperFirst(word);\n});\nvar startCase_1 = startCase;\nvar startCase$1 = /*@__PURE__*/ getDefaultExportFromCjs(startCase_1);\nvar Symbol$1 = _Symbol, isArguments = isArguments_1, isArray$2 = isArray_1;\n/** Built-in value references. */ var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */ function isFlattenable$1(value) {\n    return isArray$2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\nvar _isFlattenable = isFlattenable$1;\nvar arrayPush = _arrayPush, isFlattenable = _isFlattenable;\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */ function baseFlatten$1(array, depth, predicate, isStrict, result) {\n    var index = -1, length = array.length;\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n    while(++index < length){\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n            if (depth > 1) {\n                // Recursively flatten arrays (susceptible to call stack limits).\n                baseFlatten$1(value, depth - 1, predicate, isStrict, result);\n            } else {\n                arrayPush(result, value);\n            }\n        } else if (!isStrict) {\n            result[result.length] = value;\n        }\n    }\n    return result;\n}\nvar _baseFlatten = baseFlatten$1;\nvar baseEach$1 = _baseEach, isArrayLike = isArrayLike_1;\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */ function baseMap$1(collection, iteratee) {\n    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];\n    baseEach$1(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n    });\n    return result;\n}\nvar _baseMap = baseMap$1;\n/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */ function baseSortBy$1(array, comparer) {\n    var length = array.length;\n    array.sort(comparer);\n    while(length--){\n        array[length] = array[length].value;\n    }\n    return array;\n}\nvar _baseSortBy = baseSortBy$1;\nvar isSymbol = isSymbol_1;\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */ function compareAscending$1(value, other) {\n    if (value !== other) {\n        var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);\n        var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);\n        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\n            return 1;\n        }\n        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\n            return -1;\n        }\n    }\n    return 0;\n}\nvar _compareAscending = compareAscending$1;\nvar compareAscending = _compareAscending;\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */ function compareMultiple$1(object, other, orders) {\n    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;\n    while(++index < length){\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n            if (index >= ordersLength) {\n                return result;\n            }\n            var order = orders[index];\n            return result * (order == \"desc\" ? -1 : 1);\n        }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value for\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    // for more details.\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n    return object.index - other.index;\n}\nvar _compareMultiple = compareMultiple$1;\nvar arrayMap = _arrayMap, baseGet = _baseGet, baseIteratee$1 = _baseIteratee, baseMap = _baseMap, baseSortBy = _baseSortBy, baseUnary = _baseUnary, compareMultiple = _compareMultiple, identity = identity_1, isArray$1 = isArray_1;\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */ function baseOrderBy$1(collection, iteratees, orders) {\n    if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n            if (isArray$1(iteratee)) {\n                return function(value) {\n                    return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n                };\n            }\n            return iteratee;\n        });\n    } else {\n        iteratees = [\n            identity\n        ];\n    }\n    var index = -1;\n    iteratees = arrayMap(iteratees, baseUnary(baseIteratee$1));\n    var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n            return iteratee(value);\n        });\n        return {\n            \"criteria\": criteria,\n            \"index\": ++index,\n            \"value\": value\n        };\n    });\n    return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n    });\n}\nvar _baseOrderBy = baseOrderBy$1;\nvar baseFlatten = _baseFlatten, baseOrderBy = _baseOrderBy, baseRest = _baseRest, isIterateeCall = _isIterateeCall;\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 30 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n */ var sortBy = baseRest(function(collection, iteratees) {\n    if (collection == null) {\n        return [];\n    }\n    var length = iteratees.length;\n    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [\n            iteratees[0]\n        ];\n    }\n    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\nvar sortBy_1 = sortBy;\nvar sortBy$1 = /*@__PURE__*/ getDefaultExportFromCjs(sortBy_1);\nvar baseIsEqual = _baseIsEqual;\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */ function isEqual(value, other) {\n    return baseIsEqual(value, other);\n}\nvar isEqual_1 = isEqual;\nvar isEqual$1 = /*@__PURE__*/ getDefaultExportFromCjs(isEqual_1);\n/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */ function arrayAggregator$1(array, setter, iteratee, accumulator) {\n    var index = -1, length = array == null ? 0 : array.length;\n    while(++index < length){\n        var value = array[index];\n        setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n}\nvar _arrayAggregator = arrayAggregator$1;\nvar baseEach = _baseEach;\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */ function baseAggregator$1(collection, setter, iteratee, accumulator) {\n    baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n    });\n    return accumulator;\n}\nvar _baseAggregator = baseAggregator$1;\nvar arrayAggregator = _arrayAggregator, baseAggregator = _baseAggregator, baseIteratee = _baseIteratee, isArray = isArray_1;\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */ function createAggregator$1(setter, initializer) {\n    return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};\n        return func(collection, setter, baseIteratee(iteratee), accumulator);\n    };\n}\nvar _createAggregator = createAggregator$1;\nvar baseAssignValue = _baseAssignValue, createAggregator = _createAggregator;\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The corresponding value of\n * each key is the last element responsible for generating the key. The\n * iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * var array = [\n *   { 'dir': 'left', 'code': 97 },\n *   { 'dir': 'right', 'code': 100 }\n * ];\n *\n * _.keyBy(array, function(o) {\n *   return String.fromCharCode(o.code);\n * });\n * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n *\n * _.keyBy(array, 'dir');\n * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n */ var keyBy = createAggregator(function(result, value, key) {\n    baseAssignValue(result, key, value);\n});\nvar keyBy_1 = keyBy;\nvar keyBy$1 = /*@__PURE__*/ getDefaultExportFromCjs(keyBy_1);\nconst e = Math.exp(1);\nconst EMAIL_REGEX = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/;\n/**\n * Detects if the current environment is the browser\n *\n * @returns `true` or `false`\n */ const isBrowser = ()=>!!( false && 0);\n/**\n * Merges classNames objects together, key by key\n *\n * @returns a classNames object\n */ const mergeClassNamesDeep = ({ classNames1 = {}, classNames2 = {} })=>{\n    const newClassNames = {};\n    const keys = [\n        ...Object.keys(classNames1 || {}),\n        ...Object.keys(classNames2 || {})\n    ];\n    keys.forEach((key)=>{\n        newClassNames[key] = (0, _classnames.default)(classNames1[key], classNames2[key]);\n    });\n    return newClassNames;\n};\nconst mergeClassNamesFunctionsDeep = ({ classNames1 = {}, classNames2 = {} })=>{\n    const newClassNames = {};\n    const keys = [\n        ...Object.keys(classNames1 || {}),\n        ...Object.keys(classNames2 || {})\n    ];\n    keys.forEach((key)=>{\n        newClassNames[key] = (args)=>(0, _classnames.default)((classNames1[key] || (()=>\"\"))(args), (classNames2[key] || (()=>\"\"))(args));\n    });\n    return newClassNames;\n};\n/** Typing on this function is confusing but does work! */ const removeUndefinedValuesFromObj = (inputObject)=>{\n    const result = {};\n    // eslint-disable-next-line\n    for(const key in inputObject){\n        if (inputObject[key] !== undefined) {\n            result[key] = inputObject[key];\n        }\n    }\n    return result;\n};\n/** Typing on this function is confusing but does work! */ const removeUndefinedAndEmptyStringValuesFromObj = (inputObject)=>{\n    const result = {};\n    // eslint-disable-next-line\n    for(const key in inputObject){\n        if (inputObject[key] !== undefined && inputObject[key] !== \"\") {\n            result[key] = inputObject[key];\n        }\n    }\n    return result;\n};\n/** Typing on this function is confusing but does work! */ const removeUndefinedAndNullValuesFromObj = (inputObject)=>{\n    const result = {};\n    // eslint-disable-next-line\n    for(const key in inputObject){\n        if (inputObject[key] !== undefined && inputObject[key] !== null) {\n            result[key] = inputObject[key];\n        }\n    }\n    return result;\n};\n/**\n * Generates a query string from an object of key value pairs\n *\n * @returns a classNames object\n *\n * @example\n * generateQueryString(\\{ field1: 'value1', field2: 'value2' \\}) =\\> \"?field1=value1&field2=value2\"\n * generateQueryString(\\{ field1: 'value1', field2: 'value2', excludeQuestionMark \\}) =\\> \"field1=value1&field2=value2\"\n */ const generateQueryString = ({ queryParams = {}, excludeQuestionMark = false, excludeEmptyStringValues = false })=>{\n    // The first parameter in a querystring is preceded by a ?\n    // This flag denotes whether we already have one param set in the query string\n    let prefixQuestionMark = !excludeQuestionMark;\n    return reduce$1(excludeEmptyStringValues ? removeUndefinedAndEmptyStringValuesFromObj(queryParams || {}) : removeUndefinedValuesFromObj(queryParams || {}), (acc, field, key)=>{\n        // If the field is falsey then do not append this query param\n        if (field === undefined) {\n            return acc;\n        }\n        if (!prefixQuestionMark) {\n            return `${acc}&${key}=${field}`;\n        }\n        prefixQuestionMark = false;\n        return `${acc}?${key}=${field}`;\n    }, \"\");\n};\n/**\n * Rounds a number to N decimal places (defaults to 2)\n *\n * @returns a rounded number\n */ const roundNumber = (num, decimalPlaces = 2)=>{\n    return +`${Math.round(+`${num}e+${decimalPlaces}`)}e-${decimalPlaces}`;\n};\nconst getNRandomElementsFromArray = (array, n)=>{\n    if (array.length <= n) {\n        return [];\n    }\n    let count = n;\n    const result = new Array(count);\n    let len = array.length;\n    const taken = new Array(len);\n    if (count > len) throw new RangeError(\"getRandom: more elements taken than available\");\n    while(count--){\n        const x = Math.floor(Math.random() * len);\n        result[count] = array[x in taken ? taken[x] : x];\n        taken[x] = --len in taken ? taken[len] : len;\n    }\n    return result;\n};\nconst getRandomElementsFromArray = (array)=>{\n    const elementsCount = Math.floor(Math.random() * array.length) + 1;\n    return getNRandomElementsFromArray(array, elementsCount);\n};\nconst getRandomElementFromArray = (array)=>getNRandomElementsFromArray(array, 1)[0];\n/**\n * Converts an rgba string to a hex color code\n *\n * @returns a hex color code as a string\n */ const RGBAToHexA = (rgba, forceRemoveAlpha = false)=>{\n    const hexColor = rgba.replace(/^rgba?\\(|\\s+|\\)$/g, \"\") // Get's rgba / rgb string values\n    .split(\",\") // splits them by \",\"\n    .filter((str, index)=>!forceRemoveAlpha || index !== 3).map((str)=>parseFloat(str)) // Converts them to numbers\n    .map((number, index)=>index === 3 ? Math.round(number * 255) : number) // Converts alpha to 255 number\n    .map((number)=>number.toString(16)) // Converts numbers to hex\n    .map((str)=>str.length === 1 ? `0${str}` : str) // Adds 0 when length of one number is 1\n    .join(\"\");\n    return `#${hexColor}`;\n};\nconst isTruthyOrZero = (value)=>value !== undefined && value !== null && (!!value || value !== \"\" && Number(value) === 0);\nconst conditionalOrIfTruthyOrZero = (values)=>{\n    const value = values.find((v)=>isTruthyOrZero(v));\n    return value === undefined ? values[values.length - 1] : value;\n};\nconst arrayWithoutElements = ({ array, excludeArray })=>{\n    const toExclude = new Set(excludeArray || []);\n    return (array || []).filter((v)=>!toExclude.has(v));\n};\nconst capitaliseFirstLetter = (text = \"\")=>{\n    return text.charAt(0).toUpperCase() + text.slice(1);\n};\nconst cleanString = (text = \"\")=>{\n    return (text || \"\").trim();\n};\nconst normaliseString = (text = \"\")=>{\n    return cleanString(text).toLowerCase();\n};\nconst parseEnvVariable = (v)=>{\n    if (v === \"false\") {\n        return false;\n    }\n    if (v === \"true\") {\n        return true;\n    }\n    if (v?.[0] === \"$\") {\n        return Number(v.replace(\"$\", \"\"));\n    }\n    return v;\n};\nconst parseEnvVariables = (env)=>mapValues$1(env, (v)=>parseEnvVariable(v));\nconst getNextJSQueryParam = ({ query, id, defaultToEmptyString = false })=>{\n    const returnDefault = defaultToEmptyString ? \"\" : undefined;\n    if (!query) {\n        return returnDefault;\n    }\n    return (Array.isArray(query?.[id]) ? query?.[id]?.[0]?.toString() : query?.[id]?.toString()) || returnDefault;\n};\nconst evaluateTruthyIfNotUndefined = (v)=>{\n    if (v === undefined) {\n        return undefined;\n    }\n    return !!v;\n};\nconst evaluateOneOrZeroBooleanIfNotEmptyString = (v)=>{\n    if (v === \"\") {\n        return undefined;\n    }\n    return v === \"1\";\n};\nconst evaluateOneOrZeroBooleanIfNotUndefined = (v)=>{\n    if (v === undefined) {\n        return undefined;\n    }\n    return v === \"1\";\n};\nconst downloadFromObjectURL = ({ fileName, url })=>{\n    /** Create a link and download from it */ const link = document.createElement(\"a\");\n    link.href = url;\n    link.download = fileName;\n    document.body.appendChild(link);\n    link.click();\n    /** Clear up the element and object url */ URL.revokeObjectURL(url);\n    link.remove();\n};\nconst generateCSV = ({ data, columnHeaderNames = undefined, autoGenerateColumnHeaderNames = true, startCaseForColunmHeaderNames = false })=>{\n    return stringify(startCaseForColunmHeaderNames ? data.map((d)=>d ? mapKeys$1(d, (_v, key)=>startCase$1(key)) : d) : data, {\n        ...autoGenerateColumnHeaderNames || autoGenerateColumnHeaderNames ? {\n            header: true\n        } : {},\n        ...columnHeaderNames ? {\n            columns: columnHeaderNames\n        } : {}\n    });\n};\nconst downloadCSV = ({ csv, fileName })=>{\n    /** Create url to the csv file */ const blob = new Blob([\n        csv\n    ], {\n        type: \"text/csv;charset=utf-8,\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    downloadFromObjectURL({\n        fileName: `${fileName}.csv`,\n        url: blobUrl\n    });\n};\nconst downloadJSON = ({ json, fileName })=>{\n    /** Create url to the json file */ const blob = new Blob([\n        json\n    ], {\n        type: \"text/application/json;charset=utf-8,\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    downloadFromObjectURL({\n        fileName: `${fileName}.json`,\n        url: blobUrl\n    });\n};\nconst getReactQueryStatus = ({ isFetching = false, isLoading = true, isError = false, isSuccess, dataUpdatedAt }, { isReady = false, shouldLoadInitially = true, status })=>{\n    return {\n        isFetching,\n        isLoading: shouldLoadInitially ? !!isLoading || !isError && !isReady : !!isLoading,\n        isError,\n        isSuccess,\n        is401: status === 401,\n        updatedAt: dataUpdatedAt\n    };\n};\nconst sanitiseTextTerm = (textTerm = \"\")=>(textTerm || \"\").trim().toLowerCase();\nconst stringsEqualInsensitive = (str1, str2)=>{\n    if (str1 === undefined || str1 === null) {\n        return false;\n    }\n    return sanitiseTextTerm(str1) === sanitiseTextTerm(str2);\n};\nconst checkIfTextTermMatchesSingle = ({ sourceValue: sourceValueRaw = \"\", inputValue: inputValueRaw = \"\", useFuzzy = true })=>{\n    /** Fuzzysort match minimum threshold. 0 is a perfect match, lower is a worse match */ const FUZZYSORT_MATCH_THRESHOLD = -75;\n    const sourceValue = sanitiseTextTerm(sourceValueRaw);\n    const inputValue = sanitiseTextTerm(inputValueRaw);\n    if (!sourceValue || !inputValue) {\n        return {\n            matches: false,\n            score: -Infinity\n        };\n    }\n    if (sourceValue === inputValue) {\n        return {\n            matches: true,\n            score: 0\n        };\n    }\n    if (useFuzzy) {\n        let score = _fuzzysort.default.single(inputValue, sourceValue)?.score;\n        if (score === undefined || score === null) {\n            score = -Infinity;\n        }\n        if (sourceValue.includes(inputValue) || score > FUZZYSORT_MATCH_THRESHOLD) {\n            return {\n                matches: true,\n                score\n            };\n        }\n    }\n    return {\n        matches: false,\n        score: -Infinity\n    };\n};\nconst checkIfTextTermMatchesArray = ({ inputValue, array, useFuzzy = true })=>{\n    if ((inputValue || \"\").trim()) {\n        for(let arrayIndex = 0; arrayIndex < array.length; arrayIndex++){\n            const value = array[arrayIndex];\n            if ((value || \"\").trim()) {\n                if (checkIfTextTermMatchesSingle({\n                    sourceValue: value,\n                    inputValue,\n                    useFuzzy\n                }).matches) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    return true;\n};\nconst createCustomKey = (keys)=>keys.reduce((key, currentKey)=>{\n        const compositeKeyIsTruthy = isTruthyOrZero(key);\n        const currentKeyIsTruthy = isTruthyOrZero(currentKey);\n        return `${key}${compositeKeyIsTruthy ? \"|\" : \"\"}${currentKeyIsTruthy ? currentKey : \"\"}`;\n    }, \"\");\nconst createCustomKeyFromObject = (obj, options = {})=>{\n    const { keyValueSeparator, separator } = options;\n    const kvSep = keyValueSeparator || \":\";\n    const sep = separator || \"|\";\n    return sortBy$1(Object.entries(removeUndefinedValuesFromObj(obj)), ([k, v])=>`${k}:${v}`).reduce((key, [currentKey, currentValue])=>{\n        const shouldExcludeValue = !currentKey || currentValue === \"\" || isArray$f(currentValue) && !currentValue?.length;\n        const valueIsObject = isObject$9(currentValue);\n        const valueIsArray = isArray$f(currentValue);\n        const valueNeedsTransforming = valueIsArray || valueIsObject;\n        let value = currentValue;\n        if (valueNeedsTransforming) {\n            if (valueIsArray) {\n                value = currentValue.join(\",\");\n            } else if (valueIsObject) {\n                value = createCustomKeyFromObject(currentValue, options);\n            }\n        }\n        if (!shouldExcludeValue) {\n            return key === \"\" ? `${currentKey}${kvSep}${value}` : `${key}${sep}${currentKey}${kvSep}${value}`;\n        }\n        return key;\n    }, \"\");\n};\nconst createCustomFileNameKeyFromObject = (obj)=>createCustomKeyFromObject(mapValues$1(obj, (v)=>{\n        if (v === true || v === \"true\") {\n            return \"1\";\n        }\n        if (v === false || v === \"false\") {\n            return \"0\";\n        }\n        return v;\n    }), {\n        separator: \"_\",\n        keyValueSeparator: \"=\"\n    });\nconst createCustomKeyFromSrcTgt = ({ srcID, tgtID })=>createCustomKey([\n        srcID,\n        tgtID\n    ]);\nconst isEmail = (v)=>!!(!!v && typeof v === \"string\" && v.length && EMAIL_REGEX.test(v));\nconst sleep = (ms)=>{\n    return new Promise((resolve)=>{\n        setTimeout(resolve, ms);\n    });\n};\nconst mergeObject = (...params)=>merge$1({}, ...params);\nconst mergeObjectReplacingArrays = (...params)=>mergeWith$1({}, ...params, (_a, b)=>isArray$f(b) ? b : undefined);\nconst log = (n, base = e)=>{\n    return Math.log(n) / (base ? Math.log(base) : 1);\n};\nconst antilog = (n, base = e)=>{\n    if (base === e) return Math.exp(n);\n    return base ** n;\n};\nconst openUrlInNewTab = (url)=>{\n    if (isBrowser()) {\n        window.open(url, \"_blank\")?.focus();\n    }\n};\nconst isEqualIgnoringOrder = (a, b)=>{\n    if (isArray$f(a) && isArray$f(b)) {\n        return isEqual$1(sortBy$1(a, [\n            (v)=>v\n        ]), sortBy$1(b, [\n            (v)=>v\n        ]));\n    }\n    return isEqual$1(a, b);\n};\nconst clampValue = ({ min, max, value })=>{\n    if (value === undefined) {\n        return min;\n    }\n    if (value <= min) {\n        return min;\n    }\n    if (value >= max) {\n        return max;\n    }\n    return value;\n};\nconst keyByWithUndefined = (collection, iteratee)=>{\n    return collection ? keyBy$1(collection, iteratee) : {};\n};\nconst getRandomNumber = (min, max)=>{\n    const range = max - min;\n    const distanceThroughRange = Math.random() * range;\n    return min + distanceThroughRange;\n};\nconst getRandomInteger = (min, max)=>{\n    const randomNumber = getRandomNumber(min, max);\n    const roundedDown = Math.floor(randomNumber);\n    const roundedUp = Math.ceil(randomNumber);\n    const number = Math.random() > 0.5 ? roundedDown : roundedUp;\n    if (number > max) {\n        return number - 1;\n    }\n    if (number < min) {\n        return number + 1;\n    }\n    return number;\n};\nconst assertTruthyOrZero = (value)=>isTruthyOrZero(value);\nconst CACHE_TIME_72_HOURS = 1000 * 60 * 60 * 72;\nconst CACHE_TIME_48_HOURS = 1000 * 60 * 60 * 48;\nconst CACHE_TIME_1_HOUR = 1000 * 60 * 60 * 1;\nconst CACHE_TIME_30_MINUTES = 1000 * 60 * 30;\nconst createTimeMsInMinutes = (minutes = 0)=>1000 * 60 * minutes;\nconst createTimeMsInHours = (hours = 0)=>createTimeMsInMinutes(60 * hours);\nconst createTimeMsInDays = (days = 0)=>createTimeMsInHours(24 * days);\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SyxLQUFVO0lBQ3hELEtBQVU7SUFBTSxLQUFVO0lBQUssS0FBVTtJQUFLLEtBQVU7SUFDeEQsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN4RCxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN2RSxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN2RSxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQ3hELEtBQVU7SUFBTSxLQUFVO0lBQUssS0FBVTtJQUFLLEtBQVU7SUFDeEQsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN4RCxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN2RSxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN2RSxLQUFVO0lBQU0sS0FBVTtJQUMxQixLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFDekMsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUFLLEtBQVU7SUFDdkUsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUFLLEtBQVU7SUFDdkUsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQUssS0FBVTtJQUN4RCxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQ3hELEtBQVU7SUFBTSxLQUFVO0lBQUssS0FBVTtJQUN6QyxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFDekMsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQ3pDLEtBQVU7SUFBTSxLQUFVO0lBQUssS0FBVTtJQUN6QyxLQUFVO0lBQU0sS0FBVTtJQUFLLEtBQVU7SUFBSyxLQUFVO0lBQ3hELEtBQVU7SUFBTSxLQUFVO0lBQUssS0FBVTtJQUFLLEtBQVU7SUFDeEQsS0FBVTtJQUFNLEtBQVU7SUFBSyxLQUFVO0lBQ3pDLEtBQVU7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RixvQkFBb0IsT0FBTyxLQUFLLEtBQUs7QUFDM0MsTUFBTUMsd0JBQXdCLE9BQU8sS0FBSztBQUMxQyxNQUFNbUIsd0JBQXdCLENBQUMyakQsVUFBVSxDQUFDLEdBQUssT0FBTyxLQUFLQTtBQUMzRCxNQUFNNWpELHNCQUFzQixDQUFDNmpELFFBQVEsQ0FBQyxHQUFLNWpELHNCQUFzQixLQUFLNGpEO0FBQ3RFLE1BQU05akQscUJBQXFCLENBQUMrakQsT0FBTyxDQUFDLEdBQUs5akQsb0JBQW9CLEtBQUs4akQ7Q0FHbEUscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGZ4L2FwcC1mcm9udC1lbmQtd2Vic2l0ZS8uLi9saWItdXRpbGl0aWVzL2xpYi9pbmRleC5lc20uanM/YjJhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBmdXp6eXNvcnQgZnJvbSAnZnV6enlzb3J0JztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuXG5mdW5jdGlvbiBhcnJheVJlZHVjZSQyKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbnZhciBfYXJyYXlSZWR1Y2UgPSBhcnJheVJlZHVjZSQyO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQmFzZUZvciQxKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IkMTtcblxudmFyIGNyZWF0ZUJhc2VGb3IgPSBfY3JlYXRlQmFzZUZvcjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yJDIgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbnZhciBfYmFzZUZvciA9IGJhc2VGb3IkMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cblxuZnVuY3Rpb24gYmFzZVRpbWVzJDEobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZVRpbWVzID0gYmFzZVRpbWVzJDE7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG5cbnZhciBmcmVlR2xvYmFsJDEgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cbnZhciBfZnJlZUdsb2JhbCA9IGZyZWVHbG9iYWwkMTtcblxudmFyIGZyZWVHbG9iYWwgPSBfZnJlZUdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290JDggPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBfcm9vdCA9IHJvb3QkODtcblxudmFyIHJvb3QkNyA9IF9yb290O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wkNiA9IHJvb3QkNy5TeW1ib2w7XG5cbnZhciBfU3ltYm9sID0gU3ltYm9sJDY7XG5cbnZhciBTeW1ib2wkNSA9IF9TeW1ib2w7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkYiA9IG9iamVjdFByb3RvJGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kZS50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IFN5bWJvbCQ1ID8gU3ltYm9sJDUudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnJDEodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkkYi5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyQxKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZyQxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cbnZhciBvYmplY3RQcm90byRkID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8kZC50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nJDEodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG52YXIgX29iamVjdFRvU3RyaW5nID0gb2JqZWN0VG9TdHJpbmckMTtcblxudmFyIFN5bWJvbCQ0ID0gX1N5bWJvbCxcbiAgICBnZXRSYXdUYWcgPSBfZ2V0UmF3VGFnLFxuICAgIG9iamVjdFRvU3RyaW5nID0gX29iamVjdFRvU3RyaW5nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wkNCA/IFN5bWJvbCQ0LnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyQ2KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxudmFyIF9iYXNlR2V0VGFnID0gYmFzZUdldFRhZyQ2O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdExpa2UkNyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbnZhciBpc09iamVjdExpa2VfMSA9IGlzT2JqZWN0TGlrZSQ3O1xuXG52YXIgYmFzZUdldFRhZyQ1ID0gX2Jhc2VHZXRUYWcsXG4gICAgaXNPYmplY3RMaWtlJDYgPSBpc09iamVjdExpa2VfMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWckMiA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyQxKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UkNih2YWx1ZSkgJiYgYmFzZUdldFRhZyQ1KHZhbHVlKSA9PSBhcmdzVGFnJDI7XG59XG5cbnZhciBfYmFzZUlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzJDE7XG5cbnZhciBiYXNlSXNBcmd1bWVudHMgPSBfYmFzZUlzQXJndW1lbnRzLFxuICAgIGlzT2JqZWN0TGlrZSQ1ID0gaXNPYmplY3RMaWtlXzE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byRjID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkYSA9IG9iamVjdFByb3RvJGMuaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlJDEgPSBvYmplY3RQcm90byRjLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMkNCA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UkNSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkkYS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUkMS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG52YXIgaXNBcmd1bWVudHNfMSA9IGlzQXJndW1lbnRzJDQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG52YXIgaXNBcnJheSRlID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGlzQXJyYXlfMSA9IGlzQXJyYXkkZTtcblxudmFyIGlzQXJyYXkkZiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpc0FycmF5XzEpO1xuXG52YXIgaXNCdWZmZXIkNCA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgc3R1YkZhbHNlXzEgPSBzdHViRmFsc2U7XG5cbmlzQnVmZmVyJDQuZXhwb3J0cztcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0dmFyIHJvb3QgPSBfcm9vdCxcblx0ICAgIHN0dWJGYWxzZSA9IHN0dWJGYWxzZV8xO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG5cdHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG5cdC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cdHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG5cdC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblx0dmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4zLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHR2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjsgXG59IChpc0J1ZmZlciQ0LCBpc0J1ZmZlciQ0LmV4cG9ydHMpKTtcblxudmFyIGlzQnVmZmVyRXhwb3J0cyA9IGlzQnVmZmVyJDQuZXhwb3J0cztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSJDEgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgkMyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIkMSA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbnZhciBfaXNJbmRleCA9IGlzSW5kZXgkMztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoJDModmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxudmFyIGlzTGVuZ3RoXzEgPSBpc0xlbmd0aCQzO1xuXG52YXIgYmFzZUdldFRhZyQ0ID0gX2Jhc2VHZXRUYWcsXG4gICAgaXNMZW5ndGgkMiA9IGlzTGVuZ3RoXzEsXG4gICAgaXNPYmplY3RMaWtlJDQgPSBpc09iamVjdExpa2VfMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWckMSA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnJDEgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWckMSA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnJDEgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWckMSA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyQxID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWckMiA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyQxID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnJDMgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWckMSA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyQyID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnJDEgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnJDEgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyQxID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyQyID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWckMV0gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZyQxXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWckMV0gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWckMl0gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnJDFdID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnJDFdID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZyQxXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWckMl0gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWckMV0gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnJDNdID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnJDFdID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZyQyXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZyQxXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnJDFdID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkkMSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlJDQodmFsdWUpICYmXG4gICAgaXNMZW5ndGgkMih2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyQ0KHZhbHVlKV07XG59XG5cbnZhciBfYmFzZUlzVHlwZWRBcnJheSA9IGJhc2VJc1R5cGVkQXJyYXkkMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBiYXNlVW5hcnkkMihmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxudmFyIF9iYXNlVW5hcnkgPSBiYXNlVW5hcnkkMjtcblxudmFyIF9ub2RlVXRpbCA9IHtleHBvcnRzOiB7fX07XG5cbl9ub2RlVXRpbC5leHBvcnRzO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHR2YXIgZnJlZUdsb2JhbCA9IF9mcmVlR2xvYmFsO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG5cdHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG5cdC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cdHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuXHR2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuXHQvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cblx0dmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuXHQgIHRyeSB7XG5cdCAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cblx0ICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG5cdCAgICBpZiAodHlwZXMpIHtcblx0ICAgICAgcmV0dXJuIHR5cGVzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuXHQgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuXHQgIH0gY2F0Y2ggKGUpIHt9XG5cdH0oKSk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDsgXG59IChfbm9kZVV0aWwsIF9ub2RlVXRpbC5leHBvcnRzKSk7XG5cbnZhciBfbm9kZVV0aWxFeHBvcnRzID0gX25vZGVVdGlsLmV4cG9ydHM7XG5cbnZhciBiYXNlSXNUeXBlZEFycmF5ID0gX2Jhc2VJc1R5cGVkQXJyYXksXG4gICAgYmFzZVVuYXJ5JDEgPSBfYmFzZVVuYXJ5LFxuICAgIG5vZGVVdGlsID0gX25vZGVVdGlsRXhwb3J0cztcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5JDMgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5JDEobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG52YXIgaXNUeXBlZEFycmF5XzEgPSBpc1R5cGVkQXJyYXkkMztcblxudmFyIGJhc2VUaW1lcyA9IF9iYXNlVGltZXMsXG4gICAgaXNBcmd1bWVudHMkMyA9IGlzQXJndW1lbnRzXzEsXG4gICAgaXNBcnJheSRkID0gaXNBcnJheV8xLFxuICAgIGlzQnVmZmVyJDMgPSBpc0J1ZmZlckV4cG9ydHMsXG4gICAgaXNJbmRleCQyID0gX2lzSW5kZXgsXG4gICAgaXNUeXBlZEFycmF5JDIgPSBpc1R5cGVkQXJyYXlfMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJGIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ5ID0gb2JqZWN0UHJvdG8kYi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyQyKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSRkKHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzJDModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlciQzKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkkMih2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkkOS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgkMihrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYXJyYXlMaWtlS2V5cyA9IGFycmF5TGlrZUtleXMkMjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXG52YXIgb2JqZWN0UHJvdG8kYSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSQzKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90byRhO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbnZhciBfaXNQcm90b3R5cGUgPSBpc1Byb3RvdHlwZSQzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBvdmVyQXJnJDIoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbnZhciBfb3ZlckFyZyA9IG92ZXJBcmckMjtcblxudmFyIG92ZXJBcmckMSA9IF9vdmVyQXJnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyQxID0gb3ZlckFyZyQxKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG52YXIgX25hdGl2ZUtleXMgPSBuYXRpdmVLZXlzJDE7XG5cbnZhciBpc1Byb3RvdHlwZSQyID0gX2lzUHJvdG90eXBlLFxuICAgIG5hdGl2ZUtleXMgPSBfbmF0aXZlS2V5cztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDkgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ4ID0gb2JqZWN0UHJvdG8kOS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzJDEob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUkMihvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQ4LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VLZXlzID0gYmFzZUtleXMkMTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdCQ4KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0JDg7XG5cbnZhciBpc09iamVjdCQ5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGlzT2JqZWN0XzEpO1xuXG52YXIgYmFzZUdldFRhZyQzID0gX2Jhc2VHZXRUYWcsXG4gICAgaXNPYmplY3QkNyA9IGlzT2JqZWN0XzE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24kMyh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0JDcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWckMyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbnZhciBpc0Z1bmN0aW9uXzEgPSBpc0Z1bmN0aW9uJDM7XG5cbnZhciBpc0Z1bmN0aW9uJDIgPSBpc0Z1bmN0aW9uXzEsXG4gICAgaXNMZW5ndGgkMSA9IGlzTGVuZ3RoXzE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlJDYodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgkMSh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uJDIodmFsdWUpO1xufVxuXG52YXIgaXNBcnJheUxpa2VfMSA9IGlzQXJyYXlMaWtlJDY7XG5cbnZhciBhcnJheUxpa2VLZXlzJDEgPSBfYXJyYXlMaWtlS2V5cyxcbiAgICBiYXNlS2V5cyA9IF9iYXNlS2V5cyxcbiAgICBpc0FycmF5TGlrZSQ1ID0gaXNBcnJheUxpa2VfMTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzJDMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZSQ1KG9iamVjdCkgPyBhcnJheUxpa2VLZXlzJDEob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbnZhciBrZXlzXzEgPSBrZXlzJDM7XG5cbnZhciBiYXNlRm9yJDEgPSBfYmFzZUZvcixcbiAgICBrZXlzJDIgPSBrZXlzXzE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93biQzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yJDEob2JqZWN0LCBpdGVyYXRlZSwga2V5cyQyKTtcbn1cblxudmFyIF9iYXNlRm9yT3duID0gYmFzZUZvck93biQzO1xuXG52YXIgaXNBcnJheUxpa2UkNCA9IGlzQXJyYXlMaWtlXzE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2gkMShlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlJDQoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG52YXIgX2NyZWF0ZUJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2gkMTtcblxudmFyIGJhc2VGb3JPd24kMiA9IF9iYXNlRm9yT3duLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gX2NyZWF0ZUJhc2VFYWNoO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2gkMyA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24kMik7XG5cbnZhciBfYmFzZUVhY2ggPSBiYXNlRWFjaCQzO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cblxuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIkMSgpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2xpc3RDYWNoZUNsZWFyID0gbGlzdENhY2hlQ2xlYXIkMTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5cbmZ1bmN0aW9uIGVxJDUodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG52YXIgZXFfMSA9IGVxJDU7XG5cbnZhciBlcSQ0ID0gZXFfMTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mJDQoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEkNChhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbnZhciBfYXNzb2NJbmRleE9mID0gYXNzb2NJbmRleE9mJDQ7XG5cbnZhciBhc3NvY0luZGV4T2YkMyA9IF9hc3NvY0luZGV4T2Y7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlJDEoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mJDMoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBfbGlzdENhY2hlRGVsZXRlID0gbGlzdENhY2hlRGVsZXRlJDE7XG5cbnZhciBhc3NvY0luZGV4T2YkMiA9IF9hc3NvY0luZGV4T2Y7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldCQxKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZiQyKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG52YXIgX2xpc3RDYWNoZUdldCA9IGxpc3RDYWNoZUdldCQxO1xuXG52YXIgYXNzb2NJbmRleE9mJDEgPSBfYXNzb2NJbmRleE9mO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzJDEoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YkMSh0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbnZhciBfbGlzdENhY2hlSGFzID0gbGlzdENhY2hlSGFzJDE7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfYXNzb2NJbmRleE9mO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldCQxKGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9saXN0Q2FjaGVTZXQgPSBsaXN0Q2FjaGVTZXQkMTtcblxudmFyIGxpc3RDYWNoZUNsZWFyID0gX2xpc3RDYWNoZUNsZWFyLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IF9saXN0Q2FjaGVEZWxldGUsXG4gICAgbGlzdENhY2hlR2V0ID0gX2xpc3RDYWNoZUdldCxcbiAgICBsaXN0Q2FjaGVIYXMgPSBfbGlzdENhY2hlSGFzLFxuICAgIGxpc3RDYWNoZVNldCA9IF9saXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlJDQoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZSQ0LnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlJDQucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZSQ0LnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUkNC5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlJDQucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxudmFyIF9MaXN0Q2FjaGUgPSBMaXN0Q2FjaGUkNDtcblxudmFyIExpc3RDYWNoZSQzID0gX0xpc3RDYWNoZTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyJDEoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlJDM7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbnZhciBfc3RhY2tDbGVhciA9IHN0YWNrQ2xlYXIkMTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBzdGFja0RlbGV0ZSQxKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9zdGFja0RlbGV0ZSA9IHN0YWNrRGVsZXRlJDE7XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cblxuZnVuY3Rpb24gc3RhY2tHZXQkMShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbnZhciBfc3RhY2tHZXQgPSBzdGFja0dldCQxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBzdGFja0hhcyQxKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxudmFyIF9zdGFja0hhcyA9IHN0YWNrSGFzJDE7XG5cbnZhciByb290JDYgPSBfcm9vdDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEkMSA9IHJvb3QkNlsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbnZhciBfY29yZUpzRGF0YSA9IGNvcmVKc0RhdGEkMTtcblxudmFyIGNvcmVKc0RhdGEgPSBfY29yZUpzRGF0YTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkJDEoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG52YXIgX2lzTWFza2VkID0gaXNNYXNrZWQkMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXG52YXIgZnVuY1Byb3RvJDIgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmckMiA9IGZ1bmNQcm90byQyLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UkMihmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZyQyLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgX3RvU291cmNlID0gdG9Tb3VyY2UkMjtcblxudmFyIGlzRnVuY3Rpb24kMSA9IGlzRnVuY3Rpb25fMSxcbiAgICBpc01hc2tlZCA9IF9pc01hc2tlZCxcbiAgICBpc09iamVjdCQ2ID0gaXNPYmplY3RfMSxcbiAgICB0b1NvdXJjZSQxID0gX3RvU291cmNlO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byQxID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvJDggPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nJDEgPSBmdW5jUHJvdG8kMS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNyA9IG9iamVjdFByb3RvJDguaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmckMS5jYWxsKGhhc093blByb3BlcnR5JDcpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSQxKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QkNih2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbiQxKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UkMSh2YWx1ZSkpO1xufVxuXG52YXIgX2Jhc2VJc05hdGl2ZSA9IGJhc2VJc05hdGl2ZSQxO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cbmZ1bmN0aW9uIGdldFZhbHVlJDEob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbnZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZSQxO1xuXG52YXIgYmFzZUlzTmF0aXZlID0gX2Jhc2VJc05hdGl2ZSxcbiAgICBnZXRWYWx1ZSA9IF9nZXRWYWx1ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlJDcob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2dldE5hdGl2ZSA9IGdldE5hdGl2ZSQ3O1xuXG52YXIgZ2V0TmF0aXZlJDYgPSBfZ2V0TmF0aXZlLFxuICAgIHJvb3QkNSA9IF9yb290O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwJDMgPSBnZXROYXRpdmUkNihyb290JDUsICdNYXAnKTtcblxudmFyIF9NYXAgPSBNYXAkMztcblxudmFyIGdldE5hdGl2ZSQ1ID0gX2dldE5hdGl2ZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSQ0ID0gZ2V0TmF0aXZlJDUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbnZhciBfbmF0aXZlQ3JlYXRlID0gbmF0aXZlQ3JlYXRlJDQ7XG5cbnZhciBuYXRpdmVDcmVhdGUkMyA9IF9uYXRpdmVDcmVhdGU7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhciQxKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlJDMgPyBuYXRpdmVDcmVhdGUkMyhudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2hhc2hDbGVhciA9IGhhc2hDbGVhciQxO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNoRGVsZXRlJDEoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZSQxO1xuXG52YXIgbmF0aXZlQ3JlYXRlJDIgPSBfbmF0aXZlQ3JlYXRlO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQkMiA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDcgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ2ID0gb2JqZWN0UHJvdG8kNy5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQkMShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlJDIpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEJDIgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5JDYuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2hhc2hHZXQgPSBoYXNoR2V0JDE7XG5cbnZhciBuYXRpdmVDcmVhdGUkMSA9IF9uYXRpdmVDcmVhdGU7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ2ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNSA9IG9iamVjdFByb3RvJDYuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyQxKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUkMSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eSQ1LmNhbGwoZGF0YSwga2V5KTtcbn1cblxudmFyIF9oYXNoSGFzID0gaGFzaEhhcyQxO1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX25hdGl2ZUNyZWF0ZTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEJDEgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQkMShrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEJDEgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfaGFzaFNldCA9IGhhc2hTZXQkMTtcblxudmFyIGhhc2hDbGVhciA9IF9oYXNoQ2xlYXIsXG4gICAgaGFzaERlbGV0ZSA9IF9oYXNoRGVsZXRlLFxuICAgIGhhc2hHZXQgPSBfaGFzaEdldCxcbiAgICBoYXNoSGFzID0gX2hhc2hIYXMsXG4gICAgaGFzaFNldCA9IF9oYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaCQxKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaCQxLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gkMS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gkMS5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gkMS5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gkMS5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxudmFyIF9IYXNoID0gSGFzaCQxO1xuXG52YXIgSGFzaCA9IF9IYXNoLFxuICAgIExpc3RDYWNoZSQyID0gX0xpc3RDYWNoZSxcbiAgICBNYXAkMiA9IF9NYXA7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIkMSgpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCQyIHx8IExpc3RDYWNoZSQyKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxudmFyIF9tYXBDYWNoZUNsZWFyID0gbWFwQ2FjaGVDbGVhciQxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBpc0tleWFibGUkMSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG52YXIgX2lzS2V5YWJsZSA9IGlzS2V5YWJsZSQxO1xuXG52YXIgaXNLZXlhYmxlID0gX2lzS2V5YWJsZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YSQ0KG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbnZhciBfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGEkNDtcblxudmFyIGdldE1hcERhdGEkMyA9IF9nZXRNYXBEYXRhO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUkMShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEkMyh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWFwQ2FjaGVEZWxldGUgPSBtYXBDYWNoZURlbGV0ZSQxO1xuXG52YXIgZ2V0TWFwRGF0YSQyID0gX2dldE1hcERhdGE7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldCQxKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSQyKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbnZhciBfbWFwQ2FjaGVHZXQgPSBtYXBDYWNoZUdldCQxO1xuXG52YXIgZ2V0TWFwRGF0YSQxID0gX2dldE1hcERhdGE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMkMShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEkMSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG52YXIgX21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXMkMTtcblxudmFyIGdldE1hcERhdGEgPSBfZ2V0TWFwRGF0YTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldCQxKGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfbWFwQ2FjaGVTZXQgPSBtYXBDYWNoZVNldCQxO1xuXG52YXIgbWFwQ2FjaGVDbGVhciA9IF9tYXBDYWNoZUNsZWFyLFxuICAgIG1hcENhY2hlRGVsZXRlID0gX21hcENhY2hlRGVsZXRlLFxuICAgIG1hcENhY2hlR2V0ID0gX21hcENhY2hlR2V0LFxuICAgIG1hcENhY2hlSGFzID0gX21hcENhY2hlSGFzLFxuICAgIG1hcENhY2hlU2V0ID0gX21hcENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUkMyhlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZSQzLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZSQzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlJDMucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUkMy5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZSQzLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxudmFyIF9NYXBDYWNoZSA9IE1hcENhY2hlJDM7XG5cbnZhciBMaXN0Q2FjaGUkMSA9IF9MaXN0Q2FjaGUsXG4gICAgTWFwJDEgPSBfTWFwLFxuICAgIE1hcENhY2hlJDIgPSBfTWFwQ2FjaGU7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0JDEoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlJDEpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwJDEgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUkMihwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfc3RhY2tTZXQgPSBzdGFja1NldCQxO1xuXG52YXIgTGlzdENhY2hlID0gX0xpc3RDYWNoZSxcbiAgICBzdGFja0NsZWFyID0gX3N0YWNrQ2xlYXIsXG4gICAgc3RhY2tEZWxldGUgPSBfc3RhY2tEZWxldGUsXG4gICAgc3RhY2tHZXQgPSBfc3RhY2tHZXQsXG4gICAgc3RhY2tIYXMgPSBfc3RhY2tIYXMsXG4gICAgc3RhY2tTZXQgPSBfc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrJDMoZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjayQzLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjayQzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrJDMucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2skMy5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjayQzLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxudmFyIF9TdGFjayA9IFN0YWNrJDM7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cblxudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQkMSh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9zZXRDYWNoZUFkZCA9IHNldENhY2hlQWRkJDE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyQxKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbnZhciBfc2V0Q2FjaGVIYXMgPSBzZXRDYWNoZUhhcyQxO1xuXG52YXIgTWFwQ2FjaGUkMSA9IF9NYXBDYWNoZSxcbiAgICBzZXRDYWNoZUFkZCA9IF9zZXRDYWNoZUFkZCxcbiAgICBzZXRDYWNoZUhhcyA9IF9zZXRDYWNoZUhhcztcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSQxKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZSQxO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZSQxLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZSQxLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZSQxLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxudmFyIF9TZXRDYWNoZSA9IFNldENhY2hlJDE7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5cbmZ1bmN0aW9uIGFycmF5U29tZSQxKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2FycmF5U29tZSA9IGFycmF5U29tZSQxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5cbmZ1bmN0aW9uIGNhY2hlSGFzJDEoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbnZhciBfY2FjaGVIYXMgPSBjYWNoZUhhcyQxO1xuXG52YXIgU2V0Q2FjaGUgPSBfU2V0Q2FjaGUsXG4gICAgYXJyYXlTb21lID0gX2FycmF5U29tZSxcbiAgICBjYWNoZUhhcyA9IF9jYWNoZUhhcztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyQzID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzJDIoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgcmV0dXJuIGFyclN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBhcnJheTtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDMpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9lcXVhbEFycmF5cyA9IGVxdWFsQXJyYXlzJDI7XG5cbnZhciByb290JDQgPSBfcm9vdDtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSQzID0gcm9vdCQ0LlVpbnQ4QXJyYXk7XG5cbnZhciBfVWludDhBcnJheSA9IFVpbnQ4QXJyYXkkMztcblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5cbmZ1bmN0aW9uIG1hcFRvQXJyYXkkMShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWFwVG9BcnJheSA9IG1hcFRvQXJyYXkkMTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIHNldFRvQXJyYXkkMShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfc2V0VG9BcnJheSA9IHNldFRvQXJyYXkkMTtcblxudmFyIFN5bWJvbCQzID0gX1N5bWJvbCxcbiAgICBVaW50OEFycmF5JDIgPSBfVWludDhBcnJheSxcbiAgICBlcSQzID0gZXFfMSxcbiAgICBlcXVhbEFycmF5cyQxID0gX2VxdWFsQXJyYXlzLFxuICAgIG1hcFRvQXJyYXkgPSBfbWFwVG9BcnJheSxcbiAgICBzZXRUb0FycmF5ID0gX3NldFRvQXJyYXk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDQgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMiA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyQxID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnJDEgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWckMSA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnJDEgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byQxID0gU3ltYm9sJDMgPyBTeW1ib2wkMy5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvJDEgPyBzeW1ib2xQcm90byQxLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWckMShvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnJDE6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheSQyKG9iamVjdCksIG5ldyBVaW50OEFycmF5JDIob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSQzKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnJDE6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZyQxOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyQ0O1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRyQyO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyQxKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWckMTpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIF9lcXVhbEJ5VGFnID0gZXF1YWxCeVRhZyQxO1xuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuXG5mdW5jdGlvbiBhcnJheVB1c2gkMihhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG52YXIgX2FycmF5UHVzaCA9IGFycmF5UHVzaCQyO1xuXG52YXIgYXJyYXlQdXNoJDEgPSBfYXJyYXlQdXNoLFxuICAgIGlzQXJyYXkkYyA9IGlzQXJyYXlfMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyQxKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheSRjKG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gkMShyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG52YXIgX2Jhc2VHZXRBbGxLZXlzID0gYmFzZUdldEFsbEtleXMkMTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cblxuZnVuY3Rpb24gYXJyYXlGaWx0ZXIkMShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9hcnJheUZpbHRlciA9IGFycmF5RmlsdGVyJDE7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5mdW5jdGlvbiBzdHViQXJyYXkkMSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG52YXIgc3R1YkFycmF5XzEgPSBzdHViQXJyYXkkMTtcblxudmFyIGFycmF5RmlsdGVyID0gX2FycmF5RmlsdGVyLFxuICAgIHN0dWJBcnJheSA9IHN0dWJBcnJheV8xO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8kNS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMkMSA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbnZhciBfZ2V0U3ltYm9scyA9IGdldFN5bWJvbHMkMTtcblxudmFyIGJhc2VHZXRBbGxLZXlzID0gX2Jhc2VHZXRBbGxLZXlzLFxuICAgIGdldFN5bWJvbHMgPSBfZ2V0U3ltYm9scyxcbiAgICBrZXlzJDEgPSBrZXlzXzE7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyQxKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzJDEsIGdldFN5bWJvbHMpO1xufVxuXG52YXIgX2dldEFsbEtleXMgPSBnZXRBbGxLZXlzJDE7XG5cbnZhciBnZXRBbGxLZXlzID0gX2dldEFsbEtleXM7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDMgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDQgPSBvYmplY3RQcm90byQ0Lmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMkMShvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5JDQuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfZXF1YWxPYmplY3RzID0gZXF1YWxPYmplY3RzJDE7XG5cbnZhciBnZXROYXRpdmUkNCA9IF9nZXROYXRpdmUsXG4gICAgcm9vdCQzID0gX3Jvb3Q7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyQxID0gZ2V0TmF0aXZlJDQocm9vdCQzLCAnRGF0YVZpZXcnKTtcblxudmFyIF9EYXRhVmlldyA9IERhdGFWaWV3JDE7XG5cbnZhciBnZXROYXRpdmUkMyA9IF9nZXROYXRpdmUsXG4gICAgcm9vdCQyID0gX3Jvb3Q7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlJDIgPSBnZXROYXRpdmUkMyhyb290JDIsICdQcm9taXNlJyk7XG5cbnZhciBfUHJvbWlzZSA9IFByb21pc2UkMjtcblxudmFyIGdldE5hdGl2ZSQyID0gX2dldE5hdGl2ZSxcbiAgICByb290JDEgPSBfcm9vdDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCQyID0gZ2V0TmF0aXZlJDIocm9vdCQxLCAnU2V0Jyk7XG5cbnZhciBfU2V0ID0gU2V0JDI7XG5cbnZhciBnZXROYXRpdmUkMSA9IF9nZXROYXRpdmUsXG4gICAgcm9vdCA9IF9yb290O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCQxID0gZ2V0TmF0aXZlJDEocm9vdCwgJ1dlYWtNYXAnKTtcblxudmFyIF9XZWFrTWFwID0gV2Vha01hcCQxO1xuXG52YXIgRGF0YVZpZXcgPSBfRGF0YVZpZXcsXG4gICAgTWFwID0gX01hcCxcbiAgICBQcm9taXNlJDEgPSBfUHJvbWlzZSxcbiAgICBTZXQkMSA9IF9TZXQsXG4gICAgV2Vha01hcCA9IF9XZWFrTWFwLFxuICAgIGJhc2VHZXRUYWckMiA9IF9iYXNlR2V0VGFnLFxuICAgIHRvU291cmNlID0gX3RvU291cmNlO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnJDIgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSQxKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0JDEpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWckMiA9IGJhc2VHZXRUYWckMjtcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWckMihuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWckMihuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UkMSAmJiBnZXRUYWckMihQcm9taXNlJDEucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQkMSAmJiBnZXRUYWckMihuZXcgU2V0JDEpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWckMihuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnJDIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnJDIodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyQyID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxudmFyIF9nZXRUYWcgPSBnZXRUYWckMjtcblxudmFyIFN0YWNrJDIgPSBfU3RhY2ssXG4gICAgZXF1YWxBcnJheXMgPSBfZXF1YWxBcnJheXMsXG4gICAgZXF1YWxCeVRhZyA9IF9lcXVhbEJ5VGFnLFxuICAgIGVxdWFsT2JqZWN0cyA9IF9lcXVhbE9iamVjdHMsXG4gICAgZ2V0VGFnJDEgPSBfZ2V0VGFnLFxuICAgIGlzQXJyYXkkYiA9IGlzQXJyYXlfMSxcbiAgICBpc0J1ZmZlciQyID0gaXNCdWZmZXJFeHBvcnRzLFxuICAgIGlzVHlwZWRBcnJheSQxID0gaXNUeXBlZEFycmF5XzE7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDIgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWckMSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDMgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcCQxKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheSRiKG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkkYihvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnJDEob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWckMShvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWckMSA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWckMSA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnJDEsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWckMSxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlciQyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyJDIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrJDIpO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5JDEob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyQyKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eSQzLmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkkMy5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2skMik7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayQyKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxudmFyIF9iYXNlSXNFcXVhbERlZXAgPSBiYXNlSXNFcXVhbERlZXAkMTtcblxudmFyIGJhc2VJc0VxdWFsRGVlcCA9IF9iYXNlSXNFcXVhbERlZXAsXG4gICAgaXNPYmplY3RMaWtlJDMgPSBpc09iamVjdExpa2VfMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwkMyh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlJDModmFsdWUpICYmICFpc09iamVjdExpa2UkMyhvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsJDMsIHN0YWNrKTtcbn1cblxudmFyIF9iYXNlSXNFcXVhbCA9IGJhc2VJc0VxdWFsJDM7XG5cbnZhciBTdGFjayQxID0gX1N0YWNrLFxuICAgIGJhc2VJc0VxdWFsJDIgPSBfYmFzZUlzRXF1YWw7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDEgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMSA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaCQxKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2skMTtcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwkMihzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHJDEgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBfYmFzZUlzTWF0Y2ggPSBiYXNlSXNNYXRjaCQxO1xuXG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0XzE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlJDIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QkNSh2YWx1ZSk7XG59XG5cbnZhciBfaXNTdHJpY3RDb21wYXJhYmxlID0gaXNTdHJpY3RDb21wYXJhYmxlJDI7XG5cbnZhciBpc1N0cmljdENvbXBhcmFibGUkMSA9IF9pc1N0cmljdENvbXBhcmFibGUsXG4gICAga2V5cyA9IGtleXNfMTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEkMShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlJDEodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2dldE1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YSQxO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUkMihrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG52YXIgX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUkMjtcblxudmFyIGJhc2VJc01hdGNoID0gX2Jhc2VJc01hdGNoLFxuICAgIGdldE1hdGNoRGF0YSA9IF9nZXRNYXRjaERhdGEsXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUkMSA9IF9tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMkMShzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQxKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG52YXIgX2Jhc2VNYXRjaGVzID0gYmFzZU1hdGNoZXMkMTtcblxudmFyIGJhc2VHZXRUYWckMSA9IF9iYXNlR2V0VGFnLFxuICAgIGlzT2JqZWN0TGlrZSQyID0gaXNPYmplY3RMaWtlXzE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCQ1KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlJDIodmFsdWUpICYmIGJhc2VHZXRUYWckMSh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxudmFyIGlzU3ltYm9sXzEgPSBpc1N5bWJvbCQ1O1xuXG52YXIgaXNBcnJheSRhID0gaXNBcnJheV8xLFxuICAgIGlzU3ltYm9sJDQgPSBpc1N5bWJvbF8xO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wJDEgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AkMSA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5JDQodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSRhKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCQ0KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wJDEudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcCQxLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxudmFyIF9pc0tleSA9IGlzS2V5JDQ7XG5cbnZhciBNYXBDYWNoZSA9IF9NYXBDYWNoZTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUkMShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZSQxLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUkMS5DYWNoZSA9IE1hcENhY2hlO1xuXG52YXIgbWVtb2l6ZV8xID0gbWVtb2l6ZSQxO1xuXG52YXIgbWVtb2l6ZSA9IG1lbW9pemVfMTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQkMShmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWVtb2l6ZUNhcHBlZCA9IG1lbW9pemVDYXBwZWQkMTtcblxudmFyIG1lbW9pemVDYXBwZWQgPSBfbWVtb2l6ZUNhcHBlZDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUkMSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyJDEgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoJDIgPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lJDEsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciQxLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxudmFyIF9zdHJpbmdUb1BhdGggPSBzdHJpbmdUb1BhdGgkMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cblxuZnVuY3Rpb24gYXJyYXlNYXAkMihhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYXJyYXlNYXAgPSBhcnJheU1hcCQyO1xuXG52YXIgU3ltYm9sJDIgPSBfU3ltYm9sLFxuICAgIGFycmF5TWFwJDEgPSBfYXJyYXlNYXAsXG4gICAgaXNBcnJheSQ5ID0gaXNBcnJheV8xLFxuICAgIGlzU3ltYm9sJDMgPSBpc1N5bWJvbF8xO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSQyID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sJDIgPyBTeW1ib2wkMi5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyQxKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkkOSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCQxKHZhbHVlLCBiYXNlVG9TdHJpbmckMSkgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wkMyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkkMikgPyAnLTAnIDogcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VUb1N0cmluZyA9IGJhc2VUb1N0cmluZyQxO1xuXG52YXIgYmFzZVRvU3RyaW5nID0gX2Jhc2VUb1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nJDUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbnZhciB0b1N0cmluZ18xID0gdG9TdHJpbmckNTtcblxudmFyIGlzQXJyYXkkOCA9IGlzQXJyYXlfMSxcbiAgICBpc0tleSQzID0gX2lzS2V5LFxuICAgIHN0cmluZ1RvUGF0aCQxID0gX3N0cmluZ1RvUGF0aCxcbiAgICB0b1N0cmluZyQ0ID0gdG9TdHJpbmdfMTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoJDModmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSQ4KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkkMyh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgkMSh0b1N0cmluZyQ0KHZhbHVlKSk7XG59XG5cbnZhciBfY2FzdFBhdGggPSBjYXN0UGF0aCQzO1xuXG52YXIgaXNTeW1ib2wkMiA9IGlzU3ltYm9sXzE7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZJDEgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSQ1KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wkMih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSQxKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbnZhciBfdG9LZXkgPSB0b0tleSQ1O1xuXG52YXIgY2FzdFBhdGgkMiA9IF9jYXN0UGF0aCxcbiAgICB0b0tleSQ0ID0gX3RvS2V5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldCQzKG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgkMihwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkkNChwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2Jhc2VHZXQgPSBiYXNlR2V0JDM7XG5cbnZhciBiYXNlR2V0JDIgPSBfYmFzZUdldDtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0JDIob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldCQyKG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxudmFyIGdldF8xID0gZ2V0JDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxuZnVuY3Rpb24gYmFzZUhhc0luJDEob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxudmFyIF9iYXNlSGFzSW4gPSBiYXNlSGFzSW4kMTtcblxudmFyIGNhc3RQYXRoJDEgPSBfY2FzdFBhdGgsXG4gICAgaXNBcmd1bWVudHMkMiA9IGlzQXJndW1lbnRzXzEsXG4gICAgaXNBcnJheSQ3ID0gaXNBcnJheV8xLFxuICAgIGlzSW5kZXgkMSA9IF9pc0luZGV4LFxuICAgIGlzTGVuZ3RoID0gaXNMZW5ndGhfMSxcbiAgICB0b0tleSQzID0gX3RvS2V5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoJDEob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aCQxKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5JDMocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgkMShrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheSQ3KG9iamVjdCkgfHwgaXNBcmd1bWVudHMkMihvYmplY3QpKTtcbn1cblxudmFyIF9oYXNQYXRoID0gaGFzUGF0aCQxO1xuXG52YXIgYmFzZUhhc0luID0gX2Jhc2VIYXNJbixcbiAgICBoYXNQYXRoID0gX2hhc1BhdGg7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4kMShvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG52YXIgaGFzSW5fMSA9IGhhc0luJDE7XG5cbnZhciBiYXNlSXNFcXVhbCQxID0gX2Jhc2VJc0VxdWFsLFxuICAgIGdldCQxID0gZ2V0XzEsXG4gICAgaGFzSW4gPSBoYXNJbl8xLFxuICAgIGlzS2V5JDIgPSBfaXNLZXksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gX2lzU3RyaWN0Q29tcGFyYWJsZSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IF9tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSxcbiAgICB0b0tleSQyID0gX3RvS2V5O1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkkMShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkkMihwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5JDIocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0JDEob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsJDEoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG52YXIgX2Jhc2VNYXRjaGVzUHJvcGVydHkgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5JDE7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5cbmZ1bmN0aW9uIGlkZW50aXR5JDQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgaWRlbnRpdHlfMSA9IGlkZW50aXR5JDQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkkMShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG52YXIgX2Jhc2VQcm9wZXJ0eSA9IGJhc2VQcm9wZXJ0eSQxO1xuXG52YXIgYmFzZUdldCQxID0gX2Jhc2VHZXQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcCQxKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0JDEob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxudmFyIF9iYXNlUHJvcGVydHlEZWVwID0gYmFzZVByb3BlcnR5RGVlcCQxO1xuXG52YXIgYmFzZVByb3BlcnR5ID0gX2Jhc2VQcm9wZXJ0eSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gX2Jhc2VQcm9wZXJ0eURlZXAsXG4gICAgaXNLZXkkMSA9IF9pc0tleSxcbiAgICB0b0tleSQxID0gX3RvS2V5O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5JDEocGF0aCkge1xuICByZXR1cm4gaXNLZXkkMShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleSQxKHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbnZhciBwcm9wZXJ0eV8xID0gcHJvcGVydHkkMTtcblxudmFyIGJhc2VNYXRjaGVzID0gX2Jhc2VNYXRjaGVzLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSBfYmFzZU1hdGNoZXNQcm9wZXJ0eSxcbiAgICBpZGVudGl0eSQzID0gaWRlbnRpdHlfMSxcbiAgICBpc0FycmF5JDYgPSBpc0FycmF5XzEsXG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eV8xO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUkNSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHkkMztcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkkNih2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG52YXIgX2Jhc2VJdGVyYXRlZSA9IGJhc2VJdGVyYXRlZSQ1O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuXG5mdW5jdGlvbiBiYXNlUmVkdWNlJDEoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG52YXIgX2Jhc2VSZWR1Y2UgPSBiYXNlUmVkdWNlJDE7XG5cbnZhciBhcnJheVJlZHVjZSQxID0gX2FycmF5UmVkdWNlLFxuICAgIGJhc2VFYWNoJDIgPSBfYmFzZUVhY2gsXG4gICAgYmFzZUl0ZXJhdGVlJDQgPSBfYmFzZUl0ZXJhdGVlLFxuICAgIGJhc2VSZWR1Y2UgPSBfYmFzZVJlZHVjZSxcbiAgICBpc0FycmF5JDUgPSBpc0FycmF5XzE7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAqIGFuZCBgc29ydEJ5YFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICogICByZXR1cm4gc3VtICsgbjtcbiAqIH0sIDApO1xuICogLy8gPT4gM1xuICpcbiAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkkNShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlJDEgOiBiYXNlUmVkdWNlLFxuICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlJDQoaXRlcmF0ZWUpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCQyKTtcbn1cblxudmFyIHJlZHVjZV8xID0gcmVkdWNlO1xuXG52YXIgcmVkdWNlJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocmVkdWNlXzEpO1xuXG52YXIgZ2xvYmFsJDEgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gICAgICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcblxudmFyIGxvb2t1cCA9IFtdO1xudmFyIHJldkxvb2t1cCA9IFtdO1xudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbnZhciBpbml0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluaXQgKCkge1xuICBpbml0ZWQgPSB0cnVlO1xuICB2YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIHJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MjtcbiAgcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzO1xufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIGlmICghaW5pdGVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aDtcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcGxhY2VIb2xkZXJzID0gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMDtcblxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7XG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW47XG5cbiAgdmFyIEwgPSAwO1xuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCk7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKTtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wO1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgdG1wO1xuICB2YXIgbGVuID0gdWludDgubGVuZ3RoO1xuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKTtcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gJz09JztcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKTtcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9JztcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KTtcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IC03O1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwO1xuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7XG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmZ1bmN0aW9uIHdyaXRlIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYztcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCk7XG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSk7XG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMTtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufVxuXG52YXIgdG9TdHJpbmckMyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgaXNBcnJheSQ0ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZyQzLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWU7XG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmtNYXhMZW5ndGgoKTtcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIHJldHVybiBhcnJcbn07XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufTtcblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7XG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikgO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn07XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKTtcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5JDQob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5CdWZmZXIuaXNCdWZmZXIgPSBpc0J1ZmZlciQxO1xuZnVuY3Rpb24gaW50ZXJuYWxJc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGEpIHx8ICFpbnRlcm5hbElzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn07XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5JDQobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhciBwb3MgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufTtcblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMDtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl07XG4gIGJbbl0gPSBiW21dO1xuICBiW21dID0gaTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDA7XG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTO1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJztcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDA7XG4gIGVuZCA+Pj49IDA7XG4gIHRoaXNTdGFydCA+Pj49IDA7XG4gIHRoaXNFbmQgPj4+PSAwO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufTtcblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMTtcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgdmFsTGVuZ3RoIC89IDI7XG4gICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59O1xuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gIHZhciByZXMgPSBbXTtcblxuICB2YXIgaSA9IHN0YXJ0O1xuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxO1xuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7XG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwO1xuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pO1xuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBzdGFydCA9IH5+c3RhcnQ7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbjtcbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIHZhciBuZXdCdWY7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59O1xuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgdmFyIG11bCA9IDE7XG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gIH1cblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufTtcblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxO1xuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBpO1xuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGVuXG59O1xuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG4gIGlmICghdmFsKSB2YWwgPSAwO1xuXG4gIHZhciBpO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSk7XG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn07XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpO1xuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSc7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gIHZhciBjb2RlUG9pbnQ7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvO1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGkgPSBjID4+IDg7XG4gICAgbG8gPSBjICUgMjU2O1xuICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiB0b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG4vLyB0aGUgZm9sbG93aW5nIGlzIGZyb20gaXMtYnVmZmVyLCBhbHNvIGJ5IEZlcm9zcyBBYm91a2hhZGlqZWggYW5kIHdpdGggc2FtZSBsaXNlbmNlXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5mdW5jdGlvbiBpc0J1ZmZlciQxKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKCEhb2JqLl9pc0J1ZmZlciB8fCBpc0Zhc3RCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSlcbn1cblxuZnVuY3Rpb24gaXNGYXN0QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNGYXN0QnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cblxuLy8gTG9kYXNoIGltcGxlbWVudGF0aW9uIG9mIGBnZXRgXG5cbmNvbnN0IGNoYXJDb2RlT2ZEb3QgPSBcIi5cIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5jb25zdCByZVByb3BOYW1lID0gUmVnRXhwKFxuICAvLyBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgZG90IG9yIGJyYWNrZXQuXG4gIFwiW14uW1xcXFxdXStcIiArXG4gICAgXCJ8XCIgK1xuICAgIC8vIE9yIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBicmFja2V0cy5cbiAgICBcIlxcXFxbKD86XCIgK1xuICAgIC8vIE1hdGNoIGEgbm9uLXN0cmluZyBleHByZXNzaW9uLlxuICAgIFwiKFteXFxcIiddW15bXSopXCIgK1xuICAgIFwifFwiICtcbiAgICAvLyBPciBtYXRjaCBzdHJpbmdzIChzdXBwb3J0cyBlc2NhcGluZyBjaGFyYWN0ZXJzKS5cbiAgICBcIihbXFxcIiddKSgoPzooPyFcXFxcMilbXlxcXFxcXFxcXXxcXFxcXFxcXC4pKj8pXFxcXDJcIiArXG4gICAgXCIpXFxcXF1cIiArXG4gICAgXCJ8XCIgK1xuICAgIC8vIE9yIG1hdGNoIFwiXCIgYXMgdGhlIHNwYWNlIGJldHdlZW4gY29uc2VjdXRpdmUgZG90cyBvciBlbXB0eSBicmFja2V0cy5cbiAgICBcIig/PSg/OlxcXFwufFxcXFxbXFxcXF0pKD86XFxcXC58XFxcXFtcXFxcXXwkKSlcIixcbiAgXCJnXCIsXG4pO1xuY29uc3QgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLztcbmNvbnN0IHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuY29uc3QgZ2V0VGFnID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xufTtcblxuY29uc3QgaXNTeW1ib2wkMSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKFxuICAgIHR5cGUgPT09IFwic3ltYm9sXCIgfHxcbiAgICAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAmJiBnZXRUYWcodmFsdWUpID09PSBcIltvYmplY3QgU3ltYm9sXVwiKVxuICApO1xufTtcblxuY29uc3QgaXNLZXkgPSBmdW5jdGlvbiAodmFsdWUsIG9iamVjdCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKFxuICAgIHR5cGUgPT09IFwibnVtYmVyXCIgfHxcbiAgICB0eXBlID09PSBcInN5bWJvbFwiIHx8XG4gICAgdHlwZSA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAhdmFsdWUgfHxcbiAgICBpc1N5bWJvbCQxKHZhbHVlKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKVxuICApO1xufTtcblxuY29uc3Qgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gKHN0cmluZykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSBjaGFyQ29kZU9mRG90KSB7XG4gICAgcmVzdWx0LnB1c2goXCJcIik7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBleHByZXNzaW9uLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgbGV0IGtleSA9IG1hdGNoO1xuICAgIGlmIChxdW90ZSkge1xuICAgICAga2V5ID0gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCBcIiQxXCIpO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbikge1xuICAgICAga2V5ID0gZXhwcmVzc2lvbi50cmltKCk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY2FzdFBhdGggPSBmdW5jdGlvbiAodmFsdWUsIG9iamVjdCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG4gIH1cbn07XG5cbmNvbnN0IHRvS2V5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgaXNTeW1ib2wkMSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgY29uc3QgcmVzdWx0ID0gYCR7dmFsdWV9YDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHJldHVybiByZXN1bHQgPT0gXCIwXCIgJiYgMSAvIHZhbHVlID09IC1JTkZJTklUWSA/IFwiLTBcIiA6IHJlc3VsdDtcbn07XG5cbmNvbnN0IGdldCA9IGZ1bmN0aW9uIChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiBpbmRleCAmJiBpbmRleCA9PT0gbGVuZ3RoID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufTtcblxuY29uc3QgaXNfb2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZV9jb2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbnMpIHtcbiAgaWYgKGNvbHVtbnMgPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5zID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gIH1cbiAgaWYgKHR5cGVvZiBjb2x1bW5zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIFtFcnJvcignSW52YWxpZCBvcHRpb24gXCJjb2x1bW5zXCI6IGV4cGVjdCBhbiBhcnJheSBvciBhbiBvYmplY3QnKV07XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbHVtbnMpKSB7XG4gICAgY29uc3QgbmV3Y29sdW1ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgayBpbiBjb2x1bW5zKSB7XG4gICAgICBuZXdjb2x1bW5zLnB1c2goe1xuICAgICAgICBrZXk6IGssXG4gICAgICAgIGhlYWRlcjogY29sdW1uc1trXSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb2x1bW5zID0gbmV3Y29sdW1ucztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuZXdjb2x1bW5zID0gW107XG4gICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgICAgaWYgKHR5cGVvZiBjb2x1bW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmV3Y29sdW1ucy5wdXNoKHtcbiAgICAgICAgICBrZXk6IGNvbHVtbixcbiAgICAgICAgICBoZWFkZXI6IGNvbHVtbixcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2YgY29sdW1uID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGNvbHVtbiAhPT0gbnVsbCAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShjb2x1bW4pXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFjb2x1bW4ua2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEVycm9yKCdJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiBwcm9wZXJ0eSBcImtleVwiIGlzIHJlcXVpcmVkJyksXG4gICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uLmhlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29sdW1uLmhlYWRlciA9IGNvbHVtbi5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Y29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIEVycm9yKFwiSW52YWxpZCBjb2x1bW4gZGVmaW5pdGlvbjogZXhwZWN0IGEgc3RyaW5nIG9yIGFuIG9iamVjdFwiKSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29sdW1ucyA9IG5ld2NvbHVtbnM7XG4gIH1cbiAgcmV0dXJuIFt1bmRlZmluZWQsIGNvbHVtbnNdO1xufTtcblxuY2xhc3MgQ3N2RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIC4uLmNvbnRleHRzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIG1lc3NhZ2UgPSBtZXNzYWdlLmpvaW4oXCIgXCIpO1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDc3ZFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgZm9yIChjb25zdCBjb250ZXh0IG9mIGNvbnRleHRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dFtrZXldO1xuICAgICAgICB0aGlzW2tleV0gPSBpc0J1ZmZlciQxKHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgIDogdmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHVuZGVyc2NvcmUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoXywgbWF0Y2gpIHtcbiAgICByZXR1cm4gXCJfXCIgKyBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZV9vcHRpb25zID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAvLyBNZXJnZSB3aXRoIHVzZXIgb3B0aW9uc1xuICBmb3IgKGNvbnN0IG9wdCBpbiBvcHRzKSB7XG4gICAgb3B0aW9uc1t1bmRlcnNjb3JlKG9wdCldID0gb3B0c1tvcHRdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGJvbWBcbiAgaWYgKFxuICAgIG9wdGlvbnMuYm9tID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLmJvbSA9PT0gbnVsbCB8fFxuICAgIG9wdGlvbnMuYm9tID09PSBmYWxzZVxuICApIHtcbiAgICBvcHRpb25zLmJvbSA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuYm9tICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fQk9PTEVBTl9JTlZBTElEX1RZUEVcIiwgW1xuICAgICAgICBcIm9wdGlvbiBgYm9tYCBpcyBvcHRpb25hbCBhbmQgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWUsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvbSl9YCxcbiAgICAgIF0pLFxuICAgIF07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZGVsaW1pdGVyYFxuICBpZiAob3B0aW9ucy5kZWxpbWl0ZXIgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmRlbGltaXRlciA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gXCIsXCI7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIkMShvcHRpb25zLmRlbGltaXRlcikpIHtcbiAgICBvcHRpb25zLmRlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fREVMSU1JVEVSX0lOVkFMSURfVFlQRVwiLCBbXG4gICAgICAgIFwib3B0aW9uIGBkZWxpbWl0ZXJgIG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmRlbGltaXRlcil9YCxcbiAgICAgIF0pLFxuICAgIF07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVgXG4gIGlmIChvcHRpb25zLnF1b3RlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMucXVvdGUgPSAnXCInO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMucXVvdGUgPT09IHRydWUpIHtcbiAgICBvcHRpb25zLnF1b3RlID0gJ1wiJztcbiAgfSBlbHNlIGlmIChvcHRpb25zLnF1b3RlID09PSBmYWxzZSkge1xuICAgIG9wdGlvbnMucXVvdGUgPSBcIlwiO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyJDEob3B0aW9ucy5xdW90ZSkpIHtcbiAgICBvcHRpb25zLnF1b3RlID0gb3B0aW9ucy5xdW90ZS50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnF1b3RlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fUVVPVEVfSU5WQUxJRF9UWVBFXCIsIFtcbiAgICAgICAgXCJvcHRpb24gYHF1b3RlYCBtdXN0IGJlIGEgYm9vbGVhbiwgYSBidWZmZXIgb3IgYSBzdHJpbmcsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnF1b3RlKX1gLFxuICAgICAgXSksXG4gICAgXTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWRgXG4gIGlmIChvcHRpb25zLnF1b3RlZCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGVkID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy5xdW90ZWQgPSBmYWxzZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBlc2NhcGVfZm9ybXVsYXNgXG4gIGlmIChcbiAgICBvcHRpb25zLmVzY2FwZV9mb3JtdWxhcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgPT09IG51bGxcbiAgKSB7XG4gICAgb3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgPSBmYWxzZTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fRVNDQVBFX0ZPUk1VTEFTX0lOVkFMSURfVFlQRVwiLCBbXG4gICAgICAgIFwib3B0aW9uIGBlc2NhcGVfZm9ybXVsYXNgIG11c3QgYmUgYSBib29sZWFuLFwiLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMpfWAsXG4gICAgICBdKSxcbiAgICBdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHF1b3RlZF9lbXB0eWBcbiAgaWYgKG9wdGlvbnMucXVvdGVkX2VtcHR5ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZWRfZW1wdHkgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLnF1b3RlZF9lbXB0eSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWRfbWF0Y2hgXG4gIGlmIChcbiAgICBvcHRpb25zLnF1b3RlZF9tYXRjaCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5xdW90ZWRfbWF0Y2ggPT09IG51bGwgfHxcbiAgICBvcHRpb25zLnF1b3RlZF9tYXRjaCA9PT0gZmFsc2VcbiAgKSB7XG4gICAgb3B0aW9ucy5xdW90ZWRfbWF0Y2ggPSBudWxsO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMucXVvdGVkX21hdGNoKSkge1xuICAgIG9wdGlvbnMucXVvdGVkX21hdGNoID0gW29wdGlvbnMucXVvdGVkX21hdGNoXTtcbiAgfVxuICBpZiAob3B0aW9ucy5xdW90ZWRfbWF0Y2gpIHtcbiAgICBmb3IgKGNvbnN0IHF1b3RlZF9tYXRjaCBvZiBvcHRpb25zLnF1b3RlZF9tYXRjaCkge1xuICAgICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgcXVvdGVkX21hdGNoID09PSBcInN0cmluZ1wiO1xuICAgICAgY29uc3QgaXNSZWdFeHAgPSBxdW90ZWRfbWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICBpZiAoIWlzU3RyaW5nICYmICFpc1JlZ0V4cCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgT3B0aW9uOiBxdW90ZWRfbWF0Y2ggbXVzdCBiZSBhIHN0cmluZyBvciBhIHJlZ2V4LCBnb3QgJHtKU09OLnN0cmluZ2lmeShxdW90ZWRfbWF0Y2gpfWAsXG4gICAgICAgICAgKSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVkX3N0cmluZ2BcbiAgaWYgKG9wdGlvbnMucXVvdGVkX3N0cmluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGVkX3N0cmluZyA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMucXVvdGVkX3N0cmluZyA9IGZhbHNlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGVvZmBcbiAgaWYgKG9wdGlvbnMuZW9mID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5lb2YgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLmVvZiA9IHRydWU7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZXNjYXBlYFxuICBpZiAob3B0aW9ucy5lc2NhcGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmVzY2FwZSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuZXNjYXBlID0gJ1wiJztcbiAgfSBlbHNlIGlmIChpc0J1ZmZlciQxKG9wdGlvbnMuZXNjYXBlKSkge1xuICAgIG9wdGlvbnMuZXNjYXBlID0gb3B0aW9ucy5lc2NhcGUudG9TdHJpbmcoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lc2NhcGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIE9wdGlvbjogZXNjYXBlIG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcsIGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuZXNjYXBlKX1gLFxuICAgICAgKSxcbiAgICBdO1xuICB9XG4gIGlmIChvcHRpb25zLmVzY2FwZS5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIEVycm9yKFxuICAgICAgICBgSW52YWxpZCBPcHRpb246IGVzY2FwZSBtdXN0IGJlIG9uZSBjaGFyYWN0ZXIsIGdvdCAke29wdGlvbnMuZXNjYXBlLmxlbmd0aH0gY2hhcmFjdGVyc2AsXG4gICAgICApLFxuICAgIF07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgaGVhZGVyYFxuICBpZiAob3B0aW9ucy5oZWFkZXIgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmhlYWRlciA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuaGVhZGVyID0gZmFsc2U7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgY29sdW1uc2BcbiAgY29uc3QgW2VyckNvbHVtbnMsIGNvbHVtbnNdID0gbm9ybWFsaXplX2NvbHVtbnMob3B0aW9ucy5jb2x1bW5zKTtcbiAgaWYgKGVyckNvbHVtbnMgIT09IHVuZGVmaW5lZCkgcmV0dXJuIFtlcnJDb2x1bW5zXTtcbiAgb3B0aW9ucy5jb2x1bW5zID0gY29sdW1ucztcbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVkYFxuICBpZiAob3B0aW9ucy5xdW90ZWQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnF1b3RlZCA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMucXVvdGVkID0gZmFsc2U7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgY2FzdGBcbiAgaWYgKG9wdGlvbnMuY2FzdCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdCA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuY2FzdCA9IHt9O1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5iaWdpbnRcbiAgaWYgKG9wdGlvbnMuY2FzdC5iaWdpbnQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3QuYmlnaW50ID09PSBudWxsKSB7XG4gICAgLy8gQ2FzdCBib29sZWFuIHRvIHN0cmluZyBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0LmJpZ2ludCA9ICh2YWx1ZSkgPT4gXCJcIiArIHZhbHVlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5ib29sZWFuXG4gIGlmIChvcHRpb25zLmNhc3QuYm9vbGVhbiA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5ib29sZWFuID09PSBudWxsKSB7XG4gICAgLy8gQ2FzdCBib29sZWFuIHRvIHN0cmluZyBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0LmJvb2xlYW4gPSAodmFsdWUpID0+ICh2YWx1ZSA/IFwiMVwiIDogXCJcIik7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBjYXN0LmRhdGVcbiAgaWYgKG9wdGlvbnMuY2FzdC5kYXRlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0LmRhdGUgPT09IG51bGwpIHtcbiAgICAvLyBDYXN0IGRhdGUgdG8gdGltZXN0YW1wIHN0cmluZyBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0LmRhdGUgPSAodmFsdWUpID0+IFwiXCIgKyB2YWx1ZS5nZXRUaW1lKCk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBjYXN0Lm51bWJlclxuICBpZiAob3B0aW9ucy5jYXN0Lm51bWJlciA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5udW1iZXIgPT09IG51bGwpIHtcbiAgICAvLyBDYXN0IG51bWJlciB0byBzdHJpbmcgdXNpbmcgbmF0aXZlIGNhc3RpbmcgYnkgZGVmYXVsdFxuICAgIG9wdGlvbnMuY2FzdC5udW1iZXIgPSAodmFsdWUpID0+IFwiXCIgKyB2YWx1ZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGNhc3Qub2JqZWN0XG4gIGlmIChvcHRpb25zLmNhc3Qub2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0Lm9iamVjdCA9PT0gbnVsbCkge1xuICAgIC8vIFN0cmluZ2lmeSBvYmplY3QgYXMgSlNPTiBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0Lm9iamVjdCA9ICh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5zdHJpbmdcbiAgaWYgKG9wdGlvbnMuY2FzdC5zdHJpbmcgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3Quc3RyaW5nID09PSBudWxsKSB7XG4gICAgLy8gTGVhdmUgc3RyaW5nIHVudG91Y2hlZFxuICAgIG9wdGlvbnMuY2FzdC5zdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYG9uX3JlY29yZGBcbiAgaWYgKFxuICAgIG9wdGlvbnMub25fcmVjb3JkICE9PSB1bmRlZmluZWQgJiZcbiAgICB0eXBlb2Ygb3B0aW9ucy5vbl9yZWNvcmQgIT09IFwiZnVuY3Rpb25cIlxuICApIHtcbiAgICByZXR1cm4gW0Vycm9yKGBJbnZhbGlkIE9wdGlvbjogXCJvbl9yZWNvcmRcIiBtdXN0IGJlIGEgZnVuY3Rpb24uYCldO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHJlY29yZF9kZWxpbWl0ZXJgXG4gIGlmIChcbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9PT0gbnVsbFxuICApIHtcbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBcIlxcblwiO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyJDEob3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyKSkge1xuICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IG9wdGlvbnMucmVjb3JkX2RlbGltaXRlci50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIE9wdGlvbjogcmVjb3JkX2RlbGltaXRlciBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpfWAsXG4gICAgICApLFxuICAgIF07XG4gIH1cbiAgc3dpdGNoIChvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpIHtcbiAgICBjYXNlIFwidW5peFwiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXG5cIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtYWNcIjpcbiAgICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFwiXFxyXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwid2luZG93c1wiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXHJcXG5cIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXHUwMDFlXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidW5pY29kZVwiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXHUyMDI4XCI7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gW3VuZGVmaW5lZCwgb3B0aW9uc107XG59O1xuXG5jb25zdCBib21fdXRmOCA9IEJ1ZmZlci5mcm9tKFsyMzksIDE4NywgMTkxXSk7XG5cbmNvbnN0IHN0cmluZ2lmaWVyID0gZnVuY3Rpb24gKG9wdGlvbnMsIHN0YXRlLCBpbmZvKSB7XG4gIHJldHVybiB7XG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgaW5mbzogaW5mbyxcbiAgICBfX3RyYW5zZm9ybTogZnVuY3Rpb24gKGNodW5rLCBwdXNoKSB7XG4gICAgICAvLyBDaHVuayB2YWxpZGF0aW9uXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgUmVjb3JkOiBleHBlY3QgYW4gYXJyYXkgb3IgYW4gb2JqZWN0LCBnb3QgJHtKU09OLnN0cmluZ2lmeShjaHVuayl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBjb2x1bW5zIGZyb20gdGhlIGZpcnN0IHJlY29yZFxuICAgICAgaWYgKHRoaXMuaW5mby5yZWNvcmRzID09PSAwKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNodW5rKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oZWFkZXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb2x1bW5zID09PSB1bmRlZmluZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcihcbiAgICAgICAgICAgICAgXCJVbmRpc2NvdmVyYWJsZSBDb2x1bW5zOiBoZWFkZXIgb3B0aW9uIHJlcXVpcmVzIGNvbHVtbiBvcHRpb24gb3Igb2JqZWN0IHJlY29yZHNcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb2x1bW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBbZXJyLCBjb2x1bW5zXSA9IG5vcm1hbGl6ZV9jb2x1bW5zKE9iamVjdC5rZXlzKGNodW5rKSk7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5jb2x1bW5zID0gY29sdW1ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRW1pdCB0aGUgaGVhZGVyXG4gICAgICBpZiAodGhpcy5pbmZvLnJlY29yZHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5ib20ocHVzaCk7XG4gICAgICAgIGNvbnN0IGVyciA9IHRoaXMuaGVhZGVycyhwdXNoKTtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIC8vIEVtaXQgYW5kIHN0cmluZ2lmeSB0aGUgcmVjb3JkIGlmIGFuIG9iamVjdCBvciBhbiBhcnJheVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdGhpcy5lbWl0KCdyZWNvcmQnLCBjaHVuaywgdGhpcy5pbmZvLnJlY29yZHMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uX3JlY29yZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbl9yZWNvcmQoY2h1bmssIHRoaXMuaW5mby5yZWNvcmRzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICAvLyBDb252ZXJ0IHRoZSByZWNvcmQgaW50byBhIHN0cmluZ1xuICAgICAgbGV0IGVyciwgY2h1bmtfc3RyaW5nO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lb2YpIHtcbiAgICAgICAgW2VyciwgY2h1bmtfc3RyaW5nXSA9IHRoaXMuc3RyaW5naWZ5KGNodW5rKTtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGVycjtcbiAgICAgICAgaWYgKGNodW5rX3N0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNodW5rX3N0cmluZyA9IGNodW5rX3N0cmluZyArIHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbZXJyLCBjaHVua19zdHJpbmddID0gdGhpcy5zdHJpbmdpZnkoY2h1bmspO1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gZXJyO1xuICAgICAgICBpZiAoY2h1bmtfc3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXIgfHwgdGhpcy5pbmZvLnJlY29yZHMpIHtcbiAgICAgICAgICAgIGNodW5rX3N0cmluZyA9IHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyICsgY2h1bmtfc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRW1pdCB0aGUgY3N2XG4gICAgICB0aGlzLmluZm8ucmVjb3JkcysrO1xuICAgICAgcHVzaChjaHVua19zdHJpbmcpO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2h1bmssIGNodW5rSXNIZWFkZXIgPSBmYWxzZSkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgY2h1bmtdO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjb2x1bW5zIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCByZWNvcmQgPSBbXTtcbiAgICAgIC8vIFJlY29yZCBpcyBhbiBhcnJheVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2h1bmspKSB7XG4gICAgICAgIC8vIFdlIGFyZSBnZXR0aW5nIGFuIGFycmF5IGJ1dCB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIG91dHB1dCBjb2x1bW5zLiBJblxuICAgICAgICAvLyB0aGlzIGNhc2UsIHdlIHJlc3BlY3QgdGhlIGNvbHVtbnMgaW5kZXhlc1xuICAgICAgICBpZiAoY29sdW1ucykge1xuICAgICAgICAgIGNodW5rLnNwbGljZShjb2x1bW5zLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FzdCByZWNvcmQgZWxlbWVudHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkID0gY2h1bmtbaV07XG4gICAgICAgICAgY29uc3QgW2VyciwgdmFsdWVdID0gdGhpcy5fX2Nhc3QoZmllbGQsIHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgY29sdW1uOiBpLFxuICAgICAgICAgICAgcmVjb3JkczogdGhpcy5pbmZvLnJlY29yZHMsXG4gICAgICAgICAgICBoZWFkZXI6IGNodW5rSXNIZWFkZXIsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIFtlcnJdO1xuICAgICAgICAgIHJlY29yZFtpXSA9IFt2YWx1ZSwgZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY29yZCBpcyBhIGxpdGVyYWwgb2JqZWN0XG4gICAgICAgIC8vIGBjb2x1bW5zYCBpcyBhbHdheXMgZGVmaW5lZDogaXQgaXMgZWl0aGVyIHByb3ZpZGVkIG9yIGRpc2NvdmVyZWQuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChjaHVuaywgY29sdW1uc1tpXS5rZXkpO1xuICAgICAgICAgIGNvbnN0IFtlcnIsIHZhbHVlXSA9IHRoaXMuX19jYXN0KGZpZWxkLCB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uc1tpXS5rZXksXG4gICAgICAgICAgICByZWNvcmRzOiB0aGlzLmluZm8ucmVjb3JkcyxcbiAgICAgICAgICAgIGhlYWRlcjogY2h1bmtJc0hlYWRlcixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gW2Vycl07XG4gICAgICAgICAgcmVjb3JkW2ldID0gW3ZhbHVlLCBmaWVsZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjc3ZyZWNvcmQgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvcmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG9wdGlvbnMsIGVycjtcblxuICAgICAgICBsZXQgW3ZhbHVlLCBmaWVsZF0gPSByZWNvcmRbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX29iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICBvcHRpb25zID0gdmFsdWU7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnZhbHVlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgSW52YWxpZCBDYXN0aW5nIFZhbHVlOiByZXR1cm5lZCB2YWx1ZSBtdXN0IHJldHVybiBhIHN0cmluZywgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgIFtlcnIsIG9wdGlvbnNdID0gbm9ybWFsaXplX29wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Vycl07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgQ2FzdGluZyBWYWx1ZTogcmV0dXJuZWQgdmFsdWUgbXVzdCByZXR1cm4gYSBzdHJpbmcsIGFuIG9iamVjdCwgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkZWxpbWl0ZXIsXG4gICAgICAgICAgZXNjYXBlLFxuICAgICAgICAgIHF1b3RlLFxuICAgICAgICAgIHF1b3RlZCxcbiAgICAgICAgICBxdW90ZWRfZW1wdHksXG4gICAgICAgICAgcXVvdGVkX3N0cmluZyxcbiAgICAgICAgICBxdW90ZWRfbWF0Y2gsXG4gICAgICAgICAgcmVjb3JkX2RlbGltaXRlcixcbiAgICAgICAgICBlc2NhcGVfZm9ybXVsYXMsXG4gICAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoXCJcIiA9PT0gdmFsdWUgJiYgXCJcIiA9PT0gZmllbGQpIHtcbiAgICAgICAgICBsZXQgcXVvdGVkTWF0Y2ggPVxuICAgICAgICAgICAgcXVvdGVkX21hdGNoICYmXG4gICAgICAgICAgICBxdW90ZWRfbWF0Y2guZmlsdGVyKChxdW90ZWRfbWF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxdW90ZWRfbWF0Y2ggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihxdW90ZWRfbWF0Y2gpICE9PSAtMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGVkX21hdGNoLnRlc3QodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBxdW90ZWRNYXRjaCA9IHF1b3RlZE1hdGNoICYmIHF1b3RlZE1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkUXVvdGUgPVxuICAgICAgICAgICAgcXVvdGVkTWF0Y2ggfHxcbiAgICAgICAgICAgIHRydWUgPT09IHF1b3RlZF9lbXB0eSB8fFxuICAgICAgICAgICAgKHRydWUgPT09IHF1b3RlZF9zdHJpbmcgJiYgZmFsc2UgIT09IHF1b3RlZF9lbXB0eSk7XG4gICAgICAgICAgaWYgKHNob3VsZFF1b3RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHF1b3RlICsgdmFsdWUgKyBxdW90ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3N2cmVjb3JkICs9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEZvcm1hdHRlciBtdXN0IHJldHVybiBhIHN0cmluZywgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29udGFpbnNkZWxpbWl0ZXIgPVxuICAgICAgICAgICAgZGVsaW1pdGVyLmxlbmd0aCAmJiB2YWx1ZS5pbmRleE9mKGRlbGltaXRlcikgPj0gMDtcbiAgICAgICAgICBjb25zdCBjb250YWluc1F1b3RlID0gcXVvdGUgIT09IFwiXCIgJiYgdmFsdWUuaW5kZXhPZihxdW90ZSkgPj0gMDtcbiAgICAgICAgICBjb25zdCBjb250YWluc0VzY2FwZSA9IHZhbHVlLmluZGV4T2YoZXNjYXBlKSA+PSAwICYmIGVzY2FwZSAhPT0gcXVvdGU7XG4gICAgICAgICAgY29uc3QgY29udGFpbnNSZWNvcmREZWxpbWl0ZXIgPSB2YWx1ZS5pbmRleE9mKHJlY29yZF9kZWxpbWl0ZXIpID49IDA7XG4gICAgICAgICAgY29uc3QgcXVvdGVkU3RyaW5nID0gcXVvdGVkX3N0cmluZyAmJiB0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgbGV0IHF1b3RlZE1hdGNoID1cbiAgICAgICAgICAgIHF1b3RlZF9tYXRjaCAmJlxuICAgICAgICAgICAgcXVvdGVkX21hdGNoLmZpbHRlcigocXVvdGVkX21hdGNoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcXVvdGVkX21hdGNoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmluZGV4T2YocXVvdGVkX21hdGNoKSAhPT0gLTE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1b3RlZF9tYXRjaC50ZXN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgcXVvdGVkTWF0Y2ggPSBxdW90ZWRNYXRjaCAmJiBxdW90ZWRNYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYWRhbHRhcy9ub2RlLWNzdi9wdWxsLzM4N1xuICAgICAgICAgIC8vIE1vcmUgYWJvdXQgQ1NWIGluamVjdGlvbiBvciBmb3JtdWxhIGluamVjdGlvbiwgd2hlbiB3ZWJzaXRlcyBlbWJlZFxuICAgICAgICAgIC8vIHVudHJ1c3RlZCBpbnB1dCBpbnNpZGUgQ1NWIGZpbGVzOlxuICAgICAgICAgIC8vIGh0dHBzOi8vb3dhc3Aub3JnL3d3dy1jb21tdW5pdHkvYXR0YWNrcy9DU1ZfSW5qZWN0aW9uXG4gICAgICAgICAgLy8gaHR0cDovL2dlb3JnZW1hdWVyLm5ldC8yMDE3LzEwLzA3L2Nzdi1pbmplY3Rpb24uaHRtbFxuICAgICAgICAgIC8vIEFwcGxlIE51bWJlcnMgdW5pY29kZSBub3JtYWxpemF0aW9uIGlzIGVtcGlyaWNhbCBmcm9tIHRlc3RpbmdcbiAgICAgICAgICBpZiAoZXNjYXBlX2Zvcm11bGFzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJAXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYxRFwiOiAvLyBVbmljb2RlICc9J1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYwQlwiOiAvLyBVbmljb2RlICcrJ1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYwRFwiOiAvLyBVbmljb2RlICctJ1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYyMFwiOiAvLyBVbmljb2RlICdAJ1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYCcke3ZhbHVlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNob3VsZFF1b3RlID1cbiAgICAgICAgICAgIGNvbnRhaW5zUXVvdGUgPT09IHRydWUgfHxcbiAgICAgICAgICAgIGNvbnRhaW5zZGVsaW1pdGVyIHx8XG4gICAgICAgICAgICBjb250YWluc1JlY29yZERlbGltaXRlciB8fFxuICAgICAgICAgICAgcXVvdGVkIHx8XG4gICAgICAgICAgICBxdW90ZWRTdHJpbmcgfHxcbiAgICAgICAgICAgIHF1b3RlZE1hdGNoO1xuICAgICAgICAgIGlmIChzaG91bGRRdW90ZSA9PT0gdHJ1ZSAmJiBjb250YWluc0VzY2FwZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXhwID1cbiAgICAgICAgICAgICAgZXNjYXBlID09PSBcIlxcXFxcIlxuICAgICAgICAgICAgICAgID8gbmV3IFJlZ0V4cChlc2NhcGUgKyBlc2NhcGUsIFwiZ1wiKVxuICAgICAgICAgICAgICAgIDogbmV3IFJlZ0V4cChlc2NhcGUsIFwiZ1wiKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZWdleHAsIGVzY2FwZSArIGVzY2FwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb250YWluc1F1b3RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKHF1b3RlLCBcImdcIik7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVnZXhwLCBlc2NhcGUgKyBxdW90ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGRRdW90ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBxdW90ZSArIHZhbHVlICsgcXVvdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNzdnJlY29yZCArPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBxdW90ZWRfZW1wdHkgPT09IHRydWUgfHxcbiAgICAgICAgICAoZmllbGQgPT09IFwiXCIgJiYgcXVvdGVkX3N0cmluZyA9PT0gdHJ1ZSAmJiBxdW90ZWRfZW1wdHkgIT09IGZhbHNlKVxuICAgICAgICApIHtcbiAgICAgICAgICBjc3ZyZWNvcmQgKz0gcXVvdGUgKyBxdW90ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAhPT0gcmVjb3JkLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjc3ZyZWNvcmQgKz0gZGVsaW1pdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW3VuZGVmaW5lZCwgY3N2cmVjb3JkXTtcbiAgICB9LFxuICAgIGJvbTogZnVuY3Rpb24gKHB1c2gpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm9tICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHB1c2goYm9tX3V0ZjgpO1xuICAgIH0sXG4gICAgaGVhZGVyczogZnVuY3Rpb24gKHB1c2gpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVyID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbHVtbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZXJyO1xuICAgICAgbGV0IGhlYWRlcnMgPSB0aGlzLm9wdGlvbnMuY29sdW1ucy5tYXAoKGNvbHVtbikgPT4gY29sdW1uLmhlYWRlcik7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVvZikge1xuICAgICAgICBbZXJyLCBoZWFkZXJzXSA9IHRoaXMuc3RyaW5naWZ5KGhlYWRlcnMsIHRydWUpO1xuICAgICAgICBoZWFkZXJzICs9IHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgW2VyciwgaGVhZGVyc10gPSB0aGlzLnN0cmluZ2lmeShoZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIpIHJldHVybiBlcnI7XG4gICAgICBwdXNoKGhlYWRlcnMpO1xuICAgIH0sXG4gICAgX19jYXN0OiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIC8vIEZpbmUgZm9yIDk5JSBvZiB0aGUgY2FzZXNcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3Quc3RyaW5nKHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMuY2FzdC5iaWdpbnQodmFsdWUsIGNvbnRleHQpXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0Lm51bWJlcih2YWx1ZSwgY29udGV4dCldO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0LmJvb2xlYW4odmFsdWUsIGNvbnRleHQpXTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3QuZGF0ZSh2YWx1ZSwgY29udGV4dCldO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3Qub2JqZWN0KHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHZhbHVlLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gW2Vycl07XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn07XG5cbmNvbnN0IHN0cmluZ2lmeSA9IGZ1bmN0aW9uIChyZWNvcmRzLCBvcHRzID0ge30pIHtcbiAgY29uc3QgZGF0YSA9IFtdO1xuICBjb25zdCBbZXJyLCBvcHRpb25zXSA9IG5vcm1hbGl6ZV9vcHRpb25zKG9wdHMpO1xuICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHRocm93IGVycjtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgc3RvcDogZmFsc2UsXG4gIH07XG4gIC8vIEluZm9ybWF0aW9uXG4gIGNvbnN0IGluZm8gPSB7XG4gICAgcmVjb3JkczogMCxcbiAgfTtcbiAgY29uc3QgYXBpID0gc3RyaW5naWZpZXIob3B0aW9ucywgc3RhdGUsIGluZm8pO1xuICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgY29uc3QgZXJyID0gYXBpLl9fdHJhbnNmb3JtKHJlY29yZCwgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgZGF0YS5wdXNoKHJlY29yZCk7XG4gICAgfSk7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnI7XG4gIH1cbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgYXBpLmJvbSgoZCkgPT4ge1xuICAgICAgZGF0YS5wdXNoKGQpO1xuICAgIH0pO1xuICAgIGNvbnN0IGVyciA9IGFwaS5oZWFkZXJzKChoZWFkZXJzKSA9PiB7XG4gICAgICBkYXRhLnB1c2goaGVhZGVycyk7XG4gICAgfSk7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGRhdGEuam9pbihcIlwiKTtcbn07XG5cbnZhciBnZXROYXRpdmUgPSBfZ2V0TmF0aXZlO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHkkMjtcblxudmFyIGRlZmluZVByb3BlcnR5JDEgPSBfZGVmaW5lUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUkNihvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSQxKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkMShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbnZhciBfYmFzZUFzc2lnblZhbHVlID0gYmFzZUFzc2lnblZhbHVlJDY7XG5cbnZhciBiYXNlQXNzaWduVmFsdWUkNSA9IF9iYXNlQXNzaWduVmFsdWUsXG4gICAgYmFzZUZvck93biQxID0gX2Jhc2VGb3JPd24sXG4gICAgYmFzZUl0ZXJhdGVlJDMgPSBfYmFzZUl0ZXJhdGVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICogQHNlZSBfLm1hcEtleXNcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0ge1xuICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAqIH07XG4gKlxuICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUkMyhpdGVyYXRlZSk7XG5cbiAgYmFzZUZvck93biQxKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgYmFzZUFzc2lnblZhbHVlJDUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIG1hcFZhbHVlc18xID0gbWFwVmFsdWVzO1xuXG52YXIgbWFwVmFsdWVzJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobWFwVmFsdWVzXzEpO1xuXG52YXIgYmFzZUFzc2lnblZhbHVlJDQgPSBfYmFzZUFzc2lnblZhbHVlLFxuICAgIGVxJDIgPSBlcV8xO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZSQyKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxJDIob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlJDQob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgX2Fzc2lnbk1lcmdlVmFsdWUgPSBhc3NpZ25NZXJnZVZhbHVlJDI7XG5cbnZhciBfY2xvbmVCdWZmZXIgPSB7ZXhwb3J0czoge319O1xuXG5fY2xvbmVCdWZmZXIuZXhwb3J0cztcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0dmFyIHJvb3QgPSBfcm9vdDtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuXHR2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuXHQvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuXHR2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuXHQvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0dmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcblx0ICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG5cdCAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG5cdCAqL1xuXHRmdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuXHQgIGlmIChpc0RlZXApIHtcblx0ICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcblx0ICB9XG5cdCAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG5cdCAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuXHQgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7IFxufSAoX2Nsb25lQnVmZmVyLCBfY2xvbmVCdWZmZXIuZXhwb3J0cykpO1xuXG52YXIgX2Nsb25lQnVmZmVyRXhwb3J0cyA9IF9jbG9uZUJ1ZmZlci5leHBvcnRzO1xuXG52YXIgVWludDhBcnJheSQxID0gX1VpbnQ4QXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIkMShhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheSQxKHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5JDEoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9jbG9uZUFycmF5QnVmZmVyID0gY2xvbmVBcnJheUJ1ZmZlciQxO1xuXG52YXIgY2xvbmVBcnJheUJ1ZmZlciA9IF9jbG9uZUFycmF5QnVmZmVyO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSQxKHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbnZhciBfY2xvbmVUeXBlZEFycmF5ID0gY2xvbmVUeXBlZEFycmF5JDE7XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuXG5mdW5jdGlvbiBjb3B5QXJyYXkkMShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxudmFyIF9jb3B5QXJyYXkgPSBjb3B5QXJyYXkkMTtcblxudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdF8xO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSQxID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0JDQocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxudmFyIF9iYXNlQ3JlYXRlID0gYmFzZUNyZWF0ZSQxO1xuXG52YXIgb3ZlckFyZyA9IF9vdmVyQXJnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUkMiA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG52YXIgX2dldFByb3RvdHlwZSA9IGdldFByb3RvdHlwZSQyO1xuXG52YXIgYmFzZUNyZWF0ZSA9IF9iYXNlQ3JlYXRlLFxuICAgIGdldFByb3RvdHlwZSQxID0gX2dldFByb3RvdHlwZSxcbiAgICBpc1Byb3RvdHlwZSQxID0gX2lzUHJvdG90eXBlO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdCQxKG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUkMShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUkMShvYmplY3QpKVxuICAgIDoge307XG59XG5cbnZhciBfaW5pdENsb25lT2JqZWN0ID0gaW5pdENsb25lT2JqZWN0JDE7XG5cbnZhciBpc0FycmF5TGlrZSQzID0gaXNBcnJheUxpa2VfMSxcbiAgICBpc09iamVjdExpa2UkMSA9IGlzT2JqZWN0TGlrZV8xO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCQxKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UkMSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UkMyh2YWx1ZSk7XG59XG5cbnZhciBpc0FycmF5TGlrZU9iamVjdF8xID0gaXNBcnJheUxpa2VPYmplY3QkMTtcblxudmFyIGJhc2VHZXRUYWcgPSBfYmFzZUdldFRhZyxcbiAgICBnZXRQcm90b3R5cGUgPSBfZ2V0UHJvdG90eXBlLFxuICAgIGlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZV8xO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDIgPSBvYmplY3RQcm90byQyLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QkMSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkkMi5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG52YXIgaXNQbGFpbk9iamVjdF8xID0gaXNQbGFpbk9iamVjdCQxO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cbmZ1bmN0aW9uIHNhZmVHZXQkMihvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5cbnZhciBfc2FmZUdldCA9IHNhZmVHZXQkMjtcblxudmFyIGJhc2VBc3NpZ25WYWx1ZSQzID0gX2Jhc2VBc3NpZ25WYWx1ZSxcbiAgICBlcSQxID0gZXFfMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlJDEob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eSQxLmNhbGwob2JqZWN0LCBrZXkpICYmIGVxJDEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlJDMob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgX2Fzc2lnblZhbHVlID0gYXNzaWduVmFsdWUkMTtcblxudmFyIGFzc2lnblZhbHVlID0gX2Fzc2lnblZhbHVlLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSQyID0gX2Jhc2VBc3NpZ25WYWx1ZTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdCQxKHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUkMihvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG52YXIgX2NvcHlPYmplY3QgPSBjb3B5T2JqZWN0JDE7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbiQxKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9uYXRpdmVLZXlzSW4gPSBuYXRpdmVLZXlzSW4kMTtcblxudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdF8xLFxuICAgIGlzUHJvdG90eXBlID0gX2lzUHJvdG90eXBlLFxuICAgIG5hdGl2ZUtleXNJbiA9IF9uYXRpdmVLZXlzSW47XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4kMShvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdCQzKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VLZXlzSW4gPSBiYXNlS2V5c0luJDE7XG5cbnZhciBhcnJheUxpa2VLZXlzID0gX2FycmF5TGlrZUtleXMsXG4gICAgYmFzZUtleXNJbiA9IF9iYXNlS2V5c0luLFxuICAgIGlzQXJyYXlMaWtlJDIgPSBpc0FycmF5TGlrZV8xO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luJDIob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZSQyKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbnZhciBrZXlzSW5fMSA9IGtleXNJbiQyO1xuXG52YXIgY29weU9iamVjdCA9IF9jb3B5T2JqZWN0LFxuICAgIGtleXNJbiQxID0ga2V5c0luXzE7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0JDEodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbiQxKHZhbHVlKSk7XG59XG5cbnZhciB0b1BsYWluT2JqZWN0XzEgPSB0b1BsYWluT2JqZWN0JDE7XG5cbnZhciBhc3NpZ25NZXJnZVZhbHVlJDEgPSBfYXNzaWduTWVyZ2VWYWx1ZSxcbiAgICBjbG9uZUJ1ZmZlciA9IF9jbG9uZUJ1ZmZlckV4cG9ydHMsXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gX2Nsb25lVHlwZWRBcnJheSxcbiAgICBjb3B5QXJyYXkgPSBfY29weUFycmF5LFxuICAgIGluaXRDbG9uZU9iamVjdCA9IF9pbml0Q2xvbmVPYmplY3QsXG4gICAgaXNBcmd1bWVudHMkMSA9IGlzQXJndW1lbnRzXzEsXG4gICAgaXNBcnJheSQzID0gaXNBcnJheV8xLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gaXNBcnJheUxpa2VPYmplY3RfMSxcbiAgICBpc0J1ZmZlciA9IGlzQnVmZmVyRXhwb3J0cyxcbiAgICBpc0Z1bmN0aW9uID0gaXNGdW5jdGlvbl8xLFxuICAgIGlzT2JqZWN0JDIgPSBpc09iamVjdF8xLFxuICAgIGlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0XzEsXG4gICAgaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5XzEsXG4gICAgc2FmZUdldCQxID0gX3NhZmVHZXQsXG4gICAgdG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3RfMTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwJDEob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldCQxKG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldCQxKHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZSQxKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkkMyhzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5JDMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMkMShzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMkMShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdCQyKG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUkMShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG52YXIgX2Jhc2VNZXJnZURlZXAgPSBiYXNlTWVyZ2VEZWVwJDE7XG5cbnZhciBTdGFjayA9IF9TdGFjayxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gX2Fzc2lnbk1lcmdlVmFsdWUsXG4gICAgYmFzZUZvciA9IF9iYXNlRm9yLFxuICAgIGJhc2VNZXJnZURlZXAgPSBfYmFzZU1lcmdlRGVlcCxcbiAgICBpc09iamVjdCQxID0gaXNPYmplY3RfMSxcbiAgICBrZXlzSW4gPSBrZXlzSW5fMSxcbiAgICBzYWZlR2V0ID0gX3NhZmVHZXQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZSQyKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICBpZiAoaXNPYmplY3QkMShzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSQyLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxudmFyIF9iYXNlTWVyZ2UgPSBiYXNlTWVyZ2UkMjtcblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuXG5mdW5jdGlvbiBhcHBseSQxKGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxudmFyIF9hcHBseSA9IGFwcGx5JDE7XG5cbnZhciBhcHBseSA9IF9hcHBseTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0JDEoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG52YXIgX292ZXJSZXN0ID0gb3ZlclJlc3QkMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cblxuZnVuY3Rpb24gY29uc3RhbnQkMSh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG52YXIgY29uc3RhbnRfMSA9IGNvbnN0YW50JDE7XG5cbnZhciBjb25zdGFudCA9IGNvbnN0YW50XzEsXG4gICAgZGVmaW5lUHJvcGVydHkgPSBfZGVmaW5lUHJvcGVydHksXG4gICAgaWRlbnRpdHkkMiA9IGlkZW50aXR5XzE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyQxID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkkMiA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxudmFyIF9iYXNlU2V0VG9TdHJpbmcgPSBiYXNlU2V0VG9TdHJpbmckMTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQkMShmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIF9zaG9ydE91dCA9IHNob3J0T3V0JDE7XG5cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSBfYmFzZVNldFRvU3RyaW5nLFxuICAgIHNob3J0T3V0ID0gX3Nob3J0T3V0O1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmckMSA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbnZhciBfc2V0VG9TdHJpbmcgPSBzZXRUb1N0cmluZyQxO1xuXG52YXIgaWRlbnRpdHkkMSA9IGlkZW50aXR5XzEsXG4gICAgb3ZlclJlc3QgPSBfb3ZlclJlc3QsXG4gICAgc2V0VG9TdHJpbmcgPSBfc2V0VG9TdHJpbmc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0JDIoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSQxKSwgZnVuYyArICcnKTtcbn1cblxudmFyIF9iYXNlUmVzdCA9IGJhc2VSZXN0JDI7XG5cbnZhciBlcSA9IGVxXzEsXG4gICAgaXNBcnJheUxpa2UkMSA9IGlzQXJyYXlMaWtlXzEsXG4gICAgaXNJbmRleCA9IF9pc0luZGV4LFxuICAgIGlzT2JqZWN0ID0gaXNPYmplY3RfMTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwkMih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlJDEob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIF9pc0l0ZXJhdGVlQ2FsbCA9IGlzSXRlcmF0ZWVDYWxsJDI7XG5cbnZhciBiYXNlUmVzdCQxID0gX2Jhc2VSZXN0LFxuICAgIGlzSXRlcmF0ZWVDYWxsJDEgPSBfaXNJdGVyYXRlZUNhbGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIkMihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QkMShmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbCQxKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbnZhciBfY3JlYXRlQXNzaWduZXIgPSBjcmVhdGVBc3NpZ25lciQyO1xuXG52YXIgYmFzZU1lcmdlJDEgPSBfYmFzZU1lcmdlLFxuICAgIGNyZWF0ZUFzc2lnbmVyJDEgPSBfY3JlYXRlQXNzaWduZXI7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyJDEoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZSQxKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxudmFyIG1lcmdlXzEgPSBtZXJnZTtcblxudmFyIG1lcmdlJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobWVyZ2VfMSk7XG5cbnZhciBiYXNlTWVyZ2UgPSBfYmFzZU1lcmdlLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gX2NyZWF0ZUFzc2lnbmVyO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAqXG4gKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAqL1xudmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbn0pO1xuXG52YXIgbWVyZ2VXaXRoXzEgPSBtZXJnZVdpdGg7XG5cbnZhciBtZXJnZVdpdGgkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhtZXJnZVdpdGhfMSk7XG5cbnZhciBiYXNlQXNzaWduVmFsdWUkMSA9IF9iYXNlQXNzaWduVmFsdWUsXG4gICAgYmFzZUZvck93biA9IF9iYXNlRm9yT3duLFxuICAgIGJhc2VJdGVyYXRlZSQyID0gX2Jhc2VJdGVyYXRlZTtcblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gKiBAc2VlIF8ubWFwVmFsdWVzXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubWFwS2V5cyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICogfSk7XG4gKiAvLyA9PiB7ICdhMSc6IDEsICdiMic6IDIgfVxuICovXG5mdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZSQyKGl0ZXJhdGVlKTtcblxuICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgYmFzZUFzc2lnblZhbHVlJDEocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgbWFwS2V5c18xID0gbWFwS2V5cztcblxudmFyIG1hcEtleXMkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhtYXBLZXlzXzEpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2YkMShvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG52YXIgX2Jhc2VQcm9wZXJ0eU9mID0gYmFzZVByb3BlcnR5T2YkMTtcblxudmFyIGJhc2VQcm9wZXJ0eU9mID0gX2Jhc2VQcm9wZXJ0eU9mO1xuXG4vKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJyxcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gKi9cbnZhciBkZWJ1cnJMZXR0ZXIkMSA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbnZhciBfZGVidXJyTGV0dGVyID0gZGVidXJyTGV0dGVyJDE7XG5cbnZhciBkZWJ1cnJMZXR0ZXIgPSBfZGVidXJyTGV0dGVyLFxuICAgIHRvU3RyaW5nJDIgPSB0b1N0cmluZ18xO1xuXG4vKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbnZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0NvbWJvTWFya3NSYW5nZSQzID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQzID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMyA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UkMyA9IHJzQ29tYm9NYXJrc1JhbmdlJDMgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMyArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQ29tYm8kMiA9ICdbJyArIHJzQ29tYm9SYW5nZSQzICsgJ10nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gKi9cbnZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvJDIsICdnJyk7XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyJDEoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nJDIoc3RyaW5nKTtcbiAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbn1cblxudmFyIGRlYnVycl8xID0gZGVidXJyJDE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xuXG52YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbi8qKlxuICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gYXNjaWlXb3JkcyQxKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbn1cblxudmFyIF9hc2NpaVdvcmRzID0gYXNjaWlXb3JkcyQxO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG5cbnZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlV29yZCQxKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG59XG5cbnZhciBfaGFzVW5pY29kZVdvcmQgPSBoYXNVbmljb2RlV29yZCQxO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG5cbnZhciByc0FzdHJhbFJhbmdlJDIgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UkMiA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMiA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlJDIgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlJDIgPSByc0NvbWJvTWFya3NSYW5nZSQyICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDIgKyByc0NvbWJvU3ltYm9sc1JhbmdlJDIsXG4gICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgIHJzVmFyUmFuZ2UkMiA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyQxID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICByc0NvbWJvJDEgPSAnWycgKyByc0NvbWJvUmFuZ2UkMiArICddJyxcbiAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UkMiArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6JDEgPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyJDEgPSAnKD86JyArIHJzQ29tYm8kMSArICd8JyArIHJzRml0eiQxICsgJyknLFxuICAgIHJzTm9uQXN0cmFsJDEgPSAnW14nICsgcnNBc3RyYWxSYW5nZSQyICsgJ10nLFxuICAgIHJzUmVnaW9uYWwkMSA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyJDEgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgIHJzWldKJDIgPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MkMSArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyQxICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgIHJlT3B0TW9kJDEgPSByc01vZGlmaWVyJDEgKyAnPycsXG4gICAgcnNPcHRWYXIkMSA9ICdbJyArIHJzVmFyUmFuZ2UkMiArICddPycsXG4gICAgcnNPcHRKb2luJDEgPSAnKD86JyArIHJzWldKJDIgKyAnKD86JyArIFtyc05vbkFzdHJhbCQxLCByc1JlZ2lvbmFsJDEsIHJzU3VyclBhaXIkMV0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIkMSArIHJlT3B0TW9kJDEgKyAnKSonLFxuICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgcnNTZXEkMSA9IHJzT3B0VmFyJDEgKyByZU9wdE1vZCQxICsgcnNPcHRKb2luJDEsXG4gICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCQxLCByc1N1cnJQYWlyJDFdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxJDE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG52YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICByc09yZFVwcGVyLFxuICByc09yZExvd2VyLFxuICByc0RpZ2l0cyxcbiAgcnNFbW9qaVxuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVXb3JkcyQxKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xufVxuXG52YXIgX3VuaWNvZGVXb3JkcyA9IHVuaWNvZGVXb3JkcyQxO1xuXG52YXIgYXNjaWlXb3JkcyA9IF9hc2NpaVdvcmRzLFxuICAgIGhhc1VuaWNvZGVXb3JkID0gX2hhc1VuaWNvZGVXb3JkLFxuICAgIHRvU3RyaW5nJDEgPSB0b1N0cmluZ18xLFxuICAgIHVuaWNvZGVXb3JkcyA9IF91bmljb2RlV29yZHM7XG5cbi8qKlxuICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gKi9cbmZ1bmN0aW9uIHdvcmRzJDEoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICBzdHJpbmcgPSB0b1N0cmluZyQxKHN0cmluZyk7XG4gIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbn1cblxudmFyIHdvcmRzXzEgPSB3b3JkcyQxO1xuXG52YXIgYXJyYXlSZWR1Y2UgPSBfYXJyYXlSZWR1Y2UsXG4gICAgZGVidXJyID0gZGVidXJyXzEsXG4gICAgd29yZHMgPSB3b3Jkc18xO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCI7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xudmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlciQxKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQ29tcG91bmRlciA9IGNyZWF0ZUNvbXBvdW5kZXIkMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuXG5mdW5jdGlvbiBiYXNlU2xpY2UkMShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlU2xpY2UgPSBiYXNlU2xpY2UkMTtcblxudmFyIGJhc2VTbGljZSA9IF9iYXNlU2xpY2U7XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZSQxKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbn1cblxudmFyIF9jYXN0U2xpY2UgPSBjYXN0U2xpY2UkMTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuXG52YXIgcnNBc3RyYWxSYW5nZSQxID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlJDEgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDEgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSQxID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSQxID0gcnNDb21ib01hcmtzUmFuZ2UkMSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQxICsgcnNDb21ib1N5bWJvbHNSYW5nZSQxLFxuICAgIHJzVmFyUmFuZ2UkMSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0okMSA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0okMSArIHJzQXN0cmFsUmFuZ2UkMSAgKyByc0NvbWJvUmFuZ2UkMSArIHJzVmFyUmFuZ2UkMSArICddJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZSQyKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxudmFyIF9oYXNVbmljb2RlID0gaGFzVW5pY29kZSQyO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheSQxKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbn1cblxudmFyIF9hc2NpaVRvQXJyYXkgPSBhc2NpaVRvQXJyYXkkMTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkkMShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xufVxuXG52YXIgX3VuaWNvZGVUb0FycmF5ID0gdW5pY29kZVRvQXJyYXkkMTtcblxudmFyIGFzY2lpVG9BcnJheSA9IF9hc2NpaVRvQXJyYXksXG4gICAgaGFzVW5pY29kZSQxID0gX2hhc1VuaWNvZGUsXG4gICAgdW5pY29kZVRvQXJyYXkgPSBfdW5pY29kZVRvQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkkMShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUkMShzdHJpbmcpXG4gICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbn1cblxudmFyIF9zdHJpbmdUb0FycmF5ID0gc3RyaW5nVG9BcnJheSQxO1xuXG52YXIgY2FzdFNsaWNlID0gX2Nhc3RTbGljZSxcbiAgICBoYXNVbmljb2RlID0gX2hhc1VuaWNvZGUsXG4gICAgc3RyaW5nVG9BcnJheSA9IF9zdHJpbmdUb0FycmF5LFxuICAgIHRvU3RyaW5nID0gdG9TdHJpbmdfMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdCQxKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQ2FzZUZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0JDE7XG5cbnZhciBjcmVhdGVDYXNlRmlyc3QgPSBfY3JlYXRlQ2FzZUZpcnN0O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGUkVEJ1xuICovXG52YXIgdXBwZXJGaXJzdCQxID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG52YXIgdXBwZXJGaXJzdF8xID0gdXBwZXJGaXJzdCQxO1xuXG52YXIgY3JlYXRlQ29tcG91bmRlciA9IF9jcmVhdGVDb21wb3VuZGVyLFxuICAgIHVwcGVyRmlyc3QgPSB1cHBlckZpcnN0XzE7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAqIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4xLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXItLScpO1xuICogLy8gPT4gJ0ZvbyBCYXInXG4gKlxuICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICogLy8gPT4gJ0ZvbyBCYXInXG4gKlxuICogXy5zdGFydENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnRk9PIEJBUidcbiAqL1xudmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbn0pO1xuXG52YXIgc3RhcnRDYXNlXzEgPSBzdGFydENhc2U7XG5cbnZhciBzdGFydENhc2UkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzdGFydENhc2VfMSk7XG5cbnZhciBTeW1ib2wkMSA9IF9TeW1ib2wsXG4gICAgaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50c18xLFxuICAgIGlzQXJyYXkkMiA9IGlzQXJyYXlfMTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCQxID8gU3ltYm9sJDEuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUkMSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSQyKHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxudmFyIF9pc0ZsYXR0ZW5hYmxlID0gaXNGbGF0dGVuYWJsZSQxO1xuXG52YXIgYXJyYXlQdXNoID0gX2FycmF5UHVzaCxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gX2lzRmxhdHRlbmFibGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4kMShhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4kMSh2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlRmxhdHRlbiA9IGJhc2VGbGF0dGVuJDE7XG5cbnZhciBiYXNlRWFjaCQxID0gX2Jhc2VFYWNoLFxuICAgIGlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2VfMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcCQxKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaCQxKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYmFzZU1hcCA9IGJhc2VNYXAkMTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cblxuZnVuY3Rpb24gYmFzZVNvcnRCeSQxKGFycmF5LCBjb21wYXJlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfYmFzZVNvcnRCeSA9IGJhc2VTb3J0QnkkMTtcblxudmFyIGlzU3ltYm9sID0gaXNTeW1ib2xfMTtcblxuLyoqXG4gKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyQxKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBfY29tcGFyZUFzY2VuZGluZyA9IGNvbXBhcmVBc2NlbmRpbmckMTtcblxudmFyIGNvbXBhcmVBc2NlbmRpbmcgPSBfY29tcGFyZUFzY2VuZGluZztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICpcbiAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlJDEob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG52YXIgX2NvbXBhcmVNdWx0aXBsZSA9IGNvbXBhcmVNdWx0aXBsZSQxO1xuXG52YXIgYXJyYXlNYXAgPSBfYXJyYXlNYXAsXG4gICAgYmFzZUdldCA9IF9iYXNlR2V0LFxuICAgIGJhc2VJdGVyYXRlZSQxID0gX2Jhc2VJdGVyYXRlZSxcbiAgICBiYXNlTWFwID0gX2Jhc2VNYXAsXG4gICAgYmFzZVNvcnRCeSA9IF9iYXNlU29ydEJ5LFxuICAgIGJhc2VVbmFyeSA9IF9iYXNlVW5hcnksXG4gICAgY29tcGFyZU11bHRpcGxlID0gX2NvbXBhcmVNdWx0aXBsZSxcbiAgICBpZGVudGl0eSA9IGlkZW50aXR5XzEsXG4gICAgaXNBcnJheSQxID0gaXNBcnJheV8xO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlT3JkZXJCeSQxKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIGlmIChpdGVyYXRlZXMubGVuZ3RoKSB7XG4gICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgaWYgKGlzQXJyYXkkMShpdGVyYXRlZSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShiYXNlSXRlcmF0ZWUkMSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG52YXIgX2Jhc2VPcmRlckJ5ID0gYmFzZU9yZGVyQnkkMTtcblxudmFyIGJhc2VGbGF0dGVuID0gX2Jhc2VGbGF0dGVuLFxuICAgIGJhc2VPcmRlckJ5ID0gX2Jhc2VPcmRlckJ5LFxuICAgIGJhc2VSZXN0ID0gX2Jhc2VSZXN0LFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gX2lzSXRlcmF0ZWVDYWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAqIF07XG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgMzBdXVxuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0OF1dXG4gKi9cbnZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW107XG4gIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG59KTtcblxudmFyIHNvcnRCeV8xID0gc29ydEJ5O1xuXG52YXIgc29ydEJ5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc29ydEJ5XzEpO1xuXG52YXIgYmFzZUlzRXF1YWwgPSBfYmFzZUlzRXF1YWw7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG52YXIgaXNFcXVhbF8xID0gaXNFcXVhbDtcblxudmFyIGlzRXF1YWwkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpc0VxdWFsXzEpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gKi9cblxuZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yJDEoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG52YXIgX2FycmF5QWdncmVnYXRvciA9IGFycmF5QWdncmVnYXRvciQxO1xuXG52YXIgYmFzZUVhY2ggPSBfYmFzZUVhY2g7XG5cbi8qKlxuICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yJDEoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbnZhciBfYmFzZUFnZ3JlZ2F0b3IgPSBiYXNlQWdncmVnYXRvciQxO1xuXG52YXIgYXJyYXlBZ2dyZWdhdG9yID0gX2FycmF5QWdncmVnYXRvcixcbiAgICBiYXNlQWdncmVnYXRvciA9IF9iYXNlQWdncmVnYXRvcixcbiAgICBiYXNlSXRlcmF0ZWUgPSBfYmFzZUl0ZXJhdGVlLFxuICAgIGlzQXJyYXkgPSBpc0FycmF5XzE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3IkMShzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUpLCBhY2N1bXVsYXRvcik7XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQWdncmVnYXRvciA9IGNyZWF0ZUFnZ3JlZ2F0b3IkMTtcblxudmFyIGJhc2VBc3NpZ25WYWx1ZSA9IF9iYXNlQXNzaWduVmFsdWUsXG4gICAgY3JlYXRlQWdncmVnYXRvciA9IF9jcmVhdGVBZ2dyZWdhdG9yO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheSA9IFtcbiAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAqIF07XG4gKlxuICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xuICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICogfSk7XG4gKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gKlxuICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAqL1xudmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG59KTtcblxudmFyIGtleUJ5XzEgPSBrZXlCeTtcblxudmFyIGtleUJ5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoa2V5QnlfMSk7XG5cbmNvbnN0IGUgPSBNYXRoLmV4cCgxKTtcbmNvbnN0IEVNQUlMX1JFR0VYID0gL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kLztcbi8qKlxuICogRGV0ZWN0cyBpZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyB0aGUgYnJvd3NlclxuICpcbiAqIEByZXR1cm5zIGB0cnVlYCBvciBgZmFsc2VgXG4gKi9cbmNvbnN0IGlzQnJvd3NlciA9ICgpID0+ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgd2luZG93LmRvY3VtZW50ICYmXG4gICAgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuLyoqXG4gKiBNZXJnZXMgY2xhc3NOYW1lcyBvYmplY3RzIHRvZ2V0aGVyLCBrZXkgYnkga2V5XG4gKlxuICogQHJldHVybnMgYSBjbGFzc05hbWVzIG9iamVjdFxuICovXG5jb25zdCBtZXJnZUNsYXNzTmFtZXNEZWVwID0gKHsgY2xhc3NOYW1lczEgPSB7fSwgY2xhc3NOYW1lczIgPSB7fSwgfSkgPT4ge1xuICAgIGNvbnN0IG5ld0NsYXNzTmFtZXMgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAuLi5PYmplY3Qua2V5cyhjbGFzc05hbWVzMSB8fCB7fSksXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKGNsYXNzTmFtZXMyIHx8IHt9KSxcbiAgICBdO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIG5ld0NsYXNzTmFtZXNba2V5XSA9IGNsYXNzTmFtZXMoY2xhc3NOYW1lczFba2V5XSwgY2xhc3NOYW1lczJba2V5XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0NsYXNzTmFtZXM7XG59O1xuY29uc3QgbWVyZ2VDbGFzc05hbWVzRnVuY3Rpb25zRGVlcCA9ICh7IGNsYXNzTmFtZXMxID0ge30sIGNsYXNzTmFtZXMyID0ge30sIH0pID0+IHtcbiAgICBjb25zdCBuZXdDbGFzc05hbWVzID0ge307XG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgLi4uT2JqZWN0LmtleXMoY2xhc3NOYW1lczEgfHwge30pLFxuICAgICAgICAuLi5PYmplY3Qua2V5cyhjbGFzc05hbWVzMiB8fCB7fSksXG4gICAgXTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBuZXdDbGFzc05hbWVzW2tleV0gPSAoYXJncykgPT4gY2xhc3NOYW1lcygoY2xhc3NOYW1lczFba2V5XSB8fCAoKCkgPT4gJycpKShhcmdzKSwgKGNsYXNzTmFtZXMyW2tleV0gfHwgKCgpID0+ICcnKSkoYXJncykpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdDbGFzc05hbWVzO1xufTtcbi8qKiBUeXBpbmcgb24gdGhpcyBmdW5jdGlvbiBpcyBjb25mdXNpbmcgYnV0IGRvZXMgd29yayEgKi9cbmNvbnN0IHJlbW92ZVVuZGVmaW5lZFZhbHVlc0Zyb21PYmogPSAoaW5wdXRPYmplY3QpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICBpZiAoaW5wdXRPYmplY3Rba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGlucHV0T2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKiogVHlwaW5nIG9uIHRoaXMgZnVuY3Rpb24gaXMgY29uZnVzaW5nIGJ1dCBkb2VzIHdvcmshICovXG5jb25zdCByZW1vdmVVbmRlZmluZWRBbmRFbXB0eVN0cmluZ1ZhbHVlc0Zyb21PYmogPSAoaW5wdXRPYmplY3QpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICBpZiAoaW5wdXRPYmplY3Rba2V5XSAhPT0gdW5kZWZpbmVkICYmIGlucHV0T2JqZWN0W2tleV0gIT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGlucHV0T2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKiogVHlwaW5nIG9uIHRoaXMgZnVuY3Rpb24gaXMgY29uZnVzaW5nIGJ1dCBkb2VzIHdvcmshICovXG5jb25zdCByZW1vdmVVbmRlZmluZWRBbmROdWxsVmFsdWVzRnJvbU9iaiA9IChpbnB1dE9iamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgIGlmIChpbnB1dE9iamVjdFtrZXldICE9PSB1bmRlZmluZWQgJiYgaW5wdXRPYmplY3Rba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpbnB1dE9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBxdWVyeSBzdHJpbmcgZnJvbSBhbiBvYmplY3Qgb2Yga2V5IHZhbHVlIHBhaXJzXG4gKlxuICogQHJldHVybnMgYSBjbGFzc05hbWVzIG9iamVjdFxuICpcbiAqIEBleGFtcGxlXG4gKiBnZW5lcmF0ZVF1ZXJ5U3RyaW5nKFxceyBmaWVsZDE6ICd2YWx1ZTEnLCBmaWVsZDI6ICd2YWx1ZTInIFxcfSkgPVxcPiBcIj9maWVsZDE9dmFsdWUxJmZpZWxkMj12YWx1ZTJcIlxuICogZ2VuZXJhdGVRdWVyeVN0cmluZyhcXHsgZmllbGQxOiAndmFsdWUxJywgZmllbGQyOiAndmFsdWUyJywgZXhjbHVkZVF1ZXN0aW9uTWFyayBcXH0pID1cXD4gXCJmaWVsZDE9dmFsdWUxJmZpZWxkMj12YWx1ZTJcIlxuICovXG5jb25zdCBnZW5lcmF0ZVF1ZXJ5U3RyaW5nID0gKHsgcXVlcnlQYXJhbXMgPSB7fSwgZXhjbHVkZVF1ZXN0aW9uTWFyayA9IGZhbHNlLCBleGNsdWRlRW1wdHlTdHJpbmdWYWx1ZXMgPSBmYWxzZSwgfSkgPT4ge1xuICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaW4gYSBxdWVyeXN0cmluZyBpcyBwcmVjZWRlZCBieSBhID9cbiAgICAvLyBUaGlzIGZsYWcgZGVub3RlcyB3aGV0aGVyIHdlIGFscmVhZHkgaGF2ZSBvbmUgcGFyYW0gc2V0IGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICBsZXQgcHJlZml4UXVlc3Rpb25NYXJrID0gIWV4Y2x1ZGVRdWVzdGlvbk1hcms7XG4gICAgcmV0dXJuIHJlZHVjZSQxKGV4Y2x1ZGVFbXB0eVN0cmluZ1ZhbHVlc1xuICAgICAgICA/IHJlbW92ZVVuZGVmaW5lZEFuZEVtcHR5U3RyaW5nVmFsdWVzRnJvbU9iaihxdWVyeVBhcmFtcyB8fCB7fSlcbiAgICAgICAgOiByZW1vdmVVbmRlZmluZWRWYWx1ZXNGcm9tT2JqKHF1ZXJ5UGFyYW1zIHx8IHt9KSwgKGFjYywgZmllbGQsIGtleSkgPT4ge1xuICAgICAgICAvLyBJZiB0aGUgZmllbGQgaXMgZmFsc2V5IHRoZW4gZG8gbm90IGFwcGVuZCB0aGlzIHF1ZXJ5IHBhcmFtXG4gICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJlZml4UXVlc3Rpb25NYXJrKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSYke2tleX09JHtmaWVsZH1gO1xuICAgICAgICB9XG4gICAgICAgIHByZWZpeFF1ZXN0aW9uTWFyayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYCR7YWNjfT8ke2tleX09JHtmaWVsZH1gO1xuICAgIH0sICcnKTtcbn07XG4vKipcbiAqIFJvdW5kcyBhIG51bWJlciB0byBOIGRlY2ltYWwgcGxhY2VzIChkZWZhdWx0cyB0byAyKVxuICpcbiAqIEByZXR1cm5zIGEgcm91bmRlZCBudW1iZXJcbiAqL1xuY29uc3Qgcm91bmROdW1iZXIgPSAobnVtLCBkZWNpbWFsUGxhY2VzID0gMikgPT4ge1xuICAgIHJldHVybiArYCR7TWF0aC5yb3VuZCgrYCR7bnVtfWUrJHtkZWNpbWFsUGxhY2VzfWApfWUtJHtkZWNpbWFsUGxhY2VzfWA7XG59O1xuY29uc3QgZ2V0TlJhbmRvbUVsZW1lbnRzRnJvbUFycmF5ID0gKGFycmF5LCBuKSA9PiB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA8PSBuKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGNvdW50ID0gbjtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgY29uc3QgdGFrZW4gPSBuZXcgQXJyYXkobGVuKTtcbiAgICBpZiAoY291bnQgPiBsZW4pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdnZXRSYW5kb206IG1vcmUgZWxlbWVudHMgdGFrZW4gdGhhbiBhdmFpbGFibGUnKTtcbiAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKTtcbiAgICAgICAgcmVzdWx0W2NvdW50XSA9IGFycmF5W3ggaW4gdGFrZW4gPyB0YWtlblt4XSA6IHhdO1xuICAgICAgICB0YWtlblt4XSA9IC0tbGVuIGluIHRha2VuID8gdGFrZW5bbGVuXSA6IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBnZXRSYW5kb21FbGVtZW50c0Zyb21BcnJheSA9IChhcnJheSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzQ291bnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnJheS5sZW5ndGgpICsgMTtcbiAgICByZXR1cm4gZ2V0TlJhbmRvbUVsZW1lbnRzRnJvbUFycmF5KGFycmF5LCBlbGVtZW50c0NvdW50KTtcbn07XG5jb25zdCBnZXRSYW5kb21FbGVtZW50RnJvbUFycmF5ID0gKGFycmF5KSA9PiBnZXROUmFuZG9tRWxlbWVudHNGcm9tQXJyYXkoYXJyYXksIDEpWzBdO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiByZ2JhIHN0cmluZyB0byBhIGhleCBjb2xvciBjb2RlXG4gKlxuICogQHJldHVybnMgYSBoZXggY29sb3IgY29kZSBhcyBhIHN0cmluZ1xuICovXG5jb25zdCBSR0JBVG9IZXhBID0gKHJnYmEsIGZvcmNlUmVtb3ZlQWxwaGEgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGhleENvbG9yID0gcmdiYVxuICAgICAgICAucmVwbGFjZSgvXnJnYmE/XFwofFxccyt8XFwpJC9nLCAnJykgLy8gR2V0J3MgcmdiYSAvIHJnYiBzdHJpbmcgdmFsdWVzXG4gICAgICAgIC5zcGxpdCgnLCcpIC8vIHNwbGl0cyB0aGVtIGJ5IFwiLFwiXG4gICAgICAgIC5maWx0ZXIoKHN0ciwgaW5kZXgpID0+ICFmb3JjZVJlbW92ZUFscGhhIHx8IGluZGV4ICE9PSAzKVxuICAgICAgICAubWFwKChzdHIpID0+IHBhcnNlRmxvYXQoc3RyKSkgLy8gQ29udmVydHMgdGhlbSB0byBudW1iZXJzXG4gICAgICAgIC5tYXAoKG51bWJlciwgaW5kZXgpID0+IChpbmRleCA9PT0gMyA/IE1hdGgucm91bmQobnVtYmVyICogMjU1KSA6IG51bWJlcikpIC8vIENvbnZlcnRzIGFscGhhIHRvIDI1NSBudW1iZXJcbiAgICAgICAgLm1hcCgobnVtYmVyKSA9PiBudW1iZXIudG9TdHJpbmcoMTYpKSAvLyBDb252ZXJ0cyBudW1iZXJzIHRvIGhleFxuICAgICAgICAubWFwKChzdHIpID0+IChzdHIubGVuZ3RoID09PSAxID8gYDAke3N0cn1gIDogc3RyKSkgLy8gQWRkcyAwIHdoZW4gbGVuZ3RoIG9mIG9uZSBudW1iZXIgaXMgMVxuICAgICAgICAuam9pbignJyk7XG4gICAgcmV0dXJuIGAjJHtoZXhDb2xvcn1gO1xufTtcbmNvbnN0IGlzVHJ1dGh5T3JaZXJvID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAoISF2YWx1ZSB8fCAodmFsdWUgIT09ICcnICYmIE51bWJlcih2YWx1ZSkgPT09IDApKTtcbmNvbnN0IGNvbmRpdGlvbmFsT3JJZlRydXRoeU9yWmVybyA9ICh2YWx1ZXMpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlcy5maW5kKCh2KSA9PiBpc1RydXRoeU9yWmVybyh2KSk7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdIDogdmFsdWU7XG59O1xuY29uc3QgYXJyYXlXaXRob3V0RWxlbWVudHMgPSAoeyBhcnJheSwgZXhjbHVkZUFycmF5LCB9KSA9PiB7XG4gICAgY29uc3QgdG9FeGNsdWRlID0gbmV3IFNldChleGNsdWRlQXJyYXkgfHwgW10pO1xuICAgIHJldHVybiAoYXJyYXkgfHwgW10pLmZpbHRlcigodikgPT4gIXRvRXhjbHVkZS5oYXModikpO1xufTtcbmNvbnN0IGNhcGl0YWxpc2VGaXJzdExldHRlciA9ICh0ZXh0ID0gJycpID0+IHtcbiAgICByZXR1cm4gdGV4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleHQuc2xpY2UoMSk7XG59O1xuY29uc3QgY2xlYW5TdHJpbmcgPSAodGV4dCA9ICcnKSA9PiB7XG4gICAgcmV0dXJuICh0ZXh0IHx8ICcnKS50cmltKCk7XG59O1xuY29uc3Qgbm9ybWFsaXNlU3RyaW5nID0gKHRleHQgPSAnJykgPT4ge1xuICAgIHJldHVybiBjbGVhblN0cmluZyh0ZXh0KS50b0xvd2VyQ2FzZSgpO1xufTtcbmNvbnN0IHBhcnNlRW52VmFyaWFibGUgPSAodikgPT4ge1xuICAgIGlmICh2ID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHYgPT09ICd0cnVlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHY/LlswXSA9PT0gJyQnKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodi5yZXBsYWNlKCckJywgJycpKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuY29uc3QgcGFyc2VFbnZWYXJpYWJsZXMgPSAoZW52KSA9PiBtYXBWYWx1ZXMkMShlbnYsICh2KSA9PiBwYXJzZUVudlZhcmlhYmxlKHYpKTtcbmNvbnN0IGdldE5leHRKU1F1ZXJ5UGFyYW0gPSAoeyBxdWVyeSwgaWQsIGRlZmF1bHRUb0VtcHR5U3RyaW5nID0gZmFsc2UsIH0pID0+IHtcbiAgICBjb25zdCByZXR1cm5EZWZhdWx0ID0gZGVmYXVsdFRvRW1wdHlTdHJpbmcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiByZXR1cm5EZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gKChBcnJheS5pc0FycmF5KHF1ZXJ5Py5baWRdKVxuICAgICAgICA/IHF1ZXJ5Py5baWRdPy5bMF0/LnRvU3RyaW5nKClcbiAgICAgICAgOiBxdWVyeT8uW2lkXT8udG9TdHJpbmcoKSkgfHwgcmV0dXJuRGVmYXVsdCk7XG59O1xuY29uc3QgZXZhbHVhdGVUcnV0aHlJZk5vdFVuZGVmaW5lZCA9ICh2KSA9PiB7XG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gISF2O1xufTtcbmNvbnN0IGV2YWx1YXRlT25lT3JaZXJvQm9vbGVhbklmTm90RW1wdHlTdHJpbmcgPSAodikgPT4ge1xuICAgIGlmICh2ID09PSAnJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdiA9PT0gJzEnO1xufTtcbmNvbnN0IGV2YWx1YXRlT25lT3JaZXJvQm9vbGVhbklmTm90VW5kZWZpbmVkID0gKHYpID0+IHtcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB2ID09PSAnMSc7XG59O1xuY29uc3QgZG93bmxvYWRGcm9tT2JqZWN0VVJMID0gKHsgZmlsZU5hbWUsIHVybCwgfSkgPT4ge1xuICAgIC8qKiBDcmVhdGUgYSBsaW5rIGFuZCBkb3dubG9hZCBmcm9tIGl0ICovXG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgbGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgbGluay5jbGljaygpO1xuICAgIC8qKiBDbGVhciB1cCB0aGUgZWxlbWVudCBhbmQgb2JqZWN0IHVybCAqL1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICBsaW5rLnJlbW92ZSgpO1xufTtcbmNvbnN0IGdlbmVyYXRlQ1NWID0gKHsgZGF0YSwgY29sdW1uSGVhZGVyTmFtZXMgPSB1bmRlZmluZWQsIGF1dG9HZW5lcmF0ZUNvbHVtbkhlYWRlck5hbWVzID0gdHJ1ZSwgc3RhcnRDYXNlRm9yQ29sdW5tSGVhZGVyTmFtZXMgPSBmYWxzZSwgfSkgPT4ge1xuICAgIHJldHVybiBzdHJpbmdpZnkoc3RhcnRDYXNlRm9yQ29sdW5tSGVhZGVyTmFtZXNcbiAgICAgICAgPyBkYXRhLm1hcCgoZCkgPT4gKGQgPyBtYXBLZXlzJDEoZCwgKF92LCBrZXkpID0+IHN0YXJ0Q2FzZSQxKGtleSkpIDogZCkpXG4gICAgICAgIDogZGF0YSwge1xuICAgICAgICAuLi4oYXV0b0dlbmVyYXRlQ29sdW1uSGVhZGVyTmFtZXMgfHwgYXV0b0dlbmVyYXRlQ29sdW1uSGVhZGVyTmFtZXNcbiAgICAgICAgICAgID8geyBoZWFkZXI6IHRydWUgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLihjb2x1bW5IZWFkZXJOYW1lcyA/IHsgY29sdW1uczogY29sdW1uSGVhZGVyTmFtZXMgfSA6IHt9KSxcbiAgICB9KTtcbn07XG5jb25zdCBkb3dubG9hZENTViA9ICh7IGNzdiwgZmlsZU5hbWUsIH0pID0+IHtcbiAgICAvKiogQ3JlYXRlIHVybCB0byB0aGUgY3N2IGZpbGUgKi9cbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2Nzdl0sIHsgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTgsJyB9KTtcbiAgICBjb25zdCBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICBkb3dubG9hZEZyb21PYmplY3RVUkwoeyBmaWxlTmFtZTogYCR7ZmlsZU5hbWV9LmNzdmAsIHVybDogYmxvYlVybCB9KTtcbn07XG5jb25zdCBkb3dubG9hZEpTT04gPSAoeyBqc29uLCBmaWxlTmFtZSwgfSkgPT4ge1xuICAgIC8qKiBDcmVhdGUgdXJsIHRvIHRoZSBqc29uIGZpbGUgKi9cbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2pzb25dLCB7XG4gICAgICAgIHR5cGU6ICd0ZXh0L2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCwnLFxuICAgIH0pO1xuICAgIGNvbnN0IGJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIGRvd25sb2FkRnJvbU9iamVjdFVSTCh7IGZpbGVOYW1lOiBgJHtmaWxlTmFtZX0uanNvbmAsIHVybDogYmxvYlVybCB9KTtcbn07XG5jb25zdCBnZXRSZWFjdFF1ZXJ5U3RhdHVzID0gKHsgaXNGZXRjaGluZyA9IGZhbHNlLCBpc0xvYWRpbmcgPSB0cnVlLCBpc0Vycm9yID0gZmFsc2UsIGlzU3VjY2VzcywgZGF0YVVwZGF0ZWRBdCwgfSwgeyBpc1JlYWR5ID0gZmFsc2UsIHNob3VsZExvYWRJbml0aWFsbHkgPSB0cnVlLCBzdGF0dXMsIH0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0ZldGNoaW5nLFxuICAgICAgICBpc0xvYWRpbmc6IHNob3VsZExvYWRJbml0aWFsbHlcbiAgICAgICAgICAgID8gISFpc0xvYWRpbmcgfHwgKCFpc0Vycm9yICYmICFpc1JlYWR5KVxuICAgICAgICAgICAgOiAhIWlzTG9hZGluZyxcbiAgICAgICAgaXNFcnJvcixcbiAgICAgICAgaXNTdWNjZXNzLFxuICAgICAgICBpczQwMTogc3RhdHVzID09PSA0MDEsXG4gICAgICAgIHVwZGF0ZWRBdDogZGF0YVVwZGF0ZWRBdCxcbiAgICB9O1xufTtcbmNvbnN0IHNhbml0aXNlVGV4dFRlcm0gPSAodGV4dFRlcm0gPSAnJykgPT4gKHRleHRUZXJtIHx8ICcnKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbmNvbnN0IHN0cmluZ3NFcXVhbEluc2Vuc2l0aXZlID0gKHN0cjEsIHN0cjIpID0+IHtcbiAgICBpZiAoc3RyMSA9PT0gdW5kZWZpbmVkIHx8IHN0cjEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2FuaXRpc2VUZXh0VGVybShzdHIxKSA9PT0gc2FuaXRpc2VUZXh0VGVybShzdHIyKTtcbn07XG5jb25zdCBjaGVja0lmVGV4dFRlcm1NYXRjaGVzU2luZ2xlID0gKHsgc291cmNlVmFsdWU6IHNvdXJjZVZhbHVlUmF3ID0gJycsIGlucHV0VmFsdWU6IGlucHV0VmFsdWVSYXcgPSAnJywgdXNlRnV6enkgPSB0cnVlLCB9KSA9PiB7XG4gICAgLyoqIEZ1enp5c29ydCBtYXRjaCBtaW5pbXVtIHRocmVzaG9sZC4gMCBpcyBhIHBlcmZlY3QgbWF0Y2gsIGxvd2VyIGlzIGEgd29yc2UgbWF0Y2ggKi9cbiAgICBjb25zdCBGVVpaWVNPUlRfTUFUQ0hfVEhSRVNIT0xEID0gLTc1O1xuICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc2FuaXRpc2VUZXh0VGVybShzb3VyY2VWYWx1ZVJhdyk7XG4gICAgY29uc3QgaW5wdXRWYWx1ZSA9IHNhbml0aXNlVGV4dFRlcm0oaW5wdXRWYWx1ZVJhdyk7XG4gICAgaWYgKCFzb3VyY2VWYWx1ZSB8fCAhaW5wdXRWYWx1ZSkge1xuICAgICAgICByZXR1cm4geyBtYXRjaGVzOiBmYWxzZSwgc2NvcmU6IC1JbmZpbml0eSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlVmFsdWUgPT09IGlucHV0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgbWF0Y2hlczogdHJ1ZSwgc2NvcmU6IDAgfTtcbiAgICB9XG4gICAgaWYgKHVzZUZ1enp5KSB7XG4gICAgICAgIGxldCBzY29yZSA9IGZ1enp5c29ydC5zaW5nbGUoaW5wdXRWYWx1ZSwgc291cmNlVmFsdWUpPy5zY29yZTtcbiAgICAgICAgaWYgKHNjb3JlID09PSB1bmRlZmluZWQgfHwgc2NvcmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHNjb3JlID0gLUluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VWYWx1ZS5pbmNsdWRlcyhpbnB1dFZhbHVlKSB8fCBzY29yZSA+IEZVWlpZU09SVF9NQVRDSF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoZXM6IHRydWUsIHNjb3JlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWF0Y2hlczogZmFsc2UsIHNjb3JlOiAtSW5maW5pdHkgfTtcbn07XG5jb25zdCBjaGVja0lmVGV4dFRlcm1NYXRjaGVzQXJyYXkgPSAoeyBpbnB1dFZhbHVlLCBhcnJheSwgdXNlRnV6enkgPSB0cnVlLCB9KSA9PiB7XG4gICAgaWYgKChpbnB1dFZhbHVlIHx8ICcnKS50cmltKCkpIHtcbiAgICAgICAgZm9yIChsZXQgYXJyYXlJbmRleCA9IDA7IGFycmF5SW5kZXggPCBhcnJheS5sZW5ndGg7IGFycmF5SW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheVthcnJheUluZGV4XTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgfHwgJycpLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0lmVGV4dFRlcm1NYXRjaGVzU2luZ2xlKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB1c2VGdXp6eSxcbiAgICAgICAgICAgICAgICB9KS5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGNyZWF0ZUN1c3RvbUtleSA9IChrZXlzKSA9PiBrZXlzLnJlZHVjZSgoa2V5LCBjdXJyZW50S2V5KSA9PiB7XG4gICAgY29uc3QgY29tcG9zaXRlS2V5SXNUcnV0aHkgPSBpc1RydXRoeU9yWmVybyhrZXkpO1xuICAgIGNvbnN0IGN1cnJlbnRLZXlJc1RydXRoeSA9IGlzVHJ1dGh5T3JaZXJvKGN1cnJlbnRLZXkpO1xuICAgIHJldHVybiBgJHtrZXl9JHtjb21wb3NpdGVLZXlJc1RydXRoeSA/ICd8JyA6ICcnfSR7Y3VycmVudEtleUlzVHJ1dGh5ID8gY3VycmVudEtleSA6ICcnfWA7XG59LCAnJyk7XG5jb25zdCBjcmVhdGVDdXN0b21LZXlGcm9tT2JqZWN0ID0gKG9iaiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBrZXlWYWx1ZVNlcGFyYXRvciwgc2VwYXJhdG9yIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGt2U2VwID0ga2V5VmFsdWVTZXBhcmF0b3IgfHwgJzonO1xuICAgIGNvbnN0IHNlcCA9IHNlcGFyYXRvciB8fCAnfCc7XG4gICAgcmV0dXJuIHNvcnRCeSQxKE9iamVjdC5lbnRyaWVzKHJlbW92ZVVuZGVmaW5lZFZhbHVlc0Zyb21PYmoob2JqKSksIChbaywgdl0pID0+IGAke2t9OiR7dn1gKS5yZWR1Y2UoKGtleSwgW2N1cnJlbnRLZXksIGN1cnJlbnRWYWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3Qgc2hvdWxkRXhjbHVkZVZhbHVlID0gIWN1cnJlbnRLZXkgfHxcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9PT0gJycgfHxcbiAgICAgICAgICAgIChpc0FycmF5JGYoY3VycmVudFZhbHVlKSAmJiAhY3VycmVudFZhbHVlPy5sZW5ndGgpO1xuICAgICAgICBjb25zdCB2YWx1ZUlzT2JqZWN0ID0gaXNPYmplY3QkOShjdXJyZW50VmFsdWUpO1xuICAgICAgICBjb25zdCB2YWx1ZUlzQXJyYXkgPSBpc0FycmF5JGYoY3VycmVudFZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWVOZWVkc1RyYW5zZm9ybWluZyA9IHZhbHVlSXNBcnJheSB8fCB2YWx1ZUlzT2JqZWN0O1xuICAgICAgICBsZXQgdmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZU5lZWRzVHJhbnNmb3JtaW5nKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjdXJyZW50VmFsdWUuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVJc09iamVjdCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY3JlYXRlQ3VzdG9tS2V5RnJvbU9iamVjdChjdXJyZW50VmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2hvdWxkRXhjbHVkZVZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSAnJ1xuICAgICAgICAgICAgICAgID8gYCR7Y3VycmVudEtleX0ke2t2U2VwfSR7dmFsdWV9YFxuICAgICAgICAgICAgICAgIDogYCR7a2V5fSR7c2VwfSR7Y3VycmVudEtleX0ke2t2U2VwfSR7dmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH0sICcnKTtcbn07XG5jb25zdCBjcmVhdGVDdXN0b21GaWxlTmFtZUtleUZyb21PYmplY3QgPSAob2JqKSA9PiBjcmVhdGVDdXN0b21LZXlGcm9tT2JqZWN0KG1hcFZhbHVlcyQxKG9iaiwgKHYpID0+IHtcbiAgICBpZiAodiA9PT0gdHJ1ZSB8fCB2ID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmV0dXJuICcxJztcbiAgICB9XG4gICAgaWYgKHYgPT09IGZhbHNlIHx8IHYgPT09ICdmYWxzZScpIHtcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59KSwgeyBzZXBhcmF0b3I6ICdfJywga2V5VmFsdWVTZXBhcmF0b3I6ICc9JyB9KTtcbmNvbnN0IGNyZWF0ZUN1c3RvbUtleUZyb21TcmNUZ3QgPSAoeyBzcmNJRCwgdGd0SUQsIH0pID0+IGNyZWF0ZUN1c3RvbUtleShbc3JjSUQsIHRndElEXSk7XG5jb25zdCBpc0VtYWlsID0gKHYpID0+ICEhKCEhdiAmJiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgdi5sZW5ndGggJiYgRU1BSUxfUkVHRVgudGVzdCh2KSk7XG5jb25zdCBzbGVlcCA9IChtcykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgICB9KTtcbn07XG5jb25zdCBtZXJnZU9iamVjdCA9ICguLi5wYXJhbXMpID0+IG1lcmdlJDEoe30sIC4uLnBhcmFtcyk7XG5jb25zdCBtZXJnZU9iamVjdFJlcGxhY2luZ0FycmF5cyA9ICguLi5wYXJhbXMpID0+IG1lcmdlV2l0aCQxKHt9LCAuLi5wYXJhbXMsIChfYSwgYikgPT4gaXNBcnJheSRmKGIpID8gYiA6IHVuZGVmaW5lZCk7XG5jb25zdCBsb2cgPSAobiwgYmFzZSA9IGUpID0+IHtcbiAgICByZXR1cm4gTWF0aC5sb2cobikgLyAoYmFzZSA/IE1hdGgubG9nKGJhc2UpIDogMSk7XG59O1xuY29uc3QgYW50aWxvZyA9IChuLCBiYXNlID0gZSkgPT4ge1xuICAgIGlmIChiYXNlID09PSBlKVxuICAgICAgICByZXR1cm4gTWF0aC5leHAobik7XG4gICAgcmV0dXJuIGJhc2UgKiogbjtcbn07XG5jb25zdCBvcGVuVXJsSW5OZXdUYWIgPSAodXJsKSA9PiB7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgIHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycpPy5mb2N1cygpO1xuICAgIH1cbn07XG5jb25zdCBpc0VxdWFsSWdub3JpbmdPcmRlciA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGlzQXJyYXkkZihhKSAmJiBpc0FycmF5JGYoYikpIHtcbiAgICAgICAgcmV0dXJuIGlzRXF1YWwkMShzb3J0QnkkMShhLCBbKHYpID0+IHZdKSwgc29ydEJ5JDEoYiwgWyh2KSA9PiB2XSkpO1xuICAgIH1cbiAgICByZXR1cm4gaXNFcXVhbCQxKGEsIGIpO1xufTtcbmNvbnN0IGNsYW1wVmFsdWUgPSAoeyBtaW4sIG1heCwgdmFsdWUsIH0pID0+IHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPD0gbWluKSB7XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IGtleUJ5V2l0aFVuZGVmaW5lZCA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSkgPT4ge1xuICAgIHJldHVybiAoY29sbGVjdGlvbiA/IGtleUJ5JDEoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIDoge30pO1xufTtcbmNvbnN0IGdldFJhbmRvbU51bWJlciA9IChtaW4sIG1heCkgPT4ge1xuICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICAgIGNvbnN0IGRpc3RhbmNlVGhyb3VnaFJhbmdlID0gTWF0aC5yYW5kb20oKSAqIHJhbmdlO1xuICAgIHJldHVybiBtaW4gKyBkaXN0YW5jZVRocm91Z2hSYW5nZTtcbn07XG5jb25zdCBnZXRSYW5kb21JbnRlZ2VyID0gKG1pbiwgbWF4KSA9PiB7XG4gICAgY29uc3QgcmFuZG9tTnVtYmVyID0gZ2V0UmFuZG9tTnVtYmVyKG1pbiwgbWF4KTtcbiAgICBjb25zdCByb3VuZGVkRG93biA9IE1hdGguZmxvb3IocmFuZG9tTnVtYmVyKTtcbiAgICBjb25zdCByb3VuZGVkVXAgPSBNYXRoLmNlaWwocmFuZG9tTnVtYmVyKTtcbiAgICBjb25zdCBudW1iZXIgPSBNYXRoLnJhbmRvbSgpID4gMC41ID8gcm91bmRlZERvd24gOiByb3VuZGVkVXA7XG4gICAgaWYgKG51bWJlciA+IG1heCkge1xuICAgICAgICByZXR1cm4gbnVtYmVyIC0gMTtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IG1pbikge1xuICAgICAgICByZXR1cm4gbnVtYmVyICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIG51bWJlcjtcbn07XG5cbmNvbnN0IGFzc2VydFRydXRoeU9yWmVybyA9ICh2YWx1ZSkgPT4gaXNUcnV0aHlPclplcm8odmFsdWUpO1xuXG5jb25zdCBDQUNIRV9USU1FXzcyX0hPVVJTID0gMTAwMCAqIDYwICogNjAgKiA3MjtcbmNvbnN0IENBQ0hFX1RJTUVfNDhfSE9VUlMgPSAxMDAwICogNjAgKiA2MCAqIDQ4O1xuY29uc3QgQ0FDSEVfVElNRV8xX0hPVVIgPSAxMDAwICogNjAgKiA2MCAqIDE7XG5jb25zdCBDQUNIRV9USU1FXzMwX01JTlVURVMgPSAxMDAwICogNjAgKiAzMDtcbmNvbnN0IGNyZWF0ZVRpbWVNc0luTWludXRlcyA9IChtaW51dGVzID0gMCkgPT4gMTAwMCAqIDYwICogbWludXRlcztcbmNvbnN0IGNyZWF0ZVRpbWVNc0luSG91cnMgPSAoaG91cnMgPSAwKSA9PiBjcmVhdGVUaW1lTXNJbk1pbnV0ZXMoNjAgKiBob3Vycyk7XG5jb25zdCBjcmVhdGVUaW1lTXNJbkRheXMgPSAoZGF5cyA9IDApID0+IGNyZWF0ZVRpbWVNc0luSG91cnMoMjQgKiBkYXlzKTtcblxuZXhwb3J0IHsgQ0FDSEVfVElNRV8xX0hPVVIsIENBQ0hFX1RJTUVfMzBfTUlOVVRFUywgQ0FDSEVfVElNRV80OF9IT1VSUywgQ0FDSEVfVElNRV83Ml9IT1VSUywgUkdCQVRvSGV4QSwgYW50aWxvZywgYXJyYXlXaXRob3V0RWxlbWVudHMsIGFzc2VydFRydXRoeU9yWmVybywgY2FwaXRhbGlzZUZpcnN0TGV0dGVyLCBjaGVja0lmVGV4dFRlcm1NYXRjaGVzQXJyYXksIGNoZWNrSWZUZXh0VGVybU1hdGNoZXNTaW5nbGUsIGNsYW1wVmFsdWUsIGNsZWFuU3RyaW5nLCBjb25kaXRpb25hbE9ySWZUcnV0aHlPclplcm8sIGNyZWF0ZUN1c3RvbUZpbGVOYW1lS2V5RnJvbU9iamVjdCwgY3JlYXRlQ3VzdG9tS2V5LCBjcmVhdGVDdXN0b21LZXlGcm9tT2JqZWN0LCBjcmVhdGVDdXN0b21LZXlGcm9tU3JjVGd0LCBjcmVhdGVUaW1lTXNJbkRheXMsIGNyZWF0ZVRpbWVNc0luSG91cnMsIGNyZWF0ZVRpbWVNc0luTWludXRlcywgZG93bmxvYWRDU1YsIGRvd25sb2FkRnJvbU9iamVjdFVSTCwgZG93bmxvYWRKU09OLCBldmFsdWF0ZU9uZU9yWmVyb0Jvb2xlYW5JZk5vdEVtcHR5U3RyaW5nLCBldmFsdWF0ZU9uZU9yWmVyb0Jvb2xlYW5JZk5vdFVuZGVmaW5lZCwgZXZhbHVhdGVUcnV0aHlJZk5vdFVuZGVmaW5lZCwgZ2VuZXJhdGVDU1YsIGdlbmVyYXRlUXVlcnlTdHJpbmcsIGdldE5SYW5kb21FbGVtZW50c0Zyb21BcnJheSwgZ2V0TmV4dEpTUXVlcnlQYXJhbSwgZ2V0UmFuZG9tRWxlbWVudEZyb21BcnJheSwgZ2V0UmFuZG9tRWxlbWVudHNGcm9tQXJyYXksIGdldFJhbmRvbUludGVnZXIsIGdldFJhbmRvbU51bWJlciwgZ2V0UmVhY3RRdWVyeVN0YXR1cywgaXNCcm93c2VyLCBpc0VtYWlsLCBpc0VxdWFsSWdub3JpbmdPcmRlciwgaXNUcnV0aHlPclplcm8sIGtleUJ5V2l0aFVuZGVmaW5lZCwgbG9nLCBtZXJnZUNsYXNzTmFtZXNEZWVwLCBtZXJnZUNsYXNzTmFtZXNGdW5jdGlvbnNEZWVwLCBtZXJnZU9iamVjdCwgbWVyZ2VPYmplY3RSZXBsYWNpbmdBcnJheXMsIG5vcm1hbGlzZVN0cmluZywgb3BlblVybEluTmV3VGFiLCBwYXJzZUVudlZhcmlhYmxlLCBwYXJzZUVudlZhcmlhYmxlcywgcmVtb3ZlVW5kZWZpbmVkQW5kRW1wdHlTdHJpbmdWYWx1ZXNGcm9tT2JqLCByZW1vdmVVbmRlZmluZWRBbmROdWxsVmFsdWVzRnJvbU9iaiwgcmVtb3ZlVW5kZWZpbmVkVmFsdWVzRnJvbU9iaiwgcm91bmROdW1iZXIsIHNhbml0aXNlVGV4dFRlcm0sIHNsZWVwLCBzdHJpbmdzRXF1YWxJbnNlbnNpdGl2ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkNBQ0hFX1RJTUVfMV9IT1VSIiwiQ0FDSEVfVElNRV8zMF9NSU5VVEVTIiwiQ0FDSEVfVElNRV80OF9IT1VSUyIsIkNBQ0hFX1RJTUVfNzJfSE9VUlMiLCJSR0JBVG9IZXhBIiwiYW50aWxvZyIsImFycmF5V2l0aG91dEVsZW1lbnRzIiwiYXNzZXJ0VHJ1dGh5T3JaZXJvIiwiY2FwaXRhbGlzZUZpcnN0TGV0dGVyIiwiY2hlY2tJZlRleHRUZXJtTWF0Y2hlc0FycmF5IiwiY2hlY2tJZlRleHRUZXJtTWF0Y2hlc1NpbmdsZSIsImNsYW1wVmFsdWUiLCJjbGVhblN0cmluZyIsImNvbmRpdGlvbmFsT3JJZlRydXRoeU9yWmVybyIsImNyZWF0ZUN1c3RvbUZpbGVOYW1lS2V5RnJvbU9iamVjdCIsImNyZWF0ZUN1c3RvbUtleSIsImNyZWF0ZUN1c3RvbUtleUZyb21PYmplY3QiLCJjcmVhdGVDdXN0b21LZXlGcm9tU3JjVGd0IiwiY3JlYXRlVGltZU1zSW5EYXlzIiwiY3JlYXRlVGltZU1zSW5Ib3VycyIsImNyZWF0ZVRpbWVNc0luTWludXRlcyIsImRvd25sb2FkQ1NWIiwiZG93bmxvYWRGcm9tT2JqZWN0VVJMIiwiZG93bmxvYWRKU09OIiwiZXZhbHVhdGVPbmVPclplcm9Cb29sZWFuSWZOb3RFbXB0eVN0cmluZyIsImV2YWx1YXRlT25lT3JaZXJvQm9vbGVhbklmTm90VW5kZWZpbmVkIiwiZXZhbHVhdGVUcnV0aHlJZk5vdFVuZGVmaW5lZCIsImdlbmVyYXRlQ1NWIiwiZ2VuZXJhdGVRdWVyeVN0cmluZyIsImdldE5SYW5kb21FbGVtZW50c0Zyb21BcnJheSIsImdldE5leHRKU1F1ZXJ5UGFyYW0iLCJnZXRSYW5kb21FbGVtZW50RnJvbUFycmF5IiwiZ2V0UmFuZG9tRWxlbWVudHNGcm9tQXJyYXkiLCJnZXRSYW5kb21JbnRlZ2VyIiwiZ2V0UmFuZG9tTnVtYmVyIiwiZ2V0UmVhY3RRdWVyeVN0YXR1cyIsImlzQnJvd3NlciIsImlzRW1haWwiLCJpc0VxdWFsSWdub3JpbmdPcmRlciIsImlzVHJ1dGh5T3JaZXJvIiwia2V5QnlXaXRoVW5kZWZpbmVkIiwibG9nIiwibWVyZ2VDbGFzc05hbWVzRGVlcCIsIm1lcmdlQ2xhc3NOYW1lc0Z1bmN0aW9uc0RlZXAiLCJtZXJnZU9iamVjdCIsIm1lcmdlT2JqZWN0UmVwbGFjaW5nQXJyYXlzIiwibm9ybWFsaXNlU3RyaW5nIiwib3BlblVybEluTmV3VGFiIiwicGFyc2VFbnZWYXJpYWJsZSIsInBhcnNlRW52VmFyaWFibGVzIiwicmVtb3ZlVW5kZWZpbmVkQW5kRW1wdHlTdHJpbmdWYWx1ZXNGcm9tT2JqIiwicmVtb3ZlVW5kZWZpbmVkQW5kTnVsbFZhbHVlc0Zyb21PYmoiLCJyZW1vdmVVbmRlZmluZWRWYWx1ZXNGcm9tT2JqIiwicm91bmROdW1iZXIiLCJzYW5pdGlzZVRleHRUZXJtIiwic2xlZXAiLCJzdHJpbmdzRXF1YWxJbnNlbnNpdGl2ZSIsImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIngiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXJyYXlSZWR1Y2UkMiIsImFycmF5IiwiaXRlcmF0ZWUiLCJhY2N1bXVsYXRvciIsImluaXRBY2N1bSIsImluZGV4IiwibGVuZ3RoIiwiX2FycmF5UmVkdWNlIiwiY3JlYXRlQmFzZUZvciQxIiwiZnJvbVJpZ2h0Iiwib2JqZWN0Iiwia2V5c0Z1bmMiLCJpdGVyYWJsZSIsInByb3BzIiwia2V5IiwiX2NyZWF0ZUJhc2VGb3IiLCJjcmVhdGVCYXNlRm9yIiwiYmFzZUZvciQyIiwiX2Jhc2VGb3IiLCJiYXNlVGltZXMkMSIsIm4iLCJyZXN1bHQiLCJBcnJheSIsIl9iYXNlVGltZXMiLCJmcmVlR2xvYmFsJDEiLCJfZnJlZUdsb2JhbCIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QkOCIsIkZ1bmN0aW9uIiwiX3Jvb3QiLCJyb290JDciLCJTeW1ib2wkNiIsIlN5bWJvbCIsIl9TeW1ib2wiLCJTeW1ib2wkNSIsIm9iamVjdFByb3RvJGUiLCJoYXNPd25Qcm9wZXJ0eSRiIiwibmF0aXZlT2JqZWN0VG9TdHJpbmckMSIsInRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWckMSIsInRvU3RyaW5nVGFnIiwidW5kZWZpbmVkIiwiZ2V0UmF3VGFnJDEiLCJ2YWx1ZSIsImlzT3duIiwidGFnIiwidW5tYXNrZWQiLCJlIiwiX2dldFJhd1RhZyIsIm9iamVjdFByb3RvJGQiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsIm9iamVjdFRvU3RyaW5nJDEiLCJfb2JqZWN0VG9TdHJpbmciLCJTeW1ib2wkNCIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwiYmFzZUdldFRhZyQ2IiwiX2Jhc2VHZXRUYWciLCJpc09iamVjdExpa2UkNyIsImlzT2JqZWN0TGlrZV8xIiwiYmFzZUdldFRhZyQ1IiwiaXNPYmplY3RMaWtlJDYiLCJhcmdzVGFnJDIiLCJiYXNlSXNBcmd1bWVudHMkMSIsIl9iYXNlSXNBcmd1bWVudHMiLCJiYXNlSXNBcmd1bWVudHMiLCJpc09iamVjdExpa2UkNSIsIm9iamVjdFByb3RvJGMiLCJoYXNPd25Qcm9wZXJ0eSRhIiwicHJvcGVydHlJc0VudW1lcmFibGUkMSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMkNCIsImFyZ3VtZW50cyIsImlzQXJndW1lbnRzXzEiLCJpc0FycmF5JGUiLCJpc0FycmF5IiwiaXNBcnJheV8xIiwiaXNBcnJheSRmIiwiaXNCdWZmZXIkNCIsImV4cG9ydHMiLCJzdHViRmFsc2UiLCJzdHViRmFsc2VfMSIsIm1vZHVsZSIsInJvb3QiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiaXNCdWZmZXJFeHBvcnRzIiwiTUFYX1NBRkVfSU5URUdFUiQxIiwicmVJc1VpbnQiLCJpc0luZGV4JDMiLCJ0eXBlIiwidGVzdCIsIl9pc0luZGV4IiwiTUFYX1NBRkVfSU5URUdFUiIsImlzTGVuZ3RoJDMiLCJpc0xlbmd0aF8xIiwiYmFzZUdldFRhZyQ0IiwiaXNMZW5ndGgkMiIsImlzT2JqZWN0TGlrZSQ0IiwiYXJnc1RhZyQxIiwiYXJyYXlUYWckMSIsImJvb2xUYWckMSIsImRhdGVUYWckMSIsImVycm9yVGFnJDEiLCJmdW5jVGFnJDEiLCJtYXBUYWckMiIsIm51bWJlclRhZyQxIiwib2JqZWN0VGFnJDMiLCJyZWdleHBUYWckMSIsInNldFRhZyQyIiwic3RyaW5nVGFnJDEiLCJ3ZWFrTWFwVGFnJDEiLCJhcnJheUJ1ZmZlclRhZyQxIiwiZGF0YVZpZXdUYWckMiIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSQxIiwiX2Jhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkkMiIsImZ1bmMiLCJfYmFzZVVuYXJ5IiwiX25vZGVVdGlsIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwiX25vZGVVdGlsRXhwb3J0cyIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkkMSIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkkMyIsImlzVHlwZWRBcnJheV8xIiwiYmFzZVRpbWVzIiwiaXNBcmd1bWVudHMkMyIsImlzQXJyYXkkZCIsImlzQnVmZmVyJDMiLCJpc0luZGV4JDIiLCJpc1R5cGVkQXJyYXkkMiIsIm9iamVjdFByb3RvJGIiLCJoYXNPd25Qcm9wZXJ0eSQ5IiwiYXJyYXlMaWtlS2V5cyQyIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiU3RyaW5nIiwicHVzaCIsIl9hcnJheUxpa2VLZXlzIiwib2JqZWN0UHJvdG8kYSIsImlzUHJvdG90eXBlJDMiLCJDdG9yIiwiY29uc3RydWN0b3IiLCJwcm90byIsIl9pc1Byb3RvdHlwZSIsIm92ZXJBcmckMiIsInRyYW5zZm9ybSIsImFyZyIsIl9vdmVyQXJnIiwib3ZlckFyZyQxIiwibmF0aXZlS2V5cyQxIiwia2V5cyIsIl9uYXRpdmVLZXlzIiwiaXNQcm90b3R5cGUkMiIsIm5hdGl2ZUtleXMiLCJvYmplY3RQcm90byQ5IiwiaGFzT3duUHJvcGVydHkkOCIsImJhc2VLZXlzJDEiLCJfYmFzZUtleXMiLCJpc09iamVjdCQ4IiwiaXNPYmplY3RfMSIsImlzT2JqZWN0JDkiLCJiYXNlR2V0VGFnJDMiLCJpc09iamVjdCQ3IiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uJDMiLCJpc0Z1bmN0aW9uXzEiLCJpc0Z1bmN0aW9uJDIiLCJpc0xlbmd0aCQxIiwiaXNBcnJheUxpa2UkNiIsImlzQXJyYXlMaWtlXzEiLCJhcnJheUxpa2VLZXlzJDEiLCJiYXNlS2V5cyIsImlzQXJyYXlMaWtlJDUiLCJrZXlzJDMiLCJrZXlzXzEiLCJiYXNlRm9yJDEiLCJrZXlzJDIiLCJiYXNlRm9yT3duJDMiLCJfYmFzZUZvck93biIsImlzQXJyYXlMaWtlJDQiLCJjcmVhdGVCYXNlRWFjaCQxIiwiZWFjaEZ1bmMiLCJjb2xsZWN0aW9uIiwiX2NyZWF0ZUJhc2VFYWNoIiwiYmFzZUZvck93biQyIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRWFjaCQzIiwiX2Jhc2VFYWNoIiwibGlzdENhY2hlQ2xlYXIkMSIsIl9fZGF0YV9fIiwic2l6ZSIsIl9saXN0Q2FjaGVDbGVhciIsImVxJDUiLCJvdGhlciIsImVxXzEiLCJlcSQ0IiwiYXNzb2NJbmRleE9mJDQiLCJfYXNzb2NJbmRleE9mIiwiYXNzb2NJbmRleE9mJDMiLCJhcnJheVByb3RvIiwic3BsaWNlIiwibGlzdENhY2hlRGVsZXRlJDEiLCJkYXRhIiwibGFzdEluZGV4IiwicG9wIiwiX2xpc3RDYWNoZURlbGV0ZSIsImFzc29jSW5kZXhPZiQyIiwibGlzdENhY2hlR2V0JDEiLCJfbGlzdENhY2hlR2V0IiwiYXNzb2NJbmRleE9mJDEiLCJsaXN0Q2FjaGVIYXMkMSIsIl9saXN0Q2FjaGVIYXMiLCJhc3NvY0luZGV4T2YiLCJsaXN0Q2FjaGVTZXQkMSIsIl9saXN0Q2FjaGVTZXQiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSQ0IiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJzZXQiLCJnZXQiLCJoYXMiLCJfTGlzdENhY2hlIiwiTGlzdENhY2hlJDMiLCJzdGFja0NsZWFyJDEiLCJfc3RhY2tDbGVhciIsInN0YWNrRGVsZXRlJDEiLCJfc3RhY2tEZWxldGUiLCJzdGFja0dldCQxIiwiX3N0YWNrR2V0Iiwic3RhY2tIYXMkMSIsIl9zdGFja0hhcyIsInJvb3QkNiIsImNvcmVKc0RhdGEkMSIsIl9jb3JlSnNEYXRhIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwiSUVfUFJPVE8iLCJpc01hc2tlZCQxIiwiX2lzTWFza2VkIiwiZnVuY1Byb3RvJDIiLCJmdW5jVG9TdHJpbmckMiIsInRvU291cmNlJDIiLCJfdG9Tb3VyY2UiLCJpc0Z1bmN0aW9uJDEiLCJpc01hc2tlZCIsImlzT2JqZWN0JDYiLCJ0b1NvdXJjZSQxIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwiZnVuY1Byb3RvJDEiLCJvYmplY3RQcm90byQ4IiwiZnVuY1RvU3RyaW5nJDEiLCJoYXNPd25Qcm9wZXJ0eSQ3IiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsInJlcGxhY2UiLCJiYXNlSXNOYXRpdmUkMSIsInBhdHRlcm4iLCJfYmFzZUlzTmF0aXZlIiwiZ2V0VmFsdWUkMSIsIl9nZXRWYWx1ZSIsImJhc2VJc05hdGl2ZSIsImdldFZhbHVlIiwiZ2V0TmF0aXZlJDciLCJfZ2V0TmF0aXZlIiwiZ2V0TmF0aXZlJDYiLCJyb290JDUiLCJNYXAkMyIsIl9NYXAiLCJnZXROYXRpdmUkNSIsIm5hdGl2ZUNyZWF0ZSQ0IiwiX25hdGl2ZUNyZWF0ZSIsIm5hdGl2ZUNyZWF0ZSQzIiwiaGFzaENsZWFyJDEiLCJfaGFzaENsZWFyIiwiaGFzaERlbGV0ZSQxIiwiX2hhc2hEZWxldGUiLCJuYXRpdmVDcmVhdGUkMiIsIkhBU0hfVU5ERUZJTkVEJDIiLCJvYmplY3RQcm90byQ3IiwiaGFzT3duUHJvcGVydHkkNiIsImhhc2hHZXQkMSIsIl9oYXNoR2V0IiwibmF0aXZlQ3JlYXRlJDEiLCJvYmplY3RQcm90byQ2IiwiaGFzT3duUHJvcGVydHkkNSIsImhhc2hIYXMkMSIsIl9oYXNoSGFzIiwibmF0aXZlQ3JlYXRlIiwiSEFTSF9VTkRFRklORUQkMSIsImhhc2hTZXQkMSIsIl9oYXNoU2V0IiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2gkMSIsIl9IYXNoIiwiSGFzaCIsIkxpc3RDYWNoZSQyIiwiTWFwJDIiLCJtYXBDYWNoZUNsZWFyJDEiLCJfbWFwQ2FjaGVDbGVhciIsImlzS2V5YWJsZSQxIiwiX2lzS2V5YWJsZSIsImlzS2V5YWJsZSIsImdldE1hcERhdGEkNCIsIm1hcCIsIl9nZXRNYXBEYXRhIiwiZ2V0TWFwRGF0YSQzIiwibWFwQ2FjaGVEZWxldGUkMSIsIl9tYXBDYWNoZURlbGV0ZSIsImdldE1hcERhdGEkMiIsIm1hcENhY2hlR2V0JDEiLCJfbWFwQ2FjaGVHZXQiLCJnZXRNYXBEYXRhJDEiLCJtYXBDYWNoZUhhcyQxIiwiX21hcENhY2hlSGFzIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlU2V0JDEiLCJfbWFwQ2FjaGVTZXQiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSQzIiwiX01hcENhY2hlIiwiTGlzdENhY2hlJDEiLCJNYXAkMSIsIk1hcENhY2hlJDIiLCJMQVJHRV9BUlJBWV9TSVpFIiwic3RhY2tTZXQkMSIsInBhaXJzIiwiX3N0YWNrU2V0IiwiTGlzdENhY2hlIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiU3RhY2skMyIsIl9TdGFjayIsIkhBU0hfVU5ERUZJTkVEIiwic2V0Q2FjaGVBZGQkMSIsIl9zZXRDYWNoZUFkZCIsInNldENhY2hlSGFzJDEiLCJfc2V0Q2FjaGVIYXMiLCJNYXBDYWNoZSQxIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlNldENhY2hlJDEiLCJ2YWx1ZXMiLCJhZGQiLCJfU2V0Q2FjaGUiLCJhcnJheVNvbWUkMSIsInByZWRpY2F0ZSIsIl9hcnJheVNvbWUiLCJjYWNoZUhhcyQxIiwiY2FjaGUiLCJfY2FjaGVIYXMiLCJTZXRDYWNoZSIsImFycmF5U29tZSIsImNhY2hlSGFzIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMyIsImVxdWFsQXJyYXlzJDIiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsImVxdWFsRnVuYyIsInN0YWNrIiwiaXNQYXJ0aWFsIiwiYXJyTGVuZ3RoIiwib3RoTGVuZ3RoIiwiYXJyU3RhY2tlZCIsIm90aFN0YWNrZWQiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJfZXF1YWxBcnJheXMiLCJyb290JDQiLCJVaW50OEFycmF5JDMiLCJVaW50OEFycmF5IiwiX1VpbnQ4QXJyYXkiLCJtYXBUb0FycmF5JDEiLCJmb3JFYWNoIiwiX21hcFRvQXJyYXkiLCJzZXRUb0FycmF5JDEiLCJfc2V0VG9BcnJheSIsIlN5bWJvbCQzIiwiVWludDhBcnJheSQyIiwiZXEkMyIsImVxdWFsQXJyYXlzJDEiLCJtYXBUb0FycmF5Iiwic2V0VG9BcnJheSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDQiLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHJDIiLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnJDEiLCJudW1iZXJUYWciLCJyZWdleHBUYWciLCJzZXRUYWckMSIsInN0cmluZ1RhZyIsInN5bWJvbFRhZyQxIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyQxIiwic3ltYm9sUHJvdG8kMSIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiZXF1YWxCeVRhZyQxIiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJidWZmZXIiLCJuYW1lIiwibWVzc2FnZSIsImNvbnZlcnQiLCJzdGFja2VkIiwiX2VxdWFsQnlUYWciLCJhcnJheVB1c2gkMiIsIm9mZnNldCIsIl9hcnJheVB1c2giLCJhcnJheVB1c2gkMSIsImlzQXJyYXkkYyIsImJhc2VHZXRBbGxLZXlzJDEiLCJzeW1ib2xzRnVuYyIsIl9iYXNlR2V0QWxsS2V5cyIsImFycmF5RmlsdGVyJDEiLCJyZXNJbmRleCIsIl9hcnJheUZpbHRlciIsInN0dWJBcnJheSQxIiwic3R1YkFycmF5XzEiLCJhcnJheUZpbHRlciIsInN0dWJBcnJheSIsIm9iamVjdFByb3RvJDUiLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0U3ltYm9scyQxIiwic3ltYm9sIiwiX2dldFN5bWJvbHMiLCJiYXNlR2V0QWxsS2V5cyIsImdldFN5bWJvbHMiLCJrZXlzJDEiLCJnZXRBbGxLZXlzJDEiLCJfZ2V0QWxsS2V5cyIsImdldEFsbEtleXMiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyQzIiwib2JqZWN0UHJvdG8kNCIsImhhc093blByb3BlcnR5JDQiLCJlcXVhbE9iamVjdHMkMSIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJvYmpTdGFja2VkIiwic2tpcEN0b3IiLCJvYmpWYWx1ZSIsIm9iakN0b3IiLCJvdGhDdG9yIiwiX2VxdWFsT2JqZWN0cyIsImdldE5hdGl2ZSQ0Iiwicm9vdCQzIiwiRGF0YVZpZXckMSIsIl9EYXRhVmlldyIsImdldE5hdGl2ZSQzIiwicm9vdCQyIiwiUHJvbWlzZSQyIiwiX1Byb21pc2UiLCJnZXROYXRpdmUkMiIsInJvb3QkMSIsIlNldCQyIiwiX1NldCIsImdldE5hdGl2ZSQxIiwiV2Vha01hcCQxIiwiX1dlYWtNYXAiLCJEYXRhVmlldyIsIk1hcCIsIlByb21pc2UkMSIsIlNldCQxIiwiV2Vha01hcCIsImJhc2VHZXRUYWckMiIsInRvU291cmNlIiwibWFwVGFnIiwib2JqZWN0VGFnJDIiLCJwcm9taXNlVGFnIiwic2V0VGFnIiwid2Vha01hcFRhZyIsImRhdGFWaWV3VGFnIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiZ2V0VGFnJDIiLCJBcnJheUJ1ZmZlciIsInJlc29sdmUiLCJjdG9yU3RyaW5nIiwiX2dldFRhZyIsIlN0YWNrJDIiLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJlcXVhbE9iamVjdHMiLCJnZXRUYWckMSIsImlzQXJyYXkkYiIsImlzQnVmZmVyJDIiLCJpc1R5cGVkQXJyYXkkMSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDIiLCJhcmdzVGFnIiwiYXJyYXlUYWciLCJvYmplY3RUYWckMSIsIm9iamVjdFByb3RvJDMiLCJoYXNPd25Qcm9wZXJ0eSQzIiwiYmFzZUlzRXF1YWxEZWVwJDEiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsIl9iYXNlSXNFcXVhbERlZXAiLCJiYXNlSXNFcXVhbERlZXAiLCJpc09iamVjdExpa2UkMyIsImJhc2VJc0VxdWFsJDMiLCJfYmFzZUlzRXF1YWwiLCJTdGFjayQxIiwiYmFzZUlzRXF1YWwkMiIsIkNPTVBBUkVfUEFSVElBTF9GTEFHJDEiLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHJDEiLCJiYXNlSXNNYXRjaCQxIiwic291cmNlIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwic3JjVmFsdWUiLCJfYmFzZUlzTWF0Y2giLCJpc09iamVjdCQ1IiwiaXNTdHJpY3RDb21wYXJhYmxlJDIiLCJfaXNTdHJpY3RDb21wYXJhYmxlIiwiaXNTdHJpY3RDb21wYXJhYmxlJDEiLCJnZXRNYXRjaERhdGEkMSIsIl9nZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQyIiwiX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiYmFzZUlzTWF0Y2giLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSQxIiwiYmFzZU1hdGNoZXMkMSIsIl9iYXNlTWF0Y2hlcyIsImJhc2VHZXRUYWckMSIsImlzT2JqZWN0TGlrZSQyIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wkNSIsImlzU3ltYm9sXzEiLCJpc0FycmF5JGEiLCJpc1N5bWJvbCQ0IiwicmVJc0RlZXBQcm9wJDEiLCJyZUlzUGxhaW5Qcm9wJDEiLCJpc0tleSQ0IiwiX2lzS2V5IiwiTWFwQ2FjaGUiLCJGVU5DX0VSUk9SX1RFWFQiLCJtZW1vaXplJDEiLCJyZXNvbHZlciIsIlR5cGVFcnJvciIsIm1lbW9pemVkIiwiYXJncyIsImFwcGx5IiwiQ2FjaGUiLCJtZW1vaXplXzEiLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQkMSIsIl9tZW1vaXplQ2FwcGVkIiwibWVtb2l6ZUNhcHBlZCIsInJlUHJvcE5hbWUkMSIsInJlRXNjYXBlQ2hhciQxIiwic3RyaW5nVG9QYXRoJDIiLCJzdHJpbmciLCJjaGFyQ29kZUF0IiwibWF0Y2giLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsIl9zdHJpbmdUb1BhdGgiLCJhcnJheU1hcCQyIiwiX2FycmF5TWFwIiwiU3ltYm9sJDIiLCJhcnJheU1hcCQxIiwiaXNBcnJheSQ5IiwiaXNTeW1ib2wkMyIsIklORklOSVRZJDIiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nJDEiLCJfYmFzZVRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nIiwidG9TdHJpbmckNSIsInRvU3RyaW5nXzEiLCJpc0FycmF5JDgiLCJpc0tleSQzIiwic3RyaW5nVG9QYXRoJDEiLCJ0b1N0cmluZyQ0IiwiY2FzdFBhdGgkMyIsIl9jYXN0UGF0aCIsImlzU3ltYm9sJDIiLCJJTkZJTklUWSQxIiwidG9LZXkkNSIsIl90b0tleSIsImNhc3RQYXRoJDIiLCJ0b0tleSQ0IiwiYmFzZUdldCQzIiwicGF0aCIsIl9iYXNlR2V0IiwiYmFzZUdldCQyIiwiZ2V0JDIiLCJkZWZhdWx0VmFsdWUiLCJnZXRfMSIsImJhc2VIYXNJbiQxIiwiX2Jhc2VIYXNJbiIsImNhc3RQYXRoJDEiLCJpc0FyZ3VtZW50cyQyIiwiaXNBcnJheSQ3IiwiaXNJbmRleCQxIiwiaXNMZW5ndGgiLCJ0b0tleSQzIiwiaGFzUGF0aCQxIiwiaGFzRnVuYyIsIl9oYXNQYXRoIiwiYmFzZUhhc0luIiwiaGFzUGF0aCIsImhhc0luJDEiLCJoYXNJbl8xIiwiYmFzZUlzRXF1YWwkMSIsImdldCQxIiwiaGFzSW4iLCJpc0tleSQyIiwiaXNTdHJpY3RDb21wYXJhYmxlIiwibWF0Y2hlc1N0cmljdENvbXBhcmFibGUiLCJ0b0tleSQyIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSQxIiwiX2Jhc2VNYXRjaGVzUHJvcGVydHkiLCJpZGVudGl0eSQ0IiwiaWRlbnRpdHlfMSIsImJhc2VQcm9wZXJ0eSQxIiwiX2Jhc2VQcm9wZXJ0eSIsImJhc2VHZXQkMSIsImJhc2VQcm9wZXJ0eURlZXAkMSIsIl9iYXNlUHJvcGVydHlEZWVwIiwiYmFzZVByb3BlcnR5IiwiYmFzZVByb3BlcnR5RGVlcCIsImlzS2V5JDEiLCJ0b0tleSQxIiwicHJvcGVydHkkMSIsInByb3BlcnR5XzEiLCJiYXNlTWF0Y2hlcyIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJpZGVudGl0eSQzIiwiaXNBcnJheSQ2IiwicHJvcGVydHkiLCJiYXNlSXRlcmF0ZWUkNSIsIl9iYXNlSXRlcmF0ZWUiLCJiYXNlUmVkdWNlJDEiLCJfYmFzZVJlZHVjZSIsImFycmF5UmVkdWNlJDEiLCJiYXNlRWFjaCQyIiwiYmFzZUl0ZXJhdGVlJDQiLCJiYXNlUmVkdWNlIiwiaXNBcnJheSQ1IiwicmVkdWNlIiwicmVkdWNlXzEiLCJyZWR1Y2UkMSIsImdsb2JhbCQxIiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiaW5pdGVkIiwiaW5pdCIsImNvZGUiLCJpIiwibGVuIiwidG9CeXRlQXJyYXkiLCJiNjQiLCJqIiwibCIsInRtcCIsInBsYWNlSG9sZGVycyIsImFyciIsIkVycm9yIiwiTCIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJzdGFydCIsImVuZCIsIm91dHB1dCIsImpvaW4iLCJmcm9tQnl0ZUFycmF5IiwiZXh0cmFCeXRlcyIsInBhcnRzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwicmVhZCIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwibSIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsImQiLCJzIiwiTmFOIiwiSW5maW5pdHkiLCJNYXRoIiwicG93Iiwid3JpdGUiLCJjIiwicnQiLCJhYnMiLCJpc05hTiIsImZsb29yIiwiTE4yIiwidG9TdHJpbmckMyIsImlzQXJyYXkkNCIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsImtNYXhMZW5ndGgiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiUmFuZ2VFcnJvciIsIl9fcHJvdG9fXyIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJzcGVjaWVzIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiZmlsbCIsImVuY29kaW5nIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsImlzRW5jb2RpbmciLCJhY3R1YWwiLCJzbGljZSIsImZyb21BcnJheUxpa2UiLCJvYmoiLCJpbnRlcm5hbElzQnVmZmVyIiwiY29weSIsImlzbmFuIiwiaXNCdWZmZXIkMSIsImIiLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwiYSIsInkiLCJtaW4iLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImxpc3QiLCJwb3MiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwiaW5zcGVjdCIsInN0ciIsIm1heCIsInRhcmdldCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsInZhbCIsImRpciIsImFycmF5SW5kZXhPZiIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsInZhbExlbmd0aCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJOdW1iZXIiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZWQiLCJwYXJzZUludCIsInN1YnN0ciIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsInJldCIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzdWJhcnJheSIsInNsaWNlTGVuIiwiY2hlY2tPZmZzZXQiLCJleHQiLCJyZWFkVUludExFIiwibm9Bc3NlcnQiLCJtdWwiLCJyZWFkVUludEJFIiwicmVhZFVJbnQ4IiwicmVhZFVJbnQxNkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludExFIiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ0cmltIiwidW5pdHMiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsInNyYyIsImRzdCIsImlzRmFzdEJ1ZmZlciIsImlzU2xvd0J1ZmZlciIsImNoYXJDb2RlT2ZEb3QiLCJyZUVzY2FwZUNoYXIiLCJyZVByb3BOYW1lIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsImdldFRhZyIsImlzU3ltYm9sJDEiLCJpc0tleSIsInN0cmluZ1RvUGF0aCIsImV4cHJlc3Npb24iLCJjYXN0UGF0aCIsInRvS2V5IiwiSU5GSU5JVFkiLCJpc19vYmplY3QiLCJub3JtYWxpemVfY29sdW1ucyIsImNvbHVtbnMiLCJuZXdjb2x1bW5zIiwiayIsImhlYWRlciIsImNvbHVtbiIsIkNzdkVycm9yIiwiY29udGV4dHMiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImNvbnRleHQiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJ1bmRlcnNjb3JlIiwiXyIsIm5vcm1hbGl6ZV9vcHRpb25zIiwib3B0cyIsIm9wdGlvbnMiLCJvcHQiLCJib20iLCJkZWxpbWl0ZXIiLCJxdW90ZWQiLCJlc2NhcGVfZm9ybXVsYXMiLCJxdW90ZWRfZW1wdHkiLCJxdW90ZWRfbWF0Y2giLCJpc1N0cmluZyIsImlzUmVnRXhwIiwicXVvdGVkX3N0cmluZyIsImVvZiIsImVzY2FwZSIsImVyckNvbHVtbnMiLCJjYXN0IiwiYmlnaW50IiwiYm9vbGVhbiIsImRhdGUiLCJnZXRUaW1lIiwib25fcmVjb3JkIiwicmVjb3JkX2RlbGltaXRlciIsImJvbV91dGY4Iiwic3RyaW5naWZpZXIiLCJzdGF0ZSIsImluZm8iLCJfX3RyYW5zZm9ybSIsImNodW5rIiwicmVjb3JkcyIsImVyciIsImhlYWRlcnMiLCJjaHVua19zdHJpbmciLCJjaHVua0lzSGVhZGVyIiwicmVjb3JkIiwiZmllbGQiLCJfX2Nhc3QiLCJjc3ZyZWNvcmQiLCJxdW90ZWRNYXRjaCIsImZpbHRlciIsInNob3VsZFF1b3RlIiwiY29udGFpbnNkZWxpbWl0ZXIiLCJjb250YWluc1F1b3RlIiwiY29udGFpbnNFc2NhcGUiLCJjb250YWluc1JlY29yZERlbGltaXRlciIsInF1b3RlZFN0cmluZyIsInJlZ2V4cCIsIkRhdGUiLCJzdG9wIiwiYXBpIiwiZ2V0TmF0aXZlIiwiZGVmaW5lUHJvcGVydHkkMiIsIl9kZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnR5JDEiLCJiYXNlQXNzaWduVmFsdWUkNiIsIl9iYXNlQXNzaWduVmFsdWUiLCJiYXNlQXNzaWduVmFsdWUkNSIsImJhc2VGb3JPd24kMSIsImJhc2VJdGVyYXRlZSQzIiwibWFwVmFsdWVzIiwibWFwVmFsdWVzXzEiLCJtYXBWYWx1ZXMkMSIsImJhc2VBc3NpZ25WYWx1ZSQ0IiwiZXEkMiIsImFzc2lnbk1lcmdlVmFsdWUkMiIsIl9hc3NpZ25NZXJnZVZhbHVlIiwiX2Nsb25lQnVmZmVyIiwiY2xvbmVCdWZmZXIiLCJpc0RlZXAiLCJfY2xvbmVCdWZmZXJFeHBvcnRzIiwiVWludDhBcnJheSQxIiwiY2xvbmVBcnJheUJ1ZmZlciQxIiwiYXJyYXlCdWZmZXIiLCJfY2xvbmVBcnJheUJ1ZmZlciIsImNsb25lQXJyYXlCdWZmZXIiLCJjbG9uZVR5cGVkQXJyYXkkMSIsInR5cGVkQXJyYXkiLCJfY2xvbmVUeXBlZEFycmF5IiwiY29weUFycmF5JDEiLCJfY29weUFycmF5IiwiaXNPYmplY3QkNCIsIm9iamVjdENyZWF0ZSIsImNyZWF0ZSIsImJhc2VDcmVhdGUkMSIsIl9iYXNlQ3JlYXRlIiwib3ZlckFyZyIsImdldFByb3RvdHlwZSQyIiwiZ2V0UHJvdG90eXBlT2YiLCJfZ2V0UHJvdG90eXBlIiwiYmFzZUNyZWF0ZSIsImdldFByb3RvdHlwZSQxIiwiaXNQcm90b3R5cGUkMSIsImluaXRDbG9uZU9iamVjdCQxIiwiX2luaXRDbG9uZU9iamVjdCIsImlzQXJyYXlMaWtlJDMiLCJpc09iamVjdExpa2UkMSIsImlzQXJyYXlMaWtlT2JqZWN0JDEiLCJpc0FycmF5TGlrZU9iamVjdF8xIiwiYmFzZUdldFRhZyIsImdldFByb3RvdHlwZSIsImlzT2JqZWN0TGlrZSIsIm9iamVjdFRhZyIsImZ1bmNQcm90byIsIm9iamVjdFByb3RvJDIiLCJmdW5jVG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSQyIiwib2JqZWN0Q3RvclN0cmluZyIsImlzUGxhaW5PYmplY3QkMSIsImlzUGxhaW5PYmplY3RfMSIsInNhZmVHZXQkMiIsIl9zYWZlR2V0IiwiYmFzZUFzc2lnblZhbHVlJDMiLCJlcSQxIiwib2JqZWN0UHJvdG8kMSIsImhhc093blByb3BlcnR5JDEiLCJhc3NpZ25WYWx1ZSQxIiwiX2Fzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJiYXNlQXNzaWduVmFsdWUkMiIsImNvcHlPYmplY3QkMSIsImlzTmV3IiwibmV3VmFsdWUiLCJfY29weU9iamVjdCIsIm5hdGl2ZUtleXNJbiQxIiwiX25hdGl2ZUtleXNJbiIsImlzT2JqZWN0JDMiLCJpc1Byb3RvdHlwZSIsIm5hdGl2ZUtleXNJbiIsIm9iamVjdFByb3RvIiwiYmFzZUtleXNJbiQxIiwiaXNQcm90byIsIl9iYXNlS2V5c0luIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzSW4iLCJpc0FycmF5TGlrZSQyIiwia2V5c0luJDIiLCJrZXlzSW5fMSIsImNvcHlPYmplY3QiLCJrZXlzSW4kMSIsInRvUGxhaW5PYmplY3QkMSIsInRvUGxhaW5PYmplY3RfMSIsImFzc2lnbk1lcmdlVmFsdWUkMSIsImNsb25lVHlwZWRBcnJheSIsImNvcHlBcnJheSIsImluaXRDbG9uZU9iamVjdCIsImlzQXJndW1lbnRzJDEiLCJpc0FycmF5JDMiLCJpc0FycmF5TGlrZU9iamVjdCIsImlzRnVuY3Rpb24iLCJpc09iamVjdCQyIiwiaXNQbGFpbk9iamVjdCIsInNhZmVHZXQkMSIsInRvUGxhaW5PYmplY3QiLCJiYXNlTWVyZ2VEZWVwJDEiLCJzcmNJbmRleCIsIm1lcmdlRnVuYyIsImlzQ29tbW9uIiwiaXNUeXBlZCIsIl9iYXNlTWVyZ2VEZWVwIiwiU3RhY2siLCJhc3NpZ25NZXJnZVZhbHVlIiwiYmFzZUZvciIsImJhc2VNZXJnZURlZXAiLCJpc09iamVjdCQxIiwia2V5c0luIiwic2FmZUdldCIsImJhc2VNZXJnZSQyIiwiX2Jhc2VNZXJnZSIsImFwcGx5JDEiLCJ0aGlzQXJnIiwiX2FwcGx5IiwibmF0aXZlTWF4Iiwib3ZlclJlc3QkMSIsIm90aGVyQXJncyIsIl9vdmVyUmVzdCIsImNvbnN0YW50JDEiLCJjb25zdGFudF8xIiwiY29uc3RhbnQiLCJkZWZpbmVQcm9wZXJ0eSIsImlkZW50aXR5JDIiLCJiYXNlU2V0VG9TdHJpbmckMSIsIl9iYXNlU2V0VG9TdHJpbmciLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsIm5vdyIsInNob3J0T3V0JDEiLCJjb3VudCIsImxhc3RDYWxsZWQiLCJzdGFtcCIsIl9zaG9ydE91dCIsImJhc2VTZXRUb1N0cmluZyIsInNob3J0T3V0Iiwic2V0VG9TdHJpbmckMSIsIl9zZXRUb1N0cmluZyIsImlkZW50aXR5JDEiLCJvdmVyUmVzdCIsInNldFRvU3RyaW5nIiwiYmFzZVJlc3QkMiIsIl9iYXNlUmVzdCIsImVxIiwiaXNBcnJheUxpa2UkMSIsImlzSW5kZXgiLCJpc09iamVjdCIsImlzSXRlcmF0ZWVDYWxsJDIiLCJfaXNJdGVyYXRlZUNhbGwiLCJiYXNlUmVzdCQxIiwiaXNJdGVyYXRlZUNhbGwkMSIsImNyZWF0ZUFzc2lnbmVyJDIiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsIl9jcmVhdGVBc3NpZ25lciIsImJhc2VNZXJnZSQxIiwiY3JlYXRlQXNzaWduZXIkMSIsIm1lcmdlIiwibWVyZ2VfMSIsIm1lcmdlJDEiLCJiYXNlTWVyZ2UiLCJjcmVhdGVBc3NpZ25lciIsIm1lcmdlV2l0aCIsIm1lcmdlV2l0aF8xIiwibWVyZ2VXaXRoJDEiLCJiYXNlQXNzaWduVmFsdWUkMSIsImJhc2VGb3JPd24iLCJiYXNlSXRlcmF0ZWUkMiIsIm1hcEtleXMiLCJtYXBLZXlzXzEiLCJtYXBLZXlzJDEiLCJiYXNlUHJvcGVydHlPZiQxIiwiX2Jhc2VQcm9wZXJ0eU9mIiwiYmFzZVByb3BlcnR5T2YiLCJkZWJ1cnJlZExldHRlcnMiLCJkZWJ1cnJMZXR0ZXIkMSIsIl9kZWJ1cnJMZXR0ZXIiLCJkZWJ1cnJMZXR0ZXIiLCJ0b1N0cmluZyQyIiwicmVMYXRpbiIsInJzQ29tYm9NYXJrc1JhbmdlJDMiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMyIsInJzQ29tYm9TeW1ib2xzUmFuZ2UkMyIsInJzQ29tYm9SYW5nZSQzIiwicnNDb21ibyQyIiwicmVDb21ib01hcmsiLCJkZWJ1cnIkMSIsImRlYnVycl8xIiwicmVBc2NpaVdvcmQiLCJhc2NpaVdvcmRzJDEiLCJfYXNjaWlXb3JkcyIsInJlSGFzVW5pY29kZVdvcmQiLCJoYXNVbmljb2RlV29yZCQxIiwiX2hhc1VuaWNvZGVXb3JkIiwicnNBc3RyYWxSYW5nZSQyIiwicnNDb21ib01hcmtzUmFuZ2UkMiIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSQyIiwicnNDb21ib1N5bWJvbHNSYW5nZSQyIiwicnNDb21ib1JhbmdlJDIiLCJyc0RpbmdiYXRSYW5nZSIsInJzTG93ZXJSYW5nZSIsInJzTWF0aE9wUmFuZ2UiLCJyc05vbkNoYXJSYW5nZSIsInJzUHVuY3R1YXRpb25SYW5nZSIsInJzU3BhY2VSYW5nZSIsInJzVXBwZXJSYW5nZSIsInJzVmFyUmFuZ2UkMiIsInJzQnJlYWtSYW5nZSIsInJzQXBvcyQxIiwicnNCcmVhayIsInJzQ29tYm8kMSIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiQxIiwicnNNb2RpZmllciQxIiwicnNOb25Bc3RyYWwkMSIsInJzUmVnaW9uYWwkMSIsInJzU3VyclBhaXIkMSIsInJzVXBwZXIiLCJyc1pXSiQyIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJlT3B0TW9kJDEiLCJyc09wdFZhciQxIiwicnNPcHRKb2luJDEiLCJyc09yZExvd2VyIiwicnNPcmRVcHBlciIsInJzU2VxJDEiLCJyc0Vtb2ppIiwicmVVbmljb2RlV29yZCIsInVuaWNvZGVXb3JkcyQxIiwiX3VuaWNvZGVXb3JkcyIsImFzY2lpV29yZHMiLCJoYXNVbmljb2RlV29yZCIsInRvU3RyaW5nJDEiLCJ1bmljb2RlV29yZHMiLCJ3b3JkcyQxIiwid29yZHNfMSIsImFycmF5UmVkdWNlIiwiZGVidXJyIiwid29yZHMiLCJyc0Fwb3MiLCJyZUFwb3MiLCJjcmVhdGVDb21wb3VuZGVyJDEiLCJjYWxsYmFjayIsIl9jcmVhdGVDb21wb3VuZGVyIiwiYmFzZVNsaWNlJDEiLCJfYmFzZVNsaWNlIiwiYmFzZVNsaWNlIiwiY2FzdFNsaWNlJDEiLCJfY2FzdFNsaWNlIiwicnNBc3RyYWxSYW5nZSQxIiwicnNDb21ib01hcmtzUmFuZ2UkMSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSQxIiwicnNDb21ib1N5bWJvbHNSYW5nZSQxIiwicnNDb21ib1JhbmdlJDEiLCJyc1ZhclJhbmdlJDEiLCJyc1pXSiQxIiwicmVIYXNVbmljb2RlIiwiaGFzVW5pY29kZSQyIiwiX2hhc1VuaWNvZGUiLCJhc2NpaVRvQXJyYXkkMSIsInNwbGl0IiwiX2FzY2lpVG9BcnJheSIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNBc3RyYWwiLCJyc0NvbWJvIiwicnNGaXR6IiwicnNNb2RpZmllciIsInJzTm9uQXN0cmFsIiwicnNSZWdpb25hbCIsInJzU3VyclBhaXIiLCJyc1pXSiIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc1NlcSIsInJzU3ltYm9sIiwicmVVbmljb2RlIiwidW5pY29kZVRvQXJyYXkkMSIsIl91bmljb2RlVG9BcnJheSIsImFzY2lpVG9BcnJheSIsImhhc1VuaWNvZGUkMSIsInVuaWNvZGVUb0FycmF5Iiwic3RyaW5nVG9BcnJheSQxIiwiX3N0cmluZ1RvQXJyYXkiLCJjYXN0U2xpY2UiLCJoYXNVbmljb2RlIiwic3RyaW5nVG9BcnJheSIsImNyZWF0ZUNhc2VGaXJzdCQxIiwibWV0aG9kTmFtZSIsInN0clN5bWJvbHMiLCJjaHIiLCJjaGFyQXQiLCJ0cmFpbGluZyIsIl9jcmVhdGVDYXNlRmlyc3QiLCJjcmVhdGVDYXNlRmlyc3QiLCJ1cHBlckZpcnN0JDEiLCJ1cHBlckZpcnN0XzEiLCJjcmVhdGVDb21wb3VuZGVyIiwidXBwZXJGaXJzdCIsInN0YXJ0Q2FzZSIsIndvcmQiLCJzdGFydENhc2VfMSIsInN0YXJ0Q2FzZSQxIiwiU3ltYm9sJDEiLCJpc0FyZ3VtZW50cyIsImlzQXJyYXkkMiIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJpc0ZsYXR0ZW5hYmxlJDEiLCJfaXNGbGF0dGVuYWJsZSIsImFycmF5UHVzaCIsImlzRmxhdHRlbmFibGUiLCJiYXNlRmxhdHRlbiQxIiwiZGVwdGgiLCJpc1N0cmljdCIsIl9iYXNlRmxhdHRlbiIsImJhc2VFYWNoJDEiLCJpc0FycmF5TGlrZSIsImJhc2VNYXAkMSIsIl9iYXNlTWFwIiwiYmFzZVNvcnRCeSQxIiwiY29tcGFyZXIiLCJzb3J0IiwiX2Jhc2VTb3J0QnkiLCJpc1N5bWJvbCIsImNvbXBhcmVBc2NlbmRpbmckMSIsInZhbElzRGVmaW5lZCIsInZhbElzTnVsbCIsInZhbElzUmVmbGV4aXZlIiwidmFsSXNTeW1ib2wiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwiX2NvbXBhcmVBc2NlbmRpbmciLCJjb21wYXJlQXNjZW5kaW5nIiwiY29tcGFyZU11bHRpcGxlJDEiLCJvcmRlcnMiLCJvYmpDcml0ZXJpYSIsImNyaXRlcmlhIiwib3RoQ3JpdGVyaWEiLCJvcmRlcnNMZW5ndGgiLCJvcmRlciIsIl9jb21wYXJlTXVsdGlwbGUiLCJhcnJheU1hcCIsImJhc2VHZXQiLCJiYXNlSXRlcmF0ZWUkMSIsImJhc2VNYXAiLCJiYXNlU29ydEJ5IiwiYmFzZVVuYXJ5IiwiY29tcGFyZU11bHRpcGxlIiwiaWRlbnRpdHkiLCJpc0FycmF5JDEiLCJiYXNlT3JkZXJCeSQxIiwiaXRlcmF0ZWVzIiwiX2Jhc2VPcmRlckJ5IiwiYmFzZUZsYXR0ZW4iLCJiYXNlT3JkZXJCeSIsImJhc2VSZXN0IiwiaXNJdGVyYXRlZUNhbGwiLCJzb3J0QnkiLCJzb3J0QnlfMSIsInNvcnRCeSQxIiwiYmFzZUlzRXF1YWwiLCJpc0VxdWFsIiwiaXNFcXVhbF8xIiwiaXNFcXVhbCQxIiwiYXJyYXlBZ2dyZWdhdG9yJDEiLCJzZXR0ZXIiLCJfYXJyYXlBZ2dyZWdhdG9yIiwiYmFzZUVhY2giLCJiYXNlQWdncmVnYXRvciQxIiwiX2Jhc2VBZ2dyZWdhdG9yIiwiYXJyYXlBZ2dyZWdhdG9yIiwiYmFzZUFnZ3JlZ2F0b3IiLCJiYXNlSXRlcmF0ZWUiLCJjcmVhdGVBZ2dyZWdhdG9yJDEiLCJpbml0aWFsaXplciIsIl9jcmVhdGVBZ2dyZWdhdG9yIiwiYmFzZUFzc2lnblZhbHVlIiwiY3JlYXRlQWdncmVnYXRvciIsImtleUJ5Iiwia2V5QnlfMSIsImtleUJ5JDEiLCJleHAiLCJFTUFJTF9SRUdFWCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZXMxIiwiY2xhc3NOYW1lczIiLCJuZXdDbGFzc05hbWVzIiwiY2xhc3NOYW1lcyIsImlucHV0T2JqZWN0IiwicXVlcnlQYXJhbXMiLCJleGNsdWRlUXVlc3Rpb25NYXJrIiwiZXhjbHVkZUVtcHR5U3RyaW5nVmFsdWVzIiwicHJlZml4UXVlc3Rpb25NYXJrIiwiYWNjIiwiZGVjaW1hbFBsYWNlcyIsInJvdW5kIiwidGFrZW4iLCJyYW5kb20iLCJlbGVtZW50c0NvdW50IiwicmdiYSIsImZvcmNlUmVtb3ZlQWxwaGEiLCJoZXhDb2xvciIsInBhcnNlRmxvYXQiLCJmaW5kIiwidiIsImV4Y2x1ZGVBcnJheSIsInRvRXhjbHVkZSIsIlNldCIsInRleHQiLCJ0b1VwcGVyQ2FzZSIsImVudiIsInF1ZXJ5IiwiaWQiLCJkZWZhdWx0VG9FbXB0eVN0cmluZyIsInJldHVybkRlZmF1bHQiLCJmaWxlTmFtZSIsInVybCIsImxpbmsiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsIlVSTCIsInJldm9rZU9iamVjdFVSTCIsInJlbW92ZSIsImNvbHVtbkhlYWRlck5hbWVzIiwiYXV0b0dlbmVyYXRlQ29sdW1uSGVhZGVyTmFtZXMiLCJzdGFydENhc2VGb3JDb2x1bm1IZWFkZXJOYW1lcyIsIl92IiwiY3N2IiwiYmxvYiIsIkJsb2IiLCJibG9iVXJsIiwiY3JlYXRlT2JqZWN0VVJMIiwianNvbiIsImlzRmV0Y2hpbmciLCJpc0xvYWRpbmciLCJpc0Vycm9yIiwiaXNTdWNjZXNzIiwiZGF0YVVwZGF0ZWRBdCIsImlzUmVhZHkiLCJzaG91bGRMb2FkSW5pdGlhbGx5Iiwic3RhdHVzIiwiaXM0MDEiLCJ1cGRhdGVkQXQiLCJ0ZXh0VGVybSIsInN0cjEiLCJzdHIyIiwic291cmNlVmFsdWUiLCJzb3VyY2VWYWx1ZVJhdyIsImlucHV0VmFsdWUiLCJpbnB1dFZhbHVlUmF3IiwidXNlRnV6enkiLCJGVVpaWVNPUlRfTUFUQ0hfVEhSRVNIT0xEIiwibWF0Y2hlcyIsInNjb3JlIiwiZnV6enlzb3J0Iiwic2luZ2xlIiwiYXJyYXlJbmRleCIsImN1cnJlbnRLZXkiLCJjb21wb3NpdGVLZXlJc1RydXRoeSIsImN1cnJlbnRLZXlJc1RydXRoeSIsImtleVZhbHVlU2VwYXJhdG9yIiwic2VwYXJhdG9yIiwia3ZTZXAiLCJzZXAiLCJjdXJyZW50VmFsdWUiLCJzaG91bGRFeGNsdWRlVmFsdWUiLCJ2YWx1ZUlzT2JqZWN0IiwidmFsdWVJc0FycmF5IiwidmFsdWVOZWVkc1RyYW5zZm9ybWluZyIsInNyY0lEIiwidGd0SUQiLCJtcyIsIlByb21pc2UiLCJzZXRUaW1lb3V0IiwicGFyYW1zIiwiX2EiLCJiYXNlIiwib3BlbiIsImZvY3VzIiwicmFuZ2UiLCJkaXN0YW5jZVRocm91Z2hSYW5nZSIsInJhbmRvbU51bWJlciIsInJvdW5kZWREb3duIiwicm91bmRlZFVwIiwiY2VpbCIsIm1pbnV0ZXMiLCJob3VycyIsImRheXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../lib-utilities/lib/index.esm.js\n");

/***/ }),

/***/ "classnames":
/*!*****************************!*\
  !*** external "classnames" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("classnames");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("dotenv");

/***/ }),

/***/ "fuzzysort":
/*!****************************!*\
  !*** external "fuzzysort" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("fuzzysort");

/***/ }),

/***/ "lodash/startCase":
/*!***********************************!*\
  !*** external "lodash/startCase" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("lodash/startCase");

/***/ }),

/***/ "next/dist/compiled/next-server/pages.runtime.dev.js":
/*!**********************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages.runtime.dev.js" ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages.runtime.dev.js");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

module.exports = require("react");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/@swc","vendor-chunks/next"], () => (__webpack_exec__("./src/pages/_document.tsx")));
module.exports = __webpack_exports__;

})();